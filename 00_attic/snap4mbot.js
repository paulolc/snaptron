/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {window.repl = {}; // fake it til you make it

	//ugh, just ugh
	delete window.localStorage;
	delete window.beforeunload;
	delete window.onbeforeunload;
    
    tempStorage = {};
    
	var browserbots = __webpack_require__(6);
	var keypress = __webpack_require__(9);
	process.stdin = __webpack_require__(11);
	var SerialPort = __webpack_require__(15);
	var cachedRequire = __webpack_require__(16);
	var five = cachedRequire('johnny-five');
	var firmataBoard = cachedRequire('firmata');
	var Repl = cachedRequire('johnny-five/lib/repl')
	var require = cachedRequire
	var io, board;
	var process = window.process = process;
    var world;
    var eventPage; 
    var snapStarted = false;
    var channel;
    var emptySerialOptions = {};
    var delaySerialPortOpening = false;
    var connectedSerial; 


    window.log = log = function( text, type){
        var date = new Date();
        var inSandbox = ( typeof chrome.app === 'undefined' )
        console.log("[INFO](%s) %02d/%02d/%02d %02d:%02d:%02d.%03d - %s", 
            (inSandbox? 'S': ' '), 
            date.getFullYear(), 
            date.getMonth(), 
            date.getDate(), 
            date.getHours(), 
            date.getMinutes(), 
            date.getSeconds(), 
            date.getMilliseconds(), 
            text
         );
    }

    

	process.exit = function(){};
	window.five = five;
	window.require = require;
	window.browserbots = browserbots;
    window.onload = loadStorageAndStartSnap;
    window.saveStorage = saveStorage;
    mBotResetOngoing = false;
    serialPorts = null;
    
    
    log('browserbots: ' + JSON.stringify( browserbots ));

	Repl.prototype.initialize = function(callback){
	  log('repl initialize stub');
	  callback();
	};
    
    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
	console.log('launching sandbox');
    setDefaultSnapSettings();
    createChannel();
    overrideSnapFunctions();

    connectedSerial = null;
    window.io = null;
    board = null;
    
    startSnap4mbot();
    ////////////////////////////////////////////////////////////////////////////////////////////////////////

    function J5Bot(){
        
    }



    ////////////////////////////////////////////////////////////////////////////////////////////////////////

    function startSnap4mbot(){
        mBotResetOngoing = true;
        log("jschannel: serial port connect requested")
        channel.call( { 
            method: "connect_mbot",
            params: null,
            success: function( serialDevices ) { 
                serialPorts = serialDevices;
                log("jschannel: serial port connected")
                runScript();
                mBotResetOngoing = false;
            }
        });
    }

    function runScript(){
        log('board initialization started');


            if( connectedSerial ){
                connectedSerial.close();  
            }


            connectedSerial = new SerialPort(window.parent);  

            log('setup firmata controller');
        //if( ! window.io ){
            window.io = io = new firmataBoard(connectedSerial, {repl: false, skipHandshake: false, samplingInterval: 300});
            io.once('ready', function(ir){
                log('firmata controller ready');
            });
            io.on('error', function(err){
                log('error creating firmata controller' + e, 'danger');
            });
        //} 


        try{
            mbotCommands();          
            log('board initialized');
        } catch(e){
            log(e, 'danger');
        }

    }
    
    function mbotCommands(){
        var five = require("johnny-five");
        var pixel = require("node-pixel");


        var strip = null;
        var l_motor = null;
        var r_motor = null;
        var max_speed_l = 150;
        var max_speed_r = 140;
        var executingCommand = false;
        
/*        
        var controller = new firmata.Board( connectedSerial, { repl: false, skipHandshake: false, samplingInterval: 300 } );
        controller.once('ready', function(ir){
            log('firmata controller ready');
        });
        controller.on('error', function(e){
            log('firmata controller connection error: ' + e, 'danger');
        });
        var board = new five.Board( { io: controller } );
*/


//        if( board !== null ){
//            return;
//        } 

        board = new five.Board({});
        //var boardId = Math.random();
        
        
        board.on("message", function(event) {            
            log("board message received ("+board.id+"): " + JSON.stringify( event ));  
        });

        board.on("connect", function(event) {
           log("board connected.("+board.id+")");
        });

        board.on("ready", function() {
            log("board ready.("+board.id+")");

            strip = new pixel.Strip({
                data: 13,
                length: 2,
                board: this,
                controller: "FIRMATA"
            });

            l_motor = new five.Motor({pins: {pwm: 6, dir: 7}});
            r_motor = new five.Motor({pins: {pwm: 5, dir: 4}});


            process.stdin.on('data', function(data){                
                
                if( executingCommand ){
                    return;
                }
                
                executingCommand = true;
                
                var command = data && data.command;
                var payload = data && data.payload;                

                log('Received command: "' + command + '" with payload "' + payload + '"');
                    
                if( ! ( command && payload ) ){
                    return;
                }    
                
                switch( command ){
                    case 'move_forward':
                        l_motor.reverse(max_speed_l);
                        r_motor.forward(max_speed_r);
                        break;
                    case 'move_backward':
                        r_motor.reverse(max_speed_r);
                        l_motor.forward(max_speed_l);
                        break;
                    case 'move_left':
                        l_motor.forward(max_speed_l);
                        r_motor.forward(max_speed_r);
                        break;
                    case 'move_right':
                        r_motor.reverse(max_speed_r);
                        l_motor.reverse(max_speed_l);
                        break;
                    case 'stop':
                        l_motor.stop();
                        r_motor.stop();
                        break;                    
                    case 'left_led':
                        strip.pixel( 0 ).color( payload );
                        strip.show();                
                        break;
                    case 'right_led':
                        strip.pixel( 1 ).color( payload );
                        strip.show();                
                        break;
                    default:
                        console.log('Unknown command');
                        break;
                }

                executingCommand = false;

                
            });

        });
            
        
    }


    function startSnap(){
        world = new WorldMorph(document.getElementById('world'));
        world.worldCanvas.focus();
        
        var ide_morph = new IDE_Morph();
        ide_morph.openIn(world);
        loop();        
    };


    
    function setDefaultSnapSettings(){
        ( tempStorage[ '-snap-setting-design' ]  ? "" : tempStorage[ '-snap-setting-design' ] =  'flat' );
        ( tempStorage[ '-snap-setting-language'] ? "" : tempStorage[ '-snap-setting-language'] =  'pt' );
    }

    function createChannel(){
        channel = Channel.build( { 
            window: window.parent, 
            origin: "*", 
            scope: "snap4mbot",
            onReady: function() {
                log("jschannel is ready!");
            }            
        });
    }            
    
    function loadStorageAndStartSnap() {    
        log("jschannel: requesting to load local storage");        
        channel.call( { 
            method: "load_storage",
            success: function( loadedStorage ) {
                log("jschannel: local storage loaded.")
                if( loadedStorage) { tempStorage = loadedStorage};
                startSnap();
            }
        });
    }

    function saveStorage(){
        log("jschannel: requesting to save local storage");        
        channel.call( { 
            method: "save_storage",
            params: tempStorage,
            success: function(v) { 
                log("jschannel: local storage saved");
            }
        });        
    }




    function loop() {
        requestAnimationFrame(loop);
        world.doOneCycle();
    }


/*
    function log(text, type){
        var msg = {
        command: 'info',
        text: String(new Date()) + ' : ' + String(text),
        type: type || 'success'
        };
        var date = new Date();
        console.log("[INFO] %s-%s-%s %s:%s:%s.%s : %s", date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds(), text);
        
        //console.log(JSON.stringify(msg));
        //window.parent.postMessage(msg, '*');
    }
*/

    function overrideSnapFunctions(){
        
        IDE_Morph.prototype.getURL = function (url, callback) {                        
            myself = this;
            channel.call( { 
                method: "get_url",
                params: url,
                success: function( responseText ){ 
                    callback( responseText );
                },
                error: function( err ){
                    myself.showMessage( err );
                }                       
            });
        }

        IDE_Morph.prototype.loadImg = function( url, callback ){
            channel.call( { 
                method: "get_imgbase64",
                params: url,
                success: function( dataUrl ){ 
                    var img = new Image();
                    img.onload = function () {
                        var canvas = newCanvas(new Point(img.width, img.height));
                        canvas.getContext('2d').drawImage(img, 0, 0);
                        callback( canvas );
                    };                
                    img.src = dataUrl;
                },
                error: function( err ){
                    myself.showMessage( err );
                }                       
            });            
        }

        IDE_Morph.prototype.connectMbot = function () {
            if( !mBotResetOngoing ){
                startSnap4mbot();   
            }
        };

        IDE_Morph.prototype.serialSelectMenu = function () {
            var menu,
                stage = this.stage,
                world = this.world(),
                myself = this,
                pos = this.controlBar.serialSelectButton.bottomLeft(),
                shiftClicked = (world.currentKey === 16);

            function addPreference(label, toggle, test, onHint, offHint, hide) {
                var on = '\u25c9 ',
                    off = '\u25EF ';
                if (!hide || shiftClicked) {
                    menu.addItem(
                        (test ? on : off) + localize(label),
                        toggle,
                        test ? onHint : offHint,
                        hide ? new Color(100, 0, 0) : null
                    );
                }
            }

            menu = new MenuMorph(this);
            menu.addLine();
            var sortedSerialPorts = serialPorts.map( function( serialPort ){
                return serialPort.path;
            }).sort( function naturalCompare(a, b) {
                var ax = [], bx = [];

                a.replace(/(\d+)|(\D+)/g, function(_, $1, $2) { ax.push([$1 || Infinity, $2 || ""]) });
                b.replace(/(\d+)|(\D+)/g, function(_, $1, $2) { bx.push([$1 || Infinity, $2 || ""]) });
                
                while(ax.length && bx.length) {
                    var an = ax.shift();
                    var bn = bx.shift();
                    var nn = (an[0] - bn[0]) || an[1].localeCompare(bn[1]);
                    if(nn) return nn;
                }

                return ax.length - bx.length;
            });
            
            sortedSerialPorts.forEach( function( serialPort ){
                addPreference(
                    serialPort + ':',
                    'selectSerialPort',
                    false,
                    'click to select ' + serialPort,
                    'click to select ' + serialPort,
                    false
                );
                
            });
            
            /*
            addPreference(
                'Zebra coloring',
                'toggleZebraColoring',
                BlockMorph.prototype.zebraContrast,
                'uncheck to disable alternating\ncolors for nested block',
                'check to enable alternating\ncolors for nested blocks',
                true
            );
            addPreference(
                'Dynamic input labels',
                'toggleDynamicInputLabels',
                SyntaxElementMorph.prototype.dynamicInputLabels,
                'uncheck to disable dynamic\nlabels for variadic inputs',
                'check to enable dynamic\nlabels for variadic inputs',
                true
            );
            addPreference(
                'Prefer empty slot drops',
                'togglePreferEmptySlotDrops',
                ScriptsMorph.prototype.isPreferringEmptySlots,
                'uncheck to allow dropped\nreporters to kick out others',
                'settings menu prefer empty slots hint',
                true
            );
            addPreference(
                'Long form input dialog',
                'toggleLongFormInputDialog',
                InputSlotDialogMorph.prototype.isLaunchingExpanded,
                'uncheck to use the input\ndialog in short form',
                'check to always show slot\ntypes in the input dialog'
            );
            addPreference(
                'Plain prototype labels',
                'togglePlainPrototypeLabels',
                BlockLabelPlaceHolderMorph.prototype.plainLabel,
                'uncheck to always show (+) symbols\nin block prototype labels',
                'check to hide (+) symbols\nin block prototype labels'
            );
            addPreference(
                'Virtual keyboard',
                'toggleVirtualKeyboard',
                MorphicPreferences.useVirtualKeyboard,
                'uncheck to disable\nvirtual keyboard support\nfor mobile devices',
                'check to enable\nvirtual keyboard support\nfor mobile devices',
                true
            );
            addPreference(
                'Input sliders',
                'toggleInputSliders',
                MorphicPreferences.useSliderForInput,
                'uncheck to disable\ninput sliders for\nentry fields',
                'check to enable\ninput sliders for\nentry fields'
            );
            if (MorphicPreferences.useSliderForInput) {
                addPreference(
                    'Execute on slider change',
                    'toggleSliderExecute',
                    InputSlotMorph.prototype.executeOnSliderEdit,
                    'uncheck to supress\nrunning scripts\nwhen moving the slider',
                    'check to run\nthe edited script\nwhen moving the slider'
                );
            }
            addPreference(
                'Clicking sound',
                function () {
                    BlockMorph.prototype.toggleSnapSound();
                    if (BlockMorph.prototype.snapSound) {
                        myself.saveSetting('click', true);
                    } else {
                        myself.removeSetting('click');
                    }
                },
                BlockMorph.prototype.snapSound,
                'uncheck to turn\nblock clicking\nsound off',
                'check to turn\nblock clicking\nsound on'
            );
            addPreference(
                'Animations',
                function () {myself.isAnimating = !myself.isAnimating; },
                myself.isAnimating,
                'uncheck to disable\nIDE animations',
                'check to enable\nIDE animations',
                true
            );
            addPreference(
                'Turbo mode',
                'toggleFastTracking',
                this.stage.isFastTracked,
                'uncheck to run scripts\nat normal speed',
                'check to prioritize\nscript execution'
            );
            addPreference(
                'Cache Inputs',
                function () {
                    BlockMorph.prototype.isCachingInputs =
                        !BlockMorph.prototype.isCachingInputs;
                },
                BlockMorph.prototype.isCachingInputs,
                'uncheck to stop caching\ninputs (for debugging the evaluator)',
                'check to cache inputs\nboosts recursion',
                true
            );
            addPreference(
                'Rasterize SVGs',
                function () {
                    MorphicPreferences.rasterizeSVGs =
                        !MorphicPreferences.rasterizeSVGs;
                },
                MorphicPreferences.rasterizeSVGs,
                'uncheck for smooth\nscaling of vector costumes',
                'check to rasterize\nSVGs on import',
                true
            );
            addPreference(
                'Flat design',
                function () {
                    if (MorphicPreferences.isFlat) {
                        return myself.defaultDesign();
                    }
                    myself.flatDesign();
                },
                MorphicPreferences.isFlat,
                'uncheck for default\nGUI design',
                'check for alternative\nGUI design',
                false
            );
            addPreference(
                'Project URLs',
                function () {
                    myself.projectsInURLs = !myself.projectsInURLs;
                    if (myself.projectsInURLs) {
                        myself.saveSetting('longurls', true);
                    } else {
                        myself.removeSetting('longurls');
                    }
                },
                myself.projectsInURLs,
                'uncheck to disable\nproject data in URLs',
                'check to enable\nproject data in URLs',
                true
            );
            addPreference(
                'Sprite Nesting',
                function () {
                    SpriteMorph.prototype.enableNesting =
                        !SpriteMorph.prototype.enableNesting;
                },
                SpriteMorph.prototype.enableNesting,
                'uncheck to disable\nsprite composition',
                'check to enable\nsprite composition',
                true
            );
            addPreference(
                'Keyboard Editing',
                function () {
                    ScriptsMorph.prototype.enableKeyboard =
                        !ScriptsMorph.prototype.enableKeyboard;
                    if (ScriptsMorph.prototype.enableKeyboard) {
                        myself.saveSetting('keyboard', true);
                    } else {
                        myself.removeSetting('keyboard');
                    }
                },
                ScriptsMorph.prototype.enableKeyboard,
                'uncheck to disable\nkeyboard editing support',
                'check to enable\nkeyboard editing support',
                false
            );
            menu.addLine(); // everything below this line is stored in the project
            addPreference(
                'Thread safe scripts',
                function () {stage.isThreadSafe = !stage.isThreadSafe; },
                this.stage.isThreadSafe,
                'uncheck to allow\nscript reentrance',
                'check to disallow\nscript reentrance'
            );
            addPreference(
                'Prefer smooth animations',
                'toggleVariableFrameRate',
                StageMorph.prototype.frameRate,
                'uncheck for greater speed\nat variable frame rates',
                'check for smooth, predictable\nanimations across computers'
            );
            addPreference(
                'Flat line ends',
                function () {
                    SpriteMorph.prototype.useFlatLineEnds =
                        !SpriteMorph.prototype.useFlatLineEnds;
                },
                SpriteMorph.prototype.useFlatLineEnds,
                'uncheck for round ends of lines',
                'check for flat ends of lines'
            );
            addPreference(
                'Codification support',
                function () {
                    StageMorph.prototype.enableCodeMapping =
                        !StageMorph.prototype.enableCodeMapping;
                    myself.currentSprite.blocksCache.variables = null;
                    myself.currentSprite.paletteCache.variables = null;
                    myself.refreshPalette();
                },
                StageMorph.prototype.enableCodeMapping,
                'uncheck to disable\nblock to text mapping features',
                'check for block\nto text mapping features',
                false
            );
            addPreference(
                'Inheritance support',
                function () {
                    StageMorph.prototype.enableInheritance =
                        !StageMorph.prototype.enableInheritance;
                    myself.currentSprite.blocksCache.variables = null;
                    myself.currentSprite.paletteCache.variables = null;
                    myself.refreshPalette();
                },
                StageMorph.prototype.enableInheritance,
                'uncheck to disable\nsprite inheritance features',
                'check for sprite\ninheritance features',
                false
            );
            */
            menu.popup(world, pos);
        };
    }



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2).Buffer))

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var base64 = __webpack_require__(3)
	var ieee754 = __webpack_require__(4)
	var isArray = __webpack_require__(5)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Note:
	 *
	 * - Implementation must support adding new properties to `Uint8Array` instances.
	 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
	 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *    incorrect length in some situations.
	 *
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
	 * get the Object implementation, which is slower but will work correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  function Foo () {}
	  try {
	    var buf = new ArrayBuffer(0)
	    var arr = new Uint8Array(buf)
	    arr.foo = function () { return 42 }
	    arr.constructor = Foo
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Foo && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
	    return fromTypedArray(that, object)
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  } else if (list.length === 1) {
	    return list[0]
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` will be removed in Node 0.13+
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` will be removed in Node 0.13+
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  var res = ''
	  var tmp = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    if (buf[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
	      tmp = ''
	    } else {
	      tmp += '%' + buf[i].toString(16)
	    }
	  }

	  return res + decodeUtf8Char(tmp)
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start

	  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated, will be removed in node 0.13+
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	  var i = 0

	  for (; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (leadSurrogate) {
	        // 2 leads in a row
	        if (codePoint < 0xDC00) {
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          leadSurrogate = codePoint
	          continue
	        } else {
	          // valid surrogate pair
	          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	          leadSurrogate = null
	        }
	      } else {
	        // no lead yet

	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else {
	          // valid lead
	          leadSurrogate = codePoint
	          continue
	        }
	      }
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	      leadSurrogate = null
	    }

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x200000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function decodeUtf8Char (str) {
	  try {
	    return decodeURIComponent(str)
	  } catch (err) {
	    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 4 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var controls = __webpack_require__(7);

	function speak(text){
	  var msg = {
	    command: 'speak',
	    payload: new String(text || '')
	  };

	  window.parent.postMessage(msg, '*');
	}

	module.exports = {
	  controls : controls,
	  speak : speak
	}



/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EventEmitter = __webpack_require__(8).EventEmitter;

	var controlCache = {};

	function controls(name){
	  controlCache[name] = controlCache[name] || new EventEmitter();
	  return controlCache[name];
	}

	module.exports = controls;



/***/ },
/* 8 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(8).EventEmitter;

	/**
	 * Module exports.
	 */

	var exports = module.exports = keypress;

	/**
	 * This module offers the internal "keypress" functionality from node-core's
	 * `readline` module, for your own programs and modules to use.
	 *
	 * The `keypress` function accepts a readable Stream instance and makes it
	 * emit "keypress" events.
	 *
	 * Usage:
	 *
	 * ``` js
	 * require('keypress')(process.stdin);
	 *
	 * process.stdin.on('keypress', function (ch, key) {
	 *   console.log(ch, key);
	 *   if (key.ctrl && key.name == 'c') {
	 *     process.stdin.pause();
	 *   }
	 * });
	 * proces.stdin.resume();
	 * ```
	 *
	 * @param {Stream} stream
	 * @api public
	 */

	function keypress(stream) {
	  if (isEmittingKeypress(stream)) return;

	  var StringDecoder = __webpack_require__(10).StringDecoder; // lazy load
	  stream._keypressDecoder = new StringDecoder('utf8');

	  function onData(b) {
	    if (listenerCount(stream, 'keypress') > 0) {
	      var r = stream._keypressDecoder.write(b);
	      if (r) emitKey(stream, r);
	    } else {
	      // Nobody's watching anyway
	      stream.removeListener('data', onData);
	      stream.on('newListener', onNewListener);
	    }
	  }

	  function onNewListener(event) {
	    if (event == 'keypress') {
	      stream.on('data', onData);
	      stream.removeListener('newListener', onNewListener);
	    }
	  }

	  if (listenerCount(stream, 'keypress') > 0) {
	    stream.on('data', onData);
	  } else {
	    stream.on('newListener', onNewListener);
	  }
	}

	/**
	 * Returns `true` if the stream is already emitting "keypress" events.
	 * `false` otherwise.
	 *
	 * @param {Stream} stream readable stream
	 * @return {Boolean} `true` if the stream is emitting "keypress" events
	 * @api private
	 */

	function isEmittingKeypress(stream) {
	  var rtn = !!stream._keypressDecoder;
	  if (!rtn) {
	    // XXX: for older versions of node (v0.6.x, v0.8.x) we want to remove the
	    // existing "data" and "newListener" keypress events since they won't include
	    // this `keypress` module extensions (like "mousepress" events).
	    stream.listeners('data').slice(0).forEach(function(l) {
	      if (l.name == 'onData' && /emitKey/.test(l.toString())) {
	        stream.removeListener('data', l);
	      }
	    });
	    stream.listeners('newListener').slice(0).forEach(function(l) {
	      if (l.name == 'onNewListener' && /keypress/.test(l.toString())) {
	        stream.removeListener('newListener', l);
	      }
	    });
	  }
	  return rtn;
	}

	/**
	 * Enables "mousepress" events on the *input* stream. Note that `stream` must be
	 * an *output* stream (i.e. a Writable Stream instance), usually `process.stdout`.
	 *
	 * @param {Stream} stream writable stream instance
	 * @api public
	 */

	exports.enableMouse = function (stream) {
	  stream.write('\x1b[?1000h');
	};

	/**
	 * Disables "mousepress" events from being sent to the *input* stream.
	 * Note that `stream` must be an *output* stream (i.e. a Writable Stream instance),
	 * usually `process.stdout`.
	 *
	 * @param {Stream} stream writable stream instance
	 * @api public
	 */

	exports.disableMouse = function (stream) {
	  stream.write('\x1b[?1000l');
	};

	/**
	 * `EventEmitter.listenerCount()` polyfill, for backwards compat.
	 *
	 * @param {Emitter} emitter event emitter instance
	 * @param {String} event event name
	 * @return {Number} number of listeners for `event`
	 * @api public
	 */

	var listenerCount = EventEmitter.listenerCount;
	if (!listenerCount) {
	  listenerCount = function(emitter, event) {
	    return emitter.listeners(event).length;
	  };
	}


	///////////////////////////////////////////////////////////////////////
	// Below this function is code from node-core's `readline.js` module //
	///////////////////////////////////////////////////////////////////////


	/*
	  Some patterns seen in terminal key escape codes, derived from combos seen
	  at http://www.midnight-commander.org/browser/lib/tty/key.c

	  ESC letter
	  ESC [ letter
	  ESC [ modifier letter
	  ESC [ 1 ; modifier letter
	  ESC [ num char
	  ESC [ num ; modifier char
	  ESC O letter
	  ESC O modifier letter
	  ESC O 1 ; modifier letter
	  ESC N letter
	  ESC [ [ num ; modifier char
	  ESC [ [ 1 ; modifier letter
	  ESC ESC [ num char
	  ESC ESC O letter

	  - char is usually ~ but $ and ^ also happen with rxvt
	  - modifier is 1 +
	                (shift     * 1) +
	                (left_alt  * 2) +
	                (ctrl      * 4) +
	                (right_alt * 8)
	  - two leading ESCs apparently mean the same as one leading ESC
	*/

	// Regexes used for ansi escape code splitting
	var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
	var functionKeyCodeRe =
	    /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;

	function emitKey(stream, s) {
	  var ch,
	      key = {
	        name: undefined,
	        ctrl: false,
	        meta: false,
	        shift: false
	      },
	      parts;

	  if (Buffer.isBuffer(s)) {
	    if (s[0] > 127 && s[1] === undefined) {
	      s[0] -= 128;
	      s = '\x1b' + s.toString(stream.encoding || 'utf-8');
	    } else {
	      s = s.toString(stream.encoding || 'utf-8');
	    }
	  }

	  key.sequence = s;

	  if (s === '\r') {
	    // carriage return
	    key.name = 'return';

	  } else if (s === '\n') {
	    // enter, should have been called linefeed
	    key.name = 'enter';

	  } else if (s === '\t') {
	    // tab
	    key.name = 'tab';

	  } else if (s === '\b' || s === '\x7f' ||
	             s === '\x1b\x7f' || s === '\x1b\b') {
	    // backspace or ctrl+h
	    key.name = 'backspace';
	    key.meta = (s.charAt(0) === '\x1b');

	  } else if (s === '\x1b' || s === '\x1b\x1b') {
	    // escape key
	    key.name = 'escape';
	    key.meta = (s.length === 2);

	  } else if (s === ' ' || s === '\x1b ') {
	    key.name = 'space';
	    key.meta = (s.length === 2);

	  } else if (s <= '\x1a') {
	    // ctrl+letter
	    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
	    key.ctrl = true;

	  } else if (s.length === 1 && s >= 'a' && s <= 'z') {
	    // lowercase letter
	    key.name = s;

	  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
	    // shift+letter
	    key.name = s.toLowerCase();
	    key.shift = true;

	  } else if (parts = metaKeyCodeRe.exec(s)) {
	    // meta+character key
	    key.name = parts[1].toLowerCase();
	    key.meta = true;
	    key.shift = /^[A-Z]$/.test(parts[1]);

	  } else if (parts = functionKeyCodeRe.exec(s)) {
	    // ansi escape sequence

	    // reassemble the key code leaving out leading \x1b's,
	    // the modifier key bitflag and any meaningless "1;" sequence
	    var code = (parts[1] || '') + (parts[2] || '') +
	               (parts[4] || '') + (parts[6] || ''),
	        modifier = (parts[3] || parts[5] || 1) - 1;

	    // Parse the key modifier
	    key.ctrl = !!(modifier & 4);
	    key.meta = !!(modifier & 10);
	    key.shift = !!(modifier & 1);
	    key.code = code;

	    // Parse the key itself
	    switch (code) {
	      /* xterm/gnome ESC O letter */
	      case 'OP': key.name = 'f1'; break;
	      case 'OQ': key.name = 'f2'; break;
	      case 'OR': key.name = 'f3'; break;
	      case 'OS': key.name = 'f4'; break;

	      /* xterm/rxvt ESC [ number ~ */
	      case '[11~': key.name = 'f1'; break;
	      case '[12~': key.name = 'f2'; break;
	      case '[13~': key.name = 'f3'; break;
	      case '[14~': key.name = 'f4'; break;

	      /* from Cygwin and used in libuv */
	      case '[[A': key.name = 'f1'; break;
	      case '[[B': key.name = 'f2'; break;
	      case '[[C': key.name = 'f3'; break;
	      case '[[D': key.name = 'f4'; break;
	      case '[[E': key.name = 'f5'; break;

	      /* common */
	      case '[15~': key.name = 'f5'; break;
	      case '[17~': key.name = 'f6'; break;
	      case '[18~': key.name = 'f7'; break;
	      case '[19~': key.name = 'f8'; break;
	      case '[20~': key.name = 'f9'; break;
	      case '[21~': key.name = 'f10'; break;
	      case '[23~': key.name = 'f11'; break;
	      case '[24~': key.name = 'f12'; break;

	      /* xterm ESC [ letter */
	      case '[A': key.name = 'up'; break;
	      case '[B': key.name = 'down'; break;
	      case '[C': key.name = 'right'; break;
	      case '[D': key.name = 'left'; break;
	      case '[E': key.name = 'clear'; break;
	      case '[F': key.name = 'end'; break;
	      case '[H': key.name = 'home'; break;

	      /* xterm/gnome ESC O letter */
	      case 'OA': key.name = 'up'; break;
	      case 'OB': key.name = 'down'; break;
	      case 'OC': key.name = 'right'; break;
	      case 'OD': key.name = 'left'; break;
	      case 'OE': key.name = 'clear'; break;
	      case 'OF': key.name = 'end'; break;
	      case 'OH': key.name = 'home'; break;

	      /* xterm/rxvt ESC [ number ~ */
	      case '[1~': key.name = 'home'; break;
	      case '[2~': key.name = 'insert'; break;
	      case '[3~': key.name = 'delete'; break;
	      case '[4~': key.name = 'end'; break;
	      case '[5~': key.name = 'pageup'; break;
	      case '[6~': key.name = 'pagedown'; break;

	      /* putty */
	      case '[[5~': key.name = 'pageup'; break;
	      case '[[6~': key.name = 'pagedown'; break;

	      /* rxvt */
	      case '[7~': key.name = 'home'; break;
	      case '[8~': key.name = 'end'; break;

	      /* rxvt keys with modifiers */
	      case '[a': key.name = 'up'; key.shift = true; break;
	      case '[b': key.name = 'down'; key.shift = true; break;
	      case '[c': key.name = 'right'; key.shift = true; break;
	      case '[d': key.name = 'left'; key.shift = true; break;
	      case '[e': key.name = 'clear'; key.shift = true; break;

	      case '[2$': key.name = 'insert'; key.shift = true; break;
	      case '[3$': key.name = 'delete'; key.shift = true; break;
	      case '[5$': key.name = 'pageup'; key.shift = true; break;
	      case '[6$': key.name = 'pagedown'; key.shift = true; break;
	      case '[7$': key.name = 'home'; key.shift = true; break;
	      case '[8$': key.name = 'end'; key.shift = true; break;

	      case 'Oa': key.name = 'up'; key.ctrl = true; break;
	      case 'Ob': key.name = 'down'; key.ctrl = true; break;
	      case 'Oc': key.name = 'right'; key.ctrl = true; break;
	      case 'Od': key.name = 'left'; key.ctrl = true; break;
	      case 'Oe': key.name = 'clear'; key.ctrl = true; break;

	      case '[2^': key.name = 'insert'; key.ctrl = true; break;
	      case '[3^': key.name = 'delete'; key.ctrl = true; break;
	      case '[5^': key.name = 'pageup'; key.ctrl = true; break;
	      case '[6^': key.name = 'pagedown'; key.ctrl = true; break;
	      case '[7^': key.name = 'home'; key.ctrl = true; break;
	      case '[8^': key.name = 'end'; key.ctrl = true; break;

	      /* misc. */
	      case '[Z': key.name = 'tab'; key.shift = true; break;
	      default: key.name = 'undefined'; break;

	    }
	  } else if (s.length > 1 && s[0] !== '\x1b') {
	    // Got a longer-than-one string of characters.
	    // Probably a paste, since it wasn't a control sequence.
	    Array.prototype.forEach.call(s, function(c) {
	      emitKey(stream, c);
	    });
	    return;
	  }

	  // XXX: this "mouse" parsing code is NOT part of the node-core standard
	  // `readline.js` module, and is a `keypress` module non-standard extension.
	  if (key.code == '[M') {
	    key.name = 'mouse';
	    var s = key.sequence;
	    var b = s.charCodeAt(3);
	    key.x = s.charCodeAt(4) - 040;
	    key.y = s.charCodeAt(5) - 040;

	    key.scroll = 0;

	    key.ctrl  = !!(1<<4 & b);
	    key.meta  = !!(1<<3 & b);
	    key.shift = !!(1<<2 & b);

	    key.release = (3 & b) === 3;

	    if (1<<6 & b) { //scroll
	      key.scroll = 1 & b ? 1 : -1;
	    }

	    if (!key.release && !key.scroll) {
	      key.button = b & 3;
	    }
	  }

	  // Don't emit a key if no name was found
	  if (key.name === undefined) {
	    key = undefined;
	  }

	  if (s.length === 1) {
	    ch = s;
	  }

	  if (key && key.name == 'mouse') {
	    stream.emit('mousepress', key);
	  } else if (key || ch) {
	    stream.emit('keypress', ch, key);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(2).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(12);
	var EventEmitter = __webpack_require__(8).EventEmitter;

	function Stdin(){}

	util.inherits(Stdin, EventEmitter);

	function noop(){};

	Stdin.prototype.resume = noop;
	Stdin.prototype.setEncoding = noop;
	Stdin.prototype.write = noop;
	Stdin.prototype.setRawMode = noop;
	Stdin.prototype.pause = noop;

	module.exports = new Stdin();


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(13);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(14);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 14 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var util = __webpack_require__(12);
	var EventEmitter = __webpack_require__(8).EventEmitter;

	function SerialPort(parentWindow, options, openImmediately, callback) {
	  var self = this;
      self.messageHandler = this.onRead.bind(this);

	  options = options || {};

      self.id = btoa(Math.random());

	  self.parent = parentWindow;
	  self.window = options.window || window;
	  self.targetOrigin = options.targetOrigin || '*';

	  self.comName = 'postMessage';

	  if(openImmediately !== false){
	    process.nextTick(function(){
	      self.open(callback);
	    });
	  }


	}

	util.inherits(SerialPort, EventEmitter);

	SerialPort.prototype.connectionId = -1;

	SerialPort.prototype.comName = "";

	SerialPort.prototype.open = function (callback) {
	  this.window.addEventListener('message', this.messageHandler );
	  this.parent.postMessage({ command: 'open' }, this.targetOrigin);
	  this.emit('open');

	  if(callback){
	    callback();
	  }
	};

	SerialPort.prototype.onRead = function(event) {
      console.log( "SerialPort.prototype.onRead id: '"+ this.id +"'called" );
	  var data = event.data;
	  var command = data && data.command;
	  var payload = data && data.payload;
	  if(command === 'write' && payload){
	    this.simulateRead(payload);
	  }
	};

	SerialPort.prototype.simulateRead = function (data) {
	  var uint8View = new Uint8Array(data);
	  var string = '';
	  for (var i = 0; i < data.byteLength; i++) {
	    string += String.fromCharCode(uint8View[i]);
	  }

	  //Maybe this should be a Buffer()
	  this.emit('data', uint8View);
	  this.emit('dataString', string);
	}

	SerialPort.prototype.write = function (buffer, callback) {
	  //Make sure its not a browserify faux Buffer.
	  // if (buffer instanceof ArrayBuffer == false) {
	  //   buffer = buffer2ArrayBuffer(buffer);
	  // }

	  this.parent.postMessage({ command: 'write', payload: buffer }, this.targetOrigin);

	  if(callback){
	    callback();
	  }
	};

	SerialPort.prototype.writeString = function (string, callback) {
	  this.write(str2ab(string), callback);
	};

	SerialPort.prototype.close = function (callback) {
      this.window.removeEventListener('message', this.messageHandler );
 	  this.parent.postMessage({ command: 'close' }, this.targetOrigin);
	  this.emit('close');

	  if(callback){
	    callback();
	  }
	};

	SerialPort.prototype.flush = function (callback) {
	  this.parent.postMessage({ command: 'flush' }, this.targetOrigin);
	  this.emit('flush');

	  if(callback){
	    callback();
	  }
	};

	// Convert string to ArrayBuffer
	function str2ab(str) {
	  var buf = new ArrayBuffer(str.length);
	  var bufView = new Uint8Array(buf);
	  for (var i = 0; i < str.length; i++) {
	    bufView[i] = str.charCodeAt(i);
	  }
	  return buf;
	}

	// Convert buffer to ArrayBuffer
	function buffer2ArrayBuffer(buffer) {
	  var buf = new ArrayBuffer(buffer.length);
	  var bufView = new Uint8Array(buf);
	  for (var i = 0; i < buffer.length; i++) {
	    bufView[i] = buffer[i];
	  }
	  return buf;
	}

	module.exports = SerialPort;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var cache = {
	  "firmata": __webpack_require__(17),
	  "johnny-five": __webpack_require__(77),
	  "johnny-five/lib/repl": __webpack_require__(116),
	  "keypress": __webpack_require__(9),
	  "leapjs": __webpack_require__(180),
	  "lodash": __webpack_require__(113),
	  "mqtt": __webpack_require__(203),
	  "mqtt-serial": __webpack_require__(274),
	  "node-pixel": __webpack_require__(275),
	  "oled-js": __webpack_require__(279),
	  "request": __webpack_require__(280),
	  "rest": __webpack_require__(281),
	  "rest/interceptor": __webpack_require__(309),
	  "rest/interceptor/errorCode": __webpack_require__(310),
	  "rest/interceptor/pathPrefix": __webpack_require__(311),
	  "rest/interceptor/entity": __webpack_require__(312),
	  "rest/interceptor/mime": __webpack_require__(313),
	  "socket.io-client": __webpack_require__(326),
	  "socket.io-serial": __webpack_require__(377),
	  "temporal": __webpack_require__(131),
	  "tharp": __webpack_require__(381),
	  "vektor": __webpack_require__(382)
	};

	function cachedRequire(packageName){
	  return cache[packageName];
	}

	module.exports = cachedRequire;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {/**
	 * Global Environment Dependencies
	 */
	/* jshint -W079 */
	var Map = __webpack_require__(18);
	var assign = __webpack_require__(73);

	/**
	 * @author Julian Gautier
	 */
	/**
	 * Module Dependencies
	 */
	var util = __webpack_require__(12),
	  Emitter = __webpack_require__(8).EventEmitter,
	  chrome = chrome || undefined,
	  Encoder7Bit = __webpack_require__(74),
	  OneWireUtils = __webpack_require__(75),
	  SerialPort = null,
	  i2cActive = new Map();


	try {
	  if (process.browser) {
	    SerialPort = __webpack_require__(76).SerialPort;
	  } else {
	    SerialPort = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"serialport\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).SerialPort;
	  }
	} catch (err) {
	  SerialPort = null;
	}

	if (SerialPort == null) {
	  console.log("It looks like serialport didn't compile properly. This is a common problem and its fix is well documented here https://github.com/voodootikigod/node-serialport#to-install");
	  throw "Missing serialport dependency";
	}

	/**
	 * constants
	 */

	var ANALOG_MAPPING_QUERY = 0x69;
	var ANALOG_MAPPING_RESPONSE = 0x6A;
	var ANALOG_MESSAGE = 0xE0;
	var CAPABILITY_QUERY = 0x6B;
	var CAPABILITY_RESPONSE = 0x6C;
	var DIGITAL_MESSAGE = 0x90;
	var END_SYSEX = 0xF7;
	var EXTENDED_ANALOG = 0x6F;
	var I2C_CONFIG = 0x78;
	var I2C_REPLY = 0x77;
	var I2C_REQUEST = 0x76;
	var ONEWIRE_CONFIG_REQUEST = 0x41;
	var ONEWIRE_DATA = 0x73;
	var ONEWIRE_DELAY_REQUEST_BIT = 0x10;
	var ONEWIRE_READ_REPLY = 0x43;
	var ONEWIRE_READ_REQUEST_BIT = 0x08;
	var ONEWIRE_RESET_REQUEST_BIT = 0x01;
	var ONEWIRE_SEARCH_ALARMS_REPLY = 0x45;
	var ONEWIRE_SEARCH_ALARMS_REQUEST = 0x44;
	var ONEWIRE_SEARCH_REPLY = 0x42;
	var ONEWIRE_SEARCH_REQUEST = 0x40;
	var ONEWIRE_WITHDATA_REQUEST_BITS = 0x3C;
	var ONEWIRE_WRITE_REQUEST_BIT = 0x20;
	var PIN_MODE = 0xF4;
	var PIN_STATE_QUERY = 0x6D;
	var PIN_STATE_RESPONSE = 0x6E;
	var PING_READ = 0x75;
	var PULSE_IN = 0x74;
	var PULSE_OUT = 0x73;
	var QUERY_FIRMWARE = 0x79;
	var REPORT_ANALOG = 0xC0;
	var REPORT_DIGITAL = 0xD0;
	var REPORT_VERSION = 0xF9;
	var SAMPLING_INTERVAL = 0x7A;
	var SERVO_CONFIG = 0x70;
	var START_SYSEX = 0xF0;
	var STEPPER = 0x72;
	var STRING_DATA = 0x71;
	var SYSTEM_RESET = 0xFF;

	var MAX_PIN_COUNT = 128;

	/**
	 * MIDI_RESPONSE contains functions to be called when we receive a MIDI message from the arduino.
	 * used as a switch object as seen here http://james.padolsey.com/javascript/how-to-avoid-switch-case-syndrome/
	 * @private
	 */

	var MIDI_RESPONSE = {};

	/**
	 * Handles a REPORT_VERSION response and emits the reportversion event.  Also turns on all pins to start reporting
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	MIDI_RESPONSE[REPORT_VERSION] = function(board) {
	  board.version.major = board.currentBuffer[1];
	  board.version.minor = board.currentBuffer[2];
	  board.emit("reportversion");
	};

	/**
	 * Handles a ANALOG_MESSAGE response and emits "analog-read" and "analog-read-"+n events where n is the pin number.
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	MIDI_RESPONSE[ANALOG_MESSAGE] = function(board) {
	  var value = board.currentBuffer[1] | (board.currentBuffer[2] << 7);
	  var pin = board.currentBuffer[0] & 0x0F;

	  if (board.pins[board.analogPins[pin]]) {
	    board.pins[board.analogPins[pin]].value = value;
	  }

	  board.emit("analog-read-" + pin, value);
	  board.emit("analog-read", {
	    pin: pin,
	    value: value
	  });
	};

	/**
	 * Handles a DIGITAL_MESSAGE response and emits:
	 * "digital-read"
	 * "digital-read-"+n
	 *
	 * Where n is the pin number.
	 *
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	MIDI_RESPONSE[DIGITAL_MESSAGE] = function(board) {
	  var port = (board.currentBuffer[0] & 0x0F);
	  var portValue = board.currentBuffer[1] | (board.currentBuffer[2] << 7);

	  for (var i = 0; i < 8; i++) {
	    var pinNumber = 8 * port + i;
	    var pin = board.pins[pinNumber];
	    if (pin && (pin.mode === board.MODES.INPUT)) {
	      pin.value = (portValue >> (i & 0x07)) & 0x01;
	      board.emit("digital-read-" + pinNumber, pin.value);
	      board.emit("digital-read", {
	        pin: pinNumber,
	        value: pin.value
	      });
	    }
	  }
	};

	/**
	 * SYSEX_RESPONSE contains functions to be called when we receive a SYSEX message from the arduino.
	 * used as a switch object as seen here http://james.padolsey.com/javascript/how-to-avoid-switch-case-syndrome/
	 * @private
	 */

	var SYSEX_RESPONSE = {};

	/**
	 * Handles a QUERY_FIRMWARE response and emits the "queryfirmware" event
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	SYSEX_RESPONSE[QUERY_FIRMWARE] = function(board) {
	  var firmwareBuf = [];
	  board.firmware.version = {};
	  board.firmware.version.major = board.currentBuffer[2];
	  board.firmware.version.minor = board.currentBuffer[3];
	  for (var i = 4, length = board.currentBuffer.length - 2; i < length; i += 2) {
	    firmwareBuf.push((board.currentBuffer[i] & 0x7F) | ((board.currentBuffer[i + 1] & 0x7F) << 7));
	  }

	  board.firmware.name = new Buffer(firmwareBuf).toString("utf8", 0, firmwareBuf.length);
	  board.emit("queryfirmware");
	};

	/**
	 * Handles a CAPABILITY_RESPONSE response and emits the "capability-query" event
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	SYSEX_RESPONSE[CAPABILITY_RESPONSE] = function(board) {
	  var supportedModes = 0;

	  function pushModes(modesArray, mode) {
	    if (supportedModes & (1 << board.MODES[mode])) {
	      modesArray.push(board.MODES[mode]);
	    }
	  }

	  // Only create pins if none have been previously created on the instance.
	  if (!board.pins.length) {
	    for (var i = 2, n = 0; i < board.currentBuffer.length - 1; i++) {
	      if (board.currentBuffer[i] === 127) {
	        var modesArray = [];
	        Object.keys(board.MODES).forEach(pushModes.bind(null, modesArray));
	        board.pins.push({
	          supportedModes: modesArray,
	          mode: board.MODES.UNKNOWN,
	          value: 0,
	          report: 1
	        });
	        supportedModes = 0;
	        n = 0;
	        continue;
	      }
	      if (n === 0) {
	        supportedModes |= (1 << board.currentBuffer[i]);
	      }
	      n ^= 1;
	    }
	  }

	  board.emit("capability-query");
	};

	/**
	 * Handles a PIN_STATE response and emits the 'pin-state-'+n event where n is the pin number.
	 *
	 * Note about pin state: For output modes, the state is any value that has been
	 * previously written to the pin. For input modes, the state is the status of
	 * the pullup resistor.
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	SYSEX_RESPONSE[PIN_STATE_RESPONSE] = function (board) {
	  var pin = board.currentBuffer[2];
	  board.pins[pin].mode = board.currentBuffer[3];
	  board.pins[pin].state = board.currentBuffer[4];
	  if (board.currentBuffer.length > 6) {
	    board.pins[pin].state |= (board.currentBuffer[5] << 7);
	  }
	  if (board.currentBuffer.length > 7) {
	    board.pins[pin].state |= (board.currentBuffer[6] << 14);
	  }
	  board.emit("pin-state-" + pin);
	};

	/**
	 * Handles a ANALOG_MAPPING_RESPONSE response and emits the "analog-mapping-query" event.
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	SYSEX_RESPONSE[ANALOG_MAPPING_RESPONSE] = function(board) {
	  var pin = 0;
	  var currentValue;
	  for (var i = 2; i < board.currentBuffer.length - 1; i++) {
	    currentValue = board.currentBuffer[i];
	    board.pins[pin].analogChannel = currentValue;
	    if (currentValue !== 127) {
	      board.analogPins.push(pin);
	    }
	    pin++;
	  }
	  board.emit("analog-mapping-query");
	};

	/**
	 * Handles a I2C_REPLY response and emits the "I2C-reply-"+n event where n is the slave address of the I2C device.
	 * The event is passed the buffer of data sent from the I2C Device
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	SYSEX_RESPONSE[I2C_REPLY] = function(board) {
	  var reply = [];
	  var address = (board.currentBuffer[2] & 0x7F) | ((board.currentBuffer[3] & 0x7F) << 7);
	  var register = (board.currentBuffer[4] & 0x7F) | ((board.currentBuffer[5] & 0x7F) << 7);

	  for (var i = 6, length = board.currentBuffer.length - 1; i < length; i += 2) {
	    reply.push(board.currentBuffer[i] | (board.currentBuffer[i + 1] << 7));
	  }

	  board.emit("I2C-reply-" + address + "-" + register, reply);
	};

	SYSEX_RESPONSE[ONEWIRE_DATA] = function(board) {
	  var subCommand = board.currentBuffer[2];

	  if (!SYSEX_RESPONSE[subCommand]) {
	    return;
	  }

	  SYSEX_RESPONSE[subCommand](board);
	};

	SYSEX_RESPONSE[ONEWIRE_SEARCH_REPLY] = function(board) {
	  var pin = board.currentBuffer[3];
	  var replyBuffer = board.currentBuffer.slice(4, board.currentBuffer.length - 1);

	  board.emit("1-wire-search-reply-" + pin, OneWireUtils.readDevices(replyBuffer));
	};

	SYSEX_RESPONSE[ONEWIRE_SEARCH_ALARMS_REPLY] = function(board) {
	  var pin = board.currentBuffer[3];
	  var replyBuffer = board.currentBuffer.slice(4, board.currentBuffer.length - 1);

	  board.emit("1-wire-search-alarms-reply-" + pin, OneWireUtils.readDevices(replyBuffer));
	};

	SYSEX_RESPONSE[ONEWIRE_READ_REPLY] = function(board) {
	  var encoded = board.currentBuffer.slice(4, board.currentBuffer.length - 1);
	  var decoded = Encoder7Bit.from7BitArray(encoded);
	  var correlationId = (decoded[1] << 8) | decoded[0];

	  board.emit("1-wire-read-reply-" + correlationId, decoded.slice(2));
	};

	/**
	 * Handles a STRING_DATA response and logs the string to the console.
	 * @private
	 * @param {Board} board the current arduino board we are working with.
	 */

	SYSEX_RESPONSE[STRING_DATA] = function(board) {
	  var string = new Buffer(board.currentBuffer.slice(2, -1)).toString("utf8").replace(/\0/g, "");
	  board.emit("string", string);
	};

	/**
	 * Response from pingRead
	 */

	SYSEX_RESPONSE[PING_READ] = function(board) {
	  var pin = (board.currentBuffer[2] & 0x7F) | ((board.currentBuffer[3] & 0x7F) << 7);
	  var durationBuffer = [
	    (board.currentBuffer[4] & 0x7F) | ((board.currentBuffer[5] & 0x7F) << 7), (board.currentBuffer[6] & 0x7F) | ((board.currentBuffer[7] & 0x7F) << 7), (board.currentBuffer[8] & 0x7F) | ((board.currentBuffer[9] & 0x7F) << 7), (board.currentBuffer[10] & 0x7F) | ((board.currentBuffer[11] & 0x7F) << 7)
	  ];
	  var duration = ((durationBuffer[0] << 24) +
	    (durationBuffer[1] << 16) +
	    (durationBuffer[2] << 8) +
	    (durationBuffer[3]));
	  board.emit("ping-read-" + pin, duration);
	};

	/**
	 * Handles the message from a stepper completing move
	 * @param {Board} board
	 */

	SYSEX_RESPONSE[STEPPER] = function(board) {
	  var deviceNum = board.currentBuffer[2];
	  board.emit("stepper-done-" + deviceNum, true);
	};


	/**
	 * @class The Board object represents an arduino board.
	 * @augments EventEmitter
	 * @param {String} port This is the serial port the arduino is connected to.
	 * @param {function} function A function to be called when the arduino is ready to communicate.
	 * @property MODES All the modes available for pins on this arduino board.
	 * @property I2C_MODES All the I2C modes available.
	 * @property HIGH A constant to set a pins value to HIGH when the pin is set to an output.
	 * @property LOW A constant to set a pins value to LOW when the pin is set to an output.
	 * @property pins An array of pin object literals.
	 * @property analogPins An array of analog pins and their corresponding indexes in the pins array.
	 * @property version An object indicating the major and minor version of the firmware currently running.
	 * @property firmware An object indicateon the name, major and minor version of the firmware currently running.
	 * @property currentBuffer An array holding the current bytes received from the arduino.
	 * @property {SerialPort} sp The serial port object used to communicate with the arduino.
	 */
	var Board = function(port, options, callback) {
	  Emitter.call(this);

	  if (typeof options === "function" || typeof options === "undefined") {
	    callback = options;
	    options = {};
	  }

	  var board = this;
	  var defaults = {
	    reportVersionTimeout: 5000,
	    samplingInterval: 19,
	    serialport: {
	      baudRate: 57600,
	      bufferSize: 1
	    }
	  };

	  var settings = assign({}, defaults, options);

	  this.isReady = false;

	  this.MODES = {
	    INPUT: 0x00,
	    OUTPUT: 0x01,
	    ANALOG: 0x02,
	    PWM: 0x03,
	    SERVO: 0x04,
	    SHIFT: 0x05,
	    I2C: 0x06,
	    ONEWIRE: 0x07,
	    STEPPER: 0x08,
	    IGNORE: 0x7F,
	    UNKOWN: 0x10
	  };

	  this.I2C_MODES = {
	    WRITE: 0x00,
	    READ: 1,
	    CONTINUOUS_READ: 2,
	    STOP_READING: 3
	  };

	  this.STEPPER = {
	    TYPE: {
	      DRIVER: 1,
	      TWO_WIRE: 2,
	      FOUR_WIRE: 4
	    },
	    RUNSTATE: {
	      STOP: 0,
	      ACCEL: 1,
	      DECEL: 2,
	      RUN: 3
	    },
	    DIRECTION: {
	      CCW: 0,
	      CW: 1
	    }
	  };

	  this.HIGH = 1;
	  this.LOW = 0;
	  this.pins = [];
	  this.analogPins = [];
	  this.version = {};
	  this.firmware = {};
	  this.currentBuffer = [];
	  this.versionReceived = false;
	  this.name = "Firmata";
	  this.settings = settings;

	  if (typeof port === "object") {
	    this.transport = port;
	  } else {
	    this.transport = new SerialPort(port, settings.serialport);
	  }

	  // For backward compat
	  this.sp = this.transport;

	  this.transport.on("open", function() {
	    this.emit("connect");
	  }.bind(this));

	  this.transport.on("error", function(string) {
	    if (typeof callback === "function") {
	      callback(string);
	    }
	  });

	  this.transport.on("data", function(data) {
	    var byt, cmd;

	    if (!this.versionReceived && data[0] !== REPORT_VERSION) {
	      return;
	    } else {
	      this.versionReceived = true;
	    }

	    for (var i = 0; i < data.length; i++) {
	      byt = data[i];
	      // we dont want to push 0 as the first byte on our buffer
	      if (this.currentBuffer.length === 0 && byt === 0) {
	        continue;
	      } else {
	        this.currentBuffer.push(byt);

	        // [START_SYSEX, ... END_SYSEX]
	        if (this.currentBuffer[0] === START_SYSEX &&
	          SYSEX_RESPONSE[this.currentBuffer[1]] &&
	          this.currentBuffer[this.currentBuffer.length - 1] === END_SYSEX) {

	          SYSEX_RESPONSE[this.currentBuffer[1]](this);
	          this.currentBuffer.length = 0;
	        } else if (this.currentBuffer[0] !== START_SYSEX) {
	          // Check if data gets out of sync: first byte in buffer
	          // must be a valid command if not START_SYSEX
	          // Identify command on first byte
	          cmd = this.currentBuffer[0] < 240 ? this.currentBuffer[0] & 0xF0 : this.currentBuffer[0];

	          // Check if it is not a valid command
	          if (cmd !== REPORT_VERSION && cmd !== ANALOG_MESSAGE && cmd !== DIGITAL_MESSAGE) {
	            // console.log("OUT OF SYNC - CMD: "+cmd);
	            // Clean buffer
	            this.currentBuffer.length = 0;
	          }
	        }

	        // There are 3 bytes in the buffer and the first is not START_SYSEX:
	        // Might have a MIDI Command
	        if (this.currentBuffer.length === 3 && this.currentBuffer[0] !== START_SYSEX) {
	          //commands under 0xF0 we have a multi byte command
	          if (this.currentBuffer[0] < 240) {
	            cmd = this.currentBuffer[0] & 0xF0;
	          } else {
	            cmd = this.currentBuffer[0];
	          }

	          if (MIDI_RESPONSE[cmd]) {
	            MIDI_RESPONSE[cmd](this);
	            this.currentBuffer.length = 0;
	          } else {
	            // A bad serial read must have happened.
	            // Reseting the buffer will allow recovery.
	            this.currentBuffer.length = 0;
	          }
	        }
	      }
	    }
	  }.bind(this));

	  // if we have not received the version within the alotted
	  // time specified by the reportVersionTimeout (user or default),
	  // then send an explicit request for it.
	  this.reportVersionTimeoutId = setTimeout(function() {
	    if (this.versionReceived === false) {
	      this.reportVersion(function() {});
	      this.queryFirmware(function() {});
	    }
	  }.bind(this), settings.reportVersionTimeout);

	  function ready() {
	    board.isReady = true;
	    board.emit("ready");
	    if (typeof callback === "function") {
	      callback();
	    }
	  }

	  // Await the reported version.
	  this.once("reportversion", function() {
	    clearTimeout(this.reportVersionTimeoutId);
	    this.versionReceived = true;
	    this.once("queryfirmware", function() {

	      // Only preemptively set the sampling interval if `samplingInterval`
	      // property was _explicitly_ set as a constructor option.
	      if (options.samplingInterval !== undefined) {
	        this.setSamplingInterval(options.samplingInterval);
	      }
	      if (settings.skipCapabilities) {
	        this.analogPins = settings.analogPins || this.analogPins;
	        this.pins = settings.pins || this.pins;
	        if (!this.pins.length) {
	          for (var i = 0; i < (settings.pinCount || MAX_PIN_COUNT); i++) {
	            var analogChannel = this.analogPins.indexOf(i);
	            if (analogChannel < 0) {
	              analogChannel = 127;
	            }
	            this.pins.push({supportedModes: [], analogChannel: analogChannel});
	          }
	        }
	        ready();
	      } else {
	        this.queryCapabilities(function() {
	          this.queryAnalogMapping(ready);
	        });
	      }
	    });
	  });

	  i2cActive.set(this, false);
	};

	util.inherits(Board, Emitter);

	/**
	 * Asks the arduino to tell us its version.
	 * @param {function} callback A function to be called when the arduino has reported its version.
	 */

	Board.prototype.reportVersion = function(callback) {
	  this.once("reportversion", callback);
	  this.transport.write(new Buffer([REPORT_VERSION]));
	};

	/**
	 * Asks the arduino to tell us its firmware version.
	 * @param {function} callback A function to be called when the arduino has reported its firmware version.
	 */

	Board.prototype.queryFirmware = function(callback) {
	  this.once("queryfirmware", callback);
	  this.transport.write(new Buffer([START_SYSEX, QUERY_FIRMWARE, END_SYSEX]));
	};

	/**
	 * Asks the arduino to read analog data. Turn on reporting for this pin.
	 * @param {number} pin The pin to read analog data
	 * @param {function} callback A function to call when we have the analag data.
	 */

	Board.prototype.analogRead = function(pin, callback) {
	  this.reportAnalogPin(pin, 1);
	  this.addListener("analog-read-" + pin, callback);
	};

	/**
	 * Asks the arduino to write an analog message.
	 * @param {number} pin The pin to write analog data to.
	 * @param {nubmer} value The data to write to the pin between 0 and 255.
	 */

	Board.prototype.analogWrite = function(pin, value) {
	  var data = [];

	  this.pins[pin].value = value;

	  if (pin > 15) {
	    data[0] = START_SYSEX;
	    data[1] = EXTENDED_ANALOG;
	    data[2] = pin;
	    data[3] = value & 0x7F;
	    data[4] = (value >> 7) & 0x7F;

	    if (value > 0x00004000) {
	      data[data.length] = (value >> 14) & 0x7F;
	    }

	    if (value > 0x00200000) {
	      data[data.length] = (value >> 21) & 0x7F;
	    }

	    if (value > 0x10000000) {
	      data[data.length] = (value >> 28) & 0x7F;
	    }

	    data[data.length] = END_SYSEX;
	  } else {
	    data.push(ANALOG_MESSAGE | pin, value & 0x7F, (value >> 7) & 0x7F);
	  }

	  this.transport.write(new Buffer(data));
	};

	Board.prototype.pwmWrite = Board.prototype.analogWrite;

	/**
	 * Set a pin to SERVO mode with an explicit PWM range.
	 *
	 * @param {number} pin The pin the servo is connected to
	 * @param {number} min A 14-bit signed int.
	 * @param {number} max A 14-bit signed int.
	 */

	Board.prototype.servoConfig = function(pin, min, max) {
	  // [0]  START_SYSEX  (0xF0)
	  // [1]  SERVO_CONFIG (0x70)
	  // [2]  pin number   (0-127)
	  // [3]  minPulse LSB (0-6)
	  // [4]  minPulse MSB (7-13)
	  // [5]  maxPulse LSB (0-6)
	  // [6]  maxPulse MSB (7-13)
	  // [7]  END_SYSEX    (0xF7)

	  var data = [
	    START_SYSEX,
	    SERVO_CONFIG,
	    pin,
	    min & 0x7F,
	    (min >> 7) & 0x7F,
	    max & 0x7F,
	    (max >> 7) & 0x7F,
	    END_SYSEX
	  ];

	  this.pins[pin].mode = this.MODES.SERVO;
	  this.transport.write(new Buffer(data));
	};

	/**
	 * Asks the arduino to move a servo
	 * @param {number} pin The pin the servo is connected to
	 * @param {number} value The degrees to move the servo to.
	 */

	Board.prototype.servoWrite = function(pin, value) {
	  // Values less than 544 will be treated as angles in degrees
	  // (valid values in microseconds are handled as microseconds)
	  this.analogWrite.apply(this, arguments);
	};

	/**
	 * Asks the arduino to set the pin to a certain mode.
	 * @param {number} pin The pin you want to change the mode of.
	 * @param {number} mode The mode you want to set. Must be one of board.MODES
	 */

	Board.prototype.pinMode = function(pin, mode) {
	  this.pins[pin].mode = mode;
	  this.transport.write(new Buffer([PIN_MODE, pin, mode]));
	};

	/**
	 * Asks the arduino to write a value to a digital pin
	 * @param {number} pin The pin you want to write a value to.
	 * @param {value} value The value you want to write. Must be board.HIGH or board.LOW
	 */

	Board.prototype.digitalWrite = function(pin, value) {
	  var port = Math.floor(pin / 8);
	  var portValue = 0;
	  var pinRecord;
	  this.pins[pin].value = value;
	  for (var i = 0; i < 8; i++) {
	    pinRecord = this.pins[8 * port + i];
	    if (pinRecord && pinRecord.value) {
	      portValue |= (1 << i);
	    }
	  }
	  this.transport.write(new Buffer([DIGITAL_MESSAGE | port, portValue & 0x7F, (portValue >> 7) & 0x7F]));
	};

	/**
	 * Asks the arduino to read digital data. Turn on reporting for this pin's port.
	 *
	 * @param {number} pin The pin to read data from
	 * @param {function} callback The function to call when data has been received
	 */

	Board.prototype.digitalRead = function(pin, callback) {
	  this.reportDigitalPin(pin, 1);
	  this.addListener("digital-read-" + pin, callback);
	};

	/**
	 * Asks the arduino to tell us its capabilities
	 * @param {function} callback A function to call when we receive the capabilities
	 */

	Board.prototype.queryCapabilities = function(callback) {
	  this.once("capability-query", callback);
	  this.transport.write(new Buffer([START_SYSEX, CAPABILITY_QUERY, END_SYSEX]));
	};

	/**
	 * Asks the arduino to tell us its analog pin mapping
	 * @param {function} callback A function to call when we receive the pin mappings.
	 */

	Board.prototype.queryAnalogMapping = function(callback) {
	  this.once("analog-mapping-query", callback);
	  this.transport.write(new Buffer([START_SYSEX, ANALOG_MAPPING_QUERY, END_SYSEX]));
	};

	/**
	 * Asks the arduino to tell us the current state of a pin
	 * @param {number} pin The pin we want to the know the state of
	 * @param {function} callback A function to call when we receive the pin state.
	 */

	Board.prototype.queryPinState = function(pin, callback) {
	  this.once("pin-state-" + pin, callback);
	  this.transport.write(new Buffer([START_SYSEX, PIN_STATE_QUERY, pin, END_SYSEX]));
	};

	/**
	 * Sends a string to the arduino
	 * @param {String} string to send to the device
	 */

	Board.prototype.sendString = function(string) {
	  var bytes = new Buffer(string + "\0", "utf8");
	  var data = [];
	  data.push(START_SYSEX);
	  data.push(STRING_DATA);
	  for (var i = 0, length = bytes.length; i < length; i++) {
	    data.push(bytes[i] & 0x7F);
	    data.push((bytes[i] >> 7) & 0x7F);
	  }
	  data.push(END_SYSEX);
	  this.transport.write(data);
	};

	function i2cRequest(board, buffer) {

	  if (!i2cActive.get(board)) {
	    throw new Error("I2C is not enabled for this board. To enable, call the i2cConfig() method.");
	  }

	  board.transport.write(buffer);
	}

	/**
	 * Sends a I2C config request to the arduino board with an optional
	 * value in microseconds to delay an I2C Read.  Must be called before
	 * an I2C Read or Write
	 * @param {number} delay in microseconds to set for I2C Read
	 */

	Board.prototype.sendI2CConfig = function(delay) {
	  return this.i2cConfig(delay);
	};

	/**
	 * Enable I2C with an optional read delay. Must be called before
	 * an I2C Read or Write
	 *
	 * Supersedes sendI2CConfig
	 *
	 * @param {number} delay in microseconds to set for I2C Read
	 */

	Board.prototype.i2cConfig = function(options) {
	  var delay;

	  if (typeof options === "number") {
	    delay = options;
	  } else {
	    if (typeof options === "object" && options !== null) {
	      delay = options.delay;
	    }
	  }

	  delay = delay || 0;

	  i2cActive.set(this, true);

	  i2cRequest(this,
	    new Buffer([
	      START_SYSEX,
	      I2C_CONFIG,
	      delay & 0xFF, (delay >> 8) & 0xFF,
	      END_SYSEX
	    ])
	  );

	  return this;
	};

	/**
	 * Asks the arduino to send an I2C request to a device
	 * @param {number} slaveAddress The address of the I2C device
	 * @param {Array} bytes The bytes to send to the device
	 */

	Board.prototype.sendI2CWriteRequest = function(slaveAddress, bytes) {
	  var data = [];
	  bytes = bytes || [];

	  data.push(
	    START_SYSEX,
	    I2C_REQUEST,
	    slaveAddress,
	    this.I2C_MODES.WRITE << 3
	  );

	  for (var i = 0, length = bytes.length; i < length; i++) {
	    data.push(
	      bytes[i] & 0x7F, (bytes[i] >> 7) & 0x7F
	    );
	  }

	  data.push(END_SYSEX);

	  i2cRequest(this, new Buffer(data));
	};

	/**
	 * Write data to a register
	 *
	 * @param {number} address      The address of the I2C device.
	 * @param {array} cmdRegOrData  An array of bytes
	 *
	 * Write a command to a register
	 *
	 * @param {number} address      The address of the I2C device.
	 * @param {number} cmdRegOrData The register
	 * @param {array} inBytes       An array of bytes
	 *
	 */
	Board.prototype.i2cWrite = function(address, registerOrData, inBytes) {
	  /**
	   * registerOrData:
	   * [... arbitrary bytes]
	   *
	   * or
	   *
	   * registerOrData, inBytes:
	   * command [, ...]
	   *
	   */
	  var bytes;
	  var data = [
	    START_SYSEX,
	    I2C_REQUEST,
	    address,
	    this.I2C_MODES.WRITE << 3
	  ];


	  // If i2cWrite was used for an i2cWriteReg call...
	  if (arguments.length === 3 &&
	      !Array.isArray(registerOrData) &&
	      !Array.isArray(inBytes)) {

	    return this.i2cWriteReg(address, registerOrData, inBytes);
	  }

	  // Fix arguments if called with Firmata.js API
	  if (arguments.length === 2) {
	    if (Array.isArray(registerOrData)) {
	      inBytes = registerOrData.slice();
	      registerOrData = inBytes.shift();
	    } else {
	      inBytes = [];
	    }
	  }

	  bytes = new Buffer([registerOrData].concat(inBytes));

	  for (var i = 0, length = bytes.length; i < length; i++) {
	    data.push(
	      bytes[i] & 0x7F, (bytes[i] >> 7) & 0x7F
	    );
	  }

	  data.push(END_SYSEX);

	  i2cRequest(this, new Buffer(data));

	  return this;
	};

	/**
	 * Write data to a register
	 *
	 * @param {number} address    The address of the I2C device.
	 * @param {number} register   The register.
	 * @param {number} byte       The byte value to write.
	 *
	 */

	Board.prototype.i2cWriteReg = function(address, register, byte) {
	  i2cRequest(this,
	    new Buffer([
	      START_SYSEX,
	      I2C_REQUEST,
	      address,
	      this.I2C_MODES.WRITE << 3,
	      // register
	      register & 0x7F, (register >> 7) & 0x7F,
	      // byte
	      byte & 0x7F, (byte >> 7) & 0x7F,
	      END_SYSEX
	    ])
	  );

	  return this;
	};


	/**
	 * Asks the arduino to request bytes from an I2C device
	 * @param {number} slaveAddress The address of the I2C device
	 * @param {number} numBytes The number of bytes to receive.
	 * @param {function} callback A function to call when we have received the bytes.
	 */

	Board.prototype.sendI2CReadRequest = function(address, numBytes, callback) {
	  i2cRequest(this,
	    new Buffer([
	      START_SYSEX,
	      I2C_REQUEST,
	      address,
	      this.I2C_MODES.READ << 3,
	      numBytes & 0x7F, (numBytes >> 7) & 0x7F,
	      END_SYSEX
	    ])
	  );
	  this.once("I2C-reply-" + address + "-0" , callback);
	};

	// TODO: Refactor i2cRead and i2cReadOnce
	//      to share most operations.

	/**
	 * Initialize a continuous I2C read.
	 *
	 * @param {number} address    The address of the I2C device
	 * @param {number} register   Optionally set the register to read from.
	 * @param {number} numBytes   The number of bytes to receive.
	 * @param {function} callback A function to call when we have received the bytes.
	 */

	Board.prototype.i2cRead = function(address, register, bytesToRead, callback) {

	  if (arguments.length === 3 &&
	      typeof register === "number" &&
	      typeof bytesToRead === "function") {
	    callback = bytesToRead;
	    bytesToRead = register;
	    register = null;
	  }

	  var event = "I2C-reply-" + address + "-";
	  var data = [
	    START_SYSEX,
	    I2C_REQUEST,
	    address,
	    this.I2C_MODES.CONTINUOUS_READ << 3,
	  ];

	  if (register !== null) {
	    data.push(
	      register & 0x7F, (register >> 7) & 0x7F
	    );
	  } else {
	    register = 0;
	  }

	  event += register;

	  data.push(
	    bytesToRead & 0x7F, (bytesToRead >> 7) & 0x7F,
	    END_SYSEX
	  );

	  this.on(event, callback);

	  i2cRequest(this, new Buffer(data));

	  return this;
	};

	/**
	 * Perform a single I2C read
	 *
	 * Supersedes sendI2CReadRequest
	 *
	 * Read bytes from address
	 *
	 * @param {number} address    The address of the I2C device
	 * @param {number} register   Optionally set the register to read from.
	 * @param {number} numBytes   The number of bytes to receive.
	 * @param {function} callback A function to call when we have received the bytes.
	 *
	 */


	Board.prototype.i2cReadOnce = function(address, register, bytesToRead, callback) {

	  if (arguments.length === 3 &&
	      typeof register === "number" &&
	      typeof bytesToRead === "function") {
	    callback = bytesToRead;
	    bytesToRead = register;
	    register = null;
	  }

	  var event = "I2C-reply-" + address + "-";
	  var data = [
	    START_SYSEX,
	    I2C_REQUEST,
	    address,
	    this.I2C_MODES.READ << 3,
	  ];

	  if (register !== null) {
	    data.push(
	      register & 0x7F, (register >> 7) & 0x7F
	    );
	  } else {
	    register = 0;
	  }

	  event += register;

	  data.push(
	    bytesToRead & 0x7F, (bytesToRead >> 7) & 0x7F,
	    END_SYSEX
	  );

	  this.once(event, callback);

	  i2cRequest(this, new Buffer(data));

	  return this;
	};

	// CONTINUOUS_READ

	/**
	 * Configure the passed pin as the controller in a 1-wire bus.
	 * Pass as enableParasiticPower true if you want the data pin to power the bus.
	 * @param pin
	 * @param enableParasiticPower
	 */
	Board.prototype.sendOneWireConfig = function(pin, enableParasiticPower) {
	  this.transport.write(new Buffer([START_SYSEX, ONEWIRE_DATA, ONEWIRE_CONFIG_REQUEST, pin, enableParasiticPower ? 0x01 : 0x00, END_SYSEX]));
	};

	/**
	 * Searches for 1-wire devices on the bus.  The passed callback should accept
	 * and error argument and an array of device identifiers.
	 * @param pin
	 * @param callback
	 */
	Board.prototype.sendOneWireSearch = function(pin, callback) {
	  this._sendOneWireSearch(ONEWIRE_SEARCH_REQUEST, "1-wire-search-reply-" + pin, pin, callback);
	};

	/**
	 * Searches for 1-wire devices on the bus in an alarmed state.  The passed callback
	 * should accept and error argument and an array of device identifiers.
	 * @param pin
	 * @param callback
	 */
	Board.prototype.sendOneWireAlarmsSearch = function(pin, callback) {
	  this._sendOneWireSearch(ONEWIRE_SEARCH_ALARMS_REQUEST, "1-wire-search-alarms-reply-" + pin, pin, callback);
	};

	Board.prototype._sendOneWireSearch = function(type, event, pin, callback) {
	  this.transport.write(new Buffer([START_SYSEX, ONEWIRE_DATA, type, pin, END_SYSEX]));

	  var searchTimeout = setTimeout(function() {
	    callback(new Error("1-Wire device search timeout - are you running ConfigurableFirmata?"));
	  }, 5000);
	  this.once(event, function(devices) {
	    clearTimeout(searchTimeout);

	    callback(null, devices);
	  });
	};

	/**
	 * Reads data from a device on the bus and invokes the passed callback.
	 *
	 * N.b. ConfigurableFirmata will issue the 1-wire select command internally.
	 * @param pin
	 * @param device
	 * @param numBytesToRead
	 * @param callback
	 */
	Board.prototype.sendOneWireRead = function(pin, device, numBytesToRead, callback) {
	  var correlationId = Math.floor(Math.random() * 255);
	  var readTimeout = setTimeout(function() {
	    callback(new Error("1-Wire device read timeout - are you running ConfigurableFirmata?"));
	  }, 5000);
	  this._sendOneWireRequest(pin, ONEWIRE_READ_REQUEST_BIT, device, numBytesToRead, correlationId, null, null, "1-wire-read-reply-" + correlationId, function(data) {
	    clearTimeout(readTimeout);

	    callback(null, data);
	  });
	};

	/**
	 * Resets all devices on the bus.
	 * @param pin
	 */
	Board.prototype.sendOneWireReset = function(pin) {
	  this._sendOneWireRequest(pin, ONEWIRE_RESET_REQUEST_BIT);
	};

	/**
	 * Writes data to the bus to be received by the passed device.  The device
	 * should be obtained from a previous call to sendOneWireSearch.
	 *
	 * N.b. ConfigurableFirmata will issue the 1-wire select command internally.
	 * @param pin
	 * @param device
	 * @param data
	 */
	Board.prototype.sendOneWireWrite = function(pin, device, data) {
	  this._sendOneWireRequest(pin, ONEWIRE_WRITE_REQUEST_BIT, device, null, null, null, Array.isArray(data) ? data : [data]);
	};

	/**
	 * Tells firmata to not do anything for the passed amount of ms.  For when you
	 * need to give a device attached to the bus time to do a calculation.
	 * @param pin
	 */
	Board.prototype.sendOneWireDelay = function(pin, delay) {
	  this._sendOneWireRequest(pin, ONEWIRE_DELAY_REQUEST_BIT, null, null, null, delay);
	};

	/**
	 * Sends the passed data to the passed device on the bus, reads the specified
	 * number of bytes and invokes the passed callback.
	 *
	 * N.b. ConfigurableFirmata will issue the 1-wire select command internally.
	 * @param pin
	 * @param device
	 * @param data
	 * @param numBytesToRead
	 * @param callback
	 */
	Board.prototype.sendOneWireWriteAndRead = function(pin, device, data, numBytesToRead, callback) {
	  var correlationId = Math.floor(Math.random() * 255);
	  var readTimeout = setTimeout(function() {
	    callback(new Error("1-Wire device read timeout - are you running ConfigurableFirmata?"));
	  }, 5000);
	  this._sendOneWireRequest(pin, ONEWIRE_WRITE_REQUEST_BIT | ONEWIRE_READ_REQUEST_BIT, device, numBytesToRead, correlationId, null, Array.isArray(data) ? data : [data], "1-wire-read-reply-" + correlationId, function(data) {
	    clearTimeout(readTimeout);

	    callback(null, data);
	  });
	};

	// see http://firmata.org/wiki/Proposals#OneWire_Proposal
	Board.prototype._sendOneWireRequest = function(pin, subcommand, device, numBytesToRead, correlationId, delay, dataToWrite, event, callback) {
	  var bytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

	  if (device || numBytesToRead || correlationId || delay || dataToWrite) {
	    subcommand = subcommand | ONEWIRE_WITHDATA_REQUEST_BITS;
	  }

	  if (device) {
	    bytes.splice.apply(bytes, [0, 8].concat(device));
	  }

	  if (numBytesToRead) {
	    bytes[8] = numBytesToRead & 0xFF;
	    bytes[9] = (numBytesToRead >> 8) & 0xFF;
	  }

	  if (correlationId) {
	    bytes[10] = correlationId & 0xFF;
	    bytes[11] = (correlationId >> 8) & 0xFF;
	  }

	  if (delay) {
	    bytes[12] = delay & 0xFF;
	    bytes[13] = (delay >> 8) & 0xFF;
	    bytes[14] = (delay >> 16) & 0xFF;
	    bytes[15] = (delay >> 24) & 0xFF;
	  }

	  if (dataToWrite) {
	    dataToWrite.forEach(function(byte) {
	      bytes.push(byte);
	    });
	  }

	  var output = [START_SYSEX, ONEWIRE_DATA, subcommand, pin];
	  output = output.concat(Encoder7Bit.to7BitArray(bytes));
	  output.push(END_SYSEX);

	  this.transport.write(new Buffer(output));

	  if (event && callback) {
	    this.once(event, callback);
	  }
	};

	/**
	 * Set sampling interval in millis. Default is 19 ms
	 * @param {number} interval The sampling interval in ms > 10
	 */

	Board.prototype.setSamplingInterval = function(interval) {
	  var safeint = interval < 10 ? 10 : (interval > 65535 ? 65535 : interval); // constrained
	  this.settings.samplingInterval = safeint;
	  this.transport.write(new Buffer([START_SYSEX, SAMPLING_INTERVAL, (safeint & 0x7F), ((safeint >> 7) & 0x7F), END_SYSEX]));
	};

	/**
	 * Get sampling interval in millis. Default is 19 ms
	 */

	Board.prototype.getSamplingInterval = function(interval) {
	  return this.settings.samplingInterval;
	};

	/**
	 * Set reporting on pin
	 * @param {number} pin The pin to turn on/off reporting
	 * @param {number} value Binary value to turn reporting on/off
	 */

	Board.prototype.reportAnalogPin = function(pin, value) {
	  if (value === 0 || value === 1) {
	    this.pins[this.analogPins[pin]].report = value;
	    this.transport.write(new Buffer([REPORT_ANALOG | pin, value]));
	  }
	};

	/**
	 * Set reporting on pin
	 * @param {number} pin The pin to turn on/off reporting
	 * @param {number} value Binary value to turn reporting on/off
	 */

	Board.prototype.reportDigitalPin = function(pin, value) {
	  var port = Math.floor(pin / 8);
	  if (value === 0 || value === 1) {
	    this.pins[pin].report = value;
	    this.transport.write(new Buffer([REPORT_DIGITAL | port, value]));
	  }
	};

	/**
	 *
	 *
	 */

	Board.prototype.pingRead = function(opts, callback) {
	  var pin = opts.pin;
	  var value = opts.value;
	  var pulseOut = opts.pulseOut || 0;
	  var timeout = opts.timeout || 1000000;
	  var pulseOutArray = [
	    ((pulseOut >> 24) & 0xFF), ((pulseOut >> 16) & 0xFF), ((pulseOut >> 8) & 0XFF), ((pulseOut & 0xFF))
	  ];
	  var timeoutArray = [
	    ((timeout >> 24) & 0xFF), ((timeout >> 16) & 0xFF), ((timeout >> 8) & 0XFF), ((timeout & 0xFF))
	  ];
	  var data = [
	    START_SYSEX,
	    PING_READ,
	    pin,
	    value,
	    pulseOutArray[0] & 0x7F, (pulseOutArray[0] >> 7) & 0x7F,
	    pulseOutArray[1] & 0x7F, (pulseOutArray[1] >> 7) & 0x7F,
	    pulseOutArray[2] & 0x7F, (pulseOutArray[2] >> 7) & 0x7F,
	    pulseOutArray[3] & 0x7F, (pulseOutArray[3] >> 7) & 0x7F,
	    timeoutArray[0] & 0x7F, (timeoutArray[0] >> 7) & 0x7F,
	    timeoutArray[1] & 0x7F, (timeoutArray[1] >> 7) & 0x7F,
	    timeoutArray[2] & 0x7F, (timeoutArray[2] >> 7) & 0x7F,
	    timeoutArray[3] & 0x7F, (timeoutArray[3] >> 7) & 0x7F,
	    END_SYSEX
	  ];
	  this.transport.write(new Buffer(data));
	  this.once("ping-read-" + pin, callback);
	};

	/**
	 * Stepper functions to support AdvancedFirmata"s asynchronous control of stepper motors
	 * https://github.com/soundanalogous/AdvancedFirmata
	 */

	/**
	 * Asks the arduino to configure a stepper motor with the given config to allow asynchronous control of the stepper
	 * @param {number} deviceNum Device number for the stepper (range 0-5, expects steppers to be setup in order from 0 to 5)
	 * @param {number} type One of this.STEPPER.TYPE.*
	 * @param {number} stepsPerRev Number of steps motor takes to make one revolution
	 * @param {number} dirOrMotor1Pin If using EasyDriver type stepper driver, this is direction pin, otherwise it is motor 1 pin
	 * @param {number} stepOrMotor2Pin If using EasyDriver type stepper driver, this is step pin, otherwise it is motor 2 pin
	 * @param {number} [motor3Pin] Only required if type == this.STEPPER.TYPE.FOUR_WIRE
	 * @param {number} [motor4Pin] Only required if type == this.STEPPER.TYPE.FOUR_WIRE
	 */

	Board.prototype.stepperConfig = function(deviceNum, type, stepsPerRev, dirOrMotor1Pin, stepOrMotor2Pin, motor3Pin, motor4Pin) {
	  var data = [
	    START_SYSEX,
	    STEPPER,
	    0x00, // STEPPER_CONFIG from firmware
	    deviceNum,
	    type,
	    stepsPerRev & 0x7F, (stepsPerRev >> 7) & 0x7F,
	    dirOrMotor1Pin,
	    stepOrMotor2Pin
	  ];
	  if (type === this.STEPPER.TYPE.FOUR_WIRE) {
	    data.push(motor3Pin, motor4Pin);
	  }
	  data.push(END_SYSEX);
	  this.transport.write(new Buffer(data));
	};

	/**
	 * Asks the arduino to move a stepper a number of steps at a specific speed
	 * (and optionally with and acceleration and deceleration)
	 * speed is in units of .01 rad/sec
	 * accel and decel are in units of .01 rad/sec^2
	 * TODO: verify the units of speed, accel, and decel
	 * @param {number} deviceNum Device number for the stepper (range 0-5)
	 * @param {number} direction One of this.STEPPER.DIRECTION.*
	 * @param {number} steps Number of steps to make
	 * @param {number} speed
	 * @param {number|function} accel Acceleration or if accel and decel are not used, then it can be the callback
	 * @param {number} [decel]
	 * @param {function} [callback]
	 */

	Board.prototype.stepperStep = function(deviceNum, direction, steps, speed, accel, decel, callback) {
	  if (typeof accel === "function") {
	    callback = accel;
	    accel = 0;
	    decel = 0;
	  }

	  var data = [
	    START_SYSEX,
	    STEPPER,
	    0x01, // STEPPER_STEP from firmware
	    deviceNum,
	    direction, // one of this.STEPPER.DIRECTION.*
	    steps & 0x7F, (steps >> 7) & 0x7F, (steps >> 14) & 0x7f,
	    speed & 0x7F, (speed >> 7) & 0x7F
	  ];
	  if (accel > 0 || decel > 0) {
	    data.push(
	      accel & 0x7F, (accel >> 7) & 0x7F,
	      decel & 0x7F, (decel >> 7) & 0x7F
	    );
	  }
	  data.push(END_SYSEX);
	  this.transport.write(new Buffer(data));
	  this.once("stepper-done-" + deviceNum, callback);
	};

	/**
	 * Send SYSTEM_RESET to arduino
	 */

	Board.prototype.reset = function() {
	  this.transport.write(new Buffer([SYSTEM_RESET]));
	};

	// For backwards compatibility
	Board.Board = Board;
	Board.SYSEX_RESPONSE = SYSEX_RESPONSE;
	Board.MIDI_RESPONSE = MIDI_RESPONSE;

	module.exports = Board;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2).Buffer))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(19)() ? Map : __webpack_require__(20);


/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var map, iterator, result;
		if (typeof Map !== 'function') return false;
		try {
			// WebKit doesn't support arguments and crashes
			map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
		} catch (e) {
			return false;
		}
		if (map.size !== 3) return false;
		if (typeof map.clear !== 'function') return false;
		if (typeof map.delete !== 'function') return false;
		if (typeof map.entries !== 'function') return false;
		if (typeof map.forEach !== 'function') return false;
		if (typeof map.get !== 'function') return false;
		if (typeof map.has !== 'function') return false;
		if (typeof map.keys !== 'function') return false;
		if (typeof map.set !== 'function') return false;
		if (typeof map.values !== 'function') return false;

		iterator = map.entries();
		result = iterator.next();
		if (result.done !== false) return false;
		if (!result.value) return false;
		if (result.value[0] !== 'raz') return false;
		if (result.value[1] !== 'one') return false;
		return true;
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var clear          = __webpack_require__(21)
	  , eIndexOf       = __webpack_require__(23)
	  , setPrototypeOf = __webpack_require__(29)
	  , callable       = __webpack_require__(34)
	  , validValue     = __webpack_require__(22)
	  , d              = __webpack_require__(35)
	  , ee             = __webpack_require__(47)
	  , Symbol         = __webpack_require__(48)
	  , iterator       = __webpack_require__(51)
	  , forOf          = __webpack_require__(59)
	  , Iterator       = __webpack_require__(69)
	  , isNative       = __webpack_require__(72)

	  , call = Function.prototype.call, defineProperties = Object.defineProperties
	  , MapPoly;

	module.exports = MapPoly = function (/*iterable*/) {
		var iterable = arguments[0], keys, values;
		if (!(this instanceof MapPoly)) return new MapPoly(iterable);
		if (this.__mapKeysData__ !== undefined) {
			throw new TypeError(this + " cannot be reinitialized");
		}
		if (iterable != null) iterator(iterable);
		defineProperties(this, {
			__mapKeysData__: d('c', keys = []),
			__mapValuesData__: d('c', values = [])
		});
		if (!iterable) return;
		forOf(iterable, function (value) {
			var key = validValue(value)[0];
			value = value[1];
			if (eIndexOf.call(keys, key) !== -1) return;
			keys.push(key);
			values.push(value);
		}, this);
	};

	if (isNative) {
		if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
		MapPoly.prototype = Object.create(Map.prototype, {
			constructor: d(MapPoly)
		});
	}

	ee(defineProperties(MapPoly.prototype, {
		clear: d(function () {
			if (!this.__mapKeysData__.length) return;
			clear.call(this.__mapKeysData__);
			clear.call(this.__mapValuesData__);
			this.emit('_clear');
		}),
		delete: d(function (key) {
			var index = eIndexOf.call(this.__mapKeysData__, key);
			if (index === -1) return false;
			this.__mapKeysData__.splice(index, 1);
			this.__mapValuesData__.splice(index, 1);
			this.emit('_delete', index, key);
			return true;
		}),
		entries: d(function () { return new Iterator(this, 'key+value'); }),
		forEach: d(function (cb/*, thisArg*/) {
			var thisArg = arguments[1], iterator, result;
			callable(cb);
			iterator = this.entries();
			result = iterator._next();
			while (result !== undefined) {
				call.call(cb, thisArg, this.__mapValuesData__[result],
					this.__mapKeysData__[result], this);
				result = iterator._next();
			}
		}),
		get: d(function (key) {
			var index = eIndexOf.call(this.__mapKeysData__, key);
			if (index === -1) return;
			return this.__mapValuesData__[index];
		}),
		has: d(function (key) {
			return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
		}),
		keys: d(function () { return new Iterator(this, 'key'); }),
		set: d(function (key, value) {
			var index = eIndexOf.call(this.__mapKeysData__, key), emit;
			if (index === -1) {
				index = this.__mapKeysData__.push(key) - 1;
				emit = true;
			}
			this.__mapValuesData__[index] = value;
			if (emit) this.emit('_add', index, key);
			return this;
		}),
		size: d.gs(function () { return this.__mapKeysData__.length; }),
		values: d(function () { return new Iterator(this, 'value'); }),
		toString: d(function () { return '[object Map]'; })
	}));
	Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
		return this.entries();
	}));
	Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// Inspired by Google Closure:
	// http://closure-library.googlecode.com/svn/docs/
	// closure_goog_array_array.js.html#goog.array.clear

	'use strict';

	var value = __webpack_require__(22);

	module.exports = function () {
		value(this).length = 0;
		return this;
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var toPosInt = __webpack_require__(24)
	  , value    = __webpack_require__(22)

	  , indexOf = Array.prototype.indexOf
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , abs = Math.abs, floor = Math.floor;

	module.exports = function (searchElement/*, fromIndex*/) {
		var i, l, fromIndex, val;
		if (searchElement === searchElement) { //jslint: ignore
			return indexOf.apply(this, arguments);
		}

		l = toPosInt(value(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor(fromIndex);
		else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

		for (i = fromIndex; i < l; ++i) {
			if (hasOwnProperty.call(this, i)) {
				val = this[i];
				if (val !== val) return i; //jslint: ignore
			}
		}
		return -1;
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var toInteger = __webpack_require__(25)

	  , max = Math.max;

	module.exports = function (value) { return max(0, toInteger(value)); };


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var sign = __webpack_require__(26)

	  , abs = Math.abs, floor = Math.floor;

	module.exports = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(27)()
		? Math.sign
		: __webpack_require__(28);


/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var sign = Math.sign;
		if (typeof sign !== 'function') return false;
		return ((sign(10) === 1) && (sign(-20) === -1));
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return (value > 0) ? 1 : -1;
	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(30)()
		? Object.setPrototypeOf
		: __webpack_require__(31);


/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';

	var create = Object.create, getPrototypeOf = Object.getPrototypeOf
	  , x = {};

	module.exports = function (/*customCreate*/) {
		var setPrototypeOf = Object.setPrototypeOf
		  , customCreate = arguments[0] || create;
		if (typeof setPrototypeOf !== 'function') return false;
		return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
	};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// Big thanks to @WebReflection for sorting this out
	// https://gist.github.com/WebReflection/5593554

	'use strict';

	var isObject      = __webpack_require__(32)
	  , value         = __webpack_require__(22)

	  , isPrototypeOf = Object.prototype.isPrototypeOf
	  , defineProperty = Object.defineProperty
	  , nullDesc = { configurable: true, enumerable: false, writable: true,
			value: undefined }
	  , validate;

	validate = function (obj, prototype) {
		value(obj);
		if ((prototype === null) || isObject(prototype)) return obj;
		throw new TypeError('Prototype must be null or an object');
	};

	module.exports = (function (status) {
		var fn, set;
		if (!status) return null;
		if (status.level === 2) {
			if (status.set) {
				set = status.set;
				fn = function (obj, prototype) {
					set.call(validate(obj, prototype), prototype);
					return obj;
				};
			} else {
				fn = function (obj, prototype) {
					validate(obj, prototype).__proto__ = prototype;
					return obj;
				};
			}
		} else {
			fn = function self(obj, prototype) {
				var isNullBase;
				validate(obj, prototype);
				isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
				if (isNullBase) delete self.nullPolyfill.__proto__;
				if (prototype === null) prototype = self.nullPolyfill;
				obj.__proto__ = prototype;
				if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
				return obj;
			};
		}
		return Object.defineProperty(fn, 'level', { configurable: false,
			enumerable: false, writable: false, value: status.level });
	}((function () {
		var x = Object.create(null), y = {}, set
		  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

		if (desc) {
			try {
				set = desc.set; // Opera crashes at this point
				set.call(x, y);
			} catch (ignore) { }
			if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
		}

		x.__proto__ = y;
		if (Object.getPrototypeOf(x) === y) return { level: 2 };

		x = {};
		x.__proto__ = y;
		if (Object.getPrototypeOf(x) === y) return { level: 1 };

		return false;
	}())));

	__webpack_require__(33);


/***/ },
/* 32 */
/***/ function(module, exports) {

	'use strict';

	var map = { function: true, object: true };

	module.exports = function (x) {
		return ((x != null) && map[typeof x]) || false;
	};


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// Workaround for http://code.google.com/p/v8/issues/detail?id=2804

	'use strict';

	var create = Object.create, shim;

	if (!__webpack_require__(30)()) {
		shim = __webpack_require__(31);
	}

	module.exports = (function () {
		var nullObject, props, desc;
		if (!shim) return create;
		if (shim.level !== 1) return create;

		nullObject = {};
		props = {};
		desc = { configurable: false, enumerable: false, writable: true,
			value: undefined };
		Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
			if (name === '__proto__') {
				props[name] = { configurable: true, enumerable: false, writable: true,
					value: undefined };
				return;
			}
			props[name] = desc;
		});
		Object.defineProperties(nullObject, props);

		Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
			enumerable: false, writable: false, value: nullObject });

		return function (prototype, props) {
			return create((prototype === null) ? nullObject : prototype, props);
		};
	}());


/***/ },
/* 34 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assign        = __webpack_require__(36)
	  , normalizeOpts = __webpack_require__(42)
	  , isCallable    = __webpack_require__(43)
	  , contains      = __webpack_require__(44)

	  , d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(37)()
		? Object.assign
		: __webpack_require__(38);


/***/ },
/* 37 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys  = __webpack_require__(39)
	  , value = __webpack_require__(22)

	  , max = Math.max;

	module.exports = function (dest, src/*, srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(40)()
		? Object.keys
		: __webpack_require__(41);


/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';

	var keys = Object.keys;

	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	module.exports = function (options/*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	// Deprecated

	'use strict';

	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(45)()
		? String.prototype.contains
		: __webpack_require__(46);


/***/ },
/* 45 */
/***/ function(module, exports) {

	'use strict';

	var str = 'razdwatrzy';

	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict';

	var indexOf = String.prototype.indexOf;

	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var d        = __webpack_require__(35)
	  , callable = __webpack_require__(34)

	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		callable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		callable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(49)() ? Symbol : __webpack_require__(50);


/***/ },
/* 49 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }
		if (typeof Symbol.iterator === 'symbol') return true;

		// Return 'true' for polyfills
		if (typeof Symbol.isConcatSpreadable !== 'object') return false;
		if (typeof Symbol.isRegExp !== 'object') return false;
		if (typeof Symbol.iterator !== 'object') return false;
		if (typeof Symbol.toPrimitive !== 'object') return false;
		if (typeof Symbol.toStringTag !== 'object') return false;
		if (typeof Symbol.unscopables !== 'object') return false;

		return true;
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var d = __webpack_require__(35)

	  , create = Object.create, defineProperties = Object.defineProperties
	  , generateName, Symbol;

	generateName = (function () {
		var created = create(null);
		return function (desc) {
			var postfix = 0;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			return '@@' + desc;
		};
	}());

	module.exports = Symbol = function (description) {
		var symbol;
		if (this instanceof Symbol) {
			throw new TypeError('TypeError: Symbol is not a constructor');
		}
		symbol = create(Symbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d('', description),
			__name__: d('', generateName(description))
		});
	};

	Object.defineProperties(Symbol, {
		create: d('', Symbol('create')),
		hasInstance: d('', Symbol('hasInstance')),
		isConcatSpreadable: d('', Symbol('isConcatSpreadable')),
		isRegExp: d('', Symbol('isRegExp')),
		iterator: d('', Symbol('iterator')),
		toPrimitive: d('', Symbol('toPrimitive')),
		toStringTag: d('', Symbol('toStringTag')),
		unscopables: d('', Symbol('unscopables'))
	});

	defineProperties(Symbol.prototype, {
		properToString: d(function () {
			return 'Symbol (' + this.__description__ + ')';
		}),
		toString: d('', function () { return this.__name__; })
	});
	Object.defineProperty(Symbol.prototype, Symbol.toPrimitive, d('',
		function (hint) {
			throw new TypeError("Conversion of symbol objects is not allowed");
		}));
	Object.defineProperty(Symbol.prototype, Symbol.toStringTag, d('c', 'Symbol'));


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isIterable = __webpack_require__(52);

	module.exports = function (value) {
		if (!isIterable(value)) throw new TypeError(value + " is not iterable");
		return value;
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isString       = __webpack_require__(53)
	  , iteratorSymbol = __webpack_require__(54).iterator

	  , isArray = Array.isArray;

	module.exports = function (value) {
		if (value == null) return false;
		if (isArray(value)) return true;
		if (isString(value)) return true;
		return (typeof value[iteratorSymbol] === 'function');
	};


/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';

	var toString = Object.prototype.toString

	  , id = toString.call('');

	module.exports = function (x) {
		return (typeof x === 'string') || (x && (typeof x === 'object') &&
			((x instanceof String) || (toString.call(x) === id))) || false;
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(55)() ? Symbol : __webpack_require__(56);


/***/ },
/* 55 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }
		if (typeof Symbol.iterator === 'symbol') return true;

		// Return 'true' for polyfills
		if (typeof Symbol.isConcatSpreadable !== 'object') return false;
		if (typeof Symbol.iterator !== 'object') return false;
		if (typeof Symbol.toPrimitive !== 'object') return false;
		if (typeof Symbol.toStringTag !== 'object') return false;
		if (typeof Symbol.unscopables !== 'object') return false;

		return true;
	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var d              = __webpack_require__(35)
	  , validateSymbol = __webpack_require__(57)

	  , create = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , Symbol, HiddenSymbol, globalSymbols = create(null);

	var generateName = (function () {
		var created = create(null);
		return function (desc) {
			var postfix = 0, name;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d.gs(null, function (value) {
				defineProperty(this, name, d(value));
			}));
			return name;
		};
	}());

	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
		return Symbol(description);
	};
	module.exports = Symbol = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
		symbol = create(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d('', description),
			__name__: d('', generateName(description))
		});
	};
	defineProperties(Symbol, {
		for: d(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = Symbol(String(key)));
		}),
		keyFor: d(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),
		hasInstance: d('', Symbol('hasInstance')),
		isConcatSpreadable: d('', Symbol('isConcatSpreadable')),
		iterator: d('', Symbol('iterator')),
		match: d('', Symbol('match')),
		replace: d('', Symbol('replace')),
		search: d('', Symbol('search')),
		species: d('', Symbol('species')),
		split: d('', Symbol('split')),
		toPrimitive: d('', Symbol('toPrimitive')),
		toStringTag: d('', Symbol('toStringTag')),
		unscopables: d('', Symbol('unscopables'))
	});
	defineProperties(HiddenSymbol.prototype, {
		constructor: d(Symbol),
		toString: d('', function () { return this.__name__; })
	});

	defineProperties(Symbol.prototype, {
		toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d(function () { return validateSymbol(this); })
	});
	defineProperty(Symbol.prototype, Symbol.toPrimitive, d('',
		function () { return validateSymbol(this); }));
	defineProperty(Symbol.prototype, Symbol.toStringTag, d('c', 'Symbol'));

	defineProperty(HiddenSymbol.prototype, Symbol.toPrimitive,
		d('c', Symbol.prototype[Symbol.toPrimitive]));
	defineProperty(HiddenSymbol.prototype, Symbol.toStringTag,
		d('c', Symbol.prototype[Symbol.toStringTag]));


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isSymbol = __webpack_require__(58);

	module.exports = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};


/***/ },
/* 58 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (x) {
		return (x && ((typeof x === 'symbol') || (x['@@toStringTag'] === 'Symbol'))) || false;
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var callable = __webpack_require__(34)
	  , isString = __webpack_require__(53)
	  , get      = __webpack_require__(60)

	  , isArray = Array.isArray, call = Function.prototype.call;

	module.exports = function (iterable, cb/*, thisArg*/) {
		var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
		if (isArray(iterable)) mode = 'array';
		else if (isString(iterable)) mode = 'string';
		else iterable = get(iterable);

		callable(cb);
		doBreak = function () { broken = true; };
		if (mode === 'array') {
			iterable.some(function (value) {
				call.call(cb, thisArg, value, doBreak);
				if (broken) return true;
			});
			return;
		}
		if (mode === 'string') {
			l = iterable.length;
			for (i = 0; i < l; ++i) {
				char = iterable[i];
				if ((i + 1) < l) {
					code = char.charCodeAt(0);
					if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
				}
				call.call(cb, thisArg, char, doBreak);
				if (broken) break;
			}
			return;
		}
		result = iterable.next();

		while (!result.done) {
			call.call(cb, thisArg, result.value, doBreak);
			if (broken) return;
			result = iterable.next();
		}
	};


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isString = __webpack_require__(53)
	  , ArrayIterator  = __webpack_require__(61)
	  , StringIterator = __webpack_require__(68)
	  , iterable       = __webpack_require__(51)
	  , iteratorSymbol = __webpack_require__(54).iterator;

	module.exports = function (obj) {
		if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
		if (isString(obj)) return new StringIterator(obj);
		return new ArrayIterator(obj);
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var setPrototypeOf = __webpack_require__(29)
	  , contains       = __webpack_require__(44)
	  , d              = __webpack_require__(35)
	  , Iterator       = __webpack_require__(62)

	  , defineProperty = Object.defineProperty
	  , ArrayIterator;

	ArrayIterator = module.exports = function (arr, kind) {
		if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
		Iterator.call(this, arr);
		if (!kind) kind = 'value';
		else if (contains.call(kind, 'key+value')) kind = 'key+value';
		else if (contains.call(kind, 'key')) kind = 'key';
		else kind = 'value';
		defineProperty(this, '__kind__', d('', kind));
	};
	if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

	ArrayIterator.prototype = Object.create(Iterator.prototype, {
		constructor: d(ArrayIterator),
		_resolve: d(function (i) {
			if (this.__kind__ === 'value') return this.__list__[i];
			if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
			return i;
		}),
		toString: d(function () { return '[object Array Iterator]'; })
	});


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var clear    = __webpack_require__(21)
	  , assign   = __webpack_require__(36)
	  , callable = __webpack_require__(34)
	  , value    = __webpack_require__(22)
	  , d        = __webpack_require__(35)
	  , autoBind = __webpack_require__(63)
	  , Symbol   = __webpack_require__(54)

	  , defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , Iterator;

	module.exports = Iterator = function (list, context) {
		if (!(this instanceof Iterator)) return new Iterator(list, context);
		defineProperties(this, {
			__list__: d('w', value(list)),
			__context__: d('w', context),
			__nextIndex__: d('w', 0)
		});
		if (!context) return;
		callable(context.on);
		context.on('_add', this._onAdd);
		context.on('_delete', this._onDelete);
		context.on('_clear', this._onClear);
	};

	defineProperties(Iterator.prototype, assign({
		constructor: d(Iterator),
		_next: d(function () {
			var i;
			if (!this.__list__) return;
			if (this.__redo__) {
				i = this.__redo__.shift();
				if (i !== undefined) return i;
			}
			if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
			this._unBind();
		}),
		next: d(function () { return this._createResult(this._next()); }),
		_createResult: d(function (i) {
			if (i === undefined) return { done: true, value: undefined };
			return { done: false, value: this._resolve(i) };
		}),
		_resolve: d(function (i) { return this.__list__[i]; }),
		_unBind: d(function () {
			this.__list__ = null;
			delete this.__redo__;
			if (!this.__context__) return;
			this.__context__.off('_add', this._onAdd);
			this.__context__.off('_delete', this._onDelete);
			this.__context__.off('_clear', this._onClear);
			this.__context__ = null;
		}),
		toString: d(function () { return '[object Iterator]'; })
	}, autoBind({
		_onAdd: d(function (index) {
			if (index >= this.__nextIndex__) return;
			++this.__nextIndex__;
			if (!this.__redo__) {
				defineProperty(this, '__redo__', d('c', [index]));
				return;
			}
			this.__redo__.forEach(function (redo, i) {
				if (redo >= index) this.__redo__[i] = ++redo;
			}, this);
			this.__redo__.push(index);
		}),
		_onDelete: d(function (index) {
			var i;
			if (index >= this.__nextIndex__) return;
			--this.__nextIndex__;
			if (!this.__redo__) return;
			i = this.__redo__.indexOf(index);
			if (i !== -1) this.__redo__.splice(i, 1);
			this.__redo__.forEach(function (redo, i) {
				if (redo > index) this.__redo__[i] = --redo;
			}, this);
		}),
		_onClear: d(function () {
			if (this.__redo__) clear.call(this.__redo__);
			this.__nextIndex__ = 0;
		})
	})));

	defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
		return this;
	}));
	defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var copy       = __webpack_require__(64)
	  , map        = __webpack_require__(65)
	  , callable   = __webpack_require__(34)
	  , validValue = __webpack_require__(22)

	  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , define;

	define = function (name, desc, bindTo) {
		var value = validValue(desc) && callable(desc.value), dgs;
		dgs = copy(desc);
		delete dgs.writable;
		delete dgs.value;
		dgs.get = function () {
			if (hasOwnProperty.call(this, name)) return value;
			desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
			defineProperty(this, name, desc);
			return this[name];
		};
		return dgs;
	};

	module.exports = function (props/*, bindTo*/) {
		var bindTo = arguments[1];
		return map(props, function (desc, name) {
			return define(name, desc, bindTo);
		});
	};


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assign = __webpack_require__(36)
	  , value  = __webpack_require__(22);

	module.exports = function (obj) {
		var copy = Object(value(obj));
		if (copy !== obj) return copy;
		return assign({}, obj);
	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var callable = __webpack_require__(34)
	  , forEach  = __webpack_require__(66)

	  , call = Function.prototype.call;

	module.exports = function (obj, cb/*, thisArg*/) {
		var o = {}, thisArg = arguments[2];
		callable(cb);
		forEach(obj, function (value, key, obj, index) {
			o[key] = call.call(cb, thisArg, value, key, obj, index);
		});
		return o;
	};


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(67)('forEach');


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// Internal method, used by iteration functions.
	// Calls a function for each key-value pair found in object
	// Optionally takes compareFn to iterate object in specific order

	'use strict';

	var isCallable = __webpack_require__(43)
	  , callable   = __webpack_require__(34)
	  , value      = __webpack_require__(22)

	  , call = Function.prototype.call, keys = Object.keys
	  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

	module.exports = function (method, defVal) {
		return function (obj, cb/*, thisArg, compareFn*/) {
			var list, thisArg = arguments[2], compareFn = arguments[3];
			obj = Object(value(obj));
			callable(cb);

			list = keys(obj);
			if (compareFn) {
				list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
			}
			return list[method](function (key, index) {
				if (!propertyIsEnumerable.call(obj, key)) return defVal;
				return call.call(cb, thisArg, obj[key], key, obj, index);
			});
		};
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// Thanks @mathiasbynens
	// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols

	'use strict';

	var setPrototypeOf = __webpack_require__(29)
	  , d              = __webpack_require__(35)
	  , Iterator       = __webpack_require__(62)

	  , defineProperty = Object.defineProperty
	  , StringIterator;

	StringIterator = module.exports = function (str) {
		if (!(this instanceof StringIterator)) return new StringIterator(str);
		str = String(str);
		Iterator.call(this, str);
		defineProperty(this, '__length__', d('', str.length));

	};
	if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

	StringIterator.prototype = Object.create(Iterator.prototype, {
		constructor: d(StringIterator),
		_next: d(function () {
			if (!this.__list__) return;
			if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
			this._unBind();
		}),
		_resolve: d(function (i) {
			var char = this.__list__[i], code;
			if (this.__nextIndex__ === this.__length__) return char;
			code = char.charCodeAt(0);
			if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
			return char;
		}),
		toString: d(function () { return '[object String Iterator]'; })
	});


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var setPrototypeOf    = __webpack_require__(29)
	  , d                 = __webpack_require__(35)
	  , Iterator          = __webpack_require__(62)
	  , toStringTagSymbol = __webpack_require__(48).toStringTag
	  , kinds             = __webpack_require__(70)

	  , defineProperties = Object.defineProperties
	  , unBind = Iterator.prototype._unBind
	  , MapIterator;

	MapIterator = module.exports = function (map, kind) {
		if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
		Iterator.call(this, map.__mapKeysData__, map);
		if (!kind || !kinds[kind]) kind = 'key+value';
		defineProperties(this, {
			__kind__: d('', kind),
			__values__: d('w', map.__mapValuesData__)
		});
	};
	if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

	MapIterator.prototype = Object.create(Iterator.prototype, {
		constructor: d(MapIterator),
		_resolve: d(function (i) {
			if (this.__kind__ === 'value') return this.__values__[i];
			if (this.__kind__ === 'key') return this.__list__[i];
			return [this.__list__[i], this.__values__[i]];
		}),
		_unBind: d(function () {
			this.__values__ = null;
			unBind.call(this);
		}),
		toString: d(function () { return '[object Map Iterator]'; })
	});
	Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
		d('c', 'Map Iterator'));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(71)('key',
		'value', 'key+value');


/***/ },
/* 71 */
/***/ function(module, exports) {

	'use strict';

	var forEach = Array.prototype.forEach, create = Object.create;

	module.exports = function (arg/*, args*/) {
		var set = create(null);
		forEach.call(arguments, function (name) { set[name] = true; });
		return set;
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	// Exports true if environment provides native `Map` implementation,
	// whatever that is.

	'use strict';

	module.exports = (function () {
		if (typeof Map === 'undefined') return false;
		return (Object.prototype.toString.call(Map.prototype) === '[object Map]');
	}());


/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var pendingException;
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = Object.keys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				try {
					to[keys[i]] = from[keys[i]];
				} catch (err) {
					if (pendingException === undefined) {
						pendingException = err;
					}
				}
			}
		}

		if (pendingException) {
			throw pendingException;
		}

		return to;
	};


/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * "Inspired" by Encoder7Bit.h/Encoder7Bit.cpp in the
	 * Firmata source code.
	 */
	module.exports = {
	  to7BitArray: function(data) {
	    var shift = 0;
	    var previous = 0;
	    var output = [];

	    data.forEach(function(byte) {
	      if (shift === 0) {
	        output.push(byte & 0x7f);
	        shift++;
	        previous = byte >> 7;
	      } else {
	        output.push(((byte << shift) & 0x7f) | previous);
	        if (shift === 6) {
	          output.push(byte >> 1);
	          shift = 0;
	        } else {
	          shift++;
	          previous = byte >> (8 - shift);
	        }
	      }
	    });

	    if (shift > 0) {
	      output.push(previous);
	    }

	    return output;
	  },
	  from7BitArray: function(encoded) {
	    var expectedBytes = (encoded.length) * 7 >> 3;
	    var decoded = [];

	    for (var i = 0; i < expectedBytes; i++) {
	      var j = i << 3;
	      var pos = parseInt(j / 7, 10);
	      var shift = j % 7;
	      decoded[i] = (encoded[pos] >> shift) | ((encoded[pos + 1] << (7 - shift)) & 0xFF);
	    }

	    return decoded;
	  }
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var Encoder7Bit = __webpack_require__(74);

	var OneWireUtils = {
	  crc8: function(data) {
	    var crc = 0;

	    for (var i = 0; i < data.length; i++) {
	      var inbyte = data[i];

	      for (var n = 8; n; n--) {
	        var mix = (crc ^ inbyte) & 0x01;
	        crc >>= 1;

	        if (mix) {
	          crc ^= 0x8C;
	        }

	        inbyte >>= 1;
	      }
	    }
	    return crc;
	  },

	  readDevices: function(data) {
	    var deviceBytes = Encoder7Bit.from7BitArray(data);
	    var devices = [];

	    for (var i = 0; i < deviceBytes.length; i += 8) {
	      var device = deviceBytes.slice(i, i + 8);

	      if (device.length !== 8) {
	        continue;
	      }

	      var check = OneWireUtils.crc8(device.slice(0, 7));

	      if (check !== device[7]) {
	        console.error("ROM invalid!");
	      }

	      devices.push(device);
	    }

	    return devices;
	  }
	};

	module.exports = OneWireUtils;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';

	var EE = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);

	var DATABITS = [7, 8];
	var STOPBITS = [1, 2];
	var PARITY = ['none', 'even', 'mark', 'odd', 'space'];
	var FLOWCONTROLS = ['RTSCTS'];

	var _options = {
	  baudrate: 9600,
	  parity: 'none',
	  rtscts: false,
	  databits: 8,
	  stopbits: 1,
	  buffersize: 256
	};

	function convertOptions(options){
	  switch (options.dataBits) {
	    case 7:
	      options.dataBits = 'seven';
	      break;
	    case 8:
	      options.dataBits = 'eight';
	      break;
	  }

	  switch (options.stopBits) {
	    case 1:
	      options.stopBits = 'one';
	      break;
	    case 2:
	      options.stopBits = 'two';
	      break;
	  }

	  switch (options.parity) {
	    case 'none':
	      options.parity = 'no';
	      break;
	  }

	  return options;
	}

	function SerialPort(path, options, openImmediately, callback) {

	  EE.call(this);

	  var self = this;

	  var args = Array.prototype.slice.call(arguments);
	  callback = args.pop();
	  if (typeof(callback) !== 'function') {
	    callback = null;
	  }

	  options = (typeof options !== 'function') && options || {};

	  openImmediately = (openImmediately === undefined || openImmediately === null) ? true : openImmediately;

	  callback = callback || function (err) {
	    if (err) {
	      self.emit('error', err);
	    }
	  };

	  var err;

	  options.baudRate = options.baudRate || options.baudrate || _options.baudrate;

	  options.dataBits = options.dataBits || options.databits || _options.databits;
	  if (DATABITS.indexOf(options.dataBits) === -1) {
	    err = new Error('Invalid "databits": ' + options.dataBits);
	    callback(err);
	    return;
	  }

	  options.stopBits = options.stopBits || options.stopbits || _options.stopbits;
	  if (STOPBITS.indexOf(options.stopBits) === -1) {
	    err = new Error('Invalid "stopbits": ' + options.stopbits);
	    callback(err);
	    return;
	  }

	  options.parity = options.parity || _options.parity;
	  if (PARITY.indexOf(options.parity) === -1) {
	    err = new Error('Invalid "parity": ' + options.parity);
	    callback(err);
	    return;
	  }

	  if (!path) {
	    err = new Error('Invalid port specified: ' + path);
	    callback(err);
	    return;
	  }

	  options.rtscts = _options.rtscts;

	  if (options.flowControl || options.flowcontrol) {
	    var fc = options.flowControl || options.flowcontrol;

	    if (typeof fc === 'boolean') {
	      options.rtscts = true;
	    } else {
	      var clean = fc.every(function (flowControl) {
	        var fcup = flowControl.toUpperCase();
	        var idx = FLOWCONTROLS.indexOf(fcup);
	        if (idx < 0) {
	          var err = new Error('Invalid "flowControl": ' + fcup + '. Valid options: ' + FLOWCONTROLS.join(', '));
	          callback(err);
	          return false;
	        } else {

	          // "XON", "XOFF", "XANY", "DTRDTS", "RTSCTS"
	          switch (idx) {
	            case 0: options.rtscts = true; break;
	          }
	          return true;
	        }
	      });
	      if(!clean){
	        return;
	      }
	    }
	  }

	  options.bufferSize = options.bufferSize || options.buffersize || _options.buffersize;

	  // defaults to chrome.serial if no options.serial passed
	  // inlined instead of on _options to allow mocking global chrome.serial for optional options test
	  options.serial = options.serial || (typeof chrome !== 'undefined' && chrome.serial);

	  if (!options.serial) {
	    throw new Error('No access to serial ports. Try loading as a Chrome Application.');
	  }

	  this.options = convertOptions(options);

	  this.options.serial.onReceiveError.addListener(function(info){

	    switch (info.error) {

	      case 'disconnected':
	      case 'device_lost':
	      case 'system_error':
	        err = new Error('Disconnected');
	        // send notification of disconnect
	        if (self.options.disconnectedCallback) {
	          self.options.disconnectedCallback(err);
	        } else {
	          self.emit('disconnect', err);
	        }
	        self.connectionId = -1;
	        self.emit('close');
	        self.removeAllListeners();
	        break;
	      case 'timeout':
	        break;
	    }

	  });

	  this.path = path;

	  if (openImmediately) {
	    process.nextTick(function () {
	      self.open(callback);
	    });
	  }
	}

	util.inherits(SerialPort, EE);

	SerialPort.prototype.connectionId = -1;

	SerialPort.prototype.open = function (callback) {
	  var options = {
	    bitrate: parseInt(this.options.baudRate, 10),
	    dataBits: this.options.dataBits,
	    parityBit: this.options.parity,
	    stopBits: this.options.stopBits,
	    ctsFlowControl: this.options.rtscts
	  };

	  this.options.serial.connect(this.path, options, this.proxy('onOpen', callback));
	};

	SerialPort.prototype.onOpen = function (callback, openInfo) {
	  if(chrome.runtime.lastError){
	    if(typeof callback === 'function'){
	      callback(chrome.runtime.lastError);
	    }else{
	      this.emit('error', chrome.runtime.lastError);
	    }
	    return;
	  }

	  this.connectionId = openInfo.connectionId;

	  if (this.connectionId === -1) {
	    this.emit('error', new Error('Could not open port.'));
	    return;
	  }

	  this.emit('open', openInfo);

	  this._reader = this.proxy('onRead');

	  this.options.serial.onReceive.addListener(this._reader);

	  if(typeof callback === 'function'){
	    callback(chrome.runtime.lastError, openInfo);
	  }
	};

	SerialPort.prototype.onRead = function (readInfo) {
	  if (readInfo && this.connectionId === readInfo.connectionId) {

	    if (this.options.dataCallback) {
	      this.options.dataCallback(toBuffer(readInfo.data));
	    } else {
	      this.emit('data', toBuffer(readInfo.data));
	    }

	  }
	};

	SerialPort.prototype.write = function (buffer, callback) {
	  if (this.connectionId < 0) {
	    var err = new Error('Serialport not open.');
	    if(typeof callback === 'function'){
	      callback(err);
	    }else{
	      this.emit('error', err);
	    }
	    return;
	  }

	  if (typeof buffer === 'string') {
	    buffer = str2ab(buffer);
	  }

	  //Make sure its not a browserify faux Buffer.
	  if (buffer instanceof ArrayBuffer === false) {
	    buffer = buffer2ArrayBuffer(buffer);
	  }

	  this.options.serial.send(this.connectionId, buffer, function(info) {
	    if (typeof callback === 'function') {
	      callback(chrome.runtime.lastError, info);
	    }
	  });
	};


	SerialPort.prototype.close = function (callback) {
	  if (this.connectionId < 0) {
	    var err = new Error('Serialport not open.');
	    if(typeof callback === 'function'){
	      callback(err);
	    }else{
	      this.emit('error', err);
	    }
	    return;
	  }

	  this.options.serial.disconnect(this.connectionId, this.proxy('onClose', callback));
	};

	SerialPort.prototype.onClose = function (callback, result) {
	  this.connectionId = -1;
	  this.emit('close');

	  this.removeAllListeners();
	  if(this._reader){
	    this.options.serial.onReceive.removeListener(this._reader);
	    this._reader = null;
	  }

	  if (typeof callback === 'function') {
	    callback(chrome.runtime.lastError, result);
	  }
	};

	SerialPort.prototype.flush = function (callback) {
	  if (this.connectionId < 0) {
	    var err = new Error('Serialport not open.');
	    if(typeof callback === 'function'){
	      callback(err);
	    }else{
	      this.emit('error', err);
	    }
	    return;
	  }

	  var self = this;

	  this.options.serial.flush(this.connectionId, function(result) {
	    if (chrome.runtime.lastError) {
	      if (typeof callback === 'function') {
	        callback(chrome.runtime.lastError, result);
	      } else {
	        self.emit('error', chrome.runtime.lastError);
	      }
	      return;
	    } else {
	      callback(null, result);
	    }
	  });
	};

	SerialPort.prototype.drain = function (callback) {
	  if (this.connectionId < 0) {
	    var err = new Error('Serialport not open.');
	    if(typeof callback === 'function'){
	      callback(err);
	    }else{
	      this.emit('error', err);
	    }
	    return;
	  }

	  if (typeof callback === 'function') {
	    callback();
	  }
	};


	SerialPort.prototype.proxy = function () {
	  var self = this;
	  var proxyArgs = [];

	  //arguments isnt actually an array.
	  for (var i = 0; i < arguments.length; i++) {
	      proxyArgs[i] = arguments[i];
	  }

	  var functionName = proxyArgs.splice(0, 1)[0];

	  var func = function() {
	    var funcArgs = [];
	    for (var i = 0; i < arguments.length; i++) {
	        funcArgs[i] = arguments[i];
	    }
	    var allArgs = proxyArgs.concat(funcArgs);

	    self[functionName].apply(self, allArgs);
	  };

	  return func;
	};

	SerialPort.prototype.set = function (options, callback) {
	  this.options.serial.setControlSignals(this.connectionId, options, function(result){
	    callback(chrome.runtime.lastError, result);
	  });
	};

	function SerialPortList(callback) {
	  if (typeof chrome != 'undefined' && chrome.serial) {
	    chrome.serial.getDevices(function(ports) {
	      var portObjects = new Array(ports.length);
	      for (var i = 0; i < ports.length; i++) {
	        portObjects[i] = {
	          comName: ports[i].path,
	          manufacturer: ports[i].displayName,
	          serialNumber: '',
	          pnpId: '',
	          locationId:'',
	          vendorId: '0x' + (ports[i].vendorId||0).toString(16),
	          productId: '0x' + (ports[i].productId||0).toString(16)
	        };
	      }
	      callback(chrome.runtime.lastError, portObjects);
	    });
	  } else {
	    callback(new Error('No access to serial ports. Try loading as a Chrome Application.'), null);
	  }
	}

	// Convert string to ArrayBuffer
	function str2ab(str) {
	  var buf = new ArrayBuffer(str.length);
	  var bufView = new Uint8Array(buf);
	  for (var i = 0; i < str.length; i++) {
	    bufView[i] = str.charCodeAt(i);
	  }
	  return buf;
	}

	// Convert buffer to ArrayBuffer
	function buffer2ArrayBuffer(buffer) {
	  var buf = new ArrayBuffer(buffer.length);
	  var bufView = new Uint8Array(buf);
	  for (var i = 0; i < buffer.length; i++) {
	    bufView[i] = buffer[i];
	  }
	  return buf;
	}

	function toBuffer(ab) {
	  var buffer = new Buffer(ab.byteLength);
	  var view = new Uint8Array(ab);
	  for (var i = 0; i < buffer.length; ++i) {
	      buffer[i] = view[i];
	  }
	  return buffer;
	}

	module.exports = {
	  SerialPort: SerialPort,
	  list: SerialPortList,
	  buffer2ArrayBuffer: buffer2ArrayBuffer,
	  used: [] //TODO: Populate this somewhere.
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2).Buffer))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(78);
	__webpack_require__(79).shim();


	module.exports = {
	  // extract-start:apinames
	  Accelerometer: __webpack_require__(102),
	  Animation: __webpack_require__(129),
	  Altimeter: __webpack_require__(124),
	  Barometer: __webpack_require__(125),
	  Board: __webpack_require__(103),
	  Button: __webpack_require__(133),
	  Color: __webpack_require__(135),
	  Compass: __webpack_require__(136),
	  Distance: __webpack_require__(137),
	  ESC: __webpack_require__(140),
	  Expander: __webpack_require__(142),
	  Fn: __webpack_require__(115),
	  Gripper: __webpack_require__(143),
	  Gyro: __webpack_require__(128),
	  Hygrometer: __webpack_require__(126),
	  IMU: __webpack_require__(123),
	  IR: __webpack_require__(145),
	  Keypad: __webpack_require__(146),
	  LCD: __webpack_require__(148),
	  Led: __webpack_require__(154),
	  LedControl: __webpack_require__(159),
	  Light: __webpack_require__(162),
	  Joystick: __webpack_require__(163),
	  Motion: __webpack_require__(164),
	  Motor: __webpack_require__(165),
	  Nodebot: __webpack_require__(167),
	  Piezo: __webpack_require__(168),
	  Ping: __webpack_require__(171),
	  Pir: __webpack_require__(172),
	  Pin: __webpack_require__(149),
	  Proximity: __webpack_require__(173),
	  Relay: __webpack_require__(174),
	  Repl: __webpack_require__(116),
	  Sensor: __webpack_require__(138),
	  Servo: __webpack_require__(144),
	  ShiftRegister: __webpack_require__(166),
	  Sonar: __webpack_require__(175),
	  Stepper: __webpack_require__(176),
	  Switch: __webpack_require__(177),
	  Temperature: __webpack_require__(127),
	  Wii: __webpack_require__(178)
	  // extract-end:apinames
	};

	// Customized constructors
	//
	//
	module.exports.Board.Virtual = function(opts) {
	  var temp;

	  if (opts instanceof module.exports.Expander) {
	    temp = {
	      io: opts
	    };
	  } else {
	    temp = opts;
	  }

	  return new module.exports.Board(
	    Object.assign({}, { repl: false, debug: false, sigint: false }, temp)
	  );
	};

	module.exports.Multi = module.exports.IMU;

	module.exports.Analog = function(opts) {
	  return new module.exports.Sensor(opts);
	};

	module.exports.Digital = function(opts) {
	  var pin;

	  if (typeof opts === "number" || typeof opts === "string") {
	    pin = opts;
	    opts = {
	      type: "digital",
	      pin: pin
	    };
	  } else {
	    opts.type = opts.type || "digital";
	  }

	  return new module.exports.Sensor(opts);
	};

	module.exports.Sensor.Analog = module.exports.Analog;
	module.exports.Sensor.Digital = module.exports.Digital;

	/**
	 * @deprecated Will be deleted in version 1.0.0. Use Proximity instead.
	 */
	module.exports.IR.Distance = function(opts) {
	  console.log("IR.Distance is deprecated. Use Proximity instead");
	  return new module.exports.Distance(opts);
	};

	/**
	 * @deprecated Will be deleted in version 1.0.0. Use Motion instead.
	 */
	module.exports.IR.Motion = function(opt) {
	  console.log("IR.Motion is deprecated. Use Motion instead");
	  return new module.exports.Pir(
	    typeof opt === "number" ? opt : (
	      opt.pin === undefined ? 7 : opt.pin
	    )
	  );
	};

	/**
	 * @deprecated Will be deleted in version 1.0.0. Use Proximity instead.
	 */
	module.exports.IR.Proximity = function(opts) {
	  console.log("IR.Proximity is deprecated. Use Proximity instead");
	  // Fix a naming mistake.
	  if (module.exports.Distance.Controllers.includes(opts.controller)) {
	    return new module.exports.Distance(opts);
	  }

	  return new module.exports.IR({
	    device: opts || "GP2Y0D805Z0F",
	    freq: 50
	  });
	};

	module.exports.IR.Proximity.Controllers = module.exports.Distance.Controllers;

	module.exports.IR.Reflect = function(model) {
	  return new module.exports.IR({
	    device: model || "QRE1113GR",
	    freq: 50
	  });
	};

	module.exports.IR.Reflect.Array = __webpack_require__(179);

	module.exports.Magnetometer = function() {
	  return new module.exports.Compass({
	    controller: "HMC5883L",
	    freq: 100,
	    gauss: 1.3
	  });
	};

	// Short-handing, Aliases
	module.exports.Boards = module.exports.Board.Array;
	module.exports.ESCs = module.exports.ESC.Array;
	module.exports.Leds = module.exports.Led.Array;
	module.exports.Motors = module.exports.Motor.Array;
	module.exports.Pins = module.exports.Pin.Array;
	module.exports.Servos = module.exports.Servo.Array;

	// Direct Alias
	module.exports.Touchpad = module.exports.Keypad;

	// Back Compat
	module.exports.Nunchuk = module.exports.Wii.Nunchuk;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, process) { /*!
	  * https://github.com/paulmillr/es6-shim
	  * @license es6-shim Copyright 2013-2015 by Paul Miller (http://paulmillr.com)
	  *   and contributors,  MIT License
	  * es6-shim: v0.33.6
	  * see https://github.com/paulmillr/es6-shim/blob/0.33.3/LICENSE
	  * Details and documentation:
	  * https://github.com/paulmillr/es6-shim/
	  */

	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/returnExports.js
	(function (root, factory) {
	  /*global define, module, exports */
	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like enviroments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    // Browser globals (root is window)
	    root.returnExports = factory();
	  }
	}(this, function () {
	  'use strict';

	  var _apply = Function.call.bind(Function.apply);
	  var _call = Function.call.bind(Function.call);
	  var isArray = Array.isArray;

	  var not = function notThunker(func) {
	    return function notThunk() { return !_apply(func, this, arguments); };
	  };
	  var throwsError = function (func) {
	    try {
	      func();
	      return false;
	    } catch (e) {
	      return true;
	    }
	  };
	  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
	    try {
	      return func();
	    } catch (e) {
	      return false;
	    }
	  };

	  var isCallableWithoutNew = not(throwsError);
	  var arePropertyDescriptorsSupported = function () {
	    // if Object.defineProperty exists but throws, it's IE 8
	    return !throwsError(function () { Object.defineProperty({}, 'x', { get: function () {} }); });
	  };
	  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
	  var functionsHaveNames = (function foo() {}).name === 'foo';

	  var _forEach = Function.call.bind(Array.prototype.forEach);
	  var _reduce = Function.call.bind(Array.prototype.reduce);
	  var _filter = Function.call.bind(Array.prototype.filter);
	  var _every = Function.call.bind(Array.prototype.every);

	  var createDataProperty = function createDataProperty(object, name, value) {
	    if (supportsDescriptors) {
	      Object.defineProperty(object, name, {
	        configurable: true,
	        enumerable: true,
	        writable: true,
	        value: value
	      });
	    } else {
	      object[name] = value;
	    }
	  };
	  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
	    createDataProperty(object, name, value);
	    if (!ES.SameValue(object[name], value)) {
	      throw new TypeError('property is nonconfigurable');
	    }
	  };
	  var defineProperty = function (object, name, value, force) {
	    if (!force && name in object) { return; }
	    if (supportsDescriptors) {
	      Object.defineProperty(object, name, {
	        configurable: true,
	        enumerable: false,
	        writable: true,
	        value: value
	      });
	    } else {
	      object[name] = value;
	    }
	  };

	  // Define configurable, writable and non-enumerable props
	  // if they dont exist.
	  var defineProperties = function (object, map) {
	    _forEach(Object.keys(map), function (name) {
	      var method = map[name];
	      defineProperty(object, name, method, false);
	    });
	  };

	  // Simple shim for Object.create on ES3 browsers
	  // (unlike real shim, no attempt to support `prototype === null`)
	  var create = Object.create || function (prototype, properties) {
	    var Prototype = function Prototype() {};
	    Prototype.prototype = prototype;
	    var object = new Prototype();
	    if (typeof properties !== 'undefined') {
	      Object.keys(properties).forEach(function (key) {
	        Value.defineByDescriptor(object, key, properties[key]);
	      });
	    }
	    return object;
	  };

	  var supportsSubclassing = function (C, f) {
	    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
	    return valueOrFalseIfThrows(function () {
	      var Sub = function Subclass(arg) {
	        var o = new C(arg);
	        Object.setPrototypeOf(o, Subclass.prototype);
	        return o;
	      };
	      Object.setPrototypeOf(Sub, C);
	      Sub.prototype = create(C.prototype, {
	        constructor: { value: Sub }
	      });
	      return f(Sub);
	    });
	  };

	  var startsWithRejectsRegex = function () {
	    return String.prototype.startsWith && throwsError(function () {
	      /* throws if spec-compliant */
	      '/a/'.startsWith(/a/);
	    });
	  };
	  var startsWithHandlesInfinity = (function () {
	    return String.prototype.startsWith && 'abc'.startsWith('a', Infinity) === false;
	  }());

	  var getGlobal = function () {
		// the only reliable means to get the global object is
		// `Function('return this')()`
		// However, this causes CSP violations in Chrome apps.
	    if (typeof self !== 'undefined') { return self; }
	    if (typeof window !== 'undefined') { return window; }
	    if (typeof global !== 'undefined') { return global; }
		throw new Error('unable to locate global object');
	  };

	  var globals = getGlobal();
	  var globalIsFinite = globals.isFinite;
	  var hasStrictMode = (function () { return this === null; }.call(null));
	  var startsWithIsCompliant = startsWithRejectsRegex() && startsWithHandlesInfinity;
	  var _indexOf = Function.call.bind(String.prototype.indexOf);
	  var _toString = Function.call.bind(Object.prototype.toString);
	  var _concat = Function.call.bind(Array.prototype.concat);
	  var _strSlice = Function.call.bind(String.prototype.slice);
	  var _push = Function.call.bind(Array.prototype.push);
	  var _pushApply = Function.apply.bind(Array.prototype.push);
	  var _shift = Function.call.bind(Array.prototype.shift);
	  var _max = Math.max;
	  var _min = Math.min;
	  var _floor = Math.floor;
	  var _abs = Math.abs;
	  var _log = Math.log;
	  var _sqrt = Math.sqrt;
	  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
	  var ArrayIterator; // make our implementation private
	  var noop = function () {};

	  var Symbol = globals.Symbol || {};
	  var symbolSpecies = Symbol.species || '@@species';

	  var Value = {
	    getter: function (object, name, getter) {
	      if (!supportsDescriptors) {
	        throw new TypeError('getters require true ES5 support');
	      }
	      Object.defineProperty(object, name, {
	        configurable: true,
	        enumerable: false,
	        get: getter
	      });
	    },
	    proxy: function (originalObject, key, targetObject) {
	      if (!supportsDescriptors) {
	        throw new TypeError('getters require true ES5 support');
	      }
	      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
	      Object.defineProperty(targetObject, key, {
	        configurable: originalDescriptor.configurable,
	        enumerable: originalDescriptor.enumerable,
	        get: function getKey() { return originalObject[key]; },
	        set: function setKey(value) { originalObject[key] = value; }
	      });
	    },
	    redefine: function (object, property, newValue) {
	      if (supportsDescriptors) {
	        var descriptor = Object.getOwnPropertyDescriptor(object, property);
	        descriptor.value = newValue;
	        Object.defineProperty(object, property, descriptor);
	      } else {
	        object[property] = newValue;
	      }
	    },
	    defineByDescriptor: function (object, property, descriptor) {
	      if (supportsDescriptors) {
	        Object.defineProperty(object, property, descriptor);
	      } else if ('value' in descriptor) {
	        object[property] = descriptor.value;
	      }
	    },
	    preserveToString: function (target, source) {
	      defineProperty(target, 'toString', source.toString.bind(source), true);
	    }
	  };

	  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
	    Value.preserveToString(replacement, original);
	    if (Object.setPrototypeOf) {
	      // sets up proper prototype chain where possible
	      Object.setPrototypeOf(original, replacement);
	    }
	    _forEach(Object.getOwnPropertyNames(original), function (key) {
	      if (key in noop || keysToSkip[key]) { return; }
	      Value.proxy(original, key, replacement);
	    });
	    replacement.prototype = original.prototype;
	    Value.redefine(original.prototype, 'constructor', replacement);
	  };

	  var defaultSpeciesGetter = function () { return this; };
	  var addDefaultSpecies = function (C) {
	    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
	      Value.getter(C, symbolSpecies, defaultSpeciesGetter);
	    }
	  };
	  var Type = {
	    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
	    object: function (x) { return x !== null && typeof x === 'object'; },
	    string: function (x) { return _toString(x) === '[object String]'; },
	    regex: function (x) { return _toString(x) === '[object RegExp]'; },
	    symbol: function (x) {
	      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
	    }
	  };

	  var numberIsNaN = Number.isNaN || function isNaN(value) {
	    // NaN !== NaN, but they are identical.
	    // NaNs are the only non-reflexive value, i.e., if x !== x,
	    // then x is NaN.
	    // isNaN is broken: it converts its argument to number, so
	    // isNaN('foo') => true
	    return value !== value;
	  };
	  var numberIsFinite = Number.isFinite || function isFinite(value) {
	    return typeof value === 'number' && globalIsFinite(value);
	  };

	  var overrideNative = function overrideNative(object, property, replacement) {
	    var original = object[property];
	    defineProperty(object, property, replacement, true);
	    Value.preserveToString(object[property], original);
	  };

	  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
	  // we're going to use an arbitrary _-prefixed name to make our shims
	  // work properly with each other, even though we don't have full Iterator
	  // support.  That is, `Array.from(map.keys())` will work, but we don't
	  // pretend to export a "real" Iterator interface.
	  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
	  // Firefox ships a partial implementation using the name @@iterator.
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
	  // So use that name if we detect it.
	  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
	    $iterator$ = '@@iterator';
	  }
	  var addIterator = function (prototype, impl) {
	    var implementation = impl || function iterator() { return this; };
	    defineProperty(prototype, $iterator$, implementation);
	    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
	      // implementations are buggy when $iterator$ is a Symbol
	      prototype[$iterator$] = implementation;
	    }
	  };

	  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
	  // can be replaced with require('is-arguments') if we ever use a build process instead
	  var isStandardArguments = function isArguments(value) {
	    return _toString(value) === '[object Arguments]';
	  };
	  var isLegacyArguments = function isArguments(value) {
	    return value !== null &&
	      typeof value === 'object' &&
	      typeof value.length === 'number' &&
	      value.length >= 0 &&
	      _toString(value) !== '[object Array]' &&
	      _toString(value.callee) === '[object Function]';
	  };
	  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

	  var ES = {
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	    Call: function Call(F, V) {
	      var args = arguments.length > 2 ? arguments[2] : [];
	      if (!ES.IsCallable(F)) {
	        throw new TypeError(F + ' is not a function');
	      }
	      return _apply(F, V, args);
	    },

	    RequireObjectCoercible: function (x, optMessage) {
	      /* jshint eqnull:true */
	      if (x == null) {
	        throw new TypeError(optMessage || 'Cannot call method on ' + x);
	      }
	    },

	    TypeIsObject: function (x) {
	      /* jshint eqnull:true */
	      // this is expensive when it returns false; use this function
	      // when you expect it to return true in the common case.
	      return x != null && Object(x) === x;
	    },

	    ToObject: function (o, optMessage) {
	      ES.RequireObjectCoercible(o, optMessage);
	      return Object(o);
	    },

	    IsCallable: function (x) {
	      // some versions of IE say that typeof /abc/ === 'function'
	      return typeof x === 'function' && _toString(x) === '[object Function]';
	    },

	    IsConstructor: function (x) {
	      // We can't tell callables from constructors in ES5
	      return ES.IsCallable(x);
	    },

	    ToInt32: function (x) {
	      return ES.ToNumber(x) >> 0;
	    },

	    ToUint32: function (x) {
	      return ES.ToNumber(x) >>> 0;
	    },

	    ToNumber: function (value) {
	      if (_toString(value) === '[object Symbol]') {
	        throw new TypeError('Cannot convert a Symbol value to a number');
	      }
	      return +value;
	    },

	    ToInteger: function (value) {
	      var number = ES.ToNumber(value);
	      if (numberIsNaN(number)) { return 0; }
	      if (number === 0 || !numberIsFinite(number)) { return number; }
	      return (number > 0 ? 1 : -1) * _floor(_abs(number));
	    },

	    ToLength: function (value) {
	      var len = ES.ToInteger(value);
	      if (len <= 0) { return 0; } // includes converting -0 to +0
	      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
	      return len;
	    },

	    SameValue: function (a, b) {
	      if (a === b) {
	        // 0 === -0, but they are not identical.
	        if (a === 0) { return 1 / a === 1 / b; }
	        return true;
	      }
	      return numberIsNaN(a) && numberIsNaN(b);
	    },

	    SameValueZero: function (a, b) {
	      // same as SameValue except for SameValueZero(+0, -0) == true
	      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
	    },

	    IsIterable: function (o) {
	      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
	    },

	    GetIterator: function (o) {
	      if (isArguments(o)) {
	        // special case support for `arguments`
	        return new ArrayIterator(o, 'value');
	      }
	      var itFn = ES.GetMethod(o, $iterator$);
	      if (!ES.IsCallable(itFn)) {
	        // Better diagnostics if itFn is null or undefined
	        throw new TypeError('value is not an iterable');
	      }
	      var it = _call(itFn, o);
	      if (!ES.TypeIsObject(it)) {
	        throw new TypeError('bad iterator');
	      }
	      return it;
	    },

	    GetMethod: function (o, p) {
	      var func = ES.ToObject(o)[p];
	      if (func === void 0 || func === null) {
	        return void 0;
	      }
	      if (!ES.IsCallable(func)) {
	        throw new TypeError('Method not callable: ' + p);
	      }
	      return func;
	    },

	    IteratorComplete: function (iterResult) {
	      return !!(iterResult.done);
	    },

	    IteratorClose: function (iterator, completionIsThrow) {
	      var returnMethod = ES.GetMethod(iterator, 'return');
	      if (returnMethod === void 0) {
	        return;
	      }
	      var innerResult, innerException;
	      try {
	        innerResult = _call(returnMethod, iterator);
	      } catch (e) {
	        innerException = e;
	      }
	      if (completionIsThrow) {
	        return;
	      }
	      if (innerException) {
	        throw innerException;
	      }
	      if (!ES.TypeIsObject(innerResult)) {
	        throw new TypeError("Iterator's return method returned a non-object.");
	      }
	    },

	    IteratorNext: function (it) {
	      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
	      if (!ES.TypeIsObject(result)) {
	        throw new TypeError('bad iterator');
	      }
	      return result;
	    },

	    IteratorStep: function (it) {
	      var result = ES.IteratorNext(it);
	      var done = ES.IteratorComplete(result);
	      return done ? false : result;
	    },

	    Construct: function (C, args, newTarget, isES6internal) {
	      if (newTarget === void 0) {
	        newTarget = C;
	      }
	      if (!isES6internal) {
	        // Try to use Reflect.construct if available
	        return Reflect.construct(C, args, newTarget);
	      }
	      // OK, we have to fake it.  This will only work if the
	      // C.[[ConstructorKind]] == "base" -- but that's the only
	      // kind we can make in ES5 code anyway.

	      // OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%")
	      var proto = newTarget.prototype;
	      if (!ES.TypeIsObject(proto)) {
	        proto = Object.prototype;
	      }
	      var obj = create(proto);
	      // Call the constructor.
	      var result = ES.Call(C, obj, args);
	      return ES.TypeIsObject(result) ? result : obj;
	    },

	    SpeciesConstructor: function (O, defaultConstructor) {
	      var C = O.constructor;
	      if (C === void 0) {
	        return defaultConstructor;
	      }
	      if (!ES.TypeIsObject(C)) {
	        throw new TypeError('Bad constructor');
	      }
	      var S = C[symbolSpecies];
	      if (S === void 0 || S === null) {
	        return defaultConstructor;
	      }
	      if (!ES.IsConstructor(S)) {
	        throw new TypeError('Bad @@species');
	      }
	      return S;
	    },

	    CreateHTML: function (string, tag, attribute, value) {
	      var S = String(string);
	      var p1 = '<' + tag;
	      if (attribute !== '') {
	        var V = String(value);
	        var escapedV = V.replace(/"/g, '&quot;');
	        p1 += ' ' + attribute + '="' + escapedV + '"';
	      }
	      var p2 = p1 + '>';
	      var p3 = p2 + S;
	      return p3 + '</' + tag + '>';
	    }
	  };

	  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
	    // This is an es5 approximation to es6 construct semantics.  in es6,
	    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
	    // just sets the internal variable NewTarget (in es6 syntax `new.target`)
	    // to Foo and then returns Foo().

	    // Many ES6 object then have constructors of the form:
	    // 1. If NewTarget is undefined, throw a TypeError exception
	    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

	    // So we're going to emulate those first two steps.
	    if (!ES.TypeIsObject(o)) {
	      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
	    }
	    var proto = defaultNewTarget.prototype;
	    if (!ES.TypeIsObject(proto)) {
	      proto = defaultProto;
	    }
	    o = create(proto);
	    for (var name in slots) {
	      if (_hasOwnProperty(slots, name)) {
	        var value = slots[name];
	        defineProperty(o, name, value, true);
	      }
	    }
	    return o;
	  };

	  // Firefox 31 reports this function's length as 0
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
	  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
	    var originalFromCodePoint = String.fromCodePoint;
	    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) { return _apply(originalFromCodePoint, this, arguments); });
	  }

	  var StringShims = {
	    fromCodePoint: function fromCodePoint(codePoints) {
	      var result = [];
	      var next;
	      for (var i = 0, length = arguments.length; i < length; i++) {
	        next = Number(arguments[i]);
	        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
	          throw new RangeError('Invalid code point ' + next);
	        }

	        if (next < 0x10000) {
	          _push(result, String.fromCharCode(next));
	        } else {
	          next -= 0x10000;
	          _push(result, String.fromCharCode((next >> 10) + 0xD800));
	          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
	        }
	      }
	      return result.join('');
	    },

	    raw: function raw(callSite) {
	      var cooked = ES.ToObject(callSite, 'bad callSite');
	      var rawString = ES.ToObject(cooked.raw, 'bad raw value');
	      var len = rawString.length;
	      var literalsegments = ES.ToLength(len);
	      if (literalsegments <= 0) {
	        return '';
	      }

	      var stringElements = [];
	      var nextIndex = 0;
	      var nextKey, next, nextSeg, nextSub;
	      while (nextIndex < literalsegments) {
	        nextKey = String(nextIndex);
	        nextSeg = String(rawString[nextKey]);
	        _push(stringElements, nextSeg);
	        if (nextIndex + 1 >= literalsegments) {
	          break;
	        }
	        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
	        nextSub = String(next);
	        _push(stringElements, nextSub);
	        nextIndex++;
	      }
	      return stringElements.join('');
	    }
	  };
	  defineProperties(String, StringShims);
	  if (String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
	    // IE 11 TP has a broken String.raw implementation
	    overrideNative(String, 'raw', StringShims.raw);
	  }

	  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
	  // Perf: http://jsperf.com/string-repeat2/2
	  var stringRepeat = function repeat(s, times) {
	    if (times < 1) { return ''; }
	    if (times % 2) { return repeat(s, times - 1) + s; }
	    var half = repeat(s, times / 2);
	    return half + half;
	  };
	  var stringMaxLength = Infinity;

	  var StringPrototypeShims = {
	    repeat: function repeat(times) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      var numTimes = ES.ToInteger(times);
	      if (numTimes < 0 || numTimes >= stringMaxLength) {
	        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
	      }
	      return stringRepeat(thisStr, numTimes);
	    },

	    startsWith: function startsWith(searchString) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      if (Type.regex(searchString)) {
	        throw new TypeError('Cannot call method "startsWith" with a regex');
	      }
	      var searchStr = String(searchString);
	      var startArg = arguments.length > 1 ? arguments[1] : void 0;
	      var start = _max(ES.ToInteger(startArg), 0);
	      return _strSlice(thisStr, start, start + searchStr.length) === searchStr;
	    },

	    endsWith: function endsWith(searchString) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      if (Type.regex(searchString)) {
	        throw new TypeError('Cannot call method "endsWith" with a regex');
	      }
	      var searchStr = String(searchString);
	      var thisLen = thisStr.length;
	      var posArg = arguments.length > 1 ? arguments[1] : void 0;
	      var pos = typeof posArg === 'undefined' ? thisLen : ES.ToInteger(posArg);
	      var end = _min(_max(pos, 0), thisLen);
	      return _strSlice(thisStr, end - searchStr.length, end) === searchStr;
	    },

	    includes: function includes(searchString) {
	      if (Type.regex(searchString)) {
	        throw new TypeError('"includes" does not accept a RegExp');
	      }
	      var position;
	      if (arguments.length > 1) {
	        position = arguments[1];
	      }
	      // Somehow this trick makes method 100% compat with the spec.
	      return _indexOf(this, searchString, position) !== -1;
	    },

	    codePointAt: function codePointAt(pos) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      var position = ES.ToInteger(pos);
	      var length = thisStr.length;
	      if (position >= 0 && position < length) {
	        var first = thisStr.charCodeAt(position);
	        var isEnd = (position + 1 === length);
	        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
	        var second = thisStr.charCodeAt(position + 1);
	        if (second < 0xDC00 || second > 0xDFFF) { return first; }
	        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
	      }
	    }
	  };
	  defineProperties(String.prototype, StringPrototypeShims);

	  if ('a'.includes('a', Infinity) !== false) {
	    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
	  }

	  var hasStringTrimBug = '\u0085'.trim().length !== 1;
	  if (hasStringTrimBug) {
	    delete String.prototype.trim;
	    // whitespace from: http://es5.github.io/#x15.5.4.20
	    // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
	    var ws = [
	      '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	      '\u2029\uFEFF'
	    ].join('');
	    var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
	    defineProperties(String.prototype, {
	      trim: function trim() {
	        if (typeof this === 'undefined' || this === null) {
	          throw new TypeError("can't convert " + this + ' to object');
	        }
	        return String(this).replace(trimRegexp, '');
	      }
	    });
	  }

	  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype-@@iterator
	  var StringIterator = function (s) {
	    ES.RequireObjectCoercible(s);
	    this._s = String(s);
	    this._i = 0;
	  };
	  StringIterator.prototype.next = function () {
	    var s = this._s, i = this._i;
	    if (typeof s === 'undefined' || i >= s.length) {
	      this._s = void 0;
	      return { value: void 0, done: true };
	    }
	    var first = s.charCodeAt(i), second, len;
	    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
	      len = 1;
	    } else {
	      second = s.charCodeAt(i + 1);
	      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
	    }
	    this._i = i + len;
	    return { value: s.substr(i, len), done: false };
	  };
	  addIterator(StringIterator.prototype);
	  addIterator(String.prototype, function () {
	    return new StringIterator(this);
	  });

	  if (!startsWithIsCompliant) {
	    // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
	    overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
	    overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
	  }

	  var ArrayShims = {
	    from: function from(items) {
	      var C = this;
	      var mapFn = arguments.length > 1 ? arguments[1] : void 0;
	      var mapping, T;
	      if (mapFn === void 0) {
	        mapping = false;
	      } else {
	        if (!ES.IsCallable(mapFn)) {
	          throw new TypeError('Array.from: when provided, the second argument must be a function');
	        }
	        T = arguments.length > 2 ? arguments[2] : void 0;
	        mapping = true;
	      }

	      // Note that that Arrays will use ArrayIterator:
	      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
	      var usingIterator = isArguments(items) || ES.GetMethod(items, $iterator$);

	      var length, result, i;
	      if (usingIterator !== void 0) {
	        result = ES.IsConstructor(C) ? Object(new C()) : [];
	        var iterator = ES.GetIterator(items);
	        var next, nextValue;

	        i = 0;
	        while (true) {
	          next = ES.IteratorStep(iterator);
	          if (next === false) {
	            break;
	          }
	          nextValue = next.value;
	          try {
	            if (mapping) {
	              nextValue = T !== undefined ? _call(mapFn, T, nextValue, i) : mapFn(nextValue, i);
	            }
	            result[i] = nextValue;
	          } catch (e) {
	            ES.IteratorClose(iterator, true);
	            throw e;
	          }
	          i += 1;
	        }
	        length = i;
	      } else {
	        var arrayLike = ES.ToObject(items);
	        length = ES.ToLength(arrayLike.length);
	        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
	        var value;
	        for (i = 0; i < length; ++i) {
	          value = arrayLike[i];
	          if (mapping) {
	            value = T !== undefined ? _call(mapFn, T, value, i) : mapFn(value, i);
	          }
	          result[i] = value;
	        }
	      }

	      result.length = length;
	      return result;
	    },

	    of: function of() {
	      var len = arguments.length;
	      var C = this;
	      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
	      for (var k = 0; k < len; ++k) {
	        createDataPropertyOrThrow(A, k, arguments[k]);
	      }
	      A.length = len;
	      return A;
	    }
	  };
	  defineProperties(Array, ArrayShims);
	  addDefaultSpecies(Array);

	  // Given an argument x, it will return an IteratorResult object,
	  // with value set to x and done to false.
	  // Given no arguments, it will return an iterator completion object.
	  var iteratorResult = function (x) {
	    return { value: x, done: arguments.length === 0 };
	  };

	  // Our ArrayIterator is private; see
	  // https://github.com/paulmillr/es6-shim/issues/252
	  ArrayIterator = function (array, kind) {
	      this.i = 0;
	      this.array = array;
	      this.kind = kind;
	  };

	  defineProperties(ArrayIterator.prototype, {
	    next: function () {
	      var i = this.i, array = this.array;
	      if (!(this instanceof ArrayIterator)) {
	        throw new TypeError('Not an ArrayIterator');
	      }
	      if (typeof array !== 'undefined') {
	        var len = ES.ToLength(array.length);
	        for (; i < len; i++) {
	          var kind = this.kind;
	          var retval;
	          if (kind === 'key') {
	            retval = i;
	          } else if (kind === 'value') {
	            retval = array[i];
	          } else if (kind === 'entry') {
	            retval = [i, array[i]];
	          }
	          this.i = i + 1;
	          return { value: retval, done: false };
	        }
	      }
	      this.array = void 0;
	      return { value: void 0, done: true };
	    }
	  });
	  addIterator(ArrayIterator.prototype);

	  var ObjectIterator = function (object, kind) {
	    defineProperties(this, {
	      object: object,
	      array: getAllKeys(object),
	      kind: kind
	    });
	  };

	  var getAllKeys = function getAllKeys(object) {
	    var keys = [];

	    for (var key in object) {
	      _push(keys, key);
	    }

	    return keys;
	  };

	  defineProperties(ObjectIterator.prototype, {
	    next: function next() {
	      var key;
	      var array = this.array;

	      if (!(this instanceof ObjectIterator)) {
	        throw new TypeError('Not an ObjectIterator');
	      }

	      // Find next key in the object
	      while (array.length > 0) {
	        key = _shift(array);

	        // The candidate key isn't defined on object.
	        // Must have been deleted, or object[[Prototype]]
	        // has been modified.
	        if (!(key in this.object)) {
	          continue;
	        }

	        if (this.kind === 'key') {
	          return iteratorResult(key);
	        } else if (this.kind === 'value') {
	          return iteratorResult(this.object[key]);
	        } else {
	          return iteratorResult([key, this.object[key]]);
	        }
	      }

	      return iteratorResult();
	    }
	  });
	  addIterator(ObjectIterator.prototype);

	  // note: this is positioned here because it depends on ArrayIterator
	  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
	    // Detects a bug in Webkit nightly r181886
	    var Foo = function Foo(len) { this.length = len; };
	    Foo.prototype = [];
	    var fooArr = Array.of.apply(Foo, [1, 2]);
	    return fooArr instanceof Foo && fooArr.length === 2;
	  }());
	  if (!arrayOfSupportsSubclassing) {
	    overrideNative(Array, 'of', ArrayShims.of);
	  }

	  var ArrayPrototypeShims = {
	    copyWithin: function copyWithin(target, start) {
	      var end = arguments[2]; // copyWithin.length must be 2
	      var o = ES.ToObject(this);
	      var len = ES.ToLength(o.length);
	      var relativeTarget = ES.ToInteger(target);
	      var relativeStart = ES.ToInteger(start);
	      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
	      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
	      end = typeof end === 'undefined' ? len : ES.ToInteger(end);
	      var fin = end < 0 ? _max(len + end, 0) : _min(end, len);
	      var count = _min(fin - from, len - to);
	      var direction = 1;
	      if (from < to && to < (from + count)) {
	        direction = -1;
	        from += count - 1;
	        to += count - 1;
	      }
	      while (count > 0) {
	        if (_hasOwnProperty(o, from)) {
	          o[to] = o[from];
	        } else {
	          delete o[from];
	        }
	        from += direction;
	        to += direction;
	        count -= 1;
	      }
	      return o;
	    },

	    fill: function fill(value) {
	      var start = arguments.length > 1 ? arguments[1] : void 0;
	      var end = arguments.length > 2 ? arguments[2] : void 0;
	      var O = ES.ToObject(this);
	      var len = ES.ToLength(O.length);
	      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
	      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

	      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
	      var relativeEnd = end < 0 ? len + end : end;

	      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
	        O[i] = value;
	      }
	      return O;
	    },

	    find: function find(predicate) {
	      var list = ES.ToObject(this);
	      var length = ES.ToLength(list.length);
	      if (!ES.IsCallable(predicate)) {
	        throw new TypeError('Array#find: predicate must be a function');
	      }
	      var thisArg = arguments.length > 1 ? arguments[1] : null;
	      for (var i = 0, value; i < length; i++) {
	        value = list[i];
	        if (thisArg) {
	          if (_call(predicate, thisArg, value, i, list)) { return value; }
	        } else if (predicate(value, i, list)) {
	          return value;
	        }
	      }
	    },

	    findIndex: function findIndex(predicate) {
	      var list = ES.ToObject(this);
	      var length = ES.ToLength(list.length);
	      if (!ES.IsCallable(predicate)) {
	        throw new TypeError('Array#findIndex: predicate must be a function');
	      }
	      var thisArg = arguments.length > 1 ? arguments[1] : null;
	      for (var i = 0; i < length; i++) {
	        if (thisArg) {
	          if (_call(predicate, thisArg, list[i], i, list)) { return i; }
	        } else if (predicate(list[i], i, list)) {
	          return i;
	        }
	      }
	      return -1;
	    },

	    keys: function keys() {
	      return new ArrayIterator(this, 'key');
	    },

	    values: function values() {
	      return new ArrayIterator(this, 'value');
	    },

	    entries: function entries() {
	      return new ArrayIterator(this, 'entry');
	    }
	  };
	  // Safari 7.1 defines Array#keys and Array#entries natively,
	  // but the resulting ArrayIterator objects don't have a "next" method.
	  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
	    delete Array.prototype.keys;
	  }
	  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
	    delete Array.prototype.entries;
	  }

	  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
	  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
	    defineProperties(Array.prototype, {
	      values: Array.prototype[$iterator$]
	    });
	    if (Type.symbol(Symbol.unscopables)) {
	      Array.prototype[Symbol.unscopables].values = true;
	    }
	  }
	  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
	  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
	    var originalArrayPrototypeValues = Array.prototype.values;
	    overrideNative(Array.prototype, 'values', function values() { return _call(originalArrayPrototypeValues, this); });
	    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
	  }
	  defineProperties(Array.prototype, ArrayPrototypeShims);

	  addIterator(Array.prototype, function () { return this.values(); });
	  // Chrome defines keys/values/entries on Array, but doesn't give us
	  // any way to identify its iterator.  So add our own shimmed field.
	  if (Object.getPrototypeOf) {
	    addIterator(Object.getPrototypeOf([].values()));
	  }

	  // note: this is positioned here because it relies on Array#entries
	  var arrayFromSwallowsNegativeLengths = (function () {
	    // Detects a Firefox bug in v32
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
	    return valueOrFalseIfThrows(function () { return Array.from({ length: -1 }).length === 0; });
	  }());
	  var arrayFromHandlesIterables = (function () {
	    // Detects a bug in Webkit nightly r181886
	    var arr = Array.from([0].entries());
	    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
	  }());
	  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
	    overrideNative(Array, 'from', ArrayShims.from);
	  }
	  var arrayFromHandlesUndefinedMapFunction = (function () {
	    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
	    // but the spec doesn't care if it's provided or not - undefined doesn't throw.
	    return valueOrFalseIfThrows(function () { return Array.from([0], undefined); });
	  }());
	  if (!arrayFromHandlesUndefinedMapFunction) {
	    var origArrayFrom = Array.from;
	    overrideNative(Array, 'from', function from(items) {
	      if (arguments.length > 0 && typeof arguments[1] !== 'undefined') {
	        return _apply(origArrayFrom, this, arguments);
	      } else {
	        return _call(origArrayFrom, this, items);
	      }
	    });
	  }

	  var toLengthsCorrectly = function (method, reversed) {
	    var obj = { length: -1 };
	    obj[reversed ? ((-1 >>> 0) - 1) : 0] = true;
	    return valueOrFalseIfThrows(function () {
	      _call(method, obj, function () {
	        // note: in nonconforming browsers, this will be called
	        // -1 >>> 0 times, which is 4294967295, so the throw matters.
	        throw new RangeError('should not reach here');
	      }, []);
	    });
	  };
	  if (!toLengthsCorrectly(Array.prototype.forEach)) {
	    var originalForEach = Array.prototype.forEach;
	    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
	      return _apply(originalForEach, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.map)) {
	    var originalMap = Array.prototype.map;
	    overrideNative(Array.prototype, 'map', function map(callbackFn) {
	      return _apply(originalMap, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.filter)) {
	    var originalFilter = Array.prototype.filter;
	    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
	      return _apply(originalFilter, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.some)) {
	    var originalSome = Array.prototype.some;
	    overrideNative(Array.prototype, 'some', function some(callbackFn) {
	      return _apply(originalSome, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.every)) {
	    var originalEvery = Array.prototype.every;
	    overrideNative(Array.prototype, 'every', function every(callbackFn) {
	      return _apply(originalEvery, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.reduce)) {
	    var originalReduce = Array.prototype.reduce;
	    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
	      return _apply(originalReduce, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
	    var originalReduceRight = Array.prototype.reduceRight;
	    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
	      return _apply(originalReduceRight, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }

	  if (Number('0o10') !== 8 || Number('0b10') !== 2) {
	    var OrigNumber = Number;
	    var binaryRegex = /^0b/i;
	    var octalRegex = /^0o/i;
	    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
	    var isBinary = binaryRegex.test.bind(binaryRegex);
	    var isOctal = octalRegex.test.bind(octalRegex);
	    var toPrimitive = function (O) { // need to replace this with `es-to-primitive/es6`
	      var result;
	      if (typeof O.valueOf === 'function') {
	        result = O.valueOf();
	        if (Type.primitive(result)) {
	          return result;
	        }
	      }
	      if (typeof O.toString === 'function') {
	        result = O.toString();
	        if (Type.primitive(result)) {
	          return result;
	        }
	      }
	      throw new TypeError('No default value');
	    };
	    var NumberShim = (function () {
	      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
	      return function Number(value) {
	        var primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
	        if (typeof primValue === 'string') {
	          if (isBinary(primValue)) {
	            primValue = parseInt(_strSlice(primValue, 2), 2);
	          } else if (isOctal(primValue)) {
	            primValue = parseInt(_strSlice(primValue, 2), 8);
	          }
	        }
	        if (this instanceof Number) {
	          return new OrigNumber(primValue);
	        }
	        /* jshint newcap: false */
	        return OrigNumber(primValue);
	        /* jshint newcap: true */
	      };
	    }());
	    wrapConstructor(OrigNumber, NumberShim, {});
	    /*globals Number: true */
	    Number = NumberShim;
	    Value.redefine(globals, 'Number', NumberShim);
	    /*globals Number: false */
	  }

	  var maxSafeInteger = Math.pow(2, 53) - 1;
	  defineProperties(Number, {
	    MAX_SAFE_INTEGER: maxSafeInteger,
	    MIN_SAFE_INTEGER: -maxSafeInteger,
	    EPSILON: 2.220446049250313e-16,

	    parseInt: globals.parseInt,
	    parseFloat: globals.parseFloat,

	    isFinite: numberIsFinite,

	    isInteger: function isInteger(value) {
	      return numberIsFinite(value) && ES.ToInteger(value) === value;
	    },

	    isSafeInteger: function isSafeInteger(value) {
	      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
	    },

	    isNaN: numberIsNaN
	  });
	  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
	  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

	  // Work around bugs in Array#find and Array#findIndex -- early
	  // implementations skipped holes in sparse arrays. (Note that the
	  // implementations of find/findIndex indirectly use shimmed
	  // methods of Number, so this test has to happen down here.)
	  /*jshint elision: true */
	  if (![, 1].find(function (item, idx) { return idx === 0; })) {
	    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
	  }
	  if ([, 1].findIndex(function (item, idx) { return idx === 0; }) !== 0) {
	    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
	  }
	  /*jshint elision: false */

	  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
	  var sliceArgs = function sliceArgs() {
	    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
	    var initial = Number(this);
	    var len = arguments.length;
	    var desiredArgCount = len - initial;
	    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
	    for (var i = initial; i < len; ++i) {
	      args[i - initial] = arguments[i];
	    }
	    return args;
	  };
	  var assignTo = function assignTo(source) {
	    return function assignToSource(target, key) {
	      target[key] = source[key];
	      return target;
	    };
	  };
	  var assignReducer = function (target, source) {
	    var keys = Object.keys(Object(source));
	    var symbols;
	    if (ES.IsCallable(Object.getOwnPropertySymbols)) {
	      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
	    }
	    return _reduce(_concat(keys, symbols || []), assignTo(source), target);
	  };

	  var ObjectShims = {
	    // 19.1.3.1
	    assign: function (target, source) {
	      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
	      return _reduce(_apply(sliceArgs, 1, arguments), assignReducer, to);
	    },

	    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
	    is: function is(a, b) {
	      return ES.SameValue(a, b);
	    }
	  };
	  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
	    // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	    // which is 72% slower than our shim, and Firefox 40's native implementation.
	    var thrower = Object.preventExtensions({ 1: 2 });
	    try {
	      Object.assign(thrower, 'xy');
	    } catch (e) {
	      return thrower[1] === 'y';
	    }
	  }());
	  if (assignHasPendingExceptions) {
	    overrideNative(Object, 'assign', ObjectShims.assign);
	  }
	  defineProperties(Object, ObjectShims);

	  if (supportsDescriptors) {
	    var ES5ObjectShims = {
	      // 19.1.3.9
	      // shim from https://gist.github.com/WebReflection/5593554
	      setPrototypeOf: (function (Object, magic) {
	        var set;

	        var checkArgs = function (O, proto) {
	          if (!ES.TypeIsObject(O)) {
	            throw new TypeError('cannot set prototype on a non-object');
	          }
	          if (!(proto === null || ES.TypeIsObject(proto))) {
	            throw new TypeError('can only set prototype to an object or null' + proto);
	          }
	        };

	        var setPrototypeOf = function (O, proto) {
	          checkArgs(O, proto);
	          _call(set, O, proto);
	          return O;
	        };

	        try {
	          // this works already in Firefox and Safari
	          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
	          _call(set, {}, null);
	        } catch (e) {
	          if (Object.prototype !== {}[magic]) {
	            // IE < 11 cannot be shimmed
	            return;
	          }
	          // probably Chrome or some old Mobile stock browser
	          set = function (proto) {
	            this[magic] = proto;
	          };
	          // please note that this will **not** work
	          // in those browsers that do not inherit
	          // __proto__ by mistake from Object.prototype
	          // in these cases we should probably throw an error
	          // or at least be informed about the issue
	          setPrototypeOf.polyfill = setPrototypeOf(
	            setPrototypeOf({}, null),
	            Object.prototype
	          ) instanceof Object;
	          // setPrototypeOf.polyfill === true means it works as meant
	          // setPrototypeOf.polyfill === false means it's not 100% reliable
	          // setPrototypeOf.polyfill === undefined
	          // or
	          // setPrototypeOf.polyfill ==  null means it's not a polyfill
	          // which means it works as expected
	          // we can even delete Object.prototype.__proto__;
	        }
	        return setPrototypeOf;
	      }(Object, '__proto__'))
	    };

	    defineProperties(Object, ES5ObjectShims);
	  }

	  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
	  // but Object.create(null) does.
	  if (Object.setPrototypeOf && Object.getPrototypeOf &&
	      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
	      Object.getPrototypeOf(Object.create(null)) === null) {
	    (function () {
	      var FAKENULL = Object.create(null);
	      var gpo = Object.getPrototypeOf, spo = Object.setPrototypeOf;
	      Object.getPrototypeOf = function (o) {
	        var result = gpo(o);
	        return result === FAKENULL ? null : result;
	      };
	      Object.setPrototypeOf = function (o, p) {
	        var proto = p === null ? FAKENULL : p;
	        return spo(o, proto);
	      };
	      Object.setPrototypeOf.polyfill = false;
	    }());
	  }

	  var objectKeysAcceptsPrimitives = !throwsError(function () { Object.keys('foo'); });
	  if (!objectKeysAcceptsPrimitives) {
	    var originalObjectKeys = Object.keys;
	    overrideNative(Object, 'keys', function keys(value) {
	      return originalObjectKeys(ES.ToObject(value));
	    });
	  }

	  if (Object.getOwnPropertyNames) {
	    var objectGOPNAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyNames('foo'); });
	    if (!objectGOPNAcceptsPrimitives) {
	      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
	      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
	      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
	        var val = ES.ToObject(value);
	        if (_toString(val) === '[object Window]') {
	          try {
	            return originalObjectGetOwnPropertyNames(val);
	          } catch (e) {
	            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
	            return _concat([], cachedWindowNames);
	          }
	        }
	        return originalObjectGetOwnPropertyNames(val);
	      });
	    }
	  }
	  if (Object.getOwnPropertyDescriptor) {
	    var objectGOPDAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyDescriptor('foo', 'bar'); });
	    if (!objectGOPDAcceptsPrimitives) {
	      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
	        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
	      });
	    }
	  }
	  if (Object.seal) {
	    var objectSealAcceptsPrimitives = !throwsError(function () { Object.seal('foo'); });
	    if (!objectSealAcceptsPrimitives) {
	      var originalObjectSeal = Object.seal;
	      overrideNative(Object, 'seal', function seal(value) {
	        if (!Type.object(value)) { return value; }
	        return originalObjectSeal(value);
	      });
	    }
	  }
	  if (Object.isSealed) {
	    var objectIsSealedAcceptsPrimitives = !throwsError(function () { Object.isSealed('foo'); });
	    if (!objectIsSealedAcceptsPrimitives) {
	      var originalObjectIsSealed = Object.isSealed;
	      overrideNative(Object, 'isSealed', function isSealed(value) {
	        if (!Type.object(value)) { return true; }
	        return originalObjectIsSealed(value);
	      });
	    }
	  }
	  if (Object.freeze) {
	    var objectFreezeAcceptsPrimitives = !throwsError(function () { Object.freeze('foo'); });
	    if (!objectFreezeAcceptsPrimitives) {
	      var originalObjectFreeze = Object.freeze;
	      overrideNative(Object, 'freeze', function freeze(value) {
	        if (!Type.object(value)) { return value; }
	        return originalObjectFreeze(value);
	      });
	    }
	  }
	  if (Object.isFrozen) {
	    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { Object.isFrozen('foo'); });
	    if (!objectIsFrozenAcceptsPrimitives) {
	      var originalObjectIsFrozen = Object.isFrozen;
	      overrideNative(Object, 'isFrozen', function isFrozen(value) {
	        if (!Type.object(value)) { return true; }
	        return originalObjectIsFrozen(value);
	      });
	    }
	  }
	  if (Object.preventExtensions) {
	    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { Object.preventExtensions('foo'); });
	    if (!objectPreventExtensionsAcceptsPrimitives) {
	      var originalObjectPreventExtensions = Object.preventExtensions;
	      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
	        if (!Type.object(value)) { return value; }
	        return originalObjectPreventExtensions(value);
	      });
	    }
	  }
	  if (Object.isExtensible) {
	    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { Object.isExtensible('foo'); });
	    if (!objectIsExtensibleAcceptsPrimitives) {
	      var originalObjectIsExtensible = Object.isExtensible;
	      overrideNative(Object, 'isExtensible', function isExtensible(value) {
	        if (!Type.object(value)) { return false; }
	        return originalObjectIsExtensible(value);
	      });
	    }
	  }
	  if (Object.getPrototypeOf) {
	    var objectGetProtoAcceptsPrimitives = !throwsError(function () { Object.getPrototypeOf('foo'); });
	    if (!objectGetProtoAcceptsPrimitives) {
	      var originalGetProto = Object.getPrototypeOf;
	      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
	        return originalGetProto(ES.ToObject(value));
	      });
	    }
	  }

	  if (!RegExp.prototype.flags && supportsDescriptors) {
	    var regExpFlagsGetter = function flags() {
	      if (!ES.TypeIsObject(this)) {
	        throw new TypeError('Method called on incompatible type: must be an object.');
	      }
	      var result = '';
	      if (this.global) {
	        result += 'g';
	      }
	      if (this.ignoreCase) {
	        result += 'i';
	      }
	      if (this.multiline) {
	        result += 'm';
	      }
	      if (this.unicode) {
	        result += 'u';
	      }
	      if (this.sticky) {
	        result += 'y';
	      }
	      return result;
	    };

	    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
	  }

	  var regExpSupportsFlagsWithRegex = valueOrFalseIfThrows(function () {
	    return String(new RegExp(/a/g, 'i')) === '/a/i';
	  });

	  if (!regExpSupportsFlagsWithRegex && supportsDescriptors) {
	    var OrigRegExp = RegExp;
	    var RegExpShim = function RegExp(pattern, flags) {
	      var calledWithNew = this instanceof RegExp;
	      if (!calledWithNew && (Type.regex(pattern) || (pattern && pattern.constructor === RegExp))) {
	        return pattern;
	      }
	      if (Type.regex(pattern) && Type.string(flags)) {
	        return new RegExp(pattern.source, flags);
	      }
	      return new OrigRegExp(pattern, flags);
	    };
	    wrapConstructor(OrigRegExp, RegExpShim, {
	      $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
	    });
	    /*globals RegExp: true */
	    RegExp = RegExpShim;
	    Value.redefine(globals, 'RegExp', RegExpShim);
	    /*globals RegExp: false */
	  }

	  if (supportsDescriptors) {
	    var regexGlobals = {
	      input: '$_',
	      lastMatch: '$&',
	      lastParen: '$+',
	      leftContext: '$`',
	      rightContext: '$\''
	    };
	    _forEach(Object.keys(regexGlobals), function (prop) {
	      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
	        Value.getter(RegExp, regexGlobals[prop], function get() {
	          return RegExp[prop];
	        });
	      }
	    });
	  }
	  addDefaultSpecies(RegExp);

	  var inverseEpsilon = 1 / Number.EPSILON;
	  var roundTiesToEven = function roundTiesToEven(n) {
	    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
	    return (n + inverseEpsilon) - inverseEpsilon;
	  };
	  var BINARY_32_EPSILON = Math.pow(2, -23);
	  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
	  var BINARY_32_MIN_VALUE = Math.pow(2, -126);
	  var numberCLZ = Number.prototype.clz;
	  delete Number.prototype.clz; // Safari 8 has Number#clz

	  var MathShims = {
	    acosh: function acosh(value) {
	      var x = Number(value);
	      if (Number.isNaN(x) || value < 1) { return NaN; }
	      if (x === 1) { return 0; }
	      if (x === Infinity) { return x; }
	      return _log(x / Math.E + _sqrt(x + 1) * _sqrt(x - 1) / Math.E) + 1;
	    },

	    asinh: function asinh(value) {
	      var x = Number(value);
	      if (x === 0 || !globalIsFinite(x)) {
	        return x;
	      }
	      return x < 0 ? -Math.asinh(-x) : _log(x + _sqrt(x * x + 1));
	    },

	    atanh: function atanh(value) {
	      var x = Number(value);
	      if (Number.isNaN(x) || x < -1 || x > 1) {
	        return NaN;
	      }
	      if (x === -1) { return -Infinity; }
	      if (x === 1) { return Infinity; }
	      if (x === 0) { return x; }
	      return 0.5 * _log((1 + x) / (1 - x));
	    },

	    cbrt: function cbrt(value) {
	      var x = Number(value);
	      if (x === 0) { return x; }
	      var negate = x < 0, result;
	      if (negate) { x = -x; }
	      if (x === Infinity) {
	        result = Infinity;
	      } else {
	        result = Math.exp(_log(x) / 3);
	        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
	        result = (x / (result * result) + (2 * result)) / 3;
	      }
	      return negate ? -result : result;
	    },

	    clz32: function clz32(value) {
	      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
	      var x = Number(value);
	      var number = ES.ToUint32(x);
	      if (number === 0) {
	        return 32;
	      }
	      return numberCLZ ? _call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * Math.LOG2E);
	    },

	    cosh: function cosh(value) {
	      var x = Number(value);
	      if (x === 0) { return 1; } // +0 or -0
	      if (Number.isNaN(x)) { return NaN; }
	      if (!globalIsFinite(x)) { return Infinity; }
	      if (x < 0) { x = -x; }
	      if (x > 21) { return Math.exp(x) / 2; }
	      return (Math.exp(x) + Math.exp(-x)) / 2;
	    },

	    expm1: function expm1(value) {
	      var x = Number(value);
	      if (x === -Infinity) { return -1; }
	      if (!globalIsFinite(x) || x === 0) { return x; }
	      if (_abs(x) > 0.5) {
	        return Math.exp(x) - 1;
	      }
	      // A more precise approximation using Taylor series expansion
	      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
	      var t = x;
	      var sum = 0;
	      var n = 1;
	      while (sum + t !== sum) {
	        sum += t;
	        n += 1;
	        t *= x / n;
	      }
	      return sum;
	    },

	    hypot: function hypot(x, y) {
	      var result = 0;
	      var largest = 0;
	      for (var i = 0; i < arguments.length; ++i) {
	        var value = _abs(Number(arguments[i]));
	        if (largest < value) {
	          result *= (largest / value) * (largest / value);
	          result += 1;
	          largest = value;
	        } else {
	          result += (value > 0 ? (value / largest) * (value / largest) : value);
	        }
	      }
	      return largest === Infinity ? Infinity : largest * _sqrt(result);
	    },

	    log2: function log2(value) {
	      return _log(value) * Math.LOG2E;
	    },

	    log10: function log10(value) {
	      return _log(value) * Math.LOG10E;
	    },

	    log1p: function log1p(value) {
	      var x = Number(value);
	      if (x < -1 || Number.isNaN(x)) { return NaN; }
	      if (x === 0 || x === Infinity) { return x; }
	      if (x === -1) { return -Infinity; }

	      return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
	    },

	    sign: function sign(value) {
	      var number = Number(value);
	      if (number === 0) { return number; }
	      if (Number.isNaN(number)) { return number; }
	      return number < 0 ? -1 : 1;
	    },

	    sinh: function sinh(value) {
	      var x = Number(value);
	      if (!globalIsFinite(x) || x === 0) { return x; }

	      if (_abs(x) < 1) {
	        return (Math.expm1(x) - Math.expm1(-x)) / 2;
	      }
	      return (Math.exp(x - 1) - Math.exp(-x - 1)) * Math.E / 2;
	    },

	    tanh: function tanh(value) {
	      var x = Number(value);
	      if (Number.isNaN(x) || x === 0) { return x; }
	      if (x === Infinity) { return 1; }
	      if (x === -Infinity) { return -1; }
	      var a = Math.expm1(x);
	      var b = Math.expm1(-x);
	      if (a === Infinity) { return 1; }
	      if (b === Infinity) { return -1; }
	      return (a - b) / (Math.exp(x) + Math.exp(-x));
	    },

	    trunc: function trunc(value) {
	      var x = Number(value);
	      return x < 0 ? -_floor(-x) : _floor(x);
	    },

	    imul: function imul(x, y) {
	      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
	      var a = ES.ToUint32(x);
	      var b = ES.ToUint32(y);
	      var ah = (a >>> 16) & 0xffff;
	      var al = a & 0xffff;
	      var bh = (b >>> 16) & 0xffff;
	      var bl = b & 0xffff;
	      // the shift by 0 fixes the sign on the high part
	      // the final |0 converts the unsigned value into a signed value
	      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
	    },

	    fround: function fround(x) {
	      var v = Number(x);
	      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
	        return v;
	      }
	      var sign = Math.sign(v);
	      var abs = _abs(v);
	      if (abs < BINARY_32_MIN_VALUE) {
	        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
	      }
	      // Veltkamp's splitting (?)
	      var a = (1 + BINARY_32_EPSILON / Number.EPSILON) * abs;
	      var result = a - (a - abs);
	      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
	        return sign * Infinity;
	      }
	      return sign * result;
	    }
	  };
	  defineProperties(Math, MathShims);
	  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
	  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
	  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
	  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
	  // Chrome 40 has an imprecise Math.tanh with very small numbers
	  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
	  // Chrome 40 loses Math.acosh precision with high numbers
	  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
	  // Firefox 38 on Windows
	  defineProperty(Math, 'cbrt', MathShims.cbrt, Math.abs(1 - Math.cbrt(1e-300) / 1e-100) / Number.EPSILON > 8);
	  // node 0.11 has an imprecise Math.sinh with very small numbers
	  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
	  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
	  var expm1OfTen = Math.expm1(10);
	  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);

	  var origMathRound = Math.round;
	  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
	  var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;

	  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
	  // This behavior should be governed by "round to nearest, ties to even mode"
	  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-number-type
	  // These are the boundary cases where it breaks.
	  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
	  var largestPositiveNumberWhereRoundBreaks = 2 * inverseEpsilon - 1;
	  var roundDoesNotIncreaseIntegers = [smallestPositiveNumberWhereRoundBreaks, largestPositiveNumberWhereRoundBreaks].every(function (num) {
	    return Math.round(num) === num;
	  });
	  defineProperty(Math, 'round', function round(x) {
	    var floor = _floor(x);
	    var ceil = floor === -1 ? -0 : floor + 1;
	    return x - floor < 0.5 ? floor : ceil;
	  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
	  Value.preserveToString(Math.round, origMathRound);

	  var origImul = Math.imul;
	  if (Math.imul(0xffffffff, 5) !== -5) {
	    // Safari 6.1, at least, reports "0" for this value
	    Math.imul = MathShims.imul;
	    Value.preserveToString(Math.imul, origImul);
	  }
	  if (Math.imul.length !== 2) {
	    // Safari 8.0.4 has a length of 1
	    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
	    overrideNative(Math, 'imul', function imul(x, y) {
	      return _apply(origImul, Math, arguments);
	    });
	  }

	  // Promises
	  // Simplest possible implementation; use a 3rd-party library if you
	  // want the best possible speed and/or long stack traces.
	  var PromiseShim = (function () {
	    var setTimeout = globals.setTimeout;
	    // some environments don't have setTimeout - no way to shim here.
	    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

	    ES.IsPromise = function (promise) {
	      if (!ES.TypeIsObject(promise)) {
	        return false;
	      }
	      if (typeof promise._promise === 'undefined') {
	        return false; // uninitialized, or missing our hidden field.
	      }
	      return true;
	    };

	    // "PromiseCapability" in the spec is what most promise implementations
	    // call a "deferred".
	    var PromiseCapability = function (C) {
	      if (!ES.IsConstructor(C)) {
	        throw new TypeError('Bad promise constructor');
	      }
	      var capability = this;
	      var resolver = function (resolve, reject) {
	        if (capability.resolve !== void 0 || capability.reject !== void 0) {
	          throw new TypeError('Bad Promise implementation!');
	        }
	        capability.resolve = resolve;
	        capability.reject = reject;
	      };
	      capability.promise = new C(resolver);
	      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
	        throw new TypeError('Bad promise constructor');
	      }
	    };

	    // find an appropriate setImmediate-alike
	    var makeZeroTimeout;
	    /*global window */
	    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
	      makeZeroTimeout = function () {
	        // from http://dbaron.org/log/20100309-faster-timeouts
	        var timeouts = [];
	        var messageName = 'zero-timeout-message';
	        var setZeroTimeout = function (fn) {
	          _push(timeouts, fn);
	          window.postMessage(messageName, '*');
	        };
	        var handleMessage = function (event) {
	          if (event.source === window && event.data === messageName) {
	            event.stopPropagation();
	            if (timeouts.length === 0) { return; }
	            var fn = _shift(timeouts);
	            fn();
	          }
	        };
	        window.addEventListener('message', handleMessage, true);
	        return setZeroTimeout;
	      };
	    }
	    var makePromiseAsap = function () {
	      // An efficient task-scheduler based on a pre-existing Promise
	      // implementation, which we can use even if we override the
	      // global Promise below (in order to workaround bugs)
	      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
	      var P = globals.Promise;
	      return P && P.resolve && function (task) {
	        return P.resolve().then(task);
	      };
	    };
	    /*global process */
	    var enqueue = ES.IsCallable(globals.setImmediate) ?
	      globals.setImmediate.bind(globals) :
	      typeof process === 'object' && process.nextTick ? process.nextTick :
	      makePromiseAsap() ||
	      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() :
	      function (task) { setTimeout(task, 0); }); // fallback

	    // Constants for Promise implementation
	    var PROMISE_IDENTITY = 1;
	    var PROMISE_THROWER = 2;
	    var PROMISE_PENDING = 3;
	    var PROMISE_FULFILLED = 4;
	    var PROMISE_REJECTED = 5;

	    var promiseReactionJob = function (reaction, argument) {
	      var promiseCapability = reaction.capabilities;
	      var handler = reaction.handler;
	      var handlerResult, handlerException = false, f;
	      if (handler === PROMISE_IDENTITY) {
	        handlerResult = argument;
	      } else if (handler === PROMISE_THROWER) {
	        handlerResult = argument;
	        handlerException = true;
	      } else {
	        try {
	          handlerResult = handler(argument);
	        } catch (e) {
	          handlerResult = e;
	          handlerException = true;
	        }
	      }
	      f = handlerException ? promiseCapability.reject : promiseCapability.resolve;
	      f(handlerResult);
	    };

	    var triggerPromiseReactions = function (reactions, argument) {
	      _forEach(reactions, function (reaction) {
	        enqueue(function () {
	          promiseReactionJob(reaction, argument);
	        });
	      });
	    };

	    var fulfillPromise = function (promise, value) {
	      var _promise = promise._promise;
	      var reactions = _promise.fulfillReactions;
	      _promise.result = value;
	      _promise.fulfillReactions = void 0;
	      _promise.rejectReactions = void 0;
	      _promise.state = PROMISE_FULFILLED;
	      triggerPromiseReactions(reactions, value);
	    };

	    var rejectPromise = function (promise, reason) {
	      var _promise = promise._promise;
	      var reactions = _promise.rejectReactions;
	      _promise.result = reason;
	      _promise.fulfillReactions = void 0;
	      _promise.rejectReactions = void 0;
	      _promise.state = PROMISE_REJECTED;
	      triggerPromiseReactions(reactions, reason);
	    };

	    var createResolvingFunctions = function (promise) {
	      var alreadyResolved = false;
	      var resolve = function (resolution) {
	        var then;
	        if (alreadyResolved) { return; }
	        alreadyResolved = true;
	        if (resolution === promise) {
	          return rejectPromise(promise, new TypeError('Self resolution'));
	        }
	        if (!ES.TypeIsObject(resolution)) {
	          return fulfillPromise(promise, resolution);
	        }
	        try {
	          then = resolution.then;
	        } catch (e) {
	          return rejectPromise(promise, e);
	        }
	        if (!ES.IsCallable(then)) {
	          return fulfillPromise(promise, resolution);
	        }
	        enqueue(function () {
	          promiseResolveThenableJob(promise, resolution, then);
	        });
	      };
	      var reject = function (reason) {
	        if (alreadyResolved) { return; }
	        alreadyResolved = true;
	        return rejectPromise(promise, reason);
	      };
	      return { resolve: resolve, reject: reject };
	    };

	    var promiseResolveThenableJob = function (promise, thenable, then) {
	      var resolvingFunctions = createResolvingFunctions(promise);
	      var resolve = resolvingFunctions.resolve;
	      var reject = resolvingFunctions.reject;
	      try {
	        _call(then, thenable, resolve, reject);
	      } catch (e) {
	        reject(e);
	      }
	    };

	    // This is a common step in many Promise methods
	    var getPromiseSpecies = function (C) {
	      if (!ES.TypeIsObject(C)) {
	        throw new TypeError('Promise is not object');
	      }
	      var S = C[symbolSpecies];
	      if (S !== void 0 && S !== null) {
	        return S;
	      }
	      return C;
	    };

	    var Promise = function Promise(resolver) {
	      if (!(this instanceof Promise)) {
	        throw new TypeError('Constructor Promise requires "new"');
	      }
	      if (this && this._promise) {
	        throw new TypeError('Bad construction');
	      }
	      // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
	      if (!ES.IsCallable(resolver)) {
	        throw new TypeError('not a valid resolver');
	      }
	      var promise = emulateES6construct(this, Promise, Promise$prototype, {
	        _promise: {
	          result: void 0,
	          state: PROMISE_PENDING,
	          fulfillReactions: [],
	          rejectReactions: []
	        }
	      });
	      var resolvingFunctions = createResolvingFunctions(promise);
	      var reject = resolvingFunctions.reject;
	      try {
	        resolver(resolvingFunctions.resolve, reject);
	      } catch (e) {
	        reject(e);
	      }
	      return promise;
	    };
	    var Promise$prototype = Promise.prototype;

	    var _promiseAllResolver = function (index, values, capability, remaining) {
	      var alreadyCalled = false;
	      return function (x) {
	        if (alreadyCalled) { return; }
	        alreadyCalled = true;
	        values[index] = x;
	        if ((--remaining.count) === 0) {
	          var resolve = capability.resolve;
	          resolve(values); // call w/ this===undefined
	        }
	      };
	    };

	    var performPromiseAll = function (iteratorRecord, C, resultCapability) {
	      var it = iteratorRecord.iterator;
	      var values = [], remaining = { count: 1 }, next, nextValue;
	      var index = 0;
	      while (true) {
	        try {
	          next = ES.IteratorStep(it);
	          if (next === false) {
	            iteratorRecord.done = true;
	            break;
	          }
	          nextValue = next.value;
	        } catch (e) {
	          iteratorRecord.done = true;
	          throw e;
	        }
	        values[index] = void 0;
	        var nextPromise = C.resolve(nextValue);
	        var resolveElement = _promiseAllResolver(
	          index, values, resultCapability, remaining
	        );
	        remaining.count++;
	        nextPromise.then(resolveElement, resultCapability.reject);
	        index += 1;
	      }
	      if ((--remaining.count) === 0) {
	        var resolve = resultCapability.resolve;
	        resolve(values); // call w/ this===undefined
	      }
	      return resultCapability.promise;
	    };

	    var performPromiseRace = function (iteratorRecord, C, resultCapability) {
	      var it = iteratorRecord.iterator, next, nextValue, nextPromise;
	      while (true) {
	        try {
	          next = ES.IteratorStep(it);
	          if (next === false) {
	            // NOTE: If iterable has no items, resulting promise will never
	            // resolve; see:
	            // https://github.com/domenic/promises-unwrapping/issues/75
	            // https://bugs.ecmascript.org/show_bug.cgi?id=2515
	            iteratorRecord.done = true;
	            break;
	          }
	          nextValue = next.value;
	        } catch (e) {
	          iteratorRecord.done = true;
	          throw e;
	        }
	        nextPromise = C.resolve(nextValue);
	        nextPromise.then(resultCapability.resolve, resultCapability.reject);
	      }
	      return resultCapability.promise;
	    };

	    defineProperties(Promise, {
	      all: function all(iterable) {
	        var C = getPromiseSpecies(this);
	        var capability = new PromiseCapability(C);
	        var iterator, iteratorRecord;
	        try {
	          iterator = ES.GetIterator(iterable);
	          iteratorRecord = { iterator: iterator, done: false };
	          return performPromiseAll(iteratorRecord, C, capability);
	        } catch (e) {
	          if (iteratorRecord && !iteratorRecord.done) {
	            try {
	              ES.IteratorClose(iterator, true);
	            } catch (ee) {
	              e = ee;
	            }
	          }
	          var reject = capability.reject;
	          reject(e);
	          return capability.promise;
	        }
	      },

	      race: function race(iterable) {
	        var C = getPromiseSpecies(this);
	        var capability = new PromiseCapability(C);
	        var iterator, iteratorRecord;
	        try {
	          iterator = ES.GetIterator(iterable);
	          iteratorRecord = { iterator: iterator, done: false };
	          return performPromiseRace(iteratorRecord, C, capability);
	        } catch (e) {
	          if (iteratorRecord && !iteratorRecord.done) {
	            try {
	              ES.IteratorClose(iterator, true);
	            } catch (ee) {
	              e = ee;
	            }
	          }
	          var reject = capability.reject;
	          reject(e);
	          return capability.promise;
	        }
	      },

	      reject: function reject(reason) {
	        var C = this;
	        var capability = new PromiseCapability(C);
	        var rejectFunc = capability.reject;
	        rejectFunc(reason); // call with this===undefined
	        return capability.promise;
	      },

	      resolve: function resolve(v) {
	        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
	        var C = this;
	        if (ES.IsPromise(v)) {
	          var constructor = v.constructor;
	          if (constructor === C) { return v; }
	        }
	        var capability = new PromiseCapability(C);
	        var resolveFunc = capability.resolve;
	        resolveFunc(v); // call with this===undefined
	        return capability.promise;
	      }
	    });

	    defineProperties(Promise$prototype, {
	      'catch': function (onRejected) {
	        return this.then(void 0, onRejected);
	      },

	      then: function then(onFulfilled, onRejected) {
	        var promise = this;
	        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
	        var C = ES.SpeciesConstructor(promise, Promise);
	        var resultCapability = new PromiseCapability(C);
	        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
	        if (!ES.IsCallable(onFulfilled)) {
	          onFulfilled = PROMISE_IDENTITY;
	        }
	        if (!ES.IsCallable(onRejected)) {
	          onRejected = PROMISE_THROWER;
	        }
	        var fulfillReaction = { capabilities: resultCapability, handler: onFulfilled };
	        var rejectReaction = { capabilities: resultCapability, handler: onRejected };
	        var _promise = promise._promise, value;
	        if (_promise.state === PROMISE_PENDING) {
	          _push(_promise.fulfillReactions, fulfillReaction);
	          _push(_promise.rejectReactions, rejectReaction);
	        } else if (_promise.state === PROMISE_FULFILLED) {
	          value = _promise.result;
	          enqueue(function () {
	            promiseReactionJob(fulfillReaction, value);
	          });
	        } else if (_promise.state === PROMISE_REJECTED) {
	          value = _promise.result;
	          enqueue(function () {
	            promiseReactionJob(rejectReaction, value);
	          });
	        } else {
	          throw new TypeError('unexpected Promise state');
	        }
	        return resultCapability.promise;
	      }
	    });

	    return Promise;
	  }());

	  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
	  if (globals.Promise) {
	    delete globals.Promise.accept;
	    delete globals.Promise.defer;
	    delete globals.Promise.prototype.chain;
	  }

	  if (typeof PromiseShim === 'function') {
	    // export the Promise constructor.
	    defineProperties(globals, { Promise: PromiseShim });
	    // In Chrome 33 (and thereabouts) Promise is defined, but the
	    // implementation is buggy in a number of ways.  Let's check subclassing
	    // support to see if we have a buggy implementation.
	    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
	      return S.resolve(42).then(function () {}) instanceof S;
	    });
	    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () { globals.Promise.reject(42).then(null, 5).then(null, noop); });
	    var promiseRequiresObjectContext = throwsError(function () { globals.Promise.call(3, noop); });
	    // Promise.resolve() was errata'ed late in the ES6 process.
	    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
	    //      https://code.google.com/p/v8/issues/detail?id=4161
	    // It serves as a proxy for a number of other bugs in early Promise
	    // implementations.
	    var promiseResolveBroken = (function (Promise) {
	      var p = Promise.resolve(5);
	      p.constructor = {};
	      var p2 = Promise.resolve(p);
	      return (p === p2); // This *should* be false!
	    }(globals.Promise));
	    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
	        !promiseRequiresObjectContext || promiseResolveBroken) {
	      /*globals Promise: true */
	      Promise = PromiseShim;
	      /*globals Promise: false */
	      overrideNative(globals, 'Promise', PromiseShim);
	    }
	    addDefaultSpecies(Promise);
	  }

	  // Map and Set require a true ES5 environment
	  // Their fast path also requires that the environment preserve
	  // property insertion order, which is not guaranteed by the spec.
	  var testOrder = function (a) {
	    var b = Object.keys(_reduce(a, function (o, k) {
	      o[k] = true;
	      return o;
	    }, {}));
	    return a.join(':') === b.join(':');
	  };
	  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
	  // some engines (eg, Chrome) only preserve insertion order for string keys
	  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

	  if (supportsDescriptors) {

	    var fastkey = function fastkey(key) {
	      if (!preservesInsertionOrder) {
	        return null;
	      }
	      var type = typeof key;
	      if (type === 'undefined' || key === null) {
	        return '^' + String(key);
	      } else if (type === 'string') {
	        return '$' + key;
	      } else if (type === 'number') {
	        // note that -0 will get coerced to "0" when used as a property key
	        if (!preservesNumericInsertionOrder) {
	          return 'n' + key;
	        }
	        return key;
	      } else if (type === 'boolean') {
	        return 'b' + key;
	      }
	      return null;
	    };

	    var emptyObject = function emptyObject() {
	      // accomodate some older not-quite-ES5 browsers
	      return Object.create ? Object.create(null) : {};
	    };

	    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
	      if (isArray(iterable) || Type.string(iterable)) {
	        _forEach(iterable, function (entry) {
	          map.set(entry[0], entry[1]);
	        });
	      } else if (iterable instanceof MapConstructor) {
	        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
	          map.set(key, value);
	        });
	      } else {
	        var iter, adder;
	        if (iterable !== null && typeof iterable !== 'undefined') {
	          adder = map.set;
	          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
	          iter = ES.GetIterator(iterable);
	        }
	        if (typeof iter !== 'undefined') {
	          while (true) {
	            var next = ES.IteratorStep(iter);
	            if (next === false) { break; }
	            var nextItem = next.value;
	            try {
	              if (!ES.TypeIsObject(nextItem)) {
	                throw new TypeError('expected iterable of pairs');
	              }
	              _call(adder, map, nextItem[0], nextItem[1]);
	            } catch (e) {
	              ES.IteratorClose(iter, true);
	              throw e;
	            }
	          }
	        }
	      }
	    };
	    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
	      if (isArray(iterable) || Type.string(iterable)) {
	        _forEach(iterable, function (value) {
	          set.add(value);
	        });
	      } else if (iterable instanceof SetConstructor) {
	        _call(SetConstructor.prototype.forEach, iterable, function (value) {
	          set.add(value);
	        });
	      } else {
	        var iter, adder;
	        if (iterable !== null && typeof iterable !== 'undefined') {
	          adder = set.add;
	          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
	          iter = ES.GetIterator(iterable);
	        }
	        if (typeof iter !== 'undefined') {
	          while (true) {
	            var next = ES.IteratorStep(iter);
	            if (next === false) { break; }
	            var nextValue = next.value;
	            try {
	              _call(adder, set, nextValue);
	            } catch (e) {
	              ES.IteratorClose(iter, true);
	              throw e;
	            }
	          }
	        }
	      }
	    };

	    var collectionShims = {
	      Map: (function () {

	        var empty = {};

	        var MapEntry = function MapEntry(key, value) {
	          this.key = key;
	          this.value = value;
	          this.next = null;
	          this.prev = null;
	        };

	        MapEntry.prototype.isRemoved = function isRemoved() {
	          return this.key === empty;
	        };

	        var isMap = function isMap(map) {
	          return !!map._es6map;
	        };

	        var requireMapSlot = function requireMapSlot(map, method) {
	          if (!ES.TypeIsObject(map) || !isMap(map)) {
	            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + String(map));
	          }
	        };

	        var MapIterator = function MapIterator(map, kind) {
	          requireMapSlot(map, '[[MapIterator]]');
	          this.head = map._head;
	          this.i = this.head;
	          this.kind = kind;
	        };

	        MapIterator.prototype = {
	          next: function next() {
	            var i = this.i, kind = this.kind, head = this.head, result;
	            if (typeof this.i === 'undefined') {
	              return { value: void 0, done: true };
	            }
	            while (i.isRemoved() && i !== head) {
	              // back up off of removed entries
	              i = i.prev;
	            }
	            // advance to next unreturned element.
	            while (i.next !== head) {
	              i = i.next;
	              if (!i.isRemoved()) {
	                if (kind === 'key') {
	                  result = i.key;
	                } else if (kind === 'value') {
	                  result = i.value;
	                } else {
	                  result = [i.key, i.value];
	                }
	                this.i = i;
	                return { value: result, done: false };
	              }
	            }
	            // once the iterator is done, it is done forever.
	            this.i = void 0;
	            return { value: void 0, done: true };
	          }
	        };
	        addIterator(MapIterator.prototype);

	        var MapShim = function Map() {
	          if (!(this instanceof Map)) {
	            throw new TypeError('Constructor Map requires "new"');
	          }
	          if (this && this._es6map) {
	            throw new TypeError('Bad construction');
	          }
	          var map = emulateES6construct(this, Map, Map$prototype, {
	            _es6map: true,
	            _head: null,
	            _storage: emptyObject(),
	            _size: 0
	          });

	          var head = new MapEntry(null, null);
	          // circular doubly-linked list.
	          head.next = head.prev = head;
	          map._head = head;

	          // Optionally initialize map from iterable
	          if (arguments.length > 0) {
	            addIterableToMap(Map, map, arguments[0]);
	          }
	          return map;
	        };
	        var Map$prototype = MapShim.prototype;

	        Value.getter(Map$prototype, 'size', function () {
	          if (typeof this._size === 'undefined') {
	            throw new TypeError('size method called on incompatible Map');
	          }
	          return this._size;
	        });

	        defineProperties(Map$prototype, {
	          get: function get(key) {
	            requireMapSlot(this, 'get');
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              var entry = this._storage[fkey];
	              if (entry) {
	                return entry.value;
	              } else {
	                return;
	              }
	            }
	            var head = this._head, i = head;
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                return i.value;
	              }
	            }
	          },

	          has: function has(key) {
	            requireMapSlot(this, 'has');
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              return typeof this._storage[fkey] !== 'undefined';
	            }
	            var head = this._head, i = head;
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                return true;
	              }
	            }
	            return false;
	          },

	          set: function set(key, value) {
	            requireMapSlot(this, 'set');
	            var head = this._head, i = head, entry;
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              if (typeof this._storage[fkey] !== 'undefined') {
	                this._storage[fkey].value = value;
	                return this;
	              } else {
	                entry = this._storage[fkey] = new MapEntry(key, value);
	                i = head.prev;
	                // fall through
	              }
	            }
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                i.value = value;
	                return this;
	              }
	            }
	            entry = entry || new MapEntry(key, value);
	            if (ES.SameValue(-0, key)) {
	              entry.key = +0; // coerce -0 to +0 in entry
	            }
	            entry.next = this._head;
	            entry.prev = this._head.prev;
	            entry.prev.next = entry;
	            entry.next.prev = entry;
	            this._size += 1;
	            return this;
	          },

	          'delete': function (key) {
	            requireMapSlot(this, 'delete');
	            var head = this._head, i = head;
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              if (typeof this._storage[fkey] === 'undefined') {
	                return false;
	              }
	              i = this._storage[fkey].prev;
	              delete this._storage[fkey];
	              // fall through
	            }
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                i.key = i.value = empty;
	                i.prev.next = i.next;
	                i.next.prev = i.prev;
	                this._size -= 1;
	                return true;
	              }
	            }
	            return false;
	          },

	          clear: function clear() {
	            requireMapSlot(this, 'clear');
	            this._size = 0;
	            this._storage = emptyObject();
	            var head = this._head, i = head, p = i.next;
	            while ((i = p) !== head) {
	              i.key = i.value = empty;
	              p = i.next;
	              i.next = i.prev = head;
	            }
	            head.next = head.prev = head;
	          },

	          keys: function keys() {
	            requireMapSlot(this, 'keys');
	            return new MapIterator(this, 'key');
	          },

	          values: function values() {
	            requireMapSlot(this, 'values');
	            return new MapIterator(this, 'value');
	          },

	          entries: function entries() {
	            requireMapSlot(this, 'entries');
	            return new MapIterator(this, 'key+value');
	          },

	          forEach: function forEach(callback) {
	            requireMapSlot(this, 'forEach');
	            var context = arguments.length > 1 ? arguments[1] : null;
	            var it = this.entries();
	            for (var entry = it.next(); !entry.done; entry = it.next()) {
	              if (context) {
	                _call(callback, context, entry.value[1], entry.value[0], this);
	              } else {
	                callback(entry.value[1], entry.value[0], this);
	              }
	            }
	          }
	        });
	        addIterator(Map$prototype, Map$prototype.entries);

	        return MapShim;
	      }()),

	      Set: (function () {
	        var isSet = function isSet(set) {
	          return set._es6set && typeof set._storage !== 'undefined';
	        };
	        var requireSetSlot = function requireSetSlot(set, method) {
	          if (!ES.TypeIsObject(set) || !isSet(set)) {
	            // https://github.com/paulmillr/es6-shim/issues/176
	            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + String(set));
	          }
	        };

	        // Creating a Map is expensive.  To speed up the common case of
	        // Sets containing only string or numeric keys, we use an object
	        // as backing storage and lazily create a full Map only when
	        // required.
	        var SetShim = function Set() {
	          if (!(this instanceof Set)) {
	            throw new TypeError('Constructor Set requires "new"');
	          }
	          if (this && this._es6set) {
	            throw new TypeError('Bad construction');
	          }
	          var set = emulateES6construct(this, Set, Set$prototype, {
	            _es6set: true,
	            '[[SetData]]': null,
	            _storage: emptyObject()
	          });
	          if (!set._es6set) {
	            throw new TypeError('bad set');
	          }

	          // Optionally initialize Set from iterable
	          if (arguments.length > 0) {
	            addIterableToSet(Set, set, arguments[0]);
	          }
	          return set;
	        };
	        var Set$prototype = SetShim.prototype;

	        // Switch from the object backing storage to a full Map.
	        var ensureMap = function ensureMap(set) {
	          if (!set['[[SetData]]']) {
	            var m = set['[[SetData]]'] = new collectionShims.Map();
	            _forEach(Object.keys(set._storage), function (k) {
	              if (k === '^null') {
	                k = null;
	              } else if (k === '^undefined') {
	                k = void 0;
	              } else {
	                var first = k.charAt(0);
	                if (first === '$') {
	                  k = _strSlice(k, 1);
	                } else if (first === 'n') {
	                  k = +_strSlice(k, 1);
	                } else if (first === 'b') {
	                  k = k === 'btrue';
	                } else {
	                  k = +k;
	                }
	              }
	              m.set(k, k);
	            });
	            set._storage = null; // free old backing storage
	          }
	        };

	        Value.getter(SetShim.prototype, 'size', function () {
	          requireSetSlot(this, 'size');
	          ensureMap(this);
	          return this['[[SetData]]'].size;
	        });

	        defineProperties(SetShim.prototype, {
	          has: function has(key) {
	            requireSetSlot(this, 'has');
	            var fkey;
	            if (this._storage && (fkey = fastkey(key)) !== null) {
	              return !!this._storage[fkey];
	            }
	            ensureMap(this);
	            return this['[[SetData]]'].has(key);
	          },

	          add: function add(key) {
	            requireSetSlot(this, 'add');
	            var fkey;
	            if (this._storage && (fkey = fastkey(key)) !== null) {
	              this._storage[fkey] = true;
	              return this;
	            }
	            ensureMap(this);
	            this['[[SetData]]'].set(key, key);
	            return this;
	          },

	          'delete': function (key) {
	            requireSetSlot(this, 'delete');
	            var fkey;
	            if (this._storage && (fkey = fastkey(key)) !== null) {
	              var hasFKey = _hasOwnProperty(this._storage, fkey);
	              return (delete this._storage[fkey]) && hasFKey;
	            }
	            ensureMap(this);
	            return this['[[SetData]]']['delete'](key);
	          },

	          clear: function clear() {
	            requireSetSlot(this, 'clear');
	            if (this._storage) {
	              this._storage = emptyObject();
	            } else {
	              this['[[SetData]]'].clear();
	            }
	          },

	          values: function values() {
	            requireSetSlot(this, 'values');
	            ensureMap(this);
	            return this['[[SetData]]'].values();
	          },

	          entries: function entries() {
	            requireSetSlot(this, 'entries');
	            ensureMap(this);
	            return this['[[SetData]]'].entries();
	          },

	          forEach: function forEach(callback) {
	            requireSetSlot(this, 'forEach');
	            var context = arguments.length > 1 ? arguments[1] : null;
	            var entireSet = this;
	            ensureMap(entireSet);
	            this['[[SetData]]'].forEach(function (value, key) {
	              if (context) {
	                _call(callback, context, key, key, entireSet);
	              } else {
	                callback(key, key, entireSet);
	              }
	            });
	          }
	        });
	        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
	        addIterator(SetShim.prototype, SetShim.prototype.values);

	        return SetShim;
	      }())
	    };

	    if (globals.Map || globals.Set) {
	      // Safari 8, for example, doesn't accept an iterable.
	      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
	      if (!mapAcceptsArguments) {
	        var OrigMapNoArgs = globals.Map;
	        globals.Map = function Map() {
	          if (!(this instanceof Map)) {
	            throw new TypeError('Constructor Map requires "new"');
	          }
	          var m = new OrigMapNoArgs();
	          if (arguments.length > 0) {
	            addIterableToMap(Map, m, arguments[0]);
	          }
	          Object.setPrototypeOf(m, globals.Map.prototype);
	          defineProperty(m, 'constructor', Map, true);
	          return m;
	        };
	        globals.Map.prototype = create(OrigMapNoArgs.prototype);
	        Value.preserveToString(globals.Map, OrigMapNoArgs);
	      }
	      var testMap = new Map();
	      var mapUsesSameValueZero = (function (m) {
	        m['delete'](0);
	        m['delete'](-0);
	        m.set(0, 3);
	        m.get(-0, 4);
	        return m.get(0) === 3 && m.get(-0) === 4;
	      }(testMap));
	      var mapSupportsChaining = testMap.set(1, 2) === testMap;
	      if (!mapUsesSameValueZero || !mapSupportsChaining) {
	        var origMapSet = Map.prototype.set;
	        overrideNative(Map.prototype, 'set', function set(k, v) {
	          _call(origMapSet, this, k === 0 ? 0 : k, v);
	          return this;
	        });
	      }
	      if (!mapUsesSameValueZero) {
	        var origMapGet = Map.prototype.get;
	        var origMapHas = Map.prototype.has;
	        defineProperties(Map.prototype, {
	          get: function get(k) {
	            return _call(origMapGet, this, k === 0 ? 0 : k);
	          },
	          has: function has(k) {
	            return _call(origMapHas, this, k === 0 ? 0 : k);
	          }
	        }, true);
	        Value.preserveToString(Map.prototype.get, origMapGet);
	        Value.preserveToString(Map.prototype.has, origMapHas);
	      }
	      var testSet = new Set();
	      var setUsesSameValueZero = (function (s) {
	        s['delete'](0);
	        s.add(-0);
	        return !s.has(0);
	      }(testSet));
	      var setSupportsChaining = testSet.add(1) === testSet;
	      if (!setUsesSameValueZero || !setSupportsChaining) {
	        var origSetAdd = Set.prototype.add;
	        Set.prototype.add = function add(v) {
	          _call(origSetAdd, this, v === 0 ? 0 : v);
	          return this;
	        };
	        Value.preserveToString(Set.prototype.add, origSetAdd);
	      }
	      if (!setUsesSameValueZero) {
	        var origSetHas = Set.prototype.has;
	        Set.prototype.has = function has(v) {
	          return _call(origSetHas, this, v === 0 ? 0 : v);
	        };
	        Value.preserveToString(Set.prototype.has, origSetHas);
	        var origSetDel = Set.prototype['delete'];
	        Set.prototype['delete'] = function SetDelete(v) {
	          return _call(origSetDel, this, v === 0 ? 0 : v);
	        };
	        Value.preserveToString(Set.prototype['delete'], origSetDel);
	      }
	      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
	        var m = new M([]);
	        // Firefox 32 is ok with the instantiating the subclass but will
	        // throw when the map is used.
	        m.set(42, 42);
	        return m instanceof M;
	      });
	      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible
	      var mapRequiresNew = (function () {
	        try {
	          return !(globals.Map() instanceof globals.Map);
	        } catch (e) {
	          return e instanceof TypeError;
	        }
	      }());
	      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
	        var OrigMap = globals.Map;
	        globals.Map = function Map() {
	          if (!(this instanceof Map)) {
	            throw new TypeError('Constructor Map requires "new"');
	          }
	          var m = new OrigMap();
	          if (arguments.length > 0) {
	            addIterableToMap(Map, m, arguments[0]);
	          }
	          Object.setPrototypeOf(m, Map.prototype);
	          defineProperty(m, 'constructor', Map, true);
	          return m;
	        };
	        globals.Map.prototype = OrigMap.prototype;
	        Value.preserveToString(globals.Map, OrigMap);
	      }
	      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
	        var s = new S([]);
	        s.add(42, 42);
	        return s instanceof S;
	      });
	      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible
	      var setRequiresNew = (function () {
	        try {
	          return !(globals.Set() instanceof globals.Set);
	        } catch (e) {
	          return e instanceof TypeError;
	        }
	      }());
	      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
	        var OrigSet = globals.Set;
	        globals.Set = function Set() {
	          if (!(this instanceof Set)) {
	            throw new TypeError('Constructor Set requires "new"');
	          }
	          var s = new OrigSet();
	          if (arguments.length > 0) {
	            addIterableToSet(Set, s, arguments[0]);
	          }
	          Object.setPrototypeOf(s, Set.prototype);
	          defineProperty(s, 'constructor', Set, true);
	          return s;
	        };
	        globals.Set.prototype = OrigSet.prototype;
	        Value.preserveToString(globals.Set, OrigSet);
	      }
	      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
	        return (new Map()).keys().next().done;
	      });
	      /*
	        - In Firefox < 23, Map#size is a function.
	        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
	        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
	        - In Firefox 24, Map and Set do not implement forEach
	        - In Firefox 25 at least, Map and Set are callable without "new"
	      */
	      if (
	        typeof globals.Map.prototype.clear !== 'function' ||
	        new globals.Set().size !== 0 ||
	        new globals.Map().size !== 0 ||
	        typeof globals.Map.prototype.keys !== 'function' ||
	        typeof globals.Set.prototype.keys !== 'function' ||
	        typeof globals.Map.prototype.forEach !== 'function' ||
	        typeof globals.Set.prototype.forEach !== 'function' ||
	        isCallableWithoutNew(globals.Map) ||
	        isCallableWithoutNew(globals.Set) ||
	        typeof (new globals.Map().keys().next) !== 'function' || // Safari 8
	        mapIterationThrowsStopIterator || // Firefox 25
	        !mapSupportsSubclassing
	      ) {
	        delete globals.Map; // necessary to overwrite in Safari 8
	        delete globals.Set; // necessary to overwrite in Safari 8
	        defineProperties(globals, {
	          Map: collectionShims.Map,
	          Set: collectionShims.Set
	        }, true);
	      }

	      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
	        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
	        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
	      }

	      // Shim incomplete iterator implementations.
	      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
	      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

	      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
	        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
	        var anonymousSetHas = globals.Set.prototype.has;
	        overrideNative(globals.Set.prototype, 'has', function has(key) {
	          return _call(anonymousSetHas, this, key);
	        });
	      }
	    }
	    defineProperties(globals, collectionShims);
	    addDefaultSpecies(globals.Map);
	    addDefaultSpecies(globals.Set);
	  }

	  // Reflect
	  if (!globals.Reflect) {
	    defineProperty(globals, 'Reflect', {});
	  }
	  var Reflect = globals.Reflect;

	  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
	    if (!ES.TypeIsObject(target)) {
	      throw new TypeError('target must be an object');
	    }
	  };

	  // Some Reflect methods are basically the same as
	  // those on the Object global, except that a TypeError is thrown if
	  // target isn't an object. As well as returning a boolean indicating
	  // the success of the operation.
	  var ReflectShims = {
	    // Apply method in a functional form.
	    apply: function apply() {
	      return _apply(ES.Call, null, arguments);
	    },

	    // New operator in a functional form.
	    construct: function construct(constructor, args) {
	      if (!ES.IsConstructor(constructor)) {
	        throw new TypeError('First argument must be a constructor.');
	      }
	      var newTarget = (arguments.length < 3) ? constructor : arguments[2];
	      if (!ES.IsConstructor(newTarget)) {
	        throw new TypeError('new.target must be a constructor.');
	      }
	      return ES.Construct(constructor, args, newTarget, 'internal');
	    },

	    // When deleting a non-existent or configurable property,
	    // true is returned.
	    // When attempting to delete a non-configurable property,
	    // it will return false.
	    deleteProperty: function deleteProperty(target, key) {
	      throwUnlessTargetIsObject(target);
	      if (supportsDescriptors) {
	        var desc = Object.getOwnPropertyDescriptor(target, key);

	        if (desc && !desc.configurable) {
	          return false;
	        }
	      }

	      // Will return true.
	      return delete target[key];
	    },

	    enumerate: function enumerate(target) {
	      throwUnlessTargetIsObject(target);
	      return new ObjectIterator(target, 'key');
	    },

	    has: function has(target, key) {
	      throwUnlessTargetIsObject(target);
	      return key in target;
	    }
	  };

	  if (Object.getOwnPropertyNames) {
	    Object.assign(ReflectShims, {
	      // Basically the result of calling the internal [[OwnPropertyKeys]].
	      // Concatenating propertyNames and propertySymbols should do the trick.
	      // This should continue to work together with a Symbol shim
	      // which overrides Object.getOwnPropertyNames and implements
	      // Object.getOwnPropertySymbols.
	      ownKeys: function ownKeys(target) {
	        throwUnlessTargetIsObject(target);
	        var keys = Object.getOwnPropertyNames(target);

	        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
	          _pushApply(keys, Object.getOwnPropertySymbols(target));
	        }

	        return keys;
	      }
	    });
	  }

	  var callAndCatchException = function ConvertExceptionToBoolean(func) {
	    return !throwsError(func);
	  };

	  if (Object.preventExtensions) {
	    Object.assign(ReflectShims, {
	      isExtensible: function isExtensible(target) {
	        throwUnlessTargetIsObject(target);
	        return Object.isExtensible(target);
	      },
	      preventExtensions: function preventExtensions(target) {
	        throwUnlessTargetIsObject(target);
	        return callAndCatchException(function () {
	          Object.preventExtensions(target);
	        });
	      }
	    });
	  }

	  if (supportsDescriptors) {
	    var internalGet = function get(target, key, receiver) {
	      var desc = Object.getOwnPropertyDescriptor(target, key);

	      if (!desc) {
	        var parent = Object.getPrototypeOf(target);

	        if (parent === null) {
	          return undefined;
	        }

	        return internalGet(parent, key, receiver);
	      }

	      if ('value' in desc) {
	        return desc.value;
	      }

	      if (desc.get) {
	        return _call(desc.get, receiver);
	      }

	      return undefined;
	    };

	    var internalSet = function set(target, key, value, receiver) {
	      var desc = Object.getOwnPropertyDescriptor(target, key);

	      if (!desc) {
	        var parent = Object.getPrototypeOf(target);

	        if (parent !== null) {
	          return internalSet(parent, key, value, receiver);
	        }

	        desc = {
	          value: void 0,
	          writable: true,
	          enumerable: true,
	          configurable: true
	        };
	      }

	      if ('value' in desc) {
	        if (!desc.writable) {
	          return false;
	        }

	        if (!ES.TypeIsObject(receiver)) {
	          return false;
	        }

	        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

	        if (existingDesc) {
	          return Reflect.defineProperty(receiver, key, {
	            value: value
	          });
	        } else {
	          return Reflect.defineProperty(receiver, key, {
	            value: value,
	            writable: true,
	            enumerable: true,
	            configurable: true
	          });
	        }
	      }

	      if (desc.set) {
	        _call(desc.set, receiver, value);
	        return true;
	      }

	      return false;
	    };

	    Object.assign(ReflectShims, {
	      defineProperty: function defineProperty(target, propertyKey, attributes) {
	        throwUnlessTargetIsObject(target);
	        return callAndCatchException(function () {
	          Object.defineProperty(target, propertyKey, attributes);
	        });
	      },

	      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	        throwUnlessTargetIsObject(target);
	        return Object.getOwnPropertyDescriptor(target, propertyKey);
	      },

	      // Syntax in a functional form.
	      get: function get(target, key) {
	        throwUnlessTargetIsObject(target);
	        var receiver = arguments.length > 2 ? arguments[2] : target;

	        return internalGet(target, key, receiver);
	      },

	      set: function set(target, key, value) {
	        throwUnlessTargetIsObject(target);
	        var receiver = arguments.length > 3 ? arguments[3] : target;

	        return internalSet(target, key, value, receiver);
	      }
	    });
	  }

	  if (Object.getPrototypeOf) {
	    var objectDotGetPrototypeOf = Object.getPrototypeOf;
	    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
	      throwUnlessTargetIsObject(target);
	      return objectDotGetPrototypeOf(target);
	    };
	  }

	  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
	    var willCreateCircularPrototype = function (object, proto) {
	      while (proto) {
	        if (object === proto) {
	          return true;
	        }
	        proto = ReflectShims.getPrototypeOf(proto);
	      }
	      return false;
	    };

	    Object.assign(ReflectShims, {
	      // Sets the prototype of the given object.
	      // Returns true on success, otherwise false.
	      setPrototypeOf: function setPrototypeOf(object, proto) {
	        throwUnlessTargetIsObject(object);
	        if (proto !== null && !ES.TypeIsObject(proto)) {
	          throw new TypeError('proto must be an object or null');
	        }

	        // If they already are the same, we're done.
	        if (proto === Reflect.getPrototypeOf(object)) {
	          return true;
	        }

	        // Cannot alter prototype if object not extensible.
	        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
	          return false;
	        }

	        // Ensure that we do not create a circular prototype chain.
	        if (willCreateCircularPrototype(object, proto)) {
	          return false;
	        }

	        Object.setPrototypeOf(object, proto);

	        return true;
	      }
	    });
	  }
	  var defineOrOverrideReflectProperty = function (key, shim) {
	    if (!ES.IsCallable(globals.Reflect[key])) {
	      defineProperty(globals.Reflect, key, shim);
	    } else {
	      var acceptsPrimitives = valueOrFalseIfThrows(function () {
	        globals.Reflect[key](1);
	        globals.Reflect[key](NaN);
	        globals.Reflect[key](true);
	        return true;
	      });
	      if (acceptsPrimitives) {
	        overrideNative(globals.Reflect, key, shim);
	      }
	    }
	  };
	  Object.keys(ReflectShims).forEach(function (key) {
	    defineOrOverrideReflectProperty(key, ReflectShims[key]);
	  });
	  if (functionsHaveNames && globals.Reflect.getPrototypeOf.name !== 'getPrototypeOf') {
	    var originalReflectGetProto = globals.Reflect.getPrototypeOf;
	    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
	      return _call(originalReflectGetProto, globals.Reflect, target);
	    });
	  }
	  if (globals.Reflect.setPrototypeOf) {
	    if (valueOrFalseIfThrows(function () {
	      globals.Reflect.setPrototypeOf(1, {});
	      return true;
	    })) {
	      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
	    }
	  }
	  if (globals.Reflect.defineProperty) {
	    if (!valueOrFalseIfThrows(function () {
	      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
	      // "extensible" fails on Edge 0.12
	      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
	      return basic && extensible;
	    })) {
	      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
	    }
	  }
	  if (globals.Reflect.construct) {
	    if (!valueOrFalseIfThrows(function () {
	      var F = function F() {};
	      return globals.Reflect.construct(function () {}, [], F) instanceof F;
	    })) {
	      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
	    }
	  }

	  if (String(new Date(NaN)) !== 'Invalid Date') {
	    var dateToString = Date.prototype.toString;
	    var shimmedDateToString = function toString() {
	      var valueOf = +this;
	      if (valueOf !== valueOf) {
	        return 'Invalid Date';
	      }
	      return _call(dateToString, this);
	    };
	    overrideNative(Date.prototype, 'toString', shimmedDateToString);
	  }

	  // Annex B HTML methods
	  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-additional-properties-of-the-string.prototype-object
	  var stringHTMLshims = {
	    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
	    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
	    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
	    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
	    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
	    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
	    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
	    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
	    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
	    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
	    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
	    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
	    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
	  };
	  _forEach(Object.keys(stringHTMLshims), function (key) {
	    var method = String.prototype[key];
	    var shouldOverwrite = false;
	    if (ES.IsCallable(method)) {
	      var output = _call(method, '', ' " ');
	      var quotesCount = _concat([], output.match(/"/g)).length;
	      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
	    } else {
	      shouldOverwrite = true;
	    }
	    if (shouldOverwrite) {
	      overrideNative(String.prototype, key, stringHTMLshims[key]);
	    }
	  });

	  var JSONstringifiesSymbols = (function () {
	    // Microsoft Edge v0.12 stringifies Symbols incorrectly
	    if (!Type.symbol(Symbol.iterator)) { return false; } // Symbols are not supported
	    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
	    if (!stringify) { return false; } // JSON.stringify is not supported
	    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
	    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
	    var obj = { a: Symbol() };
	    obj[Symbol()] = true;
	    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
	    return false;
	  }());
	  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
	    // Chrome 45 throws on stringifying object symbols
	    if (!Type.symbol(Symbol.iterator)) { return true; } // Symbols are not supported
	    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
	  });
	  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
	    var origStringify = JSON.stringify;
	    overrideNative(JSON, 'stringify', function stringify(value) {
	      if (typeof value === 'symbol') { return; }
	      var replacer;
	      if (arguments.length > 1) {
	        replacer = arguments[1];
	      }
	      var args = [value];
	      if (!isArray(replacer)) {
	        var replaceFn = ES.IsCallable(replacer) ? replacer : null;
	        var wrappedReplacer = function (key, val) {
	          var parsedValue = replacer ? _call(replacer, this, key, val) : val;
	          if (typeof parsedValue !== 'symbol') {
	            if (Type.symbol(parsedValue)) {
	              return assignTo({})(parsedValue);
	            } else {
	              return parsedValue;
	            }
	          }
	        };
	        args.push(wrappedReplacer);
	      } else {
	        // create wrapped replacer that handles an array replacer?
	        args.push(replacer);
	      }
	      if (arguments.length > 2) {
	        args.push(arguments[2]);
	      }
	      return origStringify.apply(this, args);
	    });
	  }

	  return globals;
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var define = __webpack_require__(80);
	var ES = __webpack_require__(84);

	var implementation = __webpack_require__(99);
	var getPolyfill = __webpack_require__(100);
	var shim = __webpack_require__(101);

	var slice = Array.prototype.slice;

	/* eslint-disable no-unused-vars */
	var boundIncludesShim = function includes(array, searchElement) {
	/* eslint-enable no-unused-vars */
		ES.RequireObjectCoercible(array);
		return implementation.apply(array, slice.call(arguments, 1));
	};
	define(boundIncludesShim, {
		implementation: implementation,
		getPolyfill: getPolyfill,
		shim: shim
	});

	module.exports = boundIncludesShim;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys = __webpack_require__(81);
	var foreach = __webpack_require__(83);
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	var toStr = Object.prototype.toString;

	var isFunction = function (fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};

	var arePropertyDescriptorsSupported = function () {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        /* eslint-disable no-unused-vars, no-restricted-syntax */
	        for (var _ in obj) { return false; }
	        /* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) { /* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

	var defineProperty = function (object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};

	var defineProperties = function (object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};

	defineProperties.supportsDescriptors = !!supportsDescriptors;

	module.exports = defineProperties;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(82);
	var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
	var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var blacklistedKeys = {
		$console: true,
		$frameElement: true,
		$frames: true,
		$parent: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!blacklistedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	var keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};

	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = (function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2));
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};

	module.exports = keysShim;


/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;

	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' &&
				value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};


/***/ },
/* 83 */
/***/ function(module, exports) {

	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;

	module.exports = function forEach (obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};



/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
	var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

	var $isNaN = Number.isNaN || function (a) { return a !== a; };
	var $isFinite = __webpack_require__(85);
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

	var assign = __webpack_require__(86);
	var sign = __webpack_require__(87);
	var mod = __webpack_require__(88);
	var isPrimitive = __webpack_require__(89);
	var toPrimitive = __webpack_require__(90);
	var parseInteger = parseInt;
	var bind = __webpack_require__(95);
	var strSlice = bind.call(Function.call, String.prototype.slice);
	var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b/i);
	var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o/i);

	var ES5 = __webpack_require__(96);

	var hasRegExpMatcher = __webpack_require__(98);

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
	var ES6 = assign(assign({}, ES5), {

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
		Call: function Call(F, V) {
			var args = arguments.length > 2 ? arguments[2] : [];
			if (!this.IsCallable(F)) {
				throw new TypeError(F + ' is not a function');
			}
			return F.apply(V, args);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
		ToPrimitive: toPrimitive,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
		// ToBoolean: ES5.ToBoolean,

		// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
		ToNumber: function ToNumber(argument) {
			var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
			if (typeof value === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a number');
			}
			if (typeof value === 'string') {
				if (isBinary(value)) {
					return Number(parseInteger(strSlice(value, 2), 2));
				} else if (isOctal(value)) {
					return Number(parseInteger(strSlice(value, 2), 8));
				}
			}
			return Number(value);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
		// ToInteger: ES5.ToNumber,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
		// ToInt32: ES5.ToInt32,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
		// ToUint32: ES5.ToUint32,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
		ToInt16: function ToInt16(argument) {
			var int16bit = this.ToUint16(argument);
			return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
		// ToUint16: ES5.ToUint16,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
		ToInt8: function ToInt8(argument) {
			var int8bit = this.ToUint8(argument);
			return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
		ToUint8: function ToUint8(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x100);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
		ToUint8Clamp: function ToUint8Clamp(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number <= 0) { return 0; }
			if (number >= 0xFF) { return 0xFF; }
			var f = Math.floor(argument);
			if (f + 0.5 < number) { return f + 1; }
			if (number < f + 0.5) { return f; }
			if (f % 2 !== 0) { return f + 1; }
			return f;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
		ToString: function ToString(argument) {
			if (typeof argument === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a string');
			}
			return String(argument);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
		ToObject: function ToObject(value) {
			this.RequireObjectCoercible(value);
			return Object(value);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
		ToPropertyKey: function ToPropertyKey(argument) {
			var key = this.ToPrimitive(argument, String);
			return typeof key === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
		ToLength: function ToLength(argument) {
			var len = this.ToInteger(argument);
			if (len <= 0) { return 0; } // includes converting -0 to +0
			if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
			return len;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-canonicalnumericindexstring
		CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
			if (toStr.call(argument) !== '[object String]') {
				throw new TypeError('must be a string');
			}
			if (argument === '-0') { return -0; }
			var n = this.ToNumber(argument);
			if (this.SameValue(this.ToString(n), argument)) { return n; }
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
		RequireObjectCoercible: ES5.CheckObjectCoercible,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
		IsArray: Array.isArray || function IsArray(argument) {
			return toStr.call(argument) === '[object Array]';
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
		// IsCallable: ES5.IsCallable,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
		IsConstructor: function IsConstructor(argument) {
			return this.IsCallable(argument); // unfortunately there's no way to truly check this without try/catch `new argument`
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
		IsExtensible: function IsExtensible(obj) {
			if (!Object.preventExtensions) { return true; }
			if (isPrimitive(obj)) {
				return false;
			}
			return Object.isExtensible(obj);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
		IsInteger: function IsInteger(argument) {
			if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
				return false;
			}
			var abs = Math.abs(argument);
			return Math.floor(abs) === abs;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
		IsPropertyKey: function IsPropertyKey(argument) {
			return typeof argument === 'string' || typeof argument === 'symbol';
		},

		// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
		IsRegExp: function IsRegExp(argument) {
			if (!argument || typeof argument !== 'object') {
				return false;
			}
			if (hasSymbols) {
				var isRegExp = RegExp[Symbol.match];
				if (typeof isRegExp !== 'undefined') {
					return ES5.ToBoolean(isRegExp);
				}
			}
			return hasRegExpMatcher(argument);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
		// SameValue: ES5.SameValue,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
		SameValueZero: function SameValueZero(x, y) {
			return (x === y) || ($isNaN(x) && $isNaN(y));
		}
	});

	delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

	module.exports = ES6;


/***/ },
/* 85 */
/***/ function(module, exports) {

	var $isNaN = Number.isNaN || function (a) { return a !== a; };

	module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ },
/* 86 */
/***/ function(module, exports) {

	var has = Object.prototype.hasOwnProperty;
	module.exports = Object.assign || function assign(target, source) {
		for (var key in source) {
			if (has.call(source, key)) {
				target[key] = source[key];
			}
		}
		return target;
	};


/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports = function sign(number) {
		return number >= 0 ? 1 : -1;
	};


/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = function mod(number, modulo) {
		var remain = number % modulo;
		return Math.floor(remain >= 0 ? remain : remain + modulo);
	};


/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

	var isPrimitive = __webpack_require__(91);
	var isCallable = __webpack_require__(92);
	var isDate = __webpack_require__(93);
	var isSymbol = __webpack_require__(94);

	var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
		if (O == null) {
			throw new TypeError('Cannot call method on ' + O);
		}
		if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
			throw new TypeError('hint must be "string" or "number"');
		}
		var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
		var method, result, i;
		for (i = 0; i < methodNames.length; ++i) {
			method = O[methodNames[i]];
			if (isCallable(method)) {
				result = method.call(O);
				if (isPrimitive(result)) {
					return result;
				}
			}
		}
		throw new TypeError('No default value');
	};

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		var hint = 'default';
		if (arguments.length > 1) {
			if (PreferredType === String) {
				hint = 'string';
			} else if (PreferredType === Number) {
				hint = 'number';
			}
		}

		var exoticToPrim;
		if (hasSymbols) {
			if (Symbol.toPrimitive) {
				throw new TypeError('Symbol.toPrimitive not supported yet');
				// exoticToPrim = this.GetMethod(input, Symbol.toPrimitive);
			} else if (isSymbol(input)) {
				exoticToPrim = Symbol.prototype.valueOf;
			}
		}
		if (typeof exoticToPrim !== 'undefined') {
			var result = exoticToPrim.call(input, hint);
			if (isPrimitive(result)) {
				return result;
			}
			throw new TypeError('unable to convert exotic object to primitive');
		}
		if (hint === 'default' && (isDate(input) || isSymbol(input))) {
			hint = 'string';
		}
		return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
	};


/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';

	var fnToStr = Function.prototype.toString;
	var tryFunctionObject = function tryFunctionObject(value) {
		try {
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var constructorRegex = /\s*class /;
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (constructorRegex.test(value)) { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ },
/* 93 */
/***/ function(module, exports) {

	'use strict';

	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateObject(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};

	var toStr = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isDateObject(value) {
		if (typeof value !== 'object' || value === null) { return false; }
		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
	};


/***/ },
/* 94 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	if (hasSymbols) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isSymbolObject(value) {
			if (typeof value.valueOf() !== 'symbol') { return false; }
			return symStringRegex.test(symToStr.call(value));
		};
		module.exports = function isSymbol(value) {
			if (typeof value === 'symbol') { return true; }
			if (toStr.call(value) !== '[object Symbol]') { return false; }
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {
		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false;
		};
	}


/***/ },
/* 95 */
/***/ function(module, exports) {

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};



/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $isNaN = Number.isNaN || function (a) { return a !== a; };
	var $isFinite = __webpack_require__(85);

	var sign = __webpack_require__(87);
	var mod = __webpack_require__(88);

	var IsCallable = __webpack_require__(92);
	var toPrimitive = __webpack_require__(97);

	// https://es5.github.io/#x9
	var ES5 = {
		ToPrimitive: toPrimitive,

		ToBoolean: function ToBoolean(value) {
			return Boolean(value);
		},
		ToNumber: function ToNumber(value) {
			return Number(value);
		},
		ToInteger: function ToInteger(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number)) { return 0; }
			if (number === 0 || !$isFinite(number)) { return number; }
			return sign(number) * Math.floor(Math.abs(number));
		},
		ToInt32: function ToInt32(x) {
			return this.ToNumber(x) >> 0;
		},
		ToUint32: function ToUint32(x) {
			return this.ToNumber(x) >>> 0;
		},
		ToUint16: function ToUint16(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x10000);
		},
		ToString: function ToString(value) {
			return String(value);
		},
		ToObject: function ToObject(value) {
			this.CheckObjectCoercible(value);
			return Object(value);
		},
		CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
			/* jshint eqnull:true */
			if (value == null) {
				throw new TypeError(optMessage || 'Cannot call method on ' + value);
			}
			return value;
		},
		IsCallable: IsCallable,
		SameValue: function SameValue(x, y) {
			if (x === y) { // 0 === -0, but they are not identical.
				if (x === 0) { return 1 / x === 1 / y; }
				return true;
			}
	        return $isNaN(x) && $isNaN(y);
		}
	};

	module.exports = ES5;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var toStr = Object.prototype.toString;

	var isPrimitive = __webpack_require__(91);

	var isCallable = __webpack_require__(92);

	// https://es5.github.io/#x8.12
	var ES5internalSlots = {
		'[[DefaultValue]]': function (O, hint) {
			if (!hint) {
				hint = toStr.call(O) === '[object Date]' ? String : Number;
			}

			if (hint === String || hint === Number) {
				var methods = hint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
				var value, i;
				for (i = 0; i < methods.length; ++i) {
					if (isCallable(O[methods[i]])) {
						value = O[methods[i]]();
						if (isPrimitive(value)) {
							return value;
						}
					}
				}
				throw new TypeError('No default value');
			}
			throw new TypeError('invalid [[DefaultValue]] hint supplied');
		}
	};

	// https://es5.github.io/#x9
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		if (arguments.length < 2) {
			PreferredType = toStr.call(input) === '[object Date]' ? String : Number;
		}
		if (PreferredType === String) {
			return String(input);
		} else if (PreferredType === Number) {
			return Number(input);
		} else {
			throw new TypeError('invalid PreferredType supplied');
		}
		return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
	};


/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';

	var regexExec = RegExp.prototype.exec;
	var tryRegexExec = function tryRegexExec(value) {
		try {
			regexExec.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var regexClass = '[object RegExp]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isRegex(value) {
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var ES = __webpack_require__(84);
	var $isNaN = Number.isNaN || function (a) { return a !== a; };
	var $isFinite = Number.isFinite || function (n) { return typeof n === 'number' && global.isFinite(n); };
	var indexOf = Array.prototype.indexOf;

	module.exports = function includes(searchElement) {
		var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;
		if (indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== 'undefined') {
			return indexOf.apply(this, arguments) > -1;
		}

		var O = ES.ToObject(this);
		var length = ES.ToLength(O.length);
		if (length === 0) {
			return false;
		}
		var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);
		while (k < length) {
			if (ES.SameValueZero(searchElement, O[k])) {
				return true;
			}
			k += 1;
		}
		return false;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var implementation = __webpack_require__(99);

	module.exports = function getPolyfill() {
		return Array.prototype.includes || implementation;
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var define = __webpack_require__(80);
	var getPolyfill = __webpack_require__(100);

	module.exports = function shimArrayPrototypeIncludes() {
		var polyfill = getPolyfill();
		if (Array.prototype.includes !== polyfill) {
			define(Array.prototype, { includes: polyfill });
		}
		return polyfill;
	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12),
	  __ = __webpack_require__(115),
	  sum = __.sum,
	  fma = __.fma,
	  constrain = __.constrain,
	  int16 = __.int16;

	var priv = new Map();
	var rad2deg = 180 / Math.PI;
	var calibrationSize = 10;
	var axes = ["x", "y", "z"];

	function analogInitialize(opts, dataHandler) {
	  var pins = opts.pins || [],
	    state = priv.get(this),
	    dataPoints = {};

	  state.zeroV = opts.zeroV || this.DEFAULTS.zeroV;
	  state.sensitivity = opts.sensitivity || this.DEFAULTS.sensitivity;

	  pins.forEach(function(pin, index) {
	    this.io.pinMode(pin, this.io.MODES.ANALOG);
	    this.io.analogRead(pin, function(data) {
	      var axis = axes[index];
	      dataPoints[axis] = data;
	      dataHandler(dataPoints);
	    }.bind(this));
	  }, this);
	}

	function analogToGravity(raw, axis) {
	  var state = priv.get(this);
	  var zeroV = state.zeroV;

	  if (Array.isArray(zeroV) && zeroV.length > 0) {
	    var axisIndex = axes.indexOf(axis);
	    zeroV = zeroV[axisIndex || 0];
	  }

	  return (raw - zeroV) / state.sensitivity;
	}

	var Controllers = {
	  ANALOG: {
	    DEFAULTS: {
	      value: {
	        zeroV: 478,
	        sensitivity: 96
	      }
	    },
	    initialize: {
	      value: analogInitialize
	    },
	    toGravity: {
	      value: analogToGravity
	    }
	  },
	  // http://www.invensense.com/mems/gyro/mpu6050.html
	  MPU6050: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var IMU = __webpack_require__(123);
	        var driver = IMU.Drivers.get(this.board, "MPU6050", opts);
	        var state = priv.get(this);

	        state.sensitivity = opts.sensitivity || 16384;

	        driver.on("data", function(data) {
	          dataHandler(data.accelerometer);
	        });
	      }
	    },
	    toGravity: {
	      value: function(raw) {
	        var state = priv.get(this);
	        return raw / state.sensitivity;
	      }
	    }
	  },
	  ADXL335: {
	    DEFAULTS: {
	      value: {
	        zeroV: 330,
	        sensitivity: 66.5
	      }
	    },
	    initialize: {
	      value: analogInitialize
	    },
	    toGravity: {
	      value: analogToGravity
	    }
	  },
	  ADXL345: {
	    // http://www.analog.com/en/mems-sensors/mems-inertial-sensors/adxl345/products/product.html
	    // http://www.i2cdevlib.com/devices/adxl345#source

	    ADDRESSES: {
	      value: [0x53]
	    },
	    REGISTER: {
	      value: {
	        POWER: 0x2D,
	        RANGE: 0x31,
	        READREGISTER: 0x32
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var READLENGTH = 6;
	        var address = opts.address || this.ADDRESSES[0];
	        var state = priv.get(this);

	        // Sensitivity:
	        //
	        // (ADXL345_MG2G_MULTIPLIER * SENSORS_GRAVITY_STANDARD) = (0.004 * 9.80665) = 0.0390625
	        //
	        // Reference:
	        // https://github.com/adafruit/Adafruit_Sensor/blob/master/Adafruit_Sensor.h#L34-L37
	        // https://github.com/adafruit/Adafruit_ADXL345/blob/master/Adafruit_ADXL345_U.h#L73
	        // https://github.com/adafruit/Adafruit_ADXL345/blob/master/Adafruit_ADXL345_U.cpp#L298-L309
	        //
	        // Invert for parity with other controllers
	        //
	        // (1 / 0.0390625) * (1 / 9.8)
	        //
	        // OR
	        //
	        // (1 / ADXL345_MG2G_MULTIPLIER) = (1 / 0.004)
	        //
	        // OR
	        //
	        // 250
	        //
	        state.sensitivity = opts.sensitivity || 250;

	        this.io.i2cConfig(opts);

	        // Standby mode
	        this.io.i2cWrite(address, this.REGISTER.POWER, 0);

	        // Enable measurements
	        this.io.i2cWrite(address, this.REGISTER.POWER, 8);

	        // Set range (this is 2G range, should be user defined?)
	        this.io.i2cWrite(address, this.REGISTER.RANGE, 8);

	        this.io.i2cRead(address, this.REGISTER.READREGISTER, READLENGTH, function(data) {
	          dataHandler.call(this, {
	            x: int16(data[1], data[0]),
	            y: int16(data[3], data[2]),
	            z: int16(data[5], data[4])
	          });
	        }.bind(this));
	      },
	    },
	    toGravity: {
	      value: function(raw) {
	        var state = priv.get(this);
	        return raw / state.sensitivity;
	      }
	    }
	  },
	  MMA7361: {
	    DEFAULTS: {
	      value: {
	        zeroV: [336, 372, 287],
	        sensitivity: 170
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        if (opts.sleepPin !== undefined) {
	          state.sleepPin = opts.sleepPin;
	          this.board.pinMode(state.sleepPin, 1);
	          this.board.digitalWrite(state.sleepPin, 1);
	        }

	        analogInitialize.call(this, opts, dataHandler);
	      }
	    },
	    toGravity: {
	      value: analogToGravity
	    },
	    enabledChanged: {
	      value: function(value) {
	        var state = priv.get(this);

	        if (state.sleepPin !== undefined) {
	          this.board.digitalWrite(state.sleepPin, value ? 1 : 0);
	        }
	      }
	    }
	  },
	  MMA7660: {
	    ADDRESSES: {
	      value: [0x4C]
	    },
	    REGISTER: {
	      value: {
	        READREGISTER: 0x00,
	        RATE: 0x08,
	        MODE: 0x07,
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var READLENGTH = 3;
	        var address = opts.address || this.ADDRESSES[0];
	        var state = priv.get(this);

	        state.sensitivity = 21.33;

	        this.io.i2cConfig(opts);

	        // http://www.freescale.com.cn/files/sensors/doc/data_sheet/MMA7660FC.pdf?fpsp=1
	        //
	        // Standby mode
	        this.io.i2cWrite(address, this.REGISTER.MODE, 0x00);

	        // Sample Rate ()
	        this.io.i2cWrite(address, this.REGISTER.RATE, 0x07);

	        // Active Mode
	        this.io.i2cWrite(address, this.REGISTER.MODE, 0x01);

	        this.io.i2cRead(address, this.REGISTER.READREGISTER, READLENGTH, function(data) {
	          dataHandler.call(this, {
	            // Shift off the sign bits
	            // This solution is used in
	            // https://github.com/intel-iot-devkit/upm/blob/master/src/mma7660/mma7660.cxx
	            x: (data[0] << 2) / 4,
	            y: (data[1] << 2) / 4,
	            z: (data[2] << 2) / 4,
	          });
	        }.bind(this));
	      },
	    },
	    toGravity: {
	      value: function(raw) {
	        var state = priv.get(this);
	        return raw / state.sensitivity;
	      }
	    }
	  },
	  ESPLORA: {
	    DEFAULTS: {
	      value: {
	        zeroV: [320, 330, 310],
	        sensitivity: 170
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        opts.pins = [5, 11, 6];
	        analogInitialize.call(this, opts, dataHandler);
	      }
	    },
	    toGravity: {
	      value: analogToGravity
	    }
	  }
	};

	// Otherwise known as...
	Controllers["MPU-6050"] = Controllers.MPU6050;
	Controllers["TINKERKIT"] = Controllers.ANALOG;

	function ToPrecision(val, precision) {
	  return +(val).toPrecision(precision);
	}

	function magnitude(x, y, z) {
	  var a;

	  a = x * x;
	  a = fma(y, y, a);
	  a = fma(z, z, a);

	  return Math.sqrt(a);
	}

	/**
	 * Accelerometer
	 * @constructor
	 *
	 * five.Accelerometer([ x, y[, z] ]);
	 *
	 * five.Accelerometer({
	 *   pins: [ x, y[, z] ]
	 *   zeroV: ...
	 *   sensitivity: ...
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Accelerometer(opts) {
	  if (!(this instanceof Accelerometer)) {
	    return new Accelerometer(opts);
	  }

	  var controller = null;

	  var state = {
	    enabled: true,
	    x: {
	      value: 0,
	      previous: 0,
	      stash: [],
	      orientation: null,
	      inclination: null,
	      acceleration: null,
	      calibration: []
	    },
	    y: {
	      value: 0,
	      previous: 0,
	      stash: [],
	      orientation: null,
	      inclination: null,
	      acceleration: null,
	      calibration: []
	    },
	    z: {
	      value: 0,
	      previous: 0,
	      stash: [],
	      orientation: null,
	      inclination: null,
	      acceleration: null,
	      calibration: []
	    }
	  };

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["ANALOG"];
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toGravity) {
	    this.toGravity = opts.toGravity || function(raw) { return raw; };
	  }

	  if (!this.enabledChanged) {
	    this.enabledChanged = function() {};
	  }

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      var isChange = false;

	      if (!state.enabled) {
	        return;
	      }

	      Object.keys(data).forEach(function(axis) {
	        var value = data[axis];
	        var sensor = state[axis];

	        if (opts.autoCalibrate && sensor.calibration.length < calibrationSize) {
	          var axisIndex = axes.indexOf(axis);
	          sensor.calibration.push(value);

	          if (!Array.isArray(state.zeroV)) {
	            state.zeroV = [];
	          }

	          state.zeroV[axisIndex] = __.sum(sensor.calibration) / sensor.calibration.length;
	          if (axis === "z") {
	            state.zeroV[axisIndex] -= state.sensitivity;
	          }
	        }

	        // The first run needs to prime the "stash"
	        // of data values.
	        if (sensor.stash.length === 0) {
	          for (var i = 0; i < 5; i++) {
	            sensor.stash[i] = value;
	          }
	        }

	        sensor.previous = sensor.value;
	        sensor.stash.shift();
	        sensor.stash.push(value);

	        sensor.value = (sum(sensor.stash) / 5) | 0;

	        if (this.acceleration !== sensor.acceleration) {
	          sensor.acceleration = this.acceleration;
	          isChange = true;
	          this.emit("acceleration", sensor.acceleration);
	        }

	        if (this.orientation !== sensor.orientation) {
	          sensor.orientation = this.orientation;
	          isChange = true;
	          this.emit("orientation", sensor.orientation);
	        }

	        if (this.inclination !== sensor.inclination) {
	          sensor.inclination = this.inclination;
	          isChange = true;
	          this.emit("inclination", sensor.inclination);
	        }
	      }, this);

	      this.emit("data", {
	        x: state.x.value,
	        y: state.y.value,
	        z: state.z.value
	      });

	      if (isChange) {
	        this.emit("change", {
	          x: this.x,
	          y: this.y,
	          z: this.z
	        });
	      }
	    }.bind(this));
	  }

	  Object.defineProperties(this, {
	    hasAxis: {
	      value: function(axis) {
	        return state[axis] ? state[axis].stash.length > 0 : false;
	      }
	    },
	    enable: {
	      value: function() {
	        state.enabled = true;
	        this.enabledChanged(true);
	        return this;
	      }
	    },
	    disable: {
	      value: function() {
	        state.enabled = false;
	        this.enabledChanged(false);
	        return this;
	      }
	    },
	    zeroV: {
	      get: function() {
	        return state.zeroV;
	      }
	    },
	    /**
	     * [read-only] Calculated pitch value
	     * @property pitch
	     * @type Number
	     */
	    pitch: {
	      get: function() {
	        var x, y, z, rads;

	        x = this.x;
	        y = this.y;
	        z = this.z;


	        rads = this.hasAxis("z") ?
	          Math.atan2(x, Math.hypot(y, z)) :
	          Math.asin(constrain(x, -1, 1));

	        return ToPrecision(rads * rad2deg, 2);
	      }
	    },
	    /**
	     * [read-only] Calculated roll value
	     * @property roll
	     * @type Number
	     */
	    roll: {
	      get: function() {
	        var x, y, z, rads;

	        x = this.x;
	        y = this.y;
	        z = this.z;

	        rads = this.hasAxis("z") ?
	          Math.atan2(y, Math.hypot(x, z)) :
	          Math.asin(constrain(y, -1, 1));

	        return ToPrecision(rads * rad2deg, 2);
	      }
	    },
	    x: {
	      get: function() {
	        return ToPrecision(this.toGravity(state.x.value, "x"), 2);
	      }
	    },
	    y: {
	      get: function() {
	        return ToPrecision(this.toGravity(state.y.value, "y"), 2);
	      }
	    },
	    z: {
	      get: function() {
	        return this.hasAxis("z") ?
	          ToPrecision(this.toGravity(state.z.value, "z"), 2) : 0;
	      }
	    },
	    acceleration: {
	      get: function() {
	        return magnitude(
	          this.x,
	          this.y,
	          this.z
	        );
	      }
	    },
	    inclination: {
	      get: function() {
	        return Math.atan2(this.y, this.x) * rad2deg;
	      }
	    },
	    orientation: {
	      get: function() {
	        var abs = Math.abs;
	        var x = this.x;
	        var y = this.y;
	        var z = this.hasAxis(z) ? this.z : 1;
	        var xAbs = abs(x);
	        var yAbs = abs(y);
	        var zAbs = abs(z);

	        if (xAbs < yAbs && xAbs < zAbs) {
	          if (x > 0) {
	            return 1;
	          }
	          return -1;
	        }
	        if (yAbs < xAbs && yAbs < zAbs) {
	          if (y > 0) {
	            return 2;
	          }
	          return -2;
	        }
	        if (zAbs < xAbs && zAbs < yAbs) {
	          if (z > 0) {
	            return 3;
	          }
	          return -3;
	        }
	        return 0;
	      }
	    }
	  });
	}


	util.inherits(Accelerometer, events.EventEmitter);

	module.exports = Accelerometer;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {__webpack_require__(78);
	__webpack_require__(79).shim();

	var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	// var os = require("os");
	var chalk = __webpack_require__(104);
	var _ = __webpack_require__(113);
	var Collection = __webpack_require__(114);
	var __ = __webpack_require__(115);
	var Repl = __webpack_require__(116);
	var Options = __webpack_require__(118);
	var Pins = __webpack_require__(119);
	//var temporal = require("temporal");
	//var IO;

	// Environment Setup
	var boards = [];
	var rport = /usb|acm|^com/i;

	// TODO:
	//
	//    At some point we should figure out a way to
	//    make execution-on-board environments uniformally
	//    detected and reported.
	//
	// var isGalileo = (function() {
	//   var release = os.release();
	//   return release.includes("yocto") ||
	//     release.includes("edison");
	// })();
	// var isOnBoard = isGalileo;

	// if (isOnBoard) {
	//   if (isGalileo) {
	//     IO = require("galileo-io");
	//   }
	// }

	/**
	 * Process Codes
	 * SIGHUP        1       Term    Hangup detected on controlling terminal
	                              or death of controlling process
	 * SIGINT        2       Term    Interrupt from keyboard
	 * SIGQUIT       3       Core    Quit from keyboard
	 * SIGILL        4       Core    Illegal Instruction
	 * SIGABRT       6       Core    Abort signal from abort(3)
	 * SIGFPE        8       Core    Floating point exception
	 * SIGKILL       9       Term    Kill signal
	 * SIGSEGV      11       Core    Invalid memory reference
	 * SIGPIPE      13       Term    Broken pipe: write to pipe with no readers
	 * SIGALRM      14       Term    Timer signal from alarm(2)
	 * SIGTERM      15       Term    Termination signal
	 *
	 *
	 *
	 * http://www.slac.stanford.edu/BFROOT/www/Computing/Environment/Tools/Batch/exitcode.html
	 *
	 */

	var Serial = {

	  used: [],
	  attempts: [],

	  detect: function(callback) {
	    var serialport = IS_TEST_MODE ?
	      __webpack_require__(120) :
	      __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"serialport\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	    // Request a list of available ports, from
	    // the result set, filter for valid paths
	    // via known path pattern match.
	    serialport.list(function(err, result) {

	      // serialport.list() will never result in an error.
	      // On failure, an empty array is returned. (#768)

	      var ports,
	        length;

	      ports = result.filter(function(val) {
	        var available = true;

	        // Match only ports that Arduino cares about
	        // ttyUSB#, cu.usbmodem#, COM#
	        if (!rport.test(val.comName)) {
	          available = false;
	        }

	        // Don't allow already used/encountered usb device paths
	        if (Serial.used.includes(val.comName)) {
	          available = false;
	        }

	        return available;
	      }).map(function(val) {
	        return val.comName;
	      });

	      length = ports.length;

	      // If no ports are detected...
	      if (!length) {

	        if (IS_TEST_MODE && this.abort) {
	          return;
	        }

	        // Create an attempt counter
	        if (!Serial.attempts[Serial.used.length]) {
	          Serial.attempts[Serial.used.length] = 0;

	          // Log notification...
	          this.info("Board", "Looking for connected device");
	        }

	        // Set the attempt number
	        Serial.attempts[Serial.used.length]++;

	        // Retry Serial connection
	        Serial.detect.call(this, callback);

	        return;
	      }

	      this.info(
	        "Device(s)",
	        chalk.grey(ports)
	      );

	      // Get the first available device path from the list of
	      // detected ports
	      callback.call(this, ports[0]);
	    }.bind(this));
	  },

	  connect: function(portOrPath, callback) {
	    var IO = IS_TEST_MODE ?
	      __webpack_require__(121) :
	      __webpack_require__(17).Board;

	    var err, io, isConnected, path, type;

	    if (typeof portOrPath === "object" && portOrPath.path) {
	      //
	      // Board({ port: SerialPort Object })
	      //
	      path = portOrPath.path;

	      this.info(
	        (portOrPath.transport || "SerialPort"),
	        chalk.grey(path)
	      );
	    } else {
	      //
	      // Board({ port: path String })
	      //
	      // Board()
	      //    ie. auto-detected
	      //
	      path = portOrPath;
	    }

	    // Add the usb device path to the list of device paths that
	    // are currently in use - this is used by the filter function
	    // above to remove any device paths that we've already encountered
	    // or used to avoid blindly attempting to reconnect on them.
	    Serial.used.push(path);

	    try {
	      io = new IO(portOrPath, function(error) {
	        if (error !== undefined) {
	          err = error;
	        }

	        callback.call(this, err, err ? "error" : "ready", io);
	      }.bind(this));

	      // Extend io instance with special expandos used
	      // by Johny-Five for the IO Plugin system.
	      io.name = "Firmata";
	      io.defaultLed = 13;
	      io.port = path;

	      // Made this far, safely connected
	      isConnected = true;
	    } catch (error) {
	      err = error;
	    }

	    if (err) {
	      err = err.message || err;
	    }

	    // Determine the type of event that will be passed on to
	    // the board emitter in the callback passed to Serial.detect(...)
	    type = isConnected ? "connect" : "error";

	    // Execute "connect" callback
	    callback.call(this, err, type, io);
	  }
	};

	/**
	 * Board
	 * @constructor
	 *
	 * @param {Object} opts
	 */

	function Board(opts) {

	  if (!(this instanceof Board)) {
	    return new Board(opts);
	  }

	  // Ensure opts is an object
	  opts = opts || {};
	  opts.io = opts.io || global.io;

	  // Used to define the board instance's own
	  // properties in the REPL's scope.
	  var replContext = {};

	  // It's feasible that an IO-Plugin may emit
	  // "connect" and "ready" events out of order.
	  // This is used to enforce the order, by
	  // postponing the "ready" event if the IO-Plugin
	  // hasn't emitted a "connect" event. Once
	  // the "connect" event is emitted, the
	  // postponement is lifted and the board may
	  // proceed with emitting the events in the
	  // correct order.
	  var isPostponed = false;

	  // Initialize this Board instance with
	  // param specified properties.
	  _.assign(this, opts);

	  this.timer = null;

	  this.isConnected = false;

	  // Easily track state of hardware
	  this.isReady = false;

	  // Initialize instance property to reference io board
	  this.io = this.io || null;

	  // Registry of components
	  this.register = [];

	  // Pins, Addr (alt Pin name), Addresses
	  this.occupied = [];

	  // Registry of drivers by address (i.e. I2C Controllers)
	  this.Drivers = {};

	  // Identify for connect hardware cache
	  if (!this.id) {
	    this.id = __.uid();
	  }

	  // If no debug flag, default to true
	  if (typeof this.debug === "undefined") {
	    this.debug = true;
	  }

	  // If no repl flag, default to true
	  if (typeof this.repl === "undefined") {
	    this.repl = true;
	  }

	  // If no sigint flag, default to true
	  if (typeof this.sigint === "undefined") {
	    this.sigint = true;
	  }

	  // Specially processed pin capabilities object
	  // assigned when physical board has reported
	  // "ready" via Firmata or IO-Plugin.
	  this.pins = null;

	  // Create a Repl instance and store as
	  // instance property of this io/board.
	  // This will reduce the amount of boilerplate
	  // code required to _always_ have a Repl
	  // session available.
	  //
	  // If a sesssion exists, use it
	  // (instead of creating a new session)
	  //
	  if (this.repl) {
	    if (Repl.ref) {

	      replContext[this.id] = this;

	      Repl.ref.on("ready", function() {
	        Repl.ref.inject(replContext);
	      });

	      this.repl = Repl.ref;
	    } else {
	      replContext[this.id] = replContext.board = this;
	      this.repl = new Repl(replContext);
	    }
	  }

	  if (opts.io) {
	    // If you already have a connected io instance
	    this.io = opts.io;
	    this.isReady = opts.io.isReady;
	    this.transport = this.io.transport || null;
	    this.port = this.io.name;
	    this.pins = Board.Pins(this);
	  } else {

	    // if (isOnBoard) {
	    //   this.io = new IO();
	    //   this.port = this.io.name;
	    // } else {
	      if (this.port && opts.port) {
	        Serial.connect.call(this, this.port, broadcast);
	      } else {
	        // TODO: refactor to do the path lookups
	        // as soon as this file is required.
	        Serial.detect.call(this, function(path) {
	          Serial.connect.call(this, path, broadcast);
	        });
	      }
	    // }
	  }

	  // Either an IO instance was provided or isOnBoard is true
	  if (!opts.port && this.io !== null) {
	    this.info(
	      "Device(s)", chalk.grey(this.io.name || "unknown")
	    );

	    ["connect", "ready"].forEach(function(type) {
	      this.io.once(type, function() {
	        // Since connection and readiness happen asynchronously,
	        // it's actually possible for Johnny-Five to receive the
	        // events out of order and that should be ok.
	        if (type === "ready" && !this.isConnected) {
	          isPostponed = true;
	        } else {
	          // Will emit the "connect" and "ready" events
	          // if received in order. If out of order, this
	          // will only emit the "connect" event. The
	          // "ready" event will be handled in the next
	          // condition's consequent.
	          broadcast.call(this, null, type, this.io);
	        }

	        if (type === "connect" && isPostponed) {
	          broadcast.call(this, null, "ready", this.io);
	        }
	      }.bind(this));

	      if (this.io.isReady) {
	        // If the IO instance is reached "ready"
	        // state, queue tick tasks to emit the
	        // "connect" and "ready" events

	        process.nextTick(function() {
	          this.io.emit(type);
	        }.bind(this));
	      }
	    }, this);

	    // Bubble "string" events from IO layer
	    this.io.on("string", function(data) {
	      this.emit("string", data);
	    }.bind(this));
	  }

	  // Cache instance to allow access from module constructors
	  boards.push(this);
	}

	function broadcast(err, type, io) {
	  // Assign found io to instance
	  if (!this.io) {
	    this.io = io;
	  }

	  if (type === "error") {
	    if (err && err.message) {
	      console.log(err.message.red);
	    }
	  }

	  if (type === "connect") {
	    this.isConnected = true;
	    this.port = io.port || io.name;

	    this.info(
	      "Connected",
	      chalk.grey(this.port)
	    );

	    // 10 Second timeout...
	    //
	    // If "ready" hasn't fired and cleared the timer within
	    // 10 seconds of the connect event, then it's likely
	    // there is an issue with the device or firmware.
	    if (!IS_TEST_MODE) {
	      this.timer = setTimeout(function() {
	        this.error(
	          "Device or Firmware Error",
	          "A timeout occurred while connecting to the Board. \n\n" +
	          "Please check that you've properly flashed the board with the correct firmware.\n" +
	          "See: https://github.com/rwaldron/johnny-five/wiki/Getting-Started#trouble-shooting"
	        );

	        this.emit("error", new Error("A timeout occurred while connecting to the Board."));
	      }.bind(this), 3e4);
	    }
	  }

	  if (type === "ready") {
	    if (this.timer) {
	      clearTimeout(this.timer);
	    }

	    // Update instance `ready` flag
	    this.isReady = true;
	    this.pins = Board.Pins(this);
	    this.MODES = this.io.MODES;

	    // In multi-board mode, block the REPL from
	    // activation. This will be started directly
	    // by the Board.Array constructor.
	    //
	    // In single-board mode, the REPL will not
	    // be blocked at all.
	    //
	    // If the user program has not disabled the
	    // REPL, initialize it.
	    if (this.repl) {
	      this.repl.initialize(this.emit.bind(this, "ready"));
	    }

	    if (io.name !== "Mock" && this.sigint) {
	      process.on("SIGINT", function() {
	        this.warn("Board", "Closing.");
	        process.exit(0);
	      }.bind(this));
	    }

	    // Bubble "string" events from IO layer
	    io.on("string", function(data) {
	      this.emit("string", data);
	    }.bind(this));
	  }

	  // If there is a REPL...
	  if (this.repl) {
	    // "ready" will be emitted once repl.initialize
	    // is complete, so the only event that needs to
	    // be propagated here is the "connect" event.
	    if (type === "connect") {
	      this.emit(type, err);
	    }
	  } else {
	    // The REPL is disabled, propagate all events
	    this.emit(type, err);
	  }
	}

	// Inherit event api
	util.inherits(Board, Emitter);



	/**
	 * Pass through methods
	 */
	[
	  "digitalWrite", "analogWrite", "servoWrite", "sendI2CWriteRequest",
	  "analogRead", "digitalRead", "sendI2CReadRequest",
	  "pinMode", "queryPinState", "sendI2CConfig",
	  "stepperStep", "stepperConfig", "servoConfig",
	  "i2cConfig", "i2cWrite", "i2cWriteReg", "i2cRead", "i2cReadOnce",
	].forEach(function(method) {
	  Board.prototype[method] = function() {
	    this.io[method].apply(this.io, arguments);
	    return this;
	  };
	});

	Board.prototype.serialize = function(filter) {
	  var blacklist = this.serialize.blacklist;
	  var special = this.serialize.special;

	  return JSON.stringify(
	    this.register.map(function(device) {
	      return Object.getOwnPropertyNames(device).reduce(function(data, prop) {
	        var value = device[prop];

	        if (!blacklist.includes(prop) &&
	            typeof value !== "function") {

	          data[prop] = special[prop] ?
	            special[prop](value) : value;

	          if (filter) {
	            data[prop] = filter(prop, data[prop], device);
	          }
	        }
	        return data;
	      }, {});
	    }, this)
	  );
	};

	Board.prototype.serialize.blacklist = [
	  "board", "io", "_events"
	];

	Board.prototype.samplingInterval = function(ms) {

	  if (this.io.setSamplingInterval) {
	    this.io.setSamplingInterval(ms);
	  } else {
	    console.log("This IO plugin does not implement an interval adjustment method");
	  }
	  return this;
	};


	Board.prototype.serialize.special = {
	  mode: function(value) {
	    return ["INPUT", "OUTPUT", "ANALOG", "PWM", "SERVO"][value] || "unknown";
	  }
	};

	/**
	 *  shiftOut
	 *
	 */
	Board.prototype.shiftOut = function(dataPin, clockPin, isBigEndian, value) {
	  var mask, write;

	  write = function(value, mask) {
	    this.digitalWrite(clockPin, this.io.LOW);
	    this.digitalWrite(
	      dataPin, this.io[value & mask ? "HIGH" : "LOW"]
	    );
	    this.digitalWrite(clockPin, this.io.HIGH);
	  }.bind(this);

	  if (arguments.length === 3) {
	    value = arguments[2];
	    isBigEndian = true;
	  }

	  if (isBigEndian) {
	    for (mask = 128; mask > 0; mask = mask >> 1) {
	      write(value, mask);
	    }
	  } else {
	    for (mask = 0; mask < 128; mask = mask << 1) {
	      write(value, mask);
	    }
	  }
	};

	var logging = {
	  specials: [
	    "error",
	    "fail",
	    "warn",
	    "info",
	  ],
	  colors: {
	    log: "white",
	    error: "red",
	    fail: "inverse",
	    warn: "yellow",
	    info: "cyan"
	  }
	};

	Board.prototype.log = function( /* type, klass, message [, long description] */ ) {
	  var args = [].slice.call(arguments);

	  // If this was a direct call to `log(...)`, make sure
	  // there is a correct "type" to emit below.
	  if (!logging.specials.includes(args[0])) {
	    args.unshift("log");
	  }

	  var type = args.shift();
	  var klass = args.shift();
	  var message = args.shift();
	  var color = logging.colors[type];
	  var now = Date.now();
	  var event = {
	    type: type,
	    timestamp: now,
	    class: klass,
	    message: "",
	    data: null,
	  };

	  if (typeof args[args.length - 1] === "object") {
	    event.data = args.pop();
	  }

	  message += " " + args.join(", ");
	  event.message = message.trim();

	  if (this.debug) {
	    console.log([
	      // Timestamp
	      chalk.grey(now),
	      // Module, color matches type of log
	      chalk.magenta(klass),
	      // Details
	      chalk[color](message),
	      // Miscellaneous args
	      args.join(", ")
	    ].join(" "));
	  }

	  this.emit(type, event);
	  this.emit("message", event);
	};


	// Make shortcuts to all logging methods
	logging.specials.forEach(function(type) {
	  Board.prototype[type] = function() {
	    var args = [].slice.call(arguments);
	    args.unshift(type);

	    this.log.apply(this, args);
	  };
	});


	/**
	 * delay, loop, queue
	 *
	 * Pass through methods to temporal
	 */
	/*
	[
	  "delay", "loop", "queue"
	].forEach(function( method ) {
	  Board.prototype[ method ] = function( time, callback ) {
	    temporal[ method ]( time, callback );
	    return this;
	  };
	});

	// Alias wait to delay to match existing Johnny-five API
	Board.prototype.wait = Board.prototype.delay;
	*/

	// -----THIS IS A TEMPORARY FIX UNTIL THE ISSUES WITH TEMPORAL ARE RESOLVED-----
	// Aliasing.
	// (temporary, while ironing out API details)
	// The idea is to match existing hardware programming apis
	// or simply find the words that are most intuitive.

	// Eventually, there should be a queuing process
	// for all new callbacks added
	//
	// TODO: Repalce with temporal or compulsive API

	Board.prototype.wait = function(time, callback) {
	  setTimeout(callback.bind(this), time);
	  return this;
	};

	Board.prototype.loop = function(time, callback) {
	  setInterval(callback.bind(this), time);
	  return this;
	};

	// ----------
	// Static API
	// ----------

	// Board.map( val, fromLow, fromHigh, toLow, toHigh )
	//
	// Re-maps a number from one range to another.
	// Based on arduino map()
	Board.map = __.map;
	Board.fmap = __.fmap;

	// Board.constrain( val, lower, upper )
	//
	// Constrains a number to be within a range.
	// Based on arduino constrain()
	Board.constrain = __.constrain;

	// Board.range( upper )
	// Board.range( lower, upper )
	// Board.range( lower, upper, tick )
	//
	// Returns a new array range
	//
	Board.range = __.range;

	// Board.range.prefixed( prefix, upper )
	// Board.range.prefixed( prefix, lower, upper )
	// Board.range.prefixed( prefix, lower, upper, tick )
	//
	// Returns a new array range, each value prefixed
	//
	Board.range.prefixed = __.range.prefixed;

	// Board.uid()
	//
	// Returns a reasonably unique id string
	//
	Board.uid = __.uid;

	// Board.mount()
	// Board.mount( index )
	// Board.mount( object )
	//
	// Return hardware instance, based on type of param:
	// @param {arg}
	//   object, user specified
	//   number/index, specified in cache
	//   none, defaults to first in cache
	//
	// Notes:
	// Used to reduce the amount of boilerplate
	// code required in any given module or program, by
	// giving the developer the option of omitting an
	// explicit Board reference in a module
	// constructor's options
	Board.mount = function(arg) {
	  var index = typeof arg === "number" && arg,
	    hardware;

	  // board was explicitly provided
	  if (arg && arg.board) {
	    return arg.board;
	  }

	  // index specified, attempt to return
	  // hardware instance. Return null if not
	  // found or not available
	  if (index) {
	    hardware = boards[index];
	    return hardware && hardware || null;
	  }

	  // If no arg specified and hardware instances
	  // exist in the cache
	  if (boards.length) {
	    return boards[0];
	  }

	  // No mountable hardware
	  return null;
	};



	/**
	 * Board.Component
	 *
	 * Initialize a new device instance
	 *
	 * Board.Component is a |this| sensitive constructor,
	 * and must be called as:
	 *
	 * Board.Component.call( this, opts );
	 *
	 *
	 *
	 * TODO: Migrate all constructors to use this
	 *       to avoid boilerplate
	 */

	Board.Component = function(opts, componentOpts) {
	  if (typeof opts === "undefined") {
	    opts = {};
	  }

	  if (typeof componentOpts === "undefined") {
	    componentOpts = {};
	  }

	  // Board specific properties
	  this.board = Board.mount(opts);
	  this.io = this.board.io;

	  // Component/Module instance properties
	  this.id = opts.id || Board.uid();

	  var originalPins;

	  if (typeof opts.pin === "number" || typeof opts.pin === "string") {
	    originalPins = [opts.pin];
	  } else {
	    if (Array.isArray(opts.pins)) {
	      originalPins = opts.pins.slice();
	    } else {
	      if (typeof opts.pins === "object" && opts.pins !== null) {

	        var pinset = opts.pins || opts.pin;

	        originalPins = [];
	        for (var p in pinset) {
	          originalPins.push(pinset[p]);
	        }
	      }
	    }
	  }

	  componentOpts = Board.Component.initialization(componentOpts);

	  if (componentOpts.normalizePin) {
	    opts = Board.Pins.normalize(opts, this.board);
	  }

	  var requesting = [];

	  if (typeof opts.pins !== "undefined") {
	    this.pins = opts.pins || [];

	    if (Array.isArray(this.pins)) {
	      requesting = requesting.concat(
	        this.pins.map(function(pin) {
	          return {
	            value: pin,
	            type: "pin"
	          };
	        })
	      );
	    } else {
	      requesting = requesting.concat(
	        Object.keys(this.pins).map(function(key) {
	          return {
	            value: this.pins[key],
	            type: "pin"
	          };
	        }, this)
	      );
	    }
	  }

	  if (typeof opts.pin !== "undefined") {
	    this.pin = opts.pin;
	    requesting.push({
	      value: this.pin,
	      type: "pin"
	    });
	  }

	  if (typeof opts.emitter !== "undefined") {
	    this.emitter = opts.emitter;
	    requesting.push({
	      value: this.emitter,
	      type: "emitter"
	    });
	  }

	  // TODO: Kill this.
	  if (typeof opts.addr !== "undefined") {
	    this.addr = opts.addr;
	    requesting.push({
	      value: this.addr,
	      type: "addr"
	    });
	  }

	  if (typeof opts.address !== "undefined" && requesting.length) {
	    this.address = opts.address;
	    requesting.forEach(function(request) {
	      request.address = this.address;
	    }, this);
	  }

	  if (typeof opts.controller !== "undefined" && requesting.length) {
	    this.controller = opts.controller;
	    requesting.forEach(function(request) {
	      request.controller = this.controller;
	    }, this);
	  }

	  if (componentOpts.requestPin) {
	    // With the pins being requested for use by this component,
	    // compare with the list of pins that are already known to be
	    // in use by other components. If any are known to be in use,
	    // produce a warning for the user.
	    requesting.forEach(function(request, index) {
	      var hasController = typeof request.controller !== "undefined";
	      var hasAddress = typeof request.address !== "undefined";
	      var isOccupied = false;
	      var message = "";

	      request.value = originalPins[index];

	      if (this.board.occupied.length) {
	        isOccupied = this.board.occupied.some(function(occupied) {
	          var isPinOccupied = request.value === occupied.value && request.type === occupied.type;

	          if (typeof occupied.controller !== "undefined") {
	            if (hasController) {
	              return isPinOccupied && (request.controller === occupied.controller);
	            }
	            return false;
	          }

	          if (typeof occupied.address !== "undefined") {
	            if (hasAddress) {
	              return isPinOccupied && (request.address === occupied.address);
	            }
	            return false;
	          }

	          return isPinOccupied;
	        });
	      }

	      if (isOccupied) {
	        message = request.type + ": " + request.value;

	        if (hasController) {
	          message += ", controller: " + request.controller;
	        }

	        if (hasAddress) {
	          message += ", address: " + request.address;
	        }

	        this.board.warn("Component", message + " is already in use");
	      } else {
	        this.board.occupied.push(request);
	      }
	    }, this);
	  }

	  this.board.register.push(this);
	};

	Board.Component.initialization = function(opts) {
	  var defaults = {
	    requestPin: true,
	    normalizePin: true
	  };

	  return Object.assign({}, defaults, opts);
	};


	Board.Device = function(opts) {
	  Board.Component.call(this, opts);
	};

	/**
	 * Board.Controller
	 *
	 * Decorate a Component with a Controller. Must be called
	 * _AFTER_ a Controller is identified.
	 *
	 * Board.Controller is a |this| sensitive constructor,
	 * and must be called as:
	 *
	 * Board.Controller.call( this, controller, opts );
	 *
	 */

	Board.Controller = function(controller, options) {
	  var requirements = controller.requirements && controller.requirements.value;

	  if (requirements) {
	    if (requirements.options) {
	      Object.keys(requirements.options).forEach(function(key) {
	        /*
	        requirements: {
	          value: {
	            options: {
	              parameterName: {
	                throws: false,
	                message: "...blah blah blah",
	                typeof: "number",
	              }
	            }
	          }
	        },
	        */
	        if (typeof options[key] === "undefined" ||
	            typeof options[key] !== requirements.options[key].typeof) {
	          if (requirements.options[key].throws) {
	            throw new Error(requirements.options[key].message);
	          } else {
	            this.board.warn(this.constructor.name, requirements.options[key].message);
	          }
	        }
	      }, this);
	    }
	  }

	  Object.defineProperties(this, controller);
	};




	/**
	 * Pin Capability Signature Mapping
	 */

	Board.Pins = Pins;

	Board.Options = Options;

	// Define a user-safe, unwritable hardware cache access
	Object.defineProperty(Board, "cache", {
	  get: function() {
	    return boards;
	  }
	});

	/**
	 * Board event constructor.
	 * opts:
	 *   type - event type. eg: "read", "change", "up" etc.
	 *   target - the instance for which the event fired.
	 *   0..* other properties
	 */
	Board.Event = function(opts) {

	  if (!(this instanceof Board.Event)) {
	    return new Board.Event(opts);
	  }

	  opts = opts || {};

	  // default event is read
	  this.type = opts.type || "read";

	  // actual target instance
	  this.target = opts.target || null;

	  // Initialize this Board instance with
	  // param specified properties.
	  _.assign(this, opts);
	};


	/**
	 * Boards or Board.Array; Used when the program must connect to
	 * more then one board.
	 *
	 * @memberof Board
	 *
	 * @param {Array} ports List of port objects { id: ..., port: ... }
	 *                      List of id strings (initialized in order)
	 *
	 * @return {Boards} board object references
	 */
	function Boards(opts) {
	  if (!(this instanceof Boards)) {
	    return new Boards(opts);
	  }

	  var ports;

	  // new Boards([ ...Array of board opts ])
	  if (Array.isArray(opts)) {
	    ports = opts.slice();
	    opts = {
	      ports: ports,
	    };
	  }

	  // new Boards({ ports: [ ...Array of board opts ], .... })
	  if (!Array.isArray(opts) && typeof opts === "object" && opts.ports !== undefined) {
	    ports = opts.ports;
	  }

	  // new Boards(non-Array?)
	  // new Boards({ ports: non-Array? })
	  if (!Array.isArray(ports)) {
	    throw new Error("Expected ports to be an array");
	  }

	  if (typeof opts.debug === "undefined") {
	    opts.debug = true;
	  }

	  if (typeof opts.repl === "undefined") {
	    opts.repl = true;
	  }

	  var initialized = {};
	  var noRepl = ports.some(function(port) { return port.repl === false; });
	  var noDebug = ports.some(function(port) { return port.debug === false; });

	  this.length = ports.length;
	  this.debug = opts.debug;
	  this.repl = opts.repl;

	  // If any of the port definitions have
	  // explicitly shut off debug output, bubble up
	  // to the Boards instance
	  if (noDebug) {
	    this.debug = false;
	  }

	  // If any of the port definitions have
	  // explicitly shut off the repl, bubble up
	  // to the Boards instance
	  if (noRepl) {
	    this.repl = false;
	  }

	  var expecteds = ports.map(function(port, index) {
	    var portOpts;

	    if (typeof port === "string") {
	      portOpts = {
	        id: port
	      };
	    } else {
	      portOpts = port;
	    }

	    // Shut off per-board repl instance creation
	    portOpts.repl = false;

	    this[index] = initialized[portOpts.id] = new Board(portOpts);

	    // "error" event is not async, register immediately
	    this[index].on("error", function(error) {
	      this.emit("error", error);
	    }.bind(this));

	    return new Promise(function(resolve) {
	      this[index].on("ready", function() {
	        resolve(initialized[portOpts.id]);
	      });
	    }.bind(this));
	  }, this);

	  Promise.all(expecteds).then(function(boards) {
	    Object.assign(this, boards);

	    this.each(function(board) {
	      board.info("Board ID: ", chalk.green(board.id));
	    });

	    // If the Boards instance requires a REPL,
	    // make sure it's created before calling "ready"
	    if (this.repl) {
	      this.repl = new Repl(
	        Object.assign({}, initialized, {
	          board: this
	        })
	      );
	      this.repl.initialize(function() {
	        this.emit("ready", initialized);
	      }.bind(this));
	    } else {
	    // Otherwise, call ready immediately
	      this.emit("ready", initialized);
	    }
	  }.bind(this));
	}

	util.inherits(Boards, Emitter);

	Object.assign(Boards.prototype, Collection.prototype);

	Boards.prototype.byId = function(id) {
	  for (var i = 0; i < this.length; i++) {
	    if (this[i].id === id) {
	      return this[i];
	    }
	  }

	  return null;
	};

	Boards.prototype.log = Board.prototype.log;

	logging.specials.forEach(function(type) {
	  Boards.prototype[type] = function() {
	    var args = [].slice.call(arguments);
	    args.unshift(type);

	    this.log.apply(this, args);
	  };
	});


	if (IS_TEST_MODE) {
	  Board.__spy = {
	    Serial: Serial
	  };

	  Board.purge = function() {
	    Board.Pins.normalize.clear();
	    Repl.isActive = false;
	    Repl.isBlocked = true;
	    Repl.ref = null;
	    boards.length = 0;
	  };
	}


	Board.Array = Boards;

	module.exports = Board;


	// References:
	// http://arduino.cc/en/Main/arduinoBoardUno

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }())))

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var escapeStringRegexp = __webpack_require__(105);
	var ansiStyles = __webpack_require__(106);
	var stripAnsi = __webpack_require__(108);
	var hasAnsi = __webpack_require__(110);
	var supportsColor = __webpack_require__(112);
	var defineProps = Object.defineProperties;
	var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

	function Chalk(options) {
		// detect mode if not set manually
		this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
	}

	// use bright blue on Windows as the normal blue color is illegible
	if (isSimpleWindowsTerm) {
		ansiStyles.blue.open = '\u001b[94m';
	}

	var styles = (function () {
		var ret = {};

		Object.keys(ansiStyles).forEach(function (key) {
			ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

			ret[key] = {
				get: function () {
					return build.call(this, this._styles.concat(key));
				}
			};
		});

		return ret;
	})();

	var proto = defineProps(function chalk() {}, styles);

	function build(_styles) {
		var builder = function () {
			return applyStyle.apply(builder, arguments);
		};

		builder._styles = _styles;
		builder.enabled = this.enabled;
		// __proto__ is used because we must return a function, but there is
		// no way to create a function with a different prototype.
		/* eslint-disable no-proto */
		builder.__proto__ = proto;

		return builder;
	}

	function applyStyle() {
		// support varags, but simply cast to string in case there's only one arg
		var args = arguments;
		var argsLen = args.length;
		var str = argsLen !== 0 && String(arguments[0]);

		if (argsLen > 1) {
			// don't slice `arguments`, it prevents v8 optimizations
			for (var a = 1; a < argsLen; a++) {
				str += ' ' + args[a];
			}
		}

		if (!this.enabled || !str) {
			return str;
		}

		var nestedStyles = this._styles;
		var i = nestedStyles.length;

		// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
		// see https://github.com/chalk/chalk/issues/58
		// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
		var originalDim = ansiStyles.dim.open;
		if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
			ansiStyles.dim.open = '';
		}

		while (i--) {
			var code = ansiStyles[nestedStyles[i]];

			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			str = code.open + str.replace(code.closeRe, code.open) + code.close;
		}

		// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
		ansiStyles.dim.open = originalDim;

		return str;
	}

	function init() {
		var ret = {};

		Object.keys(styles).forEach(function (name) {
			ret[name] = {
				get: function () {
					return build.call(this, [name]);
				}
			};
		});

		return ret;
	}

	defineProps(Chalk.prototype, init());

	module.exports = new Chalk();
	module.exports.styles = ansiStyles;
	module.exports.hasColor = hasAnsi;
	module.exports.stripColor = stripAnsi;
	module.exports.supportsColor = supportsColor;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 105 */
/***/ function(module, exports) {

	'use strict';

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe,  '\\$&');
	};


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';

	function assembleStyles () {
		var styles = {
			modifiers: {
				reset: [0, 0],
				bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
				dim: [2, 22],
				italic: [3, 23],
				underline: [4, 24],
				inverse: [7, 27],
				hidden: [8, 28],
				strikethrough: [9, 29]
			},
			colors: {
				black: [30, 39],
				red: [31, 39],
				green: [32, 39],
				yellow: [33, 39],
				blue: [34, 39],
				magenta: [35, 39],
				cyan: [36, 39],
				white: [37, 39],
				gray: [90, 39]
			},
			bgColors: {
				bgBlack: [40, 49],
				bgRed: [41, 49],
				bgGreen: [42, 49],
				bgYellow: [43, 49],
				bgBlue: [44, 49],
				bgMagenta: [45, 49],
				bgCyan: [46, 49],
				bgWhite: [47, 49]
			}
		};

		// fix humans
		styles.colors.grey = styles.colors.gray;

		Object.keys(styles).forEach(function (groupName) {
			var group = styles[groupName];

			Object.keys(group).forEach(function (styleName) {
				var style = group[styleName];

				styles[styleName] = group[styleName] = {
					open: '\u001b[' + style[0] + 'm',
					close: '\u001b[' + style[1] + 'm'
				};
			});

			Object.defineProperty(styles, groupName, {
				value: group,
				enumerable: false
			});
		});

		return styles;
	}

	Object.defineProperty(module, 'exports', {
		enumerable: true,
		get: assembleStyles
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module)))

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(109)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 109 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(111);
	var re = new RegExp(ansiRegex().source); // remove the `g` flag
	module.exports = re.test.bind(re);


/***/ },
/* 111 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var argv = process.argv;

	var terminator = argv.indexOf('--');
	var hasFlag = function (flag) {
		flag = '--' + flag;
		var pos = argv.indexOf(flag);
		return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
	};

	module.exports = (function () {
		if ('FORCE_COLOR' in process.env) {
			return true;
		}

		if (hasFlag('no-color') ||
			hasFlag('no-colors') ||
			hasFlag('color=false')) {
			return false;
		}

		if (hasFlag('color') ||
			hasFlag('colors') ||
			hasFlag('color=true') ||
			hasFlag('color=always')) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash -o ./dist/lodash.compat.js`
	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre ES5 environments */
	  var undefined;

	  /** Used to pool arrays and objects used internally */
	  var arrayPool = [],
	      objectPool = [];

	  /** Used to generate unique IDs */
	  var idCounter = 0;

	  /** Used internally to indicate various things */
	  var indicatorObject = {};

	  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
	  var keyPrefix = +new Date + '';

	  /** Used as the size when optimizations are enabled for large arrays */
	  var largeArraySize = 75;

	  /** Used as the max size of the `arrayPool` and `objectPool` */
	  var maxPoolSize = 40;

	  /** Used to detect and test whitespace */
	  var whitespace = (
	    // whitespace
	    ' \t\x0B\f\xA0\ufeff' +

	    // line terminators
	    '\n\r\u2028\u2029' +

	    // unicode category "Zs" space separators
	    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
	  );

	  /** Used to match empty string literals in compiled template source */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /**
	   * Used to match ES6 template delimiters
	   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match regexp flags from their coerced string values */
	  var reFlags = /\w*$/;

	  /** Used to detected named functions */
	  var reFuncName = /^\s*function[ \n\r\t]+\w/;

	  /** Used to match "interpolate" template delimiters */
	  var reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match leading whitespace and zeros to be removed */
	  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

	  /** Used to ensure capturing order of template delimiters */
	  var reNoMatch = /($^)/;

	  /** Used to detect functions containing a `this` reference */
	  var reThis = /\bthis\b/;

	  /** Used to match unescaped characters in compiled string literals */
	  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

	  /** Used to assign default `context` object properties */
	  var contextProps = [
	    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
	    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
	    'parseInt', 'setTimeout'
	  ];

	  /** Used to fix the JScript [[DontEnum]] bug */
	  var shadowedProps = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
	    'toLocaleString', 'toString', 'valueOf'
	  ];

	  /** Used to make template sourceURLs easier to identify */
	  var templateCounter = 0;

	  /** `Object#toString` result shortcuts */
	  var argsClass = '[object Arguments]',
	      arrayClass = '[object Array]',
	      boolClass = '[object Boolean]',
	      dateClass = '[object Date]',
	      errorClass = '[object Error]',
	      funcClass = '[object Function]',
	      numberClass = '[object Number]',
	      objectClass = '[object Object]',
	      regexpClass = '[object RegExp]',
	      stringClass = '[object String]';

	  /** Used to identify object classifications that `_.clone` supports */
	  var cloneableClasses = {};
	  cloneableClasses[funcClass] = false;
	  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
	  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
	  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
	  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

	  /** Used as an internal `_.debounce` options object */
	  var debounceOptions = {
	    'leading': false,
	    'maxWait': 0,
	    'trailing': false
	  };

	  /** Used as the property descriptor for `__bindData__` */
	  var descriptor = {
	    'configurable': false,
	    'enumerable': false,
	    'value': null,
	    'writable': false
	  };

	  /** Used as the data object for `iteratorTemplate` */
	  var iteratorData = {
	    'args': '',
	    'array': null,
	    'bottom': '',
	    'firstArg': '',
	    'init': '',
	    'keys': null,
	    'loop': '',
	    'shadowedProps': null,
	    'support': null,
	    'top': '',
	    'useHas': false
	  };

	  /** Used to determine if values are of the language type Object */
	  var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	  };

	  /** Used to escape characters for inclusion in compiled string literals */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\t': 't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Used as a reference to the global object */
	  var root = (objectTypes[typeof window] && window) || this;

	  /** Detect free variable `exports` */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module` */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports` */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
	  var freeGlobal = objectTypes[typeof global] && global;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    root = freeGlobal;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches
	   * or `fromIndex` constraints.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} [fromIndex=0] The index to search from.
	   * @returns {number} Returns the index of the matched value or `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    var index = (fromIndex || 0) - 1,
	        length = array ? array.length : 0;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * An implementation of `_.contains` for cache objects that mimics the return
	   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
	   *
	   * @private
	   * @param {Object} cache The cache object to inspect.
	   * @param {*} value The value to search for.
	   * @returns {number} Returns `0` if `value` is found, else `-1`.
	   */
	  function cacheIndexOf(cache, value) {
	    var type = typeof value;
	    cache = cache.cache;

	    if (type == 'boolean' || value == null) {
	      return cache[value] ? 0 : -1;
	    }
	    if (type != 'number' && type != 'string') {
	      type = 'object';
	    }
	    var key = type == 'number' ? value : keyPrefix + value;
	    cache = (cache = cache[type]) && cache[key];

	    return type == 'object'
	      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
	      : (cache ? 0 : -1);
	  }

	  /**
	   * Adds a given value to the corresponding cache object.
	   *
	   * @private
	   * @param {*} value The value to add to the cache.
	   */
	  function cachePush(value) {
	    var cache = this.cache,
	        type = typeof value;

	    if (type == 'boolean' || value == null) {
	      cache[value] = true;
	    } else {
	      if (type != 'number' && type != 'string') {
	        type = 'object';
	      }
	      var key = type == 'number' ? value : keyPrefix + value,
	          typeCache = cache[type] || (cache[type] = {});

	      if (type == 'object') {
	        (typeCache[key] || (typeCache[key] = [])).push(value);
	      } else {
	        typeCache[key] = true;
	      }
	    }
	  }

	  /**
	   * Used by `_.max` and `_.min` as the default callback when a given
	   * collection is a string value.
	   *
	   * @private
	   * @param {string} value The character to inspect.
	   * @returns {number} Returns the code unit of given character.
	   */
	  function charAtCallback(value) {
	    return value.charCodeAt(0);
	  }

	  /**
	   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
	   * them in ascending order.
	   *
	   * @private
	   * @param {Object} a The object to compare to `b`.
	   * @param {Object} b The object to compare to `a`.
	   * @returns {number} Returns the sort order indicator of `1` or `-1`.
	   */
	  function compareAscending(a, b) {
	    var ac = a.criteria,
	        bc = b.criteria,
	        index = -1,
	        length = ac.length;

	    while (++index < length) {
	      var value = ac[index],
	          other = bc[index];

	      if (value !== other) {
	        if (value > other || typeof value == 'undefined') {
	          return 1;
	        }
	        if (value < other || typeof other == 'undefined') {
	          return -1;
	        }
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to return the same value for
	    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See http://code.google.com/p/v8/issues/detail?id=90
	    return a.index - b.index;
	  }

	  /**
	   * Creates a cache object to optimize linear searches of large arrays.
	   *
	   * @private
	   * @param {Array} [array=[]] The array to search.
	   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
	   */
	  function createCache(array) {
	    var index = -1,
	        length = array.length,
	        first = array[0],
	        mid = array[(length / 2) | 0],
	        last = array[length - 1];

	    if (first && typeof first == 'object' &&
	        mid && typeof mid == 'object' && last && typeof last == 'object') {
	      return false;
	    }
	    var cache = getObject();
	    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

	    var result = getObject();
	    result.array = array;
	    result.cache = cache;
	    result.push = cachePush;

	    while (++index < length) {
	      result.push(array[index]);
	    }
	    return result;
	  }

	  /**
	   * Used by `template` to escape characters for inclusion in compiled
	   * string literals.
	   *
	   * @private
	   * @param {string} match The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(match) {
	    return '\\' + stringEscapes[match];
	  }

	  /**
	   * Gets an array from the array pool or creates a new one if the pool is empty.
	   *
	   * @private
	   * @returns {Array} The array from the pool.
	   */
	  function getArray() {
	    return arrayPool.pop() || [];
	  }

	  /**
	   * Gets an object from the object pool or creates a new one if the pool is empty.
	   *
	   * @private
	   * @returns {Object} The object from the pool.
	   */
	  function getObject() {
	    return objectPool.pop() || {
	      'array': null,
	      'cache': null,
	      'criteria': null,
	      'false': false,
	      'index': 0,
	      'null': false,
	      'number': null,
	      'object': null,
	      'push': null,
	      'string': null,
	      'true': false,
	      'undefined': false,
	      'value': null
	    };
	  }

	  /**
	   * Checks if `value` is a DOM node in IE < 9.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
	   */
	  function isNode(value) {
	    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
	    // methods that are `typeof` "string" and still can coerce nodes to strings
	    return typeof value.toString != 'function' && typeof (value + '') == 'string';
	  }

	  /**
	   * Releases the given array back to the array pool.
	   *
	   * @private
	   * @param {Array} [array] The array to release.
	   */
	  function releaseArray(array) {
	    array.length = 0;
	    if (arrayPool.length < maxPoolSize) {
	      arrayPool.push(array);
	    }
	  }

	  /**
	   * Releases the given object back to the object pool.
	   *
	   * @private
	   * @param {Object} [object] The object to release.
	   */
	  function releaseObject(object) {
	    var cache = object.cache;
	    if (cache) {
	      releaseObject(cache);
	    }
	    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
	    if (objectPool.length < maxPoolSize) {
	      objectPool.push(object);
	    }
	  }

	  /**
	   * Slices the `collection` from the `start` index up to, but not including,
	   * the `end` index.
	   *
	   * Note: This function is used instead of `Array#slice` to support node lists
	   * in IE < 9 and to ensure dense arrays are returned.
	   *
	   * @private
	   * @param {Array|Object|string} collection The collection to slice.
	   * @param {number} start The start index.
	   * @param {number} end The end index.
	   * @returns {Array} Returns the new array.
	   */
	  function slice(array, start, end) {
	    start || (start = 0);
	    if (typeof end == 'undefined') {
	      end = array ? array.length : 0;
	    }
	    var index = -1,
	        length = end - start || 0,
	        result = Array(length < 0 ? 0 : length);

	    while (++index < length) {
	      result[index] = array[start + index];
	    }
	    return result;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new `lodash` function using the given context object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns the `lodash` function.
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See http://es5.github.io/#x11.1.5.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references */
	    var Array = context.Array,
	        Boolean = context.Boolean,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /**
	     * Used for `Array` method references.
	     *
	     * Normally `Array.prototype` would suffice, however, using an array literal
	     * avoids issues in Narwhal.
	     */
	    var arrayRef = [];

	    /** Used for native method references */
	    var errorProto = Error.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to restore the original `_` reference in `noConflict` */
	    var oldDash = context._;

	    /** Used to resolve the internal [[Class]] of values */
	    var toString = objectProto.toString;

	    /** Used to detect if a method is native */
	    var reNative = RegExp('^' +
	      String(toString)
	        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
	        .replace(/toString| for [^\]]+/g, '.*?') + '$'
	    );

	    /** Native method shortcuts */
	    var ceil = Math.ceil,
	        clearTimeout = context.clearTimeout,
	        floor = Math.floor,
	        fnToString = Function.prototype.toString,
	        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
	        hasOwnProperty = objectProto.hasOwnProperty,
	        push = arrayRef.push,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        setTimeout = context.setTimeout,
	        splice = arrayRef.splice,
	        unshift = arrayRef.unshift;

	    /** Used to set meta data on functions */
	    var defineProperty = (function() {
	      // IE 8 only accepts DOM elements
	      try {
	        var o = {},
	            func = isNative(func = Object.defineProperty) && func,
	            result = func(o, o, o) && func;
	      } catch(e) { }
	      return result;
	    }());

	    /* Native method shortcuts for methods with the same name as other `lodash` methods */
	    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
	        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
	        nativeIsFinite = context.isFinite,
	        nativeIsNaN = context.isNaN,
	        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used to lookup a built-in constructor by [[Class]] */
	    var ctorByClass = {};
	    ctorByClass[arrayClass] = Array;
	    ctorByClass[boolClass] = Boolean;
	    ctorByClass[dateClass] = Date;
	    ctorByClass[funcClass] = Function;
	    ctorByClass[objectClass] = Object;
	    ctorByClass[numberClass] = Number;
	    ctorByClass[regexpClass] = RegExp;
	    ctorByClass[stringClass] = String;

	    /** Used to avoid iterating non-enumerable properties in IE < 9 */
	    var nonEnumProps = {};
	    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
	    nonEnumProps[objectClass] = { 'constructor': true };

	    (function() {
	      var length = shadowedProps.length;
	      while (length--) {
	        var key = shadowedProps[length];
	        for (var className in nonEnumProps) {
	          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
	            nonEnumProps[className][key] = false;
	          }
	        }
	      }
	    }());

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps the given value to enable intuitive
	     * method chaining.
	     *
	     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
	     * and `unshift`
	     *
	     * Chaining is supported in custom builds as long as the `value` method is
	     * implicitly or explicitly included in the build.
	     *
	     * The chainable wrapper functions are:
	     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
	     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
	     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
	     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
	     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
	     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
	     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
	     * and `zip`
	     *
	     * The non-chainable wrapper functions are:
	     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
	     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
	     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
	     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
	     * `template`, `unescape`, `uniqueId`, and `value`
	     *
	     * The wrapper functions `first` and `last` return wrapped values when `n` is
	     * provided, otherwise they return unwrapped values.
	     *
	     * Explicit chaining can be enabled by using the `_.chain` method.
	     *
	     * @name _
	     * @constructor
	     * @category Chaining
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns a `lodash` instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(sum, num) {
	     *   return sum + num;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(num) {
	     *   return num * num;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
	      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
	       ? value
	       : new lodashWrapper(value);
	    }

	    /**
	     * A fast path for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @param {boolean} chainAll A flag to enable chaining for all methods
	     * @returns {Object} Returns a `lodash` instance.
	     */
	    function lodashWrapper(value, chainAll) {
	      this.__chain__ = !!chainAll;
	      this.__wrapped__ = value;
	    }
	    // ensure `new lodashWrapper` is an instance of `lodash`
	    lodashWrapper.prototype = lodash.prototype;

	    /**
	     * An object used to flag environments features.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    (function() {
	      var ctor = function() { this.x = 1; },
	          object = { '0': 1, 'length': 1 },
	          props = [];

	      ctor.prototype = { 'valueOf': 1, 'y': 1 };
	      for (var key in new ctor) { props.push(key); }
	      for (key in arguments) { }

	      /**
	       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.argsClass = toString.call(arguments) == argsClass;

	      /**
	       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

	      /**
	       * Detect if `name` or `message` properties of `Error.prototype` are
	       * enumerable by default. (IE < 9, Safari < 5.1)
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

	      /**
	       * Detect if `prototype` properties are enumerable by default.
	       *
	       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
	       * (if the prototype or a property on the prototype has been set)
	       * incorrectly sets a function's `prototype` property [[Enumerable]]
	       * value to `true`.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

	      /**
	       * Detect if functions can be decompiled by `Function#toString`
	       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

	      /**
	       * Detect if `Function#name` is supported (all but IE).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcNames = typeof Function.name == 'string';

	      /**
	       * Detect if `arguments` object indexes are non-enumerable
	       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumArgs = key != 0;

	      /**
	       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
	       *
	       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
	       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumShadows = !/valueOf/.test(props);

	      /**
	       * Detect if own properties are iterated after inherited properties (all but IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.ownLast = props[0] != 'x';

	      /**
	       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
	       *
	       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
	       * and `splice()` functions that fail to remove the last element, `value[0]`,
	       * of array-like objects even though the `length` property is set to `0`.
	       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
	       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

	      /**
	       * Detect lack of support for accessing string characters by index.
	       *
	       * IE < 8 can't access characters by index and IE 8 can only access
	       * characters by index on string literals.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';

	      /**
	       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
	       * and that the JS engine errors when attempting to coerce an object to
	       * a string without a `toString` function.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
	      } catch(e) {
	        support.nodeClass = true;
	      }
	    }(1));

	    /**
	     * By default, the template delimiters used by Lo-Dash are similar to those in
	     * embedded Ruby (ERB). Change the following template settings to use alternative
	     * delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': /<%-([\s\S]+?)%>/g,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': /<%([\s\S]+?)%>/g,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*--------------------------------------------------------------------------*/

	    /**
	     * The template used to create iterator functions.
	     *
	     * @private
	     * @param {Object} data The data object used to populate the text.
	     * @returns {string} Returns the interpolated text.
	     */
	    var iteratorTemplate = function(obj) {

	      var __p = 'var index, iterable = ' +
	      (obj.firstArg) +
	      ', result = ' +
	      (obj.init) +
	      ';\nif (!iterable) return result;\n' +
	      (obj.top) +
	      ';';
	       if (obj.array) {
	      __p += '\nvar length = iterable.length; index = -1;\nif (' +
	      (obj.array) +
	      ') {  ';
	       if (support.unindexedChars) {
	      __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
	       }
	      __p += '\n  while (++index < length) {\n    ' +
	      (obj.loop) +
	      ';\n  }\n}\nelse {  ';
	       } else if (support.nonEnumArgs) {
	      __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
	      (obj.loop) +
	      ';\n    }\n  } else {  ';
	       }

	       if (support.enumPrototypes) {
	      __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
	       }

	       if (support.enumErrorProps) {
	      __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
	       }

	          var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }

	       if (obj.useHas && obj.keys) {
	      __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
	          if (conditions.length) {
	      __p += '    if (' +
	      (conditions.join(' && ')) +
	      ') {\n  ';
	       }
	      __p +=
	      (obj.loop) +
	      ';    ';
	       if (conditions.length) {
	      __p += '\n    }';
	       }
	      __p += '\n  }  ';
	       } else {
	      __p += '\n  for (index in iterable) {\n';
	          if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
	      __p += '    if (' +
	      (conditions.join(' && ')) +
	      ') {\n  ';
	       }
	      __p +=
	      (obj.loop) +
	      ';    ';
	       if (conditions.length) {
	      __p += '\n    }';
	       }
	      __p += '\n  }    ';
	       if (support.nonEnumShadows) {
	      __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
	       for (k = 0; k < 7; k++) {
	      __p += '\n    index = \'' +
	      (obj.shadowedProps[k]) +
	      '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
	              if (!obj.useHas) {
	      __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
	       }
	      __p += ') {\n      ' +
	      (obj.loop) +
	      ';\n    }      ';
	       }
	      __p += '\n  }    ';
	       }

	       }

	       if (obj.array || support.nonEnumArgs) {
	      __p += '\n}';
	       }
	      __p +=
	      (obj.bottom) +
	      ';\nreturn result';

	      return __p
	    };

	    /*--------------------------------------------------------------------------*/

	    /**
	     * The base implementation of `_.bind` that creates the bound function and
	     * sets its meta data.
	     *
	     * @private
	     * @param {Array} bindData The bind data array.
	     * @returns {Function} Returns the new bound function.
	     */
	    function baseBind(bindData) {
	      var func = bindData[0],
	          partialArgs = bindData[2],
	          thisArg = bindData[4];

	      function bound() {
	        // `Function#bind` spec
	        // http://es5.github.io/#x15.3.4.5
	        if (partialArgs) {
	          // avoid `arguments` object deoptimizations by using `slice` instead
	          // of `Array.prototype.slice.call` and not assigning `arguments` to a
	          // variable as a ternary expression
	          var args = slice(partialArgs);
	          push.apply(args, arguments);
	        }
	        // mimic the constructor's `return` behavior
	        // http://es5.github.io/#x13.2.2
	        if (this instanceof bound) {
	          // ensure `new bound` is an instance of `func`
	          var thisBinding = baseCreate(func.prototype),
	              result = func.apply(thisBinding, args || arguments);
	          return isObject(result) ? result : thisBinding;
	        }
	        return func.apply(thisArg, args || arguments);
	      }
	      setBindData(bound, bindData);
	      return bound;
	    }

	    /**
	     * The base implementation of `_.clone` without argument juggling or support
	     * for `thisArg` binding.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep=false] Specify a deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, callback, stackA, stackB) {
	      if (callback) {
	        var result = callback(value);
	        if (typeof result != 'undefined') {
	          return result;
	        }
	      }
	      // inspect [[Class]]
	      var isObj = isObject(value);
	      if (isObj) {
	        var className = toString.call(value);
	        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
	          return value;
	        }
	        var ctor = ctorByClass[className];
	        switch (className) {
	          case boolClass:
	          case dateClass:
	            return new ctor(+value);

	          case numberClass:
	          case stringClass:
	            return new ctor(value);

	          case regexpClass:
	            result = ctor(value.source, reFlags.exec(value));
	            result.lastIndex = value.lastIndex;
	            return result;
	        }
	      } else {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isDeep) {
	        // check for circular references and return corresponding clone
	        var initedStack = !stackA;
	        stackA || (stackA = getArray());
	        stackB || (stackB = getArray());

	        var length = stackA.length;
	        while (length--) {
	          if (stackA[length] == value) {
	            return stackB[length];
	          }
	        }
	        result = isArr ? ctor(value.length) : {};
	      }
	      else {
	        result = isArr ? slice(value) : assign({}, value);
	      }
	      // add array properties assigned by `RegExp#exec`
	      if (isArr) {
	        if (hasOwnProperty.call(value, 'index')) {
	          result.index = value.index;
	        }
	        if (hasOwnProperty.call(value, 'input')) {
	          result.input = value.input;
	        }
	      }
	      // exit for shallow clone
	      if (!isDeep) {
	        return result;
	      }
	      // add the source value to the stack of traversed objects
	      // and associate it with its clone
	      stackA.push(value);
	      stackB.push(result);

	      // recursively populate clone (susceptible to call stack limits)
	      (isArr ? baseEach : forOwn)(value, function(objValue, key) {
	        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
	      });

	      if (initedStack) {
	        releaseArray(stackA);
	        releaseArray(stackB);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    function baseCreate(prototype, properties) {
	      return isObject(prototype) ? nativeCreate(prototype) : {};
	    }
	    // fallback for browsers without `Object.create`
	    if (!nativeCreate) {
	      baseCreate = (function() {
	        function Object() {}
	        return function(prototype) {
	          if (isObject(prototype)) {
	            Object.prototype = prototype;
	            var result = new Object;
	            Object.prototype = null;
	          }
	          return result || context.Object();
	        };
	      }());
	    }

	    /**
	     * The base implementation of `_.createCallback` without support for creating
	     * "_.pluck" or "_.where" style callbacks.
	     *
	     * @private
	     * @param {*} [func=identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of the created callback.
	     * @param {number} [argCount] The number of arguments the callback accepts.
	     * @returns {Function} Returns a callback function.
	     */
	    function baseCreateCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      // exit early for no `thisArg` or already bound by `Function#bind`
	      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
	        return func;
	      }
	      var bindData = func.__bindData__;
	      if (typeof bindData == 'undefined') {
	        if (support.funcNames) {
	          bindData = !func.name;
	        }
	        bindData = bindData || !support.funcDecomp;
	        if (!bindData) {
	          var source = fnToString.call(func);
	          if (!support.funcNames) {
	            bindData = !reFuncName.test(source);
	          }
	          if (!bindData) {
	            // checks if `func` references the `this` keyword and stores the result
	            bindData = reThis.test(source);
	            setBindData(func, bindData);
	          }
	        }
	      }
	      // exit early if there are no `this` references or `func` is bound
	      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 2: return function(a, b) {
	          return func.call(thisArg, a, b);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	      }
	      return bind(func, thisArg);
	    }

	    /**
	     * The base implementation of `createWrapper` that creates the wrapper and
	     * sets its meta data.
	     *
	     * @private
	     * @param {Array} bindData The bind data array.
	     * @returns {Function} Returns the new function.
	     */
	    function baseCreateWrapper(bindData) {
	      var func = bindData[0],
	          bitmask = bindData[1],
	          partialArgs = bindData[2],
	          partialRightArgs = bindData[3],
	          thisArg = bindData[4],
	          arity = bindData[5];

	      var isBind = bitmask & 1,
	          isBindKey = bitmask & 2,
	          isCurry = bitmask & 4,
	          isCurryBound = bitmask & 8,
	          key = func;

	      function bound() {
	        var thisBinding = isBind ? thisArg : this;
	        if (partialArgs) {
	          var args = slice(partialArgs);
	          push.apply(args, arguments);
	        }
	        if (partialRightArgs || isCurry) {
	          args || (args = slice(arguments));
	          if (partialRightArgs) {
	            push.apply(args, partialRightArgs);
	          }
	          if (isCurry && args.length < arity) {
	            bitmask |= 16 & ~32;
	            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
	          }
	        }
	        args || (args = arguments);
	        if (isBindKey) {
	          func = thisBinding[key];
	        }
	        if (this instanceof bound) {
	          thisBinding = baseCreate(func.prototype);
	          var result = func.apply(thisBinding, args);
	          return isObject(result) ? result : thisBinding;
	        }
	        return func.apply(thisBinding, args);
	      }
	      setBindData(bound, bindData);
	      return bound;
	    }

	    /**
	     * The base implementation of `_.difference` that accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to process.
	     * @param {Array} [values] The array of values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array ? array.length : 0,
	          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
	          result = [];

	      if (isLarge) {
	        var cache = createCache(values);
	        if (cache) {
	          indexOf = cacheIndexOf;
	          values = cache;
	        } else {
	          isLarge = false;
	        }
	      }
	      while (++index < length) {
	        var value = array[index];
	        if (indexOf(values, value) < 0) {
	          result.push(value);
	        }
	      }
	      if (isLarge) {
	        releaseObject(values);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` without support for callback
	     * shorthands or `thisArg` binding.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
	     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
	     * @param {number} [fromIndex=0] The index to start from.
	     * @returns {Array} Returns a new flattened array.
	     */
	    function baseFlatten(array, isShallow, isStrict, fromIndex) {
	      var index = (fromIndex || 0) - 1,
	          length = array ? array.length : 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];

	        if (value && typeof value == 'object' && typeof value.length == 'number'
	            && (isArray(value) || isArguments(value))) {
	          // recursively flatten arrays (susceptible to call stack limits)
	          if (!isShallow) {
	            value = baseFlatten(value, isShallow, isStrict);
	          }
	          var valIndex = -1,
	              valLength = value.length,
	              resIndex = result.length;

	          result.length += valLength;
	          while (++valIndex < valLength) {
	            result[resIndex++] = value[valIndex];
	          }
	        } else if (!isStrict) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
	     * that allows partial "_.where" style comparisons.
	     *
	     * @private
	     * @param {*} a The value to compare.
	     * @param {*} b The other value to compare.
	     * @param {Function} [callback] The function to customize comparing values.
	     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
	      // used to indicate that when comparing objects, `a` has at least the properties of `b`
	      if (callback) {
	        var result = callback(a, b);
	        if (typeof result != 'undefined') {
	          return !!result;
	        }
	      }
	      // exit early for identical values
	      if (a === b) {
	        // treat `+0` vs. `-0` as not equal
	        return a !== 0 || (1 / a == 1 / b);
	      }
	      var type = typeof a,
	          otherType = typeof b;

	      // exit early for unlike primitive values
	      if (a === a &&
	          !(a && objectTypes[type]) &&
	          !(b && objectTypes[otherType])) {
	        return false;
	      }
	      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
	      // http://es5.github.io/#x15.3.4.4
	      if (a == null || b == null) {
	        return a === b;
	      }
	      // compare [[Class]] names
	      var className = toString.call(a),
	          otherClass = toString.call(b);

	      if (className == argsClass) {
	        className = objectClass;
	      }
	      if (otherClass == argsClass) {
	        otherClass = objectClass;
	      }
	      if (className != otherClass) {
	        return false;
	      }
	      switch (className) {
	        case boolClass:
	        case dateClass:
	          // coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
	          return +a == +b;

	        case numberClass:
	          // treat `NaN` vs. `NaN` as equal
	          return (a != +a)
	            ? b != +b
	            // but treat `+0` vs. `-0` as not equal
	            : (a == 0 ? (1 / a == 1 / b) : a == +b);

	        case regexpClass:
	        case stringClass:
	          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
	          // treat string primitives and their corresponding object instances as equal
	          return a == String(b);
	      }
	      var isArr = className == arrayClass;
	      if (!isArr) {
	        // unwrap any `lodash` wrapped values
	        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
	            bWrapped = hasOwnProperty.call(b, '__wrapped__');

	        if (aWrapped || bWrapped) {
	          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
	        }
	        // exit for functions and DOM nodes
	        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
	          return false;
	        }
	        // in older versions of Opera, `arguments` objects have `Array` constructors
	        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
	            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

	        // non `Object` object instances with different constructors are not equal
	        if (ctorA != ctorB &&
	              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
	              ('constructor' in a && 'constructor' in b)
	            ) {
	          return false;
	        }
	      }
	      // assume cyclic structures are equal
	      // the algorithm for detecting cyclic structures is adapted from ES 5.1
	      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
	      var initedStack = !stackA;
	      stackA || (stackA = getArray());
	      stackB || (stackB = getArray());

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == a) {
	          return stackB[length] == b;
	        }
	      }
	      var size = 0;
	      result = true;

	      // add `a` and `b` to the stack of traversed objects
	      stackA.push(a);
	      stackB.push(b);

	      // recursively compare objects and arrays (susceptible to call stack limits)
	      if (isArr) {
	        // compare lengths to determine if a deep comparison is necessary
	        length = a.length;
	        size = b.length;
	        result = size == length;

	        if (result || isWhere) {
	          // deep compare the contents, ignoring non-numeric properties
	          while (size--) {
	            var index = length,
	                value = b[size];

	            if (isWhere) {
	              while (index--) {
	                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
	                  break;
	                }
	              }
	            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
	              break;
	            }
	          }
	        }
	      }
	      else {
	        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
	        // which, in this case, is more costly
	        forIn(b, function(value, key, b) {
	          if (hasOwnProperty.call(b, key)) {
	            // count the number of properties.
	            size++;
	            // deep compare each property value.
	            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
	          }
	        });

	        if (result && !isWhere) {
	          // ensure both objects have the same number of properties
	          forIn(a, function(value, key, a) {
	            if (hasOwnProperty.call(a, key)) {
	              // `size` will be `-1` if `a` has more properties than `b`
	              return (result = --size > -1);
	            }
	          });
	        }
	      }
	      stackA.pop();
	      stackB.pop();

	      if (initedStack) {
	        releaseArray(stackA);
	        releaseArray(stackB);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.merge` without argument juggling or support
	     * for `thisArg` binding.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [callback] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     */
	    function baseMerge(object, source, callback, stackA, stackB) {
	      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
	        var found,
	            isArr,
	            result = source,
	            value = object[key];

	        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
	          // avoid merging previously merged cyclic sources
	          var stackLength = stackA.length;
	          while (stackLength--) {
	            if ((found = stackA[stackLength] == source)) {
	              value = stackB[stackLength];
	              break;
	            }
	          }
	          if (!found) {
	            var isShallow;
	            if (callback) {
	              result = callback(value, source);
	              if ((isShallow = typeof result != 'undefined')) {
	                value = result;
	              }
	            }
	            if (!isShallow) {
	              value = isArr
	                ? (isArray(value) ? value : [])
	                : (isPlainObject(value) ? value : {});
	            }
	            // add `source` and associated `value` to the stack of traversed objects
	            stackA.push(source);
	            stackB.push(value);

	            // recursively merge objects and arrays (susceptible to call stack limits)
	            if (!isShallow) {
	              baseMerge(value, source, callback, stackA, stackB);
	            }
	          }
	        }
	        else {
	          if (callback) {
	            result = callback(value, source);
	            if (typeof result == 'undefined') {
	              result = source;
	            }
	          }
	          if (typeof result != 'undefined') {
	            value = result;
	          }
	        }
	        object[key] = value;
	      });
	    }

	    /**
	     * The base implementation of `_.random` without argument juggling or support
	     * for returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns a random number.
	     */
	    function baseRandom(min, max) {
	      return min + floor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * or `thisArg` binding.
	     *
	     * @private
	     * @param {Array} array The array to process.
	     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
	     * @param {Function} [callback] The function called per iteration.
	     * @returns {Array} Returns a duplicate-value-free array.
	     */
	    function baseUniq(array, isSorted, callback) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array ? array.length : 0,
	          result = [];

	      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
	          seen = (callback || isLarge) ? getArray() : result;

	      if (isLarge) {
	        var cache = createCache(seen);
	        indexOf = cacheIndexOf;
	        seen = cache;
	      }
	      while (++index < length) {
	        var value = array[index],
	            computed = callback ? callback(value, index, array) : value;

	        if (isSorted
	              ? !index || seen[seen.length - 1] !== computed
	              : indexOf(seen, computed) < 0
	            ) {
	          if (callback || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      if (isLarge) {
	        releaseArray(seen.array);
	        releaseObject(seen);
	      } else if (callback) {
	        releaseArray(seen);
	      }
	      return result;
	    }

	    /**
	     * Creates a function that aggregates a collection, creating an object composed
	     * of keys generated from the results of running each element of the collection
	     * through a callback. The given `setter` function sets the keys and values
	     * of the composed object.
	     *
	     * @private
	     * @param {Function} setter The setter function.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter) {
	      return function(collection, callback, thisArg) {
	        var result = {};
	        callback = lodash.createCallback(callback, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, callback(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, callback(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that, when called, either curries or invokes `func`
	     * with an optional `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of method flags to compose.
	     *  The bitmask may be composed of the following flags:
	     *  1 - `_.bind`
	     *  2 - `_.bindKey`
	     *  4 - `_.curry`
	     *  8 - `_.curry` (bound)
	     *  16 - `_.partial`
	     *  32 - `_.partialRight`
	     * @param {Array} [partialArgs] An array of arguments to prepend to those
	     *  provided to the new function.
	     * @param {Array} [partialRightArgs] An array of arguments to append to those
	     *  provided to the new function.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new function.
	     */
	    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
	      var isBind = bitmask & 1,
	          isBindKey = bitmask & 2,
	          isCurry = bitmask & 4,
	          isCurryBound = bitmask & 8,
	          isPartial = bitmask & 16,
	          isPartialRight = bitmask & 32;

	      if (!isBindKey && !isFunction(func)) {
	        throw new TypeError;
	      }
	      if (isPartial && !partialArgs.length) {
	        bitmask &= ~16;
	        isPartial = partialArgs = false;
	      }
	      if (isPartialRight && !partialRightArgs.length) {
	        bitmask &= ~32;
	        isPartialRight = partialRightArgs = false;
	      }
	      var bindData = func && func.__bindData__;
	      if (bindData && bindData !== true) {
	        // clone `bindData`
	        bindData = slice(bindData);
	        if (bindData[2]) {
	          bindData[2] = slice(bindData[2]);
	        }
	        if (bindData[3]) {
	          bindData[3] = slice(bindData[3]);
	        }
	        // set `thisBinding` is not previously bound
	        if (isBind && !(bindData[1] & 1)) {
	          bindData[4] = thisArg;
	        }
	        // set if previously bound but not currently (subsequent curried functions)
	        if (!isBind && bindData[1] & 1) {
	          bitmask |= 8;
	        }
	        // set curried arity if not yet set
	        if (isCurry && !(bindData[1] & 4)) {
	          bindData[5] = arity;
	        }
	        // append partial left arguments
	        if (isPartial) {
	          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
	        }
	        // append partial right arguments
	        if (isPartialRight) {
	          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
	        }
	        // merge flags
	        bindData[1] |= bitmask;
	        return createWrapper.apply(null, bindData);
	      }
	      // fast path for `_.bind`
	      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
	      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
	    }

	    /**
	     * Creates compiled iteration functions.
	     *
	     * @private
	     * @param {...Object} [options] The compile options object(s).
	     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
	     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
	     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
	     * @param {string} [options.args] A comma separated string of iteration function arguments.
	     * @param {string} [options.top] Code to execute before the iteration branches.
	     * @param {string} [options.loop] Code to execute in the object loop.
	     * @param {string} [options.bottom] Code to execute after the iteration branches.
	     * @returns {Function} Returns the compiled function.
	     */
	    function createIterator() {
	      // data properties
	      iteratorData.shadowedProps = shadowedProps;

	      // iterator options
	      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
	      iteratorData.init = 'iterable';
	      iteratorData.useHas = true;

	      // merge options into a template data object
	      for (var object, index = 0; object = arguments[index]; index++) {
	        for (var key in object) {
	          iteratorData[key] = object[key];
	        }
	      }
	      var args = iteratorData.args;
	      iteratorData.firstArg = /^[^,]+/.exec(args)[0];

	      // create the function factory
	      var factory = Function(
	          'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
	          'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
	          'objectTypes, nonEnumProps, stringClass, stringProto, toString',
	        'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
	      );

	      // return the compiled function
	      return factory(
	        baseCreateCallback, errorClass, errorProto, hasOwnProperty,
	        indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
	        objectTypes, nonEnumProps, stringClass, stringProto, toString
	      );
	    }

	    /**
	     * Used by `escape` to convert characters to HTML entities.
	     *
	     * @private
	     * @param {string} match The matched character to escape.
	     * @returns {string} Returns the escaped character.
	     */
	    function escapeHtmlChar(match) {
	      return htmlEscapes[match];
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized, this method returns the custom method, otherwise it returns
	     * the `baseIndexOf` function.
	     *
	     * @private
	     * @returns {Function} Returns the "indexOf" function.
	     */
	    function getIndexOf() {
	      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
	      return result;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
	     */
	    function isNative(value) {
	      return typeof value == 'function' && reNative.test(value);
	    }

	    /**
	     * Sets `this` binding data on a given function.
	     *
	     * @private
	     * @param {Function} func The function to set data on.
	     * @param {Array} value The data array to set.
	     */
	    var setBindData = !defineProperty ? noop : function(func, value) {
	      descriptor.value = value;
	      defineProperty(func, '__bindData__', descriptor);
	      descriptor.value = null;
	    };

	    /**
	     * A fallback implementation of `isPlainObject` which checks if a given value
	     * is an object created by the `Object` constructor, assuming objects created
	     * by the `Object` constructor have no inherited enumerable properties and that
	     * there are no `Object.prototype` extensions.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     */
	    function shimIsPlainObject(value) {
	      var ctor,
	          result;

	      // avoid non Object objects, `arguments` objects, and DOM elements
	      if (!(value && toString.call(value) == objectClass) ||
	          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
	          (!support.argsClass && isArguments(value)) ||
	          (!support.nodeClass && isNode(value))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      if (support.ownLast) {
	        forIn(value, function(value, key, object) {
	          result = hasOwnProperty.call(object, key);
	          return false;
	        });
	        return result !== false;
	      }
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      forIn(value, function(value, key) {
	        result = key;
	      });
	      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Used by `unescape` to convert HTML entities to characters.
	     *
	     * @private
	     * @param {string} match The matched character to unescape.
	     * @returns {string} Returns the unescaped character.
	     */
	    function unescapeHtmlChar(match) {
	      return htmlUnescapes[match];
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Checks if `value` is an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
	     * @example
	     *
	     * (function() { return _.isArguments(arguments); })(1, 2, 3);
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return value && typeof value == 'object' && typeof value.length == 'number' &&
	        toString.call(value) == argsClass || false;
	    }
	    // fallback for browsers that can't detect `arguments` objects by [[Class]]
	    if (!support.argsClass) {
	      isArguments = function(value) {
	        return value && typeof value == 'object' && typeof value.length == 'number' &&
	          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
	      };
	    }

	    /**
	     * Checks if `value` is an array.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
	     * @example
	     *
	     * (function() { return _.isArray(arguments); })();
	     * // => false
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     */
	    var isArray = nativeIsArray || function(value) {
	      return value && typeof value == 'object' && typeof value.length == 'number' &&
	        toString.call(value) == arrayClass || false;
	    };

	    /**
	     * A fallback implementation of `Object.keys` which produces an array of the
	     * given object's own enumerable property names.
	     *
	     * @private
	     * @type Function
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names.
	     */
	    var shimKeys = createIterator({
	      'args': 'object',
	      'init': '[]',
	      'top': 'if (!(objectTypes[typeof object])) return result',
	      'loop': 'result.push(index)'
	    });

	    /**
	     * Creates an array composed of the own enumerable property names of an object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names.
	     * @example
	     *
	     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      if (!isObject(object)) {
	        return [];
	      }
	      if ((support.enumPrototypes && typeof object == 'function') ||
	          (support.nonEnumArgs && object.length && isArguments(object))) {
	        return shimKeys(object);
	      }
	      return nativeKeys(object);
	    };

	    /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
	    var eachIteratorOptions = {
	      'args': 'collection, callback, thisArg',
	      'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
	      'array': "typeof length == 'number'",
	      'keys': keys,
	      'loop': 'if (callback(iterable[index], index, collection) === false) return result'
	    };

	    /** Reusable iterator options for `assign` and `defaults` */
	    var defaultsIteratorOptions = {
	      'args': 'object, source, guard',
	      'top':
	        'var args = arguments,\n' +
	        '    argsIndex = 0,\n' +
	        "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
	        'while (++argsIndex < argsLength) {\n' +
	        '  iterable = args[argsIndex];\n' +
	        '  if (iterable && objectTypes[typeof iterable]) {',
	      'keys': keys,
	      'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
	      'bottom': '  }\n}'
	    };

	    /** Reusable iterator options for `forIn` and `forOwn` */
	    var forOwnIteratorOptions = {
	      'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
	      'array': false
	    };

	    /**
	     * Used to convert characters to HTML entities:
	     *
	     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
	     * don't require escaping in HTML and have no special meaning unless they're part
	     * of a tag or an unquoted attribute value.
	     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
	     */
	    var htmlEscapes = {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#39;'
	    };

	    /** Used to convert HTML entities to characters */
	    var htmlUnescapes = invert(htmlEscapes);

	    /** Used to match HTML entities and HTML characters */
	    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
	        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

	    /**
	     * A function compiled to iterate `arguments` objects, arrays, objects, and
	     * strings consistenly across environments, executing the callback for each
	     * element in the collection. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index|key, collection). Callbacks may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @type Function
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createIterator(eachIteratorOptions);

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources will overwrite property assignments of previous
	     * sources. If a callback is provided it will be executed to produce the
	     * assigned values. The callback is bound to `thisArg` and invoked with two
	     * arguments; (objectValue, sourceValue).
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @alias extend
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param {Function} [callback] The function to customize assigning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
	     * // => { 'name': 'fred', 'employer': 'slate' }
	     *
	     * var defaults = _.partialRight(_.assign, function(a, b) {
	     *   return typeof a == 'undefined' ? b : a;
	     * });
	     *
	     * var object = { 'name': 'barney' };
	     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
	     * // => { 'name': 'barney', 'employer': 'slate' }
	     */
	    var assign = createIterator(defaultsIteratorOptions, {
	      'top':
	        defaultsIteratorOptions.top.replace(';',
	          ';\n' +
	          "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
	          '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
	          "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
	          '  callback = args[--argsLength];\n' +
	          '}'
	        ),
	      'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
	    });

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
	     * be cloned, otherwise they will be assigned by reference. If a callback
	     * is provided it will be executed to produce the cloned values. If the
	     * callback returns `undefined` cloning will be handled by the method instead.
	     * The callback is bound to `thisArg` and invoked with one argument; (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep=false] Specify a deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * var shallow = _.clone(characters);
	     * shallow[0] === characters[0];
	     * // => true
	     *
	     * var deep = _.clone(characters, true);
	     * deep[0] === characters[0];
	     * // => false
	     *
	     * _.mixin({
	     *   'clone': _.partialRight(_.clone, function(value) {
	     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
	     *   })
	     * });
	     *
	     * var clone = _.clone(document.body);
	     * clone.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, callback, thisArg) {
	      // allows working with "Collections" methods without using their `index`
	      // and `collection` arguments for `isDeep` and `callback`
	      if (typeof isDeep != 'boolean' && isDeep != null) {
	        thisArg = callback;
	        callback = isDeep;
	        isDeep = false;
	      }
	      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
	    }

	    /**
	     * Creates a deep clone of `value`. If a callback is provided it will be
	     * executed to produce the cloned values. If the callback returns `undefined`
	     * cloning will be handled by the method instead. The callback is bound to
	     * `thisArg` and invoked with one argument; (value).
	     *
	     * Note: This method is loosely based on the structured clone algorithm. Functions
	     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
	     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
	     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * var deep = _.cloneDeep(characters);
	     * deep[0] === characters[0];
	     * // => false
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'node': element
	     * };
	     *
	     * var clone = _.cloneDeep(view, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
	     * });
	     *
	     * clone.node == view.node;
	     * // => false
	     */
	    function cloneDeep(value, callback, thisArg) {
	      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
	    }

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties ? assign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional defaults of the same property will be ignored.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param- {Object} [guard] Allows working with `_.reduce` without using its
	     *  `key` and `object` arguments as sources.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * var object = { 'name': 'barney' };
	     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
	     * // => { 'name': 'barney', 'employer': 'slate' }
	     */
	    var defaults = createIterator(defaultsIteratorOptions);

	    /**
	     * This method is like `_.findIndex` except that it returns the key of the
	     * first element that passes the callback check, instead of the element itself.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [callback=identity] The function called per
	     *  iteration. If a property name or object is provided it will be used to
	     *  create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
	     * @example
	     *
	     * var characters = {
	     *   'barney': {  'age': 36, 'blocked': false },
	     *   'fred': {    'age': 40, 'blocked': true },
	     *   'pebbles': { 'age': 1,  'blocked': false }
	     * };
	     *
	     * _.findKey(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (property order is not guaranteed across environments)
	     *
	     * // using "_.where" callback shorthand
	     * _.findKey(characters, { 'age': 1 });
	     * // => 'pebbles'
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findKey(characters, 'blocked');
	     * // => 'fred'
	     */
	    function findKey(object, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forOwn(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result = key;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [callback=identity] The function called per
	     *  iteration. If a property name or object is provided it will be used to
	     *  create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
	     * @example
	     *
	     * var characters = {
	     *   'barney': {  'age': 36, 'blocked': true },
	     *   'fred': {    'age': 40, 'blocked': false },
	     *   'pebbles': { 'age': 1,  'blocked': true }
	     * };
	     *
	     * _.findLastKey(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
	     *
	     * // using "_.where" callback shorthand
	     * _.findLastKey(characters, { 'age': 40 });
	     * // => 'fred'
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findLastKey(characters, 'blocked');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forOwnRight(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result = key;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * Iterates over own and inherited enumerable properties of an object,
	     * executing the callback for each property. The callback is bound to `thisArg`
	     * and invoked with three arguments; (value, key, object). Callbacks may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * Shape.prototype.move = function(x, y) {
	     *   this.x += x;
	     *   this.y += y;
	     * };
	     *
	     * _.forIn(new Shape, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
	     */
	    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
	      'useHas': false
	    });

	    /**
	     * This method is like `_.forIn` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * Shape.prototype.move = function(x, y) {
	     *   this.x += x;
	     *   this.y += y;
	     * };
	     *
	     * _.forInRight(new Shape, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
	     */
	    function forInRight(object, callback, thisArg) {
	      var pairs = [];

	      forIn(object, function(value, key) {
	        pairs.push(key, value);
	      });

	      var length = pairs.length;
	      callback = baseCreateCallback(callback, thisArg, 3);
	      while (length--) {
	        if (callback(pairs[length--], pairs[length], object) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * Iterates over own enumerable properties of an object, executing the callback
	     * for each property. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, key, object). Callbacks may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	     *   console.log(key);
	     * });
	     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
	     */
	    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

	    /**
	     * This method is like `_.forOwn` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
	     */
	    function forOwnRight(object, callback, thisArg) {
	      var props = keys(object),
	          length = props.length;

	      callback = baseCreateCallback(callback, thisArg, 3);
	      while (length--) {
	        var key = props[length];
	        if (callback(object[key], key, object) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * Creates a sorted array of property names of all enumerable properties,
	     * own and inherited, of `object` that have function values.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names that have function values.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
	     */
	    function functions(object) {
	      var result = [];
	      forIn(object, function(value, key) {
	        if (isFunction(value)) {
	          result.push(key);
	        }
	      });
	      return result.sort();
	    }

	    /**
	     * Checks if the specified property name exists as a direct property of `object`,
	     * instead of an inherited property.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @param {string} key The name of the property to check.
	     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
	     * @example
	     *
	     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
	     * // => true
	     */
	    function has(object, key) {
	      return object ? hasOwnProperty.call(object, key) : false;
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of the given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the created inverted object.
	     * @example
	     *
	     * _.invert({ 'first': 'fred', 'second': 'barney' });
	     * // => { 'fred': 'first', 'barney': 'second' }
	     */
	    function invert(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        result[object[key]] = key;
	      }
	      return result;
	    }

	    /**
	     * Checks if `value` is a boolean value.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
	     * @example
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        value && typeof value == 'object' && toString.call(value) == boolClass || false;
	    }

	    /**
	     * Checks if `value` is a date.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     */
	    function isDate(value) {
	      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     */
	    function isElement(value) {
	      return value && value.nodeType === 1 || false;
	    }

	    /**
	     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
	     * length of `0` and objects with no own enumerable properties are considered
	     * "empty".
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({});
	     * // => true
	     *
	     * _.isEmpty('');
	     * // => true
	     */
	    function isEmpty(value) {
	      var result = true;
	      if (!value) {
	        return result;
	      }
	      var className = toString.call(value),
	          length = value.length;

	      if ((className == arrayClass || className == stringClass ||
	          (support.argsClass ? className == argsClass : isArguments(value))) ||
	          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
	        return !length;
	      }
	      forOwn(value, function() {
	        return (result = false);
	      });
	      return result;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent to each other. If a callback is provided it will be executed
	     * to compare values. If the callback returns `undefined` comparisons will
	     * be handled by the method instead. The callback is bound to `thisArg` and
	     * invoked with two arguments; (a, b).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} a The value to compare.
	     * @param {*} b The other value to compare.
	     * @param {Function} [callback] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * var copy = { 'name': 'fred' };
	     *
	     * object == copy;
	     * // => false
	     *
	     * _.isEqual(object, copy);
	     * // => true
	     *
	     * var words = ['hello', 'goodbye'];
	     * var otherWords = ['hi', 'goodbye'];
	     *
	     * _.isEqual(words, otherWords, function(a, b) {
	     *   var reGreet = /^(?:hello|hi)$/i,
	     *       aGreet = _.isString(a) && reGreet.test(a),
	     *       bGreet = _.isString(b) && reGreet.test(b);
	     *
	     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
	     * });
	     * // => true
	     */
	    function isEqual(a, b, callback, thisArg) {
	      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
	    }

	    /**
	     * Checks if `value` is, or can be coerced to, a finite number.
	     *
	     * Note: This is not the same as native `isFinite` which will return true for
	     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
	     * @example
	     *
	     * _.isFinite(-101);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => true
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite('');
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
	    }

	    /**
	     * Checks if `value` is a function.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     */
	    function isFunction(value) {
	      return typeof value == 'function';
	    }
	    // fallback for older versions of Chrome and Safari
	    if (isFunction(/x/)) {
	      isFunction = function(value) {
	        return typeof value == 'function' && toString.call(value) == funcClass;
	      };
	    }

	    /**
	     * Checks if `value` is the language type of Object.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // check if the value is the ECMAScript language type of Object
	      // http://es5.github.io/#x8
	      // and avoid a V8 bug
	      // http://code.google.com/p/v8/issues/detail?id=2291
	      return !!(value && objectTypes[typeof value]);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * Note: This is not the same as native `isNaN` which will return `true` for
	     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // `NaN` as a primitive is the only value that is not equal to itself
	      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(undefined);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is a number.
	     *
	     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4 * 5);
	     * // => true
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        value && typeof value == 'object' && toString.call(value) == numberClass || false;
	    }

	    /**
	     * Checks if `value` is an object created by the `Object` constructor.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * _.isPlainObject(new Shape);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     */
	    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
	        return false;
	      }
	      var valueOf = value.valueOf,
	          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

	      return objProto
	        ? (value == objProto || getPrototypeOf(value) == objProto)
	        : shimIsPlainObject(value);
	    };

	    /**
	     * Checks if `value` is a regular expression.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
	     * @example
	     *
	     * _.isRegExp(/fred/);
	     * // => true
	     */
	    function isRegExp(value) {
	      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
	    }

	    /**
	     * Checks if `value` is a string.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('fred');
	     * // => true
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        value && typeof value == 'object' && toString.call(value) == stringClass || false;
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     */
	    function isUndefined(value) {
	      return typeof value == 'undefined';
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through the callback.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     *
	     * var characters = {
	     *   'fred': { 'name': 'fred', 'age': 40 },
	     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.mapValues(characters, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 }
	     */
	    function mapValues(object, callback, thisArg) {
	      var result = {};
	      callback = lodash.createCallback(callback, thisArg, 3);

	      forOwn(object, function(value, key, object) {
	        result[key] = callback(value, key, object);
	      });
	      return result;
	    }

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * will overwrite property assignments of previous sources. If a callback is
	     * provided it will be executed to produce the merged values of the destination
	     * and source properties. If the callback returns `undefined` merging will
	     * be handled by the method instead. The callback is bound to `thisArg` and
	     * invoked with two arguments; (objectValue, sourceValue).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param {Function} [callback] The function to customize merging properties.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * var names = {
	     *   'characters': [
	     *     { 'name': 'barney' },
	     *     { 'name': 'fred' }
	     *   ]
	     * };
	     *
	     * var ages = {
	     *   'characters': [
	     *     { 'age': 36 },
	     *     { 'age': 40 }
	     *   ]
	     * };
	     *
	     * _.merge(names, ages);
	     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
	     *
	     * var food = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var otherFood = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(food, otherFood, function(a, b) {
	     *   return _.isArray(a) ? a.concat(b) : undefined;
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
	     */
	    function merge(object) {
	      var args = arguments,
	          length = 2;

	      if (!isObject(object)) {
	        return object;
	      }
	      // allows working with `_.reduce` and `_.reduceRight` without using
	      // their `index` and `collection` arguments
	      if (typeof args[2] != 'number') {
	        length = args.length;
	      }
	      if (length > 3 && typeof args[length - 2] == 'function') {
	        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
	      } else if (length > 2 && typeof args[length - 1] == 'function') {
	        callback = args[--length];
	      }
	      var sources = slice(arguments, 1, length),
	          index = -1,
	          stackA = getArray(),
	          stackB = getArray();

	      while (++index < length) {
	        baseMerge(object, sources[index], callback, stackA, stackB);
	      }
	      releaseArray(stackA);
	      releaseArray(stackB);
	      return object;
	    }

	    /**
	     * Creates a shallow clone of `object` excluding the specified properties.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If a callback is provided it will be executed for each
	     * property of `object` omitting the properties the callback returns truey
	     * for. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The source object.
	     * @param {Function|...string|string[]} [callback] The properties to omit or the
	     *  function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns an object without the omitted properties.
	     * @example
	     *
	     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
	     * // => { 'name': 'fred' }
	     *
	     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
	     *   return typeof value == 'number';
	     * });
	     * // => { 'name': 'fred' }
	     */
	    function omit(object, callback, thisArg) {
	      var result = {};
	      if (typeof callback != 'function') {
	        var props = [];
	        forIn(object, function(value, key) {
	          props.push(key);
	        });
	        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

	        var index = -1,
	            length = props.length;

	        while (++index < length) {
	          var key = props[index];
	          result[key] = object[key];
	        }
	      } else {
	        callback = lodash.createCallback(callback, thisArg, 3);
	        forIn(object, function(value, key, object) {
	          if (!callback(value, key, object)) {
	            result[key] = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Creates a two dimensional array of an object's key-value pairs,
	     * i.e. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
	     */
	    function pairs(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates a shallow clone of `object` composed of the specified properties.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If a callback is provided it will be executed for each
	     * property of `object` picking the properties the callback returns truey
	     * for. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The source object.
	     * @param {Function|...string|string[]} [callback] The function called per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns an object composed of the picked properties.
	     * @example
	     *
	     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
	     * // => { 'name': 'fred' }
	     *
	     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
	     *   return key.charAt(0) != '_';
	     * });
	     * // => { 'name': 'fred' }
	     */
	    function pick(object, callback, thisArg) {
	      var result = {};
	      if (typeof callback != 'function') {
	        var index = -1,
	            props = baseFlatten(arguments, true, false, 1),
	            length = isObject(object) ? props.length : 0;

	        while (++index < length) {
	          var key = props[index];
	          if (key in object) {
	            result[key] = object[key];
	          }
	        }
	      } else {
	        callback = lodash.createCallback(callback, thisArg, 3);
	        forIn(object, function(value, key, object) {
	          if (callback(value, key, object)) {
	            result[key] = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * An alternative to `_.reduce` this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable properties through a callback, with each callback execution
	     * potentially mutating the `accumulator` object. The callback is bound to
	     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
	     * Callbacks may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
	     *   num *= num;
	     *   if (num % 2) {
	     *     return result.push(num) < 3;
	     *   }
	     * });
	     * // => [1, 9, 25]
	     *
	     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	     *   result[key] = num * 3;
	     * });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function transform(object, callback, accumulator, thisArg) {
	      var isArr = isArray(object);
	      if (accumulator == null) {
	        if (isArr) {
	          accumulator = [];
	        } else {
	          var ctor = object && object.constructor,
	              proto = ctor && ctor.prototype;

	          accumulator = baseCreate(proto);
	        }
	      }
	      if (callback) {
	        callback = lodash.createCallback(callback, thisArg, 4);
	        (isArr ? baseEach : forOwn)(object, function(value, index, object) {
	          return callback(accumulator, value, index, object);
	        });
	      }
	      return accumulator;
	    }

	    /**
	     * Creates an array composed of the own enumerable property values of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property values.
	     * @example
	     *
	     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => [1, 2, 3] (property order is not guaranteed across environments)
	     */
	    function values(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements from the specified indexes, or keys, of the
	     * `collection`. Indexes may be specified as individual arguments or as arrays
	     * of indexes.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
	     *   to retrieve, specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns a new array of elements corresponding to the
	     *  provided indexes.
	     * @example
	     *
	     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
	     * // => ['a', 'c', 'e']
	     *
	     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
	     * // => ['fred', 'pebbles']
	     */
	    function at(collection) {
	      var args = arguments,
	          index = -1,
	          props = baseFlatten(args, true, false, 1),
	          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
	          result = Array(length);

	      if (support.unindexedChars && isString(collection)) {
	        collection = collection.split('');
	      }
	      while(++index < length) {
	        result[index] = collection[props[index]];
	      }
	      return result;
	    }

	    /**
	     * Checks if a given value is present in a collection using strict equality
	     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
	     * offset from the end of the collection.
	     *
	     * @static
	     * @memberOf _
	     * @alias include
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {*} target The value to check for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
	     * @example
	     *
	     * _.contains([1, 2, 3], 1);
	     * // => true
	     *
	     * _.contains([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.contains('pebbles', 'eb');
	     * // => true
	     */
	    function contains(collection, target, fromIndex) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = collection ? collection.length : 0,
	          result = false;

	      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
	      if (isArray(collection)) {
	        result = indexOf(collection, target, fromIndex) > -1;
	      } else if (typeof length == 'number') {
	        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
	      } else {
	        baseEach(collection, function(value) {
	          if (++index >= fromIndex) {
	            return !(result = value === target);
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through the callback. The corresponding value
	     * of each key is the number of times the key was returned by the callback.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
	    });

	    /**
	     * Checks if the given callback returns truey value for **all** elements of
	     * a collection. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if all elements passed the callback check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes']);
	     * // => false
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.every(characters, 'age');
	     * // => true
	     *
	     * // using "_.where" callback shorthand
	     * _.every(characters, { 'age': 36 });
	     * // => false
	     */
	    function every(collection, callback, thisArg) {
	      var result = true;
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          if (!(result = !!callback(collection[index], index, collection))) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          return (result = !!callback(value, index, collection));
	        });
	      }
	      return result;
	    }

	    /**
	     * Iterates over elements of a collection, returning an array of all elements
	     * the callback returns truey for. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of elements that passed the callback check.
	     * @example
	     *
	     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	     * // => [2, 4, 6]
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.filter(characters, 'blocked');
	     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
	     *
	     * // using "_.where" callback shorthand
	     * _.filter(characters, { 'age': 36 });
	     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
	     */
	    function filter(collection, callback, thisArg) {
	      var result = [];
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (callback(value, index, collection)) {
	            result.push(value);
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          if (callback(value, index, collection)) {
	            result.push(value);
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Iterates over elements of a collection, returning the first element that
	     * the callback returns truey for. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect, findWhere
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the found element, else `undefined`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': false },
	     *   { 'name': 'fred',    'age': 40, 'blocked': true },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
	     * ];
	     *
	     * _.find(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
	     *
	     * // using "_.where" callback shorthand
	     * _.find(characters, { 'age': 1 });
	     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
	     *
	     * // using "_.pluck" callback shorthand
	     * _.find(characters, 'blocked');
	     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
	     */
	    function find(collection, callback, thisArg) {
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (callback(value, index, collection)) {
	            return value;
	          }
	        }
	      } else {
	        var result;
	        baseEach(collection, function(value, index, collection) {
	          if (callback(value, index, collection)) {
	            result = value;
	            return false;
	          }
	        });
	        return result;
	      }
	    }

	    /**
	     * This method is like `_.find` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the found element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(num) {
	     *   return num % 2 == 1;
	     * });
	     * // => 3
	     */
	    function findLast(collection, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forEachRight(collection, function(value, index, collection) {
	        if (callback(value, index, collection)) {
	          result = value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * Iterates over elements of a collection, executing the callback for each
	     * element. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection). Callbacks may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * Note: As with other "Collections" methods, objects with a `length` property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
	     * // => logs each number and returns '1,2,3'
	     *
	     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
	     * // => logs each number and returns the object (property order is not guaranteed across environments)
	     */
	    function forEach(collection, callback, thisArg) {
	      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          if (callback(collection[index], index, collection) === false) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, callback, thisArg);
	      }
	      return collection;
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
	     * // => logs each number from right to left and returns '3,2,1'
	     */
	    function forEachRight(collection, callback, thisArg) {
	      var iterable = collection,
	          length = collection ? collection.length : 0;

	      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
	      if (isArray(collection)) {
	        while (length--) {
	          if (callback(collection[length], length, collection) === false) {
	            break;
	          }
	        }
	      } else {
	        if (typeof length != 'number') {
	          var props = keys(collection);
	          length = props.length;
	        } else if (support.unindexedChars && isString(collection)) {
	          iterable = collection.split('');
	        }
	        baseEach(collection, function(value, key, collection) {
	          key = props ? props[--length] : --length;
	          return callback(iterable[key], key, collection);
	        });
	      }
	      return collection;
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of a collection through the callback. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using "_.pluck" callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of the collection through the given callback. The corresponding
	     * value of each key is the last element responsible for generating the key.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keys = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keys, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method named by `methodName` on each element in the `collection`
	     * returning an array of the results of each invoked method. Additional arguments
	     * will be provided to each invoked method. If `methodName` is a function it
	     * will be invoked for, and `this` bound to, each element in the `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [arg] Arguments to invoke the method with.
	     * @returns {Array} Returns a new array of the results of each invoked method.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    function invoke(collection, methodName) {
	      var args = slice(arguments, 2),
	          index = -1,
	          isFunc = typeof methodName == 'function',
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      forEach(collection, function(value) {
	        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
	      });
	      return result;
	    }

	    /**
	     * Creates an array of values by running each element in the collection
	     * through the callback. The callback is bound to `thisArg` and invoked with
	     * three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of the results of each `callback` execution.
	     * @example
	     *
	     * _.map([1, 2, 3], function(num) { return num * 3; });
	     * // => [3, 6, 9]
	     *
	     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
	     * // => [3, 6, 9] (property order is not guaranteed across environments)
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.map(characters, 'name');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, callback, thisArg) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      callback = lodash.createCallback(callback, thisArg, 3);
	      if (isArray(collection)) {
	        while (++index < length) {
	          result[index] = callback(collection[index], index, collection);
	        }
	      } else {
	        baseEach(collection, function(value, key, collection) {
	          result[++index] = callback(value, key, collection);
	        });
	      }
	      return result;
	    }

	    /**
	     * Retrieves the maximum value of a collection. If the collection is empty or
	     * falsey `-Infinity` is returned. If a callback is provided it will be executed
	     * for each value in the collection to generate the criterion by which the value
	     * is ranked. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(characters, function(chr) { return chr.age; });
	     * // => { 'name': 'fred', 'age': 40 };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.max(characters, 'age');
	     * // => { 'name': 'fred', 'age': 40 };
	     */
	    function max(collection, callback, thisArg) {
	      var computed = -Infinity,
	          result = computed;

	      // allows working with functions like `_.map` without using
	      // their `index` argument as a callback
	      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
	        callback = null;
	      }
	      if (callback == null && isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (value > result) {
	            result = value;
	          }
	        }
	      } else {
	        callback = (callback == null && isString(collection))
	          ? charAtCallback
	          : lodash.createCallback(callback, thisArg, 3);

	        baseEach(collection, function(value, index, collection) {
	          var current = callback(value, index, collection);
	          if (current > computed) {
	            computed = current;
	            result = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Retrieves the minimum value of a collection. If the collection is empty or
	     * falsey `Infinity` is returned. If a callback is provided it will be executed
	     * for each value in the collection to generate the criterion by which the value
	     * is ranked. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(characters, function(chr) { return chr.age; });
	     * // => { 'name': 'barney', 'age': 36 };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.min(characters, 'age');
	     * // => { 'name': 'barney', 'age': 36 };
	     */
	    function min(collection, callback, thisArg) {
	      var computed = Infinity,
	          result = computed;

	      // allows working with functions like `_.map` without using
	      // their `index` argument as a callback
	      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
	        callback = null;
	      }
	      if (callback == null && isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (value < result) {
	            result = value;
	          }
	        }
	      } else {
	        callback = (callback == null && isString(collection))
	          ? charAtCallback
	          : lodash.createCallback(callback, thisArg, 3);

	        baseEach(collection, function(value, index, collection) {
	          var current = callback(value, index, collection);
	          if (current < computed) {
	            computed = current;
	            result = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Retrieves the value of a specified property from all elements in the collection.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {string} property The name of the property to pluck.
	     * @returns {Array} Returns a new array of property values.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(characters, 'name');
	     * // => ['barney', 'fred']
	     */
	    var pluck = map;

	    /**
	     * Reduces a collection to a value which is the accumulated result of running
	     * each element in the collection through the callback, where each successive
	     * callback execution consumes the return value of the previous execution. If
	     * `accumulator` is not provided the first element of the collection will be
	     * used as the initial `accumulator` value. The callback is bound to `thisArg`
	     * and invoked with four arguments; (accumulator, value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] Initial value of the accumulator.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var sum = _.reduce([1, 2, 3], function(sum, num) {
	     *   return sum + num;
	     * });
	     * // => 6
	     *
	     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	     *   result[key] = num * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function reduce(collection, callback, accumulator, thisArg) {
	      var noaccum = arguments.length < 3;
	      callback = lodash.createCallback(callback, thisArg, 4);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        if (noaccum) {
	          accumulator = collection[++index];
	        }
	        while (++index < length) {
	          accumulator = callback(accumulator, collection[index], index, collection);
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          accumulator = noaccum
	            ? (noaccum = false, value)
	            : callback(accumulator, value, index, collection)
	        });
	      }
	      return accumulator;
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] Initial value of the accumulator.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var list = [[0, 1], [2, 3], [4, 5]];
	     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, callback, accumulator, thisArg) {
	      var noaccum = arguments.length < 3;
	      callback = lodash.createCallback(callback, thisArg, 4);
	      forEachRight(collection, function(value, index, collection) {
	        accumulator = noaccum
	          ? (noaccum = false, value)
	          : callback(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The opposite of `_.filter` this method returns the elements of a
	     * collection that the callback does **not** return truey for.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of elements that failed the callback check.
	     * @example
	     *
	     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	     * // => [1, 3, 5]
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.reject(characters, 'blocked');
	     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
	     *
	     * // using "_.where" callback shorthand
	     * _.reject(characters, { 'age': 36 });
	     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
	     */
	    function reject(collection, callback, thisArg) {
	      callback = lodash.createCallback(callback, thisArg, 3);
	      return filter(collection, function(value, index, collection) {
	        return !callback(value, index, collection);
	      });
	    }

	    /**
	     * Retrieves a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Allows working with functions like `_.map`
	     *  without using their `index` arguments as `n`.
	     * @returns {Array} Returns the random sample(s) of `collection`.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (collection && typeof collection.length != 'number') {
	        collection = values(collection);
	      } else if (support.unindexedChars && isString(collection)) {
	        collection = collection.split('');
	      }
	      if (n == null || guard) {
	        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
	      }
	      var result = shuffle(collection);
	      result.length = nativeMin(nativeMax(0, n), result.length);
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the Fisher-Yates
	     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns a new shuffled collection.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4, 5, 6]);
	     * // => [4, 1, 6, 3, 5, 2]
	     */
	    function shuffle(collection) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      forEach(collection, function(value) {
	        var rand = baseRandom(0, ++index);
	        result[index] = result[rand];
	        result[rand] = value;
	      });
	      return result;
	    }

	    /**
	     * Gets the size of the `collection` by returning `collection.length` for arrays
	     * and array-like objects or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns `collection.length` or number of own enumerable properties.
	     * @example
	     *
	     * _.size([1, 2]);
	     * // => 2
	     *
	     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => 3
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? collection.length : 0;
	      return typeof length == 'number' ? length : keys(collection).length;
	    }

	    /**
	     * Checks if the callback returns a truey value for **any** element of a
	     * collection. The function returns as soon as it finds a passing value and
	     * does not iterate over the entire collection. The callback is bound to
	     * `thisArg` and invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if any element passed the callback check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.some(characters, 'blocked');
	     * // => true
	     *
	     * // using "_.where" callback shorthand
	     * _.some(characters, { 'age': 1 });
	     * // => false
	     */
	    function some(collection, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          if ((result = callback(collection[index], index, collection))) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          return !(result = callback(value, index, collection));
	        });
	      }
	      return !!result;
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through the callback. This method
	     * performs a stable sort, that is, it will preserve the original sort order
	     * of equal elements. The callback is bound to `thisArg` and invoked with
	     * three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an array of property names is provided for `callback` the collection
	     * will be sorted by each property value.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of sorted elements.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
	     * // => [3, 1, 2]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36 },
	     *   { 'name': 'fred',    'age': 40 },
	     *   { 'name': 'barney',  'age': 26 },
	     *   { 'name': 'fred',    'age': 30 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.map(_.sortBy(characters, 'age'), _.values);
	     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
	     *
	     * // sorting by multiple properties
	     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
	     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
	     */
	    function sortBy(collection, callback, thisArg) {
	      var index = -1,
	          isArr = isArray(callback),
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      if (!isArr) {
	        callback = lodash.createCallback(callback, thisArg, 3);
	      }
	      forEach(collection, function(value, key, collection) {
	        var object = result[++index] = getObject();
	        if (isArr) {
	          object.criteria = map(callback, function(key) { return value[key]; });
	        } else {
	          (object.criteria = getArray())[0] = callback(value, key, collection);
	        }
	        object.index = index;
	        object.value = value;
	      });

	      length = result.length;
	      result.sort(compareAscending);
	      while (length--) {
	        var object = result[length];
	        result[length] = object.value;
	        if (!isArr) {
	          releaseArray(object.criteria);
	        }
	        releaseObject(object);
	      }
	      return result;
	    }

	    /**
	     * Converts the `collection` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to convert.
	     * @returns {Array} Returns the new converted array.
	     * @example
	     *
	     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
	     * // => [2, 3, 4]
	     */
	    function toArray(collection) {
	      if (collection && typeof collection.length == 'number') {
	        return (support.unindexedChars && isString(collection))
	          ? collection.split('')
	          : slice(collection);
	      }
	      return values(collection);
	    }

	    /**
	     * Performs a deep comparison of each element in a `collection` to the given
	     * `properties` object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Object} props The object of property values to filter by.
	     * @returns {Array} Returns a new array of elements that have the given properties.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
	     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.where(characters, { 'age': 36 });
	     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
	     *
	     * _.where(characters, { 'pets': ['dino'] });
	     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
	     */
	    var where = filter;

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are all falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array excluding all values of the provided arrays using strict
	     * equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to process.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
	     * // => [1, 3, 4]
	     */
	    function difference(array) {
	      return baseDifference(array, baseFlatten(arguments, true, true, 1));
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element that passes the callback check, instead of the element itself.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': false },
	     *   { 'name': 'fred',    'age': 40, 'blocked': true },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
	     * ];
	     *
	     * _.findIndex(characters, function(chr) {
	     *   return chr.age < 20;
	     * });
	     * // => 2
	     *
	     * // using "_.where" callback shorthand
	     * _.findIndex(characters, { 'age': 36 });
	     * // => 0
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findIndex(characters, 'blocked');
	     * // => 1
	     */
	    function findIndex(array, callback, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0;

	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (++index < length) {
	        if (callback(array[index], index, array)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': true },
	     *   { 'name': 'fred',    'age': 40, 'blocked': false },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
	     * ];
	     *
	     * _.findLastIndex(characters, function(chr) {
	     *   return chr.age > 30;
	     * });
	     * // => 1
	     *
	     * // using "_.where" callback shorthand
	     * _.findLastIndex(characters, { 'age': 36 });
	     * // => 0
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findLastIndex(characters, 'blocked');
	     * // => 2
	     */
	    function findLastIndex(array, callback, thisArg) {
	      var length = array ? array.length : 0;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (length--) {
	        if (callback(array[length], length, array)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Gets the first element or first `n` elements of an array. If a callback
	     * is provided elements at the beginning of the array are returned as long
	     * as the callback returns truey. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head, take
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback] The function called
	     *  per element or the number of elements to return. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the first element(s) of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.first([1, 2, 3], function(num) {
	     *   return num < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.first(characters, 'blocked');
	     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
	     *
	     * // using "_.where" callback shorthand
	     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
	     * // => ['barney', 'fred']
	     */
	    function first(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;

	      if (typeof callback != 'number' && callback != null) {
	        var index = -1;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array ? array[0] : undefined;
	        }
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, n), length));
	    }

	    /**
	     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
	     * is truey, the array will only be flattened a single level. If a callback
	     * is provided each element of the array is passed through the callback before
	     * flattening. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, 4];
	     *
	     * _.flatten([1, [2], [3, [[4]]]], true);
	     * // => [1, 2, 3, [[4]]];
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
	     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.flatten(characters, 'pets');
	     * // => ['hoppy', 'baby puss', 'dino']
	     */
	    function flatten(array, isShallow, callback, thisArg) {
	      // juggle arguments
	      if (typeof isShallow != 'boolean' && isShallow != null) {
	        thisArg = callback;
	        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
	        isShallow = false;
	      }
	      if (callback != null) {
	        array = map(array, callback, thisArg);
	      }
	      return baseFlatten(array, isShallow);
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found using
	     * strict equality for comparisons, i.e. `===`. If the array is already sorted
	     * providing `true` for `fromIndex` will run a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value or `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 1
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 4
	     *
	     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      if (typeof fromIndex == 'number') {
	        var length = array ? array.length : 0;
	        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
	      } else if (fromIndex) {
	        var index = sortedIndex(array, value);
	        return array[index] === value ? index : -1;
	      }
	      return baseIndexOf(array, value, fromIndex);
	    }

	    /**
	     * Gets all but the last element or last `n` elements of an array. If a
	     * callback is provided elements at the end of the array are excluded from
	     * the result as long as the callback returns truey. The callback is bound
	     * to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback=1] The function called
	     *  per element or the number of elements to exclude. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.initial([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.initial([1, 2, 3], function(num) {
	     *   return num > 1;
	     * });
	     * // => [1]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.initial(characters, 'blocked');
	     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
	     *
	     * // using "_.where" callback shorthand
	     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
	     * // => ['barney', 'fred']
	     */
	    function initial(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;

	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = (callback == null || thisArg) ? 1 : callback || n;
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
	    }

	    /**
	     * Creates an array of unique values present in all provided arrays using
	     * strict equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of shared values.
	     * @example
	     *
	     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2]
	     */
	    function intersection() {
	      var args = [],
	          argsIndex = -1,
	          argsLength = arguments.length,
	          caches = getArray(),
	          indexOf = getIndexOf(),
	          trustIndexOf = indexOf === baseIndexOf,
	          seen = getArray();

	      while (++argsIndex < argsLength) {
	        var value = arguments[argsIndex];
	        if (isArray(value) || isArguments(value)) {
	          args.push(value);
	          caches.push(trustIndexOf && value.length >= largeArraySize &&
	            createCache(argsIndex ? args[argsIndex] : seen));
	        }
	      }
	      var array = args[0],
	          index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      outer:
	      while (++index < length) {
	        var cache = caches[0];
	        value = array[index];

	        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
	          argsIndex = argsLength;
	          (cache || seen).push(value);
	          while (--argsIndex) {
	            cache = caches[argsIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	      }
	      while (argsLength--) {
	        cache = caches[argsLength];
	        if (cache) {
	          releaseObject(cache);
	        }
	      }
	      releaseArray(caches);
	      releaseArray(seen);
	      return result;
	    }

	    /**
	     * Gets the last element or last `n` elements of an array. If a callback is
	     * provided elements at the end of the array are returned as long as the
	     * callback returns truey. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback] The function called
	     *  per element or the number of elements to return. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the last element(s) of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     *
	     * _.last([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.last([1, 2, 3], function(num) {
	     *   return num > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.pluck(_.last(characters, 'blocked'), 'name');
	     * // => ['fred', 'pebbles']
	     *
	     * // using "_.where" callback shorthand
	     * _.last(characters, { 'employer': 'na' });
	     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
	     */
	    function last(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;

	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array ? array[length - 1] : undefined;
	        }
	      }
	      return slice(array, nativeMax(0, length - n));
	    }

	    /**
	     * Gets the index at which the last occurrence of `value` is found using strict
	     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
	     * as the offset from the end of the collection.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value or `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 4
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var index = array ? array.length : 0;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from the given array using strict equality for
	     * comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to modify.
	     * @param {...*} [value] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull(array) {
	      var args = arguments,
	          argsIndex = 0,
	          argsLength = args.length,
	          length = array ? array.length : 0;

	      while (++argsIndex < argsLength) {
	        var index = -1,
	            value = args[argsIndex];
	        while (++index < length) {
	          if (array[index] === value) {
	            splice.call(array, index--, 1);
	            length--;
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to but not including `end`. If `start` is less than `stop` a
	     * zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns a new range array.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      start = +start || 0;
	      step = typeof step == 'number' ? step : (+step || 1);

	      if (end == null) {
	        end = start;
	        start = 0;
	      }
	      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
	      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
	      var index = -1,
	          length = nativeMax(0, ceil((end - start) / (step || 1))),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Removes all elements from an array that the callback returns truey for
	     * and returns an array of removed elements. The callback is bound to `thisArg`
	     * and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4, 5, 6];
	     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
	     *
	     * console.log(array);
	     * // => [1, 3, 5]
	     *
	     * console.log(evens);
	     * // => [2, 4, 6]
	     */
	    function remove(array, callback, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (callback(value, index, array)) {
	          result.push(value);
	          splice.call(array, index--, 1);
	          length--;
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.initial` this method gets all but the first element or
	     * first `n` elements of an array. If a callback function is provided elements
	     * at the beginning of the array are excluded from the result as long as the
	     * callback returns truey. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias drop, tail
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback=1] The function called
	     *  per element or the number of elements to exclude. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.rest([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.rest([1, 2, 3], function(num) {
	     *   return num < 3;
	     * });
	     * // => [3]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.pluck(_.rest(characters, 'blocked'), 'name');
	     * // => ['fred', 'pebbles']
	     *
	     * // using "_.where" callback shorthand
	     * _.rest(characters, { 'employer': 'slate' });
	     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
	     */
	    function rest(array, callback, thisArg) {
	      if (typeof callback != 'number' && callback != null) {
	        var n = 0,
	            index = -1,
	            length = array ? array.length : 0;

	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
	      }
	      return slice(array, n);
	    }

	    /**
	     * Uses a binary search to determine the smallest index at which a value
	     * should be inserted into a given sorted array in order to maintain the sort
	     * order of the array. If a callback is provided it will be executed for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * callback is bound to `thisArg` and invoked with one argument; (value).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([20, 30, 50], 40);
	     * // => 2
	     *
	     * // using "_.pluck" callback shorthand
	     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 2
	     *
	     * var dict = {
	     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
	     * };
	     *
	     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	     *   return dict.wordToNumber[word];
	     * });
	     * // => 2
	     *
	     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	     *   return this.wordToNumber[word];
	     * }, dict);
	     * // => 2
	     */
	    function sortedIndex(array, value, callback, thisArg) {
	      var low = 0,
	          high = array ? array.length : low;

	      // explicitly reference `identity` for better inlining in Firefox
	      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
	      value = callback(value);

	      while (low < high) {
	        var mid = (low + high) >>> 1;
	        (callback(array[mid]) < value)
	          ? low = mid + 1
	          : high = mid;
	      }
	      return low;
	    }

	    /**
	     * Creates an array of unique values, in order, of the provided arrays using
	     * strict equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of combined values.
	     * @example
	     *
	     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2, 3, 5, 4]
	     */
	    function union() {
	      return baseUniq(baseFlatten(arguments, true, true));
	    }

	    /**
	     * Creates a duplicate-value-free version of an array using strict equality
	     * for comparisons, i.e. `===`. If the array is sorted, providing
	     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
	     * each element of `array` is passed through the callback before uniqueness
	     * is computed. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Arrays
	     * @param {Array} array The array to process.
	     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([1, 2, 1, 3, 1]);
	     * // => [1, 2, 3]
	     *
	     * _.uniq([1, 1, 2, 2, 3], true);
	     * // => [1, 2, 3]
	     *
	     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
	     * // => ['A', 'b', 'C']
	     *
	     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
	     * // => [1, 2.5, 3]
	     *
	     * // using "_.pluck" callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, callback, thisArg) {
	      // juggle arguments
	      if (typeof isSorted != 'boolean' && isSorted != null) {
	        thisArg = callback;
	        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
	        isSorted = false;
	      }
	      if (callback != null) {
	        callback = lodash.createCallback(callback, thisArg, 3);
	      }
	      return baseUniq(array, isSorted, callback);
	    }

	    /**
	     * Creates an array excluding all provided values using strict equality for
	     * comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to filter.
	     * @param {...*} [value] The values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
	     * // => [2, 3, 4]
	     */
	    function without(array) {
	      return baseDifference(array, slice(arguments, 1));
	    }

	    /**
	     * Creates an array that is the symmetric difference of the provided arrays.
	     * See http://en.wikipedia.org/wiki/Symmetric_difference.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of values.
	     * @example
	     *
	     * _.xor([1, 2, 3], [5, 2, 1, 4]);
	     * // => [3, 5, 4]
	     *
	     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
	     * // => [1, 4, 5]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArray(array) || isArguments(array)) {
	          var result = result
	            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
	            : array;
	        }
	      }
	      return result || [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second
	     * elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @alias unzip
	     * @category Arrays
	     * @param {...Array} [array] Arrays to process.
	     * @returns {Array} Returns a new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    function zip() {
	      var array = arguments.length > 1 ? arguments : arguments[0],
	          index = -1,
	          length = array ? max(pluck(array, 'length')) : 0,
	          result = Array(length < 0 ? 0 : length);

	      while (++index < length) {
	        result[index] = pluck(array, index);
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed from arrays of `keys` and `values`. Provide
	     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
	     * or two arrays, one of `keys` and one of corresponding `values`.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Arrays
	     * @param {Array} keys The array of keys.
	     * @param {Array} [values=[]] The array of values.
	     * @returns {Object} Returns an object composed of the given keys and
	     *  corresponding values.
	     * @example
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(keys, values) {
	      var index = -1,
	          length = keys ? keys.length : 0,
	          result = {};

	      if (!values && length && !isArray(keys[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = keys[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a function that executes `func`, with  the `this` binding and
	     * arguments of the created function, only after being called `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {number} n The number of times the function must be called before
	     *  `func` is executed.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('Done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'Done saving!', after all saves have completed
	     */
	    function after(n, func) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that, when called, invokes `func` with the `this`
	     * binding of `thisArg` and prepends any additional `bind` arguments to those
	     * provided to the bound function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var func = function(greeting) {
	     *   return greeting + ' ' + this.name;
	     * };
	     *
	     * func = _.bind(func, { 'name': 'fred' }, 'hi');
	     * func();
	     * // => 'hi fred'
	     */
	    function bind(func, thisArg) {
	      return arguments.length > 2
	        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
	        : createWrapper(func, 1, null, null, thisArg);
	    }

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all the function properties
	     * of `object` will be bound.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...string} [methodName] The object method names to
	     *  bind, specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() { console.log('clicked ' + this.label); }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs', when the button is clicked
	     */
	    function bindAll(object) {
	      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
	          index = -1,
	          length = funcs.length;

	      while (++index < length) {
	        var key = funcs[index];
	        object[key] = createWrapper(object[key], 1, null, null, object);
	      }
	      return object;
	    }

	    /**
	     * Creates a function that, when called, invokes the method at `object[key]`
	     * and prepends any additional `bindKey` arguments to those provided to the bound
	     * function. This method differs from `_.bind` by allowing bound functions to
	     * reference methods that will be redefined or don't yet exist.
	     * See http://michaux.ca/articles/lazy-function-definition-pattern.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'name': 'fred',
	     *   'greet': function(greeting) {
	     *     return greeting + ' ' + this.name;
	     *   }
	     * };
	     *
	     * var func = _.bindKey(object, 'greet', 'hi');
	     * func();
	     * // => 'hi fred'
	     *
	     * object.greet = function(greeting) {
	     *   return greeting + 'ya ' + this.name + '!';
	     * };
	     *
	     * func();
	     * // => 'hiya fred!'
	     */
	    function bindKey(object, key) {
	      return arguments.length > 2
	        ? createWrapper(key, 19, slice(arguments, 2), null, object)
	        : createWrapper(key, 3, null, null, object);
	    }

	    /**
	     * Creates a function that is the composition of the provided functions,
	     * where each function consumes the return value of the function that follows.
	     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	     * Each function is executed with the `this` binding of the composed function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {...Function} [func] Functions to compose.
	     * @returns {Function} Returns the new composed function.
	     * @example
	     *
	     * var realNameMap = {
	     *   'pebbles': 'penelope'
	     * };
	     *
	     * var format = function(name) {
	     *   name = realNameMap[name.toLowerCase()] || name;
	     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
	     * };
	     *
	     * var greet = function(formatted) {
	     *   return 'Hiya ' + formatted + '!';
	     * };
	     *
	     * var welcome = _.compose(greet, format);
	     * welcome('pebbles');
	     * // => 'Hiya Penelope!'
	     */
	    function compose() {
	      var funcs = arguments,
	          length = funcs.length;

	      while (length--) {
	        if (!isFunction(funcs[length])) {
	          throw new TypeError;
	        }
	      }
	      return function() {
	        var args = arguments,
	            length = funcs.length;

	        while (length--) {
	          args = [funcs[length].apply(this, args)];
	        }
	        return args[0];
	      };
	    }

	    /**
	     * Creates a function which accepts one or more arguments of `func` that when
	     * invoked either executes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` can be specified
	     * if `func.length` is not sufficient.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var curried = _.curry(function(a, b, c) {
	     *   console.log(a + b + c);
	     * });
	     *
	     * curried(1)(2)(3);
	     * // => 6
	     *
	     * curried(1, 2)(3);
	     * // => 6
	     *
	     * curried(1, 2, 3);
	     * // => 6
	     */
	    function curry(func, arity) {
	      arity = typeof arity == 'number' ? arity : (+arity || func.length);
	      return createWrapper(func, 4, null, null, null, arity);
	    }

	    /**
	     * Creates a function that will delay the execution of `func` until after
	     * `wait` milliseconds have elapsed since the last time it was invoked.
	     * Provide an options object to indicate that `func` should be invoked on
	     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
	     * to the debounced function will return the result of the last `func` call.
	     *
	     * Note: If `leading` and `trailing` options are `true` `func` will be called
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to debounce.
	     * @param {number} wait The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
	     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * var lazyLayout = _.debounce(calculateLayout, 150);
	     * jQuery(window).on('resize', lazyLayout);
	     *
	     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * });
	     *
	     * // ensure `batchLog` is executed once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * source.addEventListener('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }, false);
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      wait = nativeMax(0, wait) || 0;
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = options.leading;
	        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }
	      var delayed = function() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0) {
	          if (maxTimeoutId) {
	            clearTimeout(maxTimeoutId);
	          }
	          var isCalled = trailingCall;
	          maxTimeoutId = timeoutId = trailingCall = undefined;
	          if (isCalled) {
	            lastCalled = now();
	            result = func.apply(thisArg, args);
	            if (!timeoutId && !maxTimeoutId) {
	              args = thisArg = null;
	            }
	          }
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      };

	      var maxDelayed = function() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (trailing || (maxWait !== wait)) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = null;
	          }
	        }
	      };

	      return function() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = null;
	        }
	        return result;
	      };
	    }

	    /**
	     * Defers executing the `func` function until the current call stack has cleared.
	     * Additional arguments will be provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to defer.
	     * @param {...*} [arg] Arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) { console.log(text); }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    function defer(func) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var args = slice(arguments, 1);
	      return setTimeout(function() { func.apply(undefined, args); }, 1);
	    }

	    /**
	     * Executes the `func` function after `wait` milliseconds. Additional arguments
	     * will be provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay execution.
	     * @param {...*} [arg] Arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) { console.log(text); }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    function delay(func, wait) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var args = slice(arguments, 2);
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it will be used to determine the cache key for storing the result
	     * based on the arguments provided to the memoized function. By default, the
	     * first argument provided to the memoized function is used as the cache key.
	     * The `func` is executed with the `this` binding of the memoized function.
	     * The result cache is exposed as the `cache` property on the memoized function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] A function used to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var fibonacci = _.memoize(function(n) {
	     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
	     * });
	     *
	     * fibonacci(9)
	     * // => 34
	     *
	     * var data = {
	     *   'fred': { 'name': 'fred', 'age': 40 },
	     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // modifying the result cache
	     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
	     * get('pebbles');
	     * // => { 'name': 'pebbles', 'age': 1 }
	     *
	     * get.cache.pebbles.name = 'penelope';
	     * get('pebbles');
	     * // => { 'name': 'penelope', 'age': 1 }
	     */
	    function memoize(func, resolver) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var memoized = function() {
	        var cache = memoized.cache,
	            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

	        return hasOwnProperty.call(cache, key)
	          ? cache[key]
	          : (cache[key] = func.apply(this, arguments));
	      }
	      memoized.cache = {};
	      return memoized;
	    }

	    /**
	     * Creates a function that is restricted to execute `func` once. Repeat calls to
	     * the function will return the value of the first call. The `func` is executed
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` executes `createApplication` once
	     */
	    function once(func) {
	      var ran,
	          result;

	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      return function() {
	        if (ran) {
	          return result;
	        }
	        ran = true;
	        result = func.apply(this, arguments);

	        // clear the `func` variable so the function may be garbage collected
	        func = null;
	        return result;
	      };
	    }

	    /**
	     * Creates a function that, when called, invokes `func` with any additional
	     * `partial` arguments prepended to those provided to the new function. This
	     * method is similar to `_.bind` except it does **not** alter the `this` binding.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) { return greeting + ' ' + name; };
	     * var hi = _.partial(greet, 'hi');
	     * hi('fred');
	     * // => 'hi fred'
	     */
	    function partial(func) {
	      return createWrapper(func, 16, slice(arguments, 1));
	    }

	    /**
	     * This method is like `_.partial` except that `partial` arguments are
	     * appended to those provided to the new function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
	     *
	     * var options = {
	     *   'variable': 'data',
	     *   'imports': { 'jq': $ }
	     * };
	     *
	     * defaultsDeep(options, _.templateSettings);
	     *
	     * options.variable
	     * // => 'data'
	     *
	     * options.imports
	     * // => { '_': _, 'jq': $ }
	     */
	    function partialRight(func) {
	      return createWrapper(func, 32, null, slice(arguments, 1));
	    }

	    /**
	     * Creates a function that, when executed, will only call the `func` function
	     * at most once per every `wait` milliseconds. Provide an options object to
	     * indicate that `func` should be invoked on the leading and/or trailing edge
	     * of the `wait` timeout. Subsequent calls to the throttled function will
	     * return the result of the last `func` call.
	     *
	     * Note: If `leading` and `trailing` options are `true` `func` will be called
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to throttle.
	     * @param {number} wait The number of milliseconds to throttle executions to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * var throttled = _.throttle(updatePosition, 100);
	     * jQuery(window).on('scroll', throttled);
	     *
	     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? options.leading : leading;
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }
	      debounceOptions.leading = leading;
	      debounceOptions.maxWait = wait;
	      debounceOptions.trailing = trailing;

	      return debounce(func, wait, debounceOptions);
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Additional arguments provided to the function are appended
	     * to those provided to the wrapper function. The wrapper is executed with
	     * the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('Fred, Wilma, & Pebbles');
	     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return createWrapper(wrapper, 16, [value]);
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * var getter = _.constant(object);
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Produces a callback bound to an optional `thisArg`. If `func` is a property
	     * name the created callback will return the property value for a given element.
	     * If `func` is an object the created callback will return `true` for elements
	     * that contain the equivalent object properties, otherwise it will return `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} [func=identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of the created callback.
	     * @param {number} [argCount] The number of arguments the callback accepts.
	     * @returns {Function} Returns a callback function.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
	     *   return !match ? func(callback, thisArg) : function(object) {
	     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(characters, 'age__gt38');
	     * // => [{ 'name': 'fred', 'age': 40 }]
	     */
	    function createCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (func == null || type == 'function') {
	        return baseCreateCallback(func, thisArg, argCount);
	      }
	      // handle "_.pluck" style callback shorthands
	      if (type != 'object') {
	        return property(func);
	      }
	      var props = keys(func),
	          key = props[0],
	          a = func[key];

	      // handle "_.where" style callback shorthands
	      if (props.length == 1 && a === a && !isObject(a)) {
	        // fast path the common case of providing an object with a single
	        // property containing a primitive value
	        return function(object) {
	          var b = object[key];
	          return a === b && (a !== 0 || (1 / a == 1 / b));
	        };
	      }
	      return function(object) {
	        var length = props.length,
	            result = false;

	        while (length--) {
	          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
	            break;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
	     * corresponding HTML entities.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} string The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('Fred, Wilma, & Pebbles');
	     * // => 'Fred, Wilma, &amp; Pebbles'
	     */
	    function escape(string) {
	      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Adds function properties of a source object to the destination object.
	     * If `object` is a function methods will be added to its prototype as well.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {Function|Object} [object=lodash] object The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
	     * @example
	     *
	     * function capitalize(string) {
	     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	     * }
	     *
	     * _.mixin({ 'capitalize': capitalize });
	     * _.capitalize('fred');
	     * // => 'Fred'
	     *
	     * _('fred').capitalize().value();
	     * // => 'Fred'
	     *
	     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
	     * _('fred').capitalize();
	     * // => 'Fred'
	     */
	    function mixin(object, source, options) {
	      var chain = true,
	          methodNames = source && functions(source);

	      if (!source || (!options && !methodNames.length)) {
	        if (options == null) {
	          options = source;
	        }
	        ctor = lodashWrapper;
	        source = object;
	        object = lodash;
	        methodNames = functions(source);
	      }
	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      var ctor = object,
	          isFunc = isFunction(ctor);

	      forEach(methodNames, function(methodName) {
	        var func = object[methodName] = source[methodName];
	        if (isFunc) {
	          ctor.prototype[methodName] = function() {
	            var chainAll = this.__chain__,
	                value = this.__wrapped__,
	                args = [value];

	            push.apply(args, arguments);
	            var result = func.apply(object, args);
	            if (chain || chainAll) {
	              if (value === result && isObject(result)) {
	                return this;
	              }
	              result = new ctor(result);
	              result.__chain__ = chainAll;
	            }
	            return result;
	          };
	        }
	      });
	    }

	    /**
	     * Reverts the '_' variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      context._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // no operation performed
	    }

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @example
	     *
	     * var stamp = _.now();
	     * _.defer(function() { console.log(_.now() - stamp); });
	     * // => logs the number of milliseconds it took for the deferred function to be called
	     */
	    var now = isNative(now = Date.now) && now || function() {
	      return new Date().getTime();
	    };

	    /**
	     * Converts the given value into an integer of the specified radix.
	     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
	     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
	     * implementations. See http://es5.github.io/#E.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} value The value to parse.
	     * @param {number} [radix] The radix used to interpret the value to parse.
	     * @returns {number} Returns the new integer value.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     */
	    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
	      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
	      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
	    };

	    /**
	     * Creates a "_.pluck" style function, which returns the `key` value of a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} key The name of the property to retrieve.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'fred',   'age': 40 },
	     *   { 'name': 'barney', 'age': 36 }
	     * ];
	     *
	     * var getName = _.property('name');
	     *
	     * _.map(characters, getName);
	     * // => ['barney', 'fred']
	     *
	     * _.sortBy(characters, getName);
	     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
	     */
	    function property(key) {
	      return function(object) {
	        return object[key];
	      };
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number will be
	     * returned. If `floating` is truey or either `min` or `max` are floats a
	     * floating-point number will be returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating=false] Specify returning a floating-point number.
	     * @returns {number} Returns a random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (typeof min == 'boolean' && noMax) {
	          floating = min;
	          min = 1;
	        }
	        else if (!noMax && typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /**
	     * Resolves the value of property `key` on `object`. If `key` is a function
	     * it will be invoked with the `this` binding of `object` and its result returned,
	     * else the property value is returned. If `object` is falsey then `undefined`
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {Object} object The object to inspect.
	     * @param {string} key The name of the property to resolve.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = {
	     *   'cheese': 'crumpets',
	     *   'stuff': function() {
	     *     return 'nonsense';
	     *   }
	     * };
	     *
	     * _.result(object, 'cheese');
	     * // => 'crumpets'
	     *
	     * _.result(object, 'stuff');
	     * // => 'nonsense'
	     */
	    function result(object, key) {
	      if (object) {
	        var value = object[key];
	        return isFunction(value) ? object[key]() : value;
	      }
	    }

	    /**
	     * A micro-templating method that handles arbitrary delimiters, preserves
	     * whitespace, and correctly escapes quotes within interpolated code.
	     *
	     * Note: In the development build, `_.template` utilizes sourceURLs for easier
	     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	     *
	     * For more information on precompiling templates see:
	     * https://lodash.com/custom-builds
	     *
	     * For more information on Chrome extension sandboxes see:
	     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} text The template text.
	     * @param {Object} data The data object used to populate the text.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as local variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [variable] The data object variable name.
	     * @returns {Function|string} Returns a compiled function when no `data` object
	     *  is given, else it returns the interpolated text.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= name %>');
	     * compiled({ 'name': 'fred' });
	     * // => 'hello fred'
	     *
	     * // using the "escape" delimiter to escape HTML in data property values
	     * _.template('<b><%- value %></b>', { 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to generate HTML
	     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
	     * _.template(list, { 'people': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
	     * _.template('hello ${ name }', { 'name': 'pebbles' });
	     * // => 'hello pebbles'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using a custom template delimiters
	     * _.templateSettings = {
	     *   'interpolate': /{{([\s\S]+?)}}/g
	     * };
	     *
	     * _.template('hello {{ name }}!', { 'name': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using the `imports` option to import jQuery
	     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
	     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     *   var __t, __p = '', __e = _.escape;
	     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
	     *   return __p;
	     * }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(text, data, options) {
	      // based on John Resig's `tmpl` implementation
	      // http://ejohn.org/blog/javascript-micro-templating/
	      // and Laura Doktorova's doT.js
	      // https://github.com/olado/doT
	      var settings = lodash.templateSettings;
	      text = String(text || '');

	      // avoid missing dependencies when `iteratorTemplate` is not defined
	      options = defaults({}, options, settings);

	      var imports = defaults({}, options.imports, settings.imports),
	          importsKeys = keys(imports),
	          importsValues = values(imports);

	      var isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // compile the regexp to match each delimiter
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // escape characters that cannot be included in string literals
	        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // replace delimiters with snippets
	        if (escapeValue) {
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // the JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value
	        return match;
	      });

	      source += "';\n";

	      // if `variable` is not specified, wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain
	      var variable = options.variable,
	          hasVariable = variable;

	      if (!hasVariable) {
	        variable = 'obj';
	        source = 'with (' + variable + ') {\n' + source + '\n}\n';
	      }
	      // cleanup code by stripping empty strings
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // frame code as the function body
	      source = 'function(' + variable + ') {\n' +
	        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
	        "var __t, __p = '', __e = _.escape" +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      // Use a sourceURL for easier debugging.
	      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

	      try {
	        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
	      } catch(e) {
	        e.source = source;
	        throw e;
	      }
	      if (data) {
	        return result(data);
	      }
	      // provide the compiled function's source by its `toString` method, in
	      // supported environments, or the `source` property as a convenience for
	      // inlining compiled templates during the build process
	      result.source = source;
	      return result;
	    }

	    /**
	     * Executes the callback `n` times, returning an array of the results
	     * of each callback execution. The callback is bound to `thisArg` and invoked
	     * with one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {number} n The number of times to execute the callback.
	     * @param {Function} callback The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns an array of the results of each `callback` execution.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) { mage.castSpell(n); });
	     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
	     *
	     * _.times(3, function(n) { this.cast(n); }, mage);
	     * // => also calls `mage.castSpell(n)` three times
	     */
	    function times(n, callback, thisArg) {
	      n = (n = +n) > -1 ? n : 0;
	      var index = -1,
	          result = Array(n);

	      callback = baseCreateCallback(callback, thisArg, 1);
	      while (++index < n) {
	        result[index] = callback(index);
	      }
	      return result;
	    }

	    /**
	     * The inverse of `_.escape` this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
	     * corresponding characters.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} string The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('Fred, Barney &amp; Pebbles');
	     * // => 'Fred, Barney & Pebbles'
	     */
	    function unescape(string) {
	      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return String(prefix == null ? '' : prefix) + id;
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps the given value with explicit
	     * method chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chaining
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36 },
	     *   { 'name': 'fred',    'age': 40 },
	     *   { 'name': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(characters)
	     *     .sortBy('age')
	     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
	     *     .first()
	     *     .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      value = new lodashWrapper(value);
	      value.__chain__ = true;
	      return value;
	    }

	    /**
	     * Invokes `interceptor` with the `value` as the first argument and then
	     * returns `value`. The purpose of this method is to "tap into" a method
	     * chain in order to perform operations on intermediate results within
	     * the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chaining
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3, 4])
	     *  .tap(function(array) { array.pop(); })
	     *  .reverse()
	     *  .value();
	     * // => [3, 2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chaining
	     * @returns {*} Returns the wrapper object.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(characters).first();
	     * // => { 'name': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(characters).chain()
	     *   .first()
	     *   .pick('age')
	     *   .value();
	     * // => { 'age': 36 }
	     */
	    function wrapperChain() {
	      this.__chain__ = true;
	      return this;
	    }

	    /**
	     * Produces the `toString` result of the wrapped value.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chaining
	     * @returns {string} Returns the string result.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return String(this.__wrapped__);
	    }

	    /**
	     * Extracts the wrapped value.
	     *
	     * @name valueOf
	     * @memberOf _
	     * @alias value
	     * @category Chaining
	     * @returns {*} Returns the wrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).valueOf();
	     * // => [1, 2, 3]
	     */
	    function wrapperValueOf() {
	      return this.__wrapped__;
	    }

	    /*--------------------------------------------------------------------------*/

	    // add functions that return wrapped values when chaining
	    lodash.after = after;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.chain = chain;
	    lodash.compact = compact;
	    lodash.compose = compose;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.createCallback = createCallback;
	    lodash.curry = curry;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.map = map;
	    lodash.mapValues = mapValues;
	    lodash.max = max;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.min = min;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.pull = pull;
	    lodash.range = range;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.shuffle = shuffle;
	    lodash.sortBy = sortBy;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.values = values;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;

	    // add aliases
	    lodash.collect = map;
	    lodash.drop = rest;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;
	    lodash.unzip = zip;

	    // add functions to `lodash.prototype`
	    mixin(lodash);

	    /*--------------------------------------------------------------------------*/

	    // add functions that return unwrapped values when chaining
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.contains = contains;
	    lodash.escape = escape;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.indexOf = indexOf;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isNaN = isNaN;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isUndefined = isUndefined;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.mixin = mixin;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.result = result;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.template = template;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;

	    // add aliases
	    lodash.all = every;
	    lodash.any = some;
	    lodash.detect = find;
	    lodash.findWhere = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.include = contains;
	    lodash.inject = reduce;

	    mixin(function() {
	      var source = {}
	      forOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }(), false);

	    /*--------------------------------------------------------------------------*/

	    // add functions capable of returning wrapped and unwrapped values when chaining
	    lodash.first = first;
	    lodash.last = last;
	    lodash.sample = sample;

	    // add aliases
	    lodash.take = first;
	    lodash.head = first;

	    forOwn(lodash, function(func, methodName) {
	      var callbackable = methodName !== 'sample';
	      if (!lodash.prototype[methodName]) {
	        lodash.prototype[methodName]= function(n, guard) {
	          var chainAll = this.__chain__,
	              result = func(this.__wrapped__, n, guard);

	          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
	            ? result
	            : new lodashWrapper(result, chainAll);
	        };
	      }
	    });

	    /*--------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = '2.4.2';

	    // add "Chaining" functions to the wrapper
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.value = wrapperValueOf;
	    lodash.prototype.valueOf = wrapperValueOf;

	    // add `Array` functions that return unwrapped values
	    baseEach(['join', 'pop', 'shift'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        var chainAll = this.__chain__,
	            result = func.apply(this.__wrapped__, arguments);

	        return chainAll
	          ? new lodashWrapper(result, chainAll)
	          : result;
	      };
	    });

	    // add `Array` functions that return the existing wrapped value
	    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        func.apply(this.__wrapped__, arguments);
	        return this;
	      };
	    });

	    // add `Array` functions that return new wrapped values
	    baseEach(['concat', 'slice', 'splice'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
	      };
	    });

	    // avoid array-like object bugs with `Array#shift` and `Array#splice`
	    // in IE < 9, Firefox < 10, Narwhal, and RingoJS
	    if (!support.spliceObjects) {
	      baseEach(['pop', 'shift', 'splice'], function(methodName) {
	        var func = arrayRef[methodName],
	            isSplice = methodName == 'splice';

	        lodash.prototype[methodName] = function() {
	          var chainAll = this.__chain__,
	              value = this.__wrapped__,
	              result = func.apply(value, arguments);

	          if (value.length === 0) {
	            delete value[0];
	          }
	          return (chainAll || isSplice)
	            ? new lodashWrapper(result, chainAll)
	            : result;
	        };
	      });
	    }

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // expose Lo-Dash
	  var _ = runInContext();

	  // some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose Lo-Dash to the global object even when an AMD loader is present in
	    // case Lo-Dash is loaded with a RequireJS shim config.
	    // See http://requirejs.org/docs/api.html#config-shim
	    root._ = _;

	    // define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // check for `exports` after `define` in case a build optimizer adds an `exports` object
	  else if (freeExports && freeModule) {
	    // in Node.js or RingoJS
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // in Narwhal or Rhino -require
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // in a browser or Rhino
	    root._ = _;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module), (function() { return this; }())))

/***/ },
/* 114 */
/***/ function(module, exports) {

	function Collection(numsOrObjects) {
	  var Type = this.type;

	  this.length = 0;

	  if (numsOrObjects) {
	    while (numsOrObjects.length) {
	      var numOrObject = numsOrObjects.shift();

	      if (!(numOrObject instanceof Type || numOrObject instanceof this.constructor)) {
	        numOrObject = new Type(numOrObject);
	      }
	      this.add(numOrObject);
	    }
	  }
	}

	Collection.prototype.add = function() {
	  var length = this.length;
	  var aLen = arguments.length;

	  for (var i = 0; i < aLen; i++) {
	    if (arguments[i] instanceof this.type || arguments[i] instanceof this.constructor) {
	      this[length++] = arguments[i];
	    }
	  }

	  return (this.length = length);
	};

	Collection.prototype.each = function(callbackFn) {
	  var length = this.length;

	  for (var i = 0; i < length; i++) {
	    callbackFn.call(this[i], this[i], i);
	  }

	  return this;
	};

	module.exports = Collection;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var lodash = __webpack_require__(113);

	var Fn = {
	    assign: lodash.assign,
	    extend: lodash.extend,
	    defaults: lodash.defaults,
	    debounce: lodash.debounce,
	    cloneDeep: lodash.cloneDeep,
	    mixin: lodash.mixin,
	    every: lodash.every,
	    pluck: lodash.pluck
	  };

	// Fn.fmap( val, fromLow, fromHigh, toLow, toHigh )
	//
	// Re-maps a number from one range to another.
	// Based on arduino map()
	//
	// Return float
	//
	Fn.fmap = function(value, fromLow, fromHigh, toLow, toHigh) {
	  return (value - fromLow) * (toHigh - toLow) /
	    (fromHigh - fromLow) + toLow;
	};

	// Alias
	Fn.fscale = Fn.fmap;

	// Fn.map( val, fromLow, fromHigh, toLow, toHigh )
	//
	// Re-maps a number from one range to another.
	// Based on arduino map()
	//
	// Retun int
	//
	Fn.map = function(value, fromLow, fromHigh, toLow, toHigh) {
	  return Fn.fmap(value, fromLow, fromHigh, toLow, toHigh) | 0;
	};

	// Alias
	Fn.scale = Fn.map;

	// Fn.constrain( val, lower, upper )
	//
	// Constrains a number to be within a range.
	// Based on arduino constrain()
	//
	Fn.constrain = function(value, lower, upper) {
	  return Math.min(upper, Math.max(lower, value));
	};

	// Fn.range( upper )
	// Fn.range( lower, upper )
	// Fn.range( lower, upper, tick )
	//
	// Returns a new array range
	//
	Fn.range = function(lower, upper, tick) {

	  if (arguments.length === 1) {
	    upper = lower - 1;
	    lower = 0;
	  }

	  lower = lower || 0;
	  upper = upper || 0;
	  tick = tick || 1;

	  var len = Math.max(Math.ceil((upper - lower) / tick), 0),
	    idx = 0,
	    range = [];

	  while (idx <= len) {
	    range[idx++] = lower;
	    lower += tick;
	  }

	  return range;
	};

	// Fn.range.prefixed( prefix, upper )
	// Fn.range.prefixed( prefix, lower, upper )
	// Fn.range.prefixed( prefix, lower, upper, tick )
	//
	// Returns a new array range, each value prefixed
	//
	Fn.range.prefixed = function(prefix) {
	  return Fn.range.apply(null, [].slice.call(arguments, 1)).map(function(val) {
	    return prefix + val;
	  });
	};

	// Fn.uid()
	//
	// Returns a reasonably unique id string
	//
	Fn.uid = function() {
	  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(chr) {
	    var rnd = Math.random() * 16 | 0;
	    return (chr === "x" ? rnd : (rnd & 0x3 | 0x8)).toString(16);
	  }).toUpperCase();
	};

	// Fn.square()
	//
	// Returns squared x
	//
	Fn.square = function(x) {
	  return x * x;
	};

	// Fn.sum( values )
	//
	// Returns the sum of all values from array
	//
	Fn.sum = function sum(values) {
	  var vals;
	  if (Array.isArray(values)) {
	    vals = values;
	  } else {
	    vals = [].slice.call(arguments);
	  }
	  return vals.reduce(function(accum, value) {
	    return accum + value;
	  }, 0);
	};

	// fma function
	// Copyright (c) 2012, Jens Nockert
	// All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are met:
	//
	//  1. Redistributions of source code must retain the above copyright notice,
	//     this list of conditions and the following disclaimer.
	//  2. Redistributions in binary form must reproduce the above copyright notice,
	//     this list of conditions and the following disclaimer in the documentation
	//     and/or other materials provided with the distribution.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
	// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	// POSSIBILITY OF SUCH DAMAGE.
	//
	Fn.fma = function(a, b, c) {
	  var aHigh = 134217729 * a;
	  var aLow;

	  aHigh = aHigh + (a - aHigh);
	  aLow = a - aHigh;

	  var bHigh = 134217729 * b;
	  var bLow;

	  bHigh = bHigh + (b - bHigh);
	  bLow = b - bHigh;

	  var r1 = a * b;
	  var r2 = -r1 + aHigh * bHigh + aHigh * bLow + aLow * bHigh + aLow * bLow;

	  var s = r1 + c;
	  var t = (r1 - (s - c)) + (c - (s - r1));

	  return s + (t + r2);
	};
	// end fma function copyright


	// Fn._BV(bit)
	//
	// (from avr/io.h; "BV" => Bit Value)
	//
	// Return byte value with that bit set.
	//
	Fn._BV = Fn.bitValue = Fn.bv = function(bit) {
	  return 1 << bit;
	};

	/*
	  Example of _BV/bitValue usage...

	  Logically OR these bits together:
	  var ORed = _BV(0) | _BV(2) | _BV(7);

	  BIT         7  6  5  4  3  2  1  0
	  ---------------------------------------------------------
	  _BV(0)  =   0  0  0  0  0  0  0  1
	  _BV(2)  =   0  0  0  0  0  1  0  0
	  _BV(7)  =   1  0  0  0  0  0  0  0
	  ORed    =   1  0  0  0  0  1  0  1

	  ORed === 133;

	*/


	// Fn.int16(high, low)

	Fn.int16 = function(high, low) {
	  var result = (high << 8) | low;

	  // if highest bit is on, it is negative
	  return result >> 15 ? ((result ^ 0xFFFF) + 1) * -1 : result;
	};

	Fn.uint16 = function(high, low) {
	  return (high << 8) | low;
	};

	Fn.int24 = function(high, low, xlow) {
	  var result = (high << 16) | (low << 8) | xlow;

	  // if highest bit is on, it is negative
	  return result >> 23 ? ((result ^ 0xFFFFFF) + 1) * -1 : result;
	};

	Fn.uint24 = function(high, low, xlow) {
	  return (high << 16) | (low << 8) | xlow;
	};


	module.exports = Fn;



/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var repl = __webpack_require__(117),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12);

	var priv = new Map();

	// Ported from
	// https://github.com/jgautier/firmata

	function Repl(opts) {
	  if (!Repl.isActive) {
	    Repl.isActive = true;

	    if (!(this instanceof Repl)) {
	      return new Repl(opts);
	    }

	    // Store context values in instance property
	    // this will be used for managing scope when
	    // injecting new values into an existing Repl
	    // session.
	    this.context = {};
	    this.ready = false;

	    var state = {
	      opts: opts,
	      board: opts.board,
	    };

	    priv.set(this, state);

	    // Store an accessible copy of the Repl instance
	    // on a static property. This is later used by the
	    // Board constructor to automattically setup Repl
	    // sessions for all programs, which reduces the
	    // boilerplate requirement.
	    Repl.ref = this;
	  } else {
	    return Repl.ref;
	  }
	}

	// Inherit event api
	util.inherits(Repl, events.EventEmitter);

	Repl.isActive = false;
	Repl.isBlocked = false;

	// See Repl.ref notes above.
	Repl.ref = null;

	Repl.prototype.initialize = function(callback) {
	  var state = priv.get(this);

	  process.stdin.resume();
	  process.stdin.setEncoding("utf8");

	  var replDefaults = {
	    prompt: ">> ",
	    useGlobal: false
	  };

	  // Call this immediately before repl.start to
	  // avoid crash on Intel Edison
	  state.board.info("Repl", "Initialized");

	  // Initialize the REPL session with the default
	  // repl settings.
	  // Assign the returned repl instance to "cmd"
	  var cmd = repl.start(replDefaults);

	  this.ready = true;

	  // Assign a reference to the REPL's "content" object
	  // This will be use later by the Repl.prototype.inject
	  // method for allowing user programs to inject their
	  // own explicit values and reference
	  this.cmd = cmd;
	  this.context = cmd.context;

	  cmd.on("exit", function() {
	    state.board.warn("Board", "Closing.");
	    process.reallyExit();
	  });

	  this.inject(state.opts);

	  if (callback) {
	    process.nextTick(callback);
	  }
	};

	Repl.prototype.close = function() {
	  this.cmd.emit("exit");
	};

	Repl.prototype.inject = function(obj) {
	  Object.keys(obj).forEach(function(key) {
	    Object.defineProperty(
	      this.context, key, Object.getOwnPropertyDescriptor(obj, key)
	    );
	  }, this);
	};

	module.exports = Repl;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 117 */
/***/ function(module, exports) {

	module.exports = repl;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(113);

	/**
	 * Options
	 *
	 * @param {String} arg Pin address.
	 * @param {Number} arg Pin address.
	 * @param {Array} arg List of Pin addresses.
	 *
	 * @return {Options} normalized board options instance.
	 */

	function Options(arg) {
	  if (!(this instanceof Options)) {
	    return new Options(arg);
	  }

	  var opts = {};

	  if (typeof arg === "number" ||
	    typeof arg === "string") {
	    opts.pin = arg;
	  } else if (Array.isArray(arg)) {
	    opts.pins = arg;
	  } else {
	    opts = arg;
	  }

	  _.assign(this, opts);
	}

	module.exports = Options;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var Options = __webpack_require__(118);

	var MODES = {
	  INPUT: 0x00,
	  OUTPUT: 0x01,
	  ANALOG: 0x02,
	  PWM: 0x03,
	  SERVO: 0x04
	};


	/**
	 * Pin Capability Signature Mapping
	 */

	var pinsToType = {
	  20: "UNO",
	  25: "LEONARDO",
	  70: "MEGA"
	};

	function Pins(board) {
	  if (!(this instanceof Pins)) {
	    return new Pins(board);
	  }

	  var io = board.io;
	  var pins = io.pins.slice();
	  var length = pins.length;
	  var type = pinsToType[length] || "OTHER";

	  board.type = type;

	  // Copy pin data to index
	  for (var i = 0; i < length; i++) {
	    this[i] = pins[i];
	  }

	  Object.defineProperties(this, {
	    type: {
	      value: type
	    },
	    length: {
	      value: length
	    }
	  });
	}

	Object.keys(MODES).forEach(function(mode) {
	  Object.defineProperty(Pins, mode, {
	    value: MODES[mode]
	  });
	});

	function isFirmata(board) {
	  return board.io.name === "Firmata" || board.io.name === "Mock";
	}

	function hasPins(opts) {
	  return typeof opts.pin !== "undefined" ||
	    (typeof opts.pins !== "undefined" && opts.pins.length);
	}

	Pins.isFirmata = isFirmata;

	Pins.Error = function(opts) {
	  throw new Error(
	    "Pin Error: " + opts.pin +
	    " is not a valid " + opts.type +
	    " pin (" + opts.via + ")"
	  );
	};

	var normalizers = new Map();

	Pins.normalize = function(opts, board) {
	  var type = board.pins.type;
	  var isArduino = isFirmata(board);
	  var normalizer = normalizers.get(board);
	  var isNormalizing;

	  if (typeof opts === "string" ||
	    typeof opts === "number" ||
	    Array.isArray(opts)) {

	    opts = new Options(opts);
	  }

	  if (!normalizer) {
	    isNormalizing = board.io && typeof board.io.normalize === "function";

	    normalizer = function(pin) {
	      return isArduino ?
	        Pins.fromAnalog(Pins.translate(pin, type)) :
	        (isNormalizing ? board.io.normalize(pin) : pin);
	    };

	    normalizers.set(board, normalizer);
	  }

	  // Auto-normalize pin values, this reduces boilerplate code
	  // inside module constructors
	  if (hasPins(opts)) {

	    // When an array of pins is present, attempt to
	    // normalize them if necessary
	    if (opts.pins) {
	      opts.pins = opts.pins.map(normalizer);
	    } else {
	      opts.pin = normalizer(opts.pin);
	    }
	  }

	  return opts;
	};

	Pins.normalize.clear = function() {
	  normalizers.clear();
	};

	// Special kit-centric pin translations
	Pins.translations = {
	  UNO: {
	    dtoa: {
	      14: "A0",
	      15: "A1",
	      16: "A2",
	      17: "A3",
	      18: "A4",
	      19: "A5"
	    },

	    // TinkerKit
	    tinker: {
	      I0: "A0",
	      I1: "A1",
	      I2: "A2",
	      I3: "A3",
	      I4: "A4",
	      I5: "A5",

	      O0: 11,
	      O1: 10,
	      O2: 9,
	      O3: 6,
	      O4: 5,
	      O5: 3,

	      D13: 13,
	      D12: 12,
	      D8: 8,
	      D7: 7,
	      D4: 4,
	      D2: 2
	    }
	  },
	  MEGA: {
	    dtoa: {
	      54: "A0",
	      55: "A1",
	      56: "A2",
	      57: "A3",
	      58: "A4",
	      59: "A5",
	      60: "A6",
	      61: "A7",
	      62: "A8",
	      63: "A9"
	    },

	    // TinkerKit
	    tinker: {
	      I0: "A0",
	      I1: "A1",
	      I2: "A2",
	      I3: "A3",
	      I4: "A4",
	      I5: "A5",
	      I6: "A6",
	      I7: "A7",
	      I8: "A8",
	      I9: "A9",

	      O0: 11,
	      O1: 10,
	      O2: 9,
	      O3: 6,
	      O4: 5,
	      O5: 3,

	      D13: 13,
	      D12: 12,
	      D8: 8,
	      D7: 7,
	      D4: 4,
	      D2: 2
	    }
	  }
	};

	Pins.translations.LEONARDO = Pins.translations.UNO;

	Pins.translate = function(pin, type) {
	  var translations = Pins.translations[type.toUpperCase()];

	  if (!translations) {
	    return pin;
	  }

	  return Object.keys(translations).reduce(function(pin, map) {
	    return translations[map][pin] || pin;
	  }, pin);
	};

	Pins.fromAnalog = function(pin) {
	  if (typeof pin === "string" && pin[0] === "A") {
	    return parseInt(pin.slice(1), 10);
	  }
	  return pin;
	};

	Pins.identity = function(pins, needle) {
	  return [].findIndex.call(pins, function(pin) {
	    return pin.name === needle || pin.id === needle || pin.port === needle;
	  });
	};

	/**
	 * (generated methods)
	 *
	 * Pins.prototype.isInput
	 * Pins.prototype.isOutput
	 * Pins.prototype.isAnalog
	 * Pins.prototype.isPwm
	 * Pins.prototype.isServo
	 *
	 */
	Object.keys(MODES).forEach(function(key) {
	  var name = key[0] + key.slice(1).toLowerCase();

	  Pins.prototype["is" + name] = function(pin) {
	    var attrs = this[pin] || this[Pins.identity(this, pin)];

	    if (attrs && attrs.supportedModes.includes(MODES[key])) {
	      return true;
	    }
	    return false;
	  };
	});

	Pins.prototype.isDigital = function(pin) {
	  var attrs = this[pin] || this[Pins.identity(this, pin)];

	  if (attrs && attrs.supportedModes.length) {
	    return true;
	  }
	  return false;
	};

	module.exports = Pins;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Derived and adapted from firmata/test/MockSerialPort.js

	var util = __webpack_require__(12),
	  events = __webpack_require__(8);

	var MockSerialPort = function(path) {
	  this.path = path;
	  this.isClosed = false;
	};

	util.inherits(MockSerialPort, events.EventEmitter);

	MockSerialPort.prototype.write = function() {
	};

	MockSerialPort.prototype.close = function() {
	  this.isClosed = true;
	};

	module.exports.SerialPort = MockSerialPort;

	var calls = 0;

	module.exports.list = function(callback) {
	  calls++;
	  process.nextTick(function() {
	    callback(null, calls === 2 ? [{comName: "/dev/usb"}] : []);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"board-io\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var util = __webpack_require__(12);
	// var Emitter = require("events").EventEmitter,
	var mockPins = __webpack_require__(122);

	function MockFirmata(opts) {
	  Board.call(this, {
	    quiet: true
	  });

	  opts = opts || {};

	  this.name = "Mock";

	  var pins = opts.pins || mockPins.UNO;

	  pins.forEach(function(pin) {
	    this._pins.push(pin);
	  }, this);

	  // set/override for special cases
	  // like AdvancedFirmata
	  for (var i in opts) {
	    this[i] = opts[i];
	  }

	  if (typeof opts.path === "string" && opts.write && opts.close) {
	    this.sp = this.transport = opts;
	  }
	}

	util.inherits(MockFirmata, Board);


	MockFirmata.prototype.servoConfig = function() {};
	MockFirmata.prototype.pingRead = MockFirmata.prototype.pulseIn;

	module.exports = MockFirmata;


/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports.UNOANALOG = [14, 15, 16, 17, 18, 19];

	module.exports.UNO = [{
	  name: "foo",
	  supportedModes: [],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  id: "bar",
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  port: "P9_22",
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 2, 4],
	  mode: 1,
	  value: 134,
	  report: 1,
	  analogChannel: 0
	}, {
	  supportedModes: [0, 1, 2, 4],
	  mode: 1,
	  value: 132,
	  report: 1,
	  analogChannel: 1
	}, {
	  supportedModes: [0, 1, 2, 4],
	  mode: 1,
	  value: 131,
	  report: 1,
	  analogChannel: 2
	}, {
	  supportedModes: [0, 1, 2, 4],
	  mode: 1,
	  value: 128,
	  report: 1,
	  analogChannel: 3
	}, {
	  supportedModes: [0, 1, 2, 4],
	  mode: 1,
	  value: 127,
	  report: 1,
	  analogChannel: 4
	}, {
	  supportedModes: [0, 1, 2, 4],
	  mode: 1,
	  value: 121,
	  report: 1,
	  analogChannel: 5
	}];


	module.exports.MEGA = [{
	  supportedModes: [],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 3, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1, 4],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  supportedModes: [0, 1],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 127
	}, {
	  id: "A0",
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 0
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 1
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 2
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 3
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 4
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 5
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 6
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 7
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 8
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 9
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 10
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 11
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 12
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 13
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 14
	}, {
	  supportedModes: [0, 1, 2],
	  mode: 1,
	  value: 0,
	  report: 1,
	  analogChannel: 15
	}];


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var __ = __webpack_require__(115);
	var Accelerometer = __webpack_require__(102);
	var Altimeter = __webpack_require__(124);
	var Barometer = __webpack_require__(125);
	var Hygrometer = __webpack_require__(126);
	var Temperature = __webpack_require__(127);
	var Gyro = __webpack_require__(128);
	var int16 = __.int16;
	var uint16 = __.uint16;
	var uint24 = __.uint24;

	var priv = new Map();
	var activeDrivers = new Map();

	var Drivers = {
	  // Based on the AdaFruit Arduino driver
	  // https://github.com/adafruit/Adafruit_HTU21DF_Library
	  // https://www.adafruit.com/products/1899
	  HTU21D: {
	    ADDRESSES: {
	      value: [0x40]
	    },
	    REGISTER: {
	      value: {
	        TEMPERATURE: 0xE3,
	        HUMIDITY: 0xE5
	      }
	    },
	    initialize: {
	      value: function(board, opts) {
	        var READLENGTH = 3;
	        var io = board.io;
	        var address = opts.address || this.ADDRESSES[0];

	        var computed = {
	          temperature: {},
	          humidity: {}
	        };

	        var readCycle = function(isTemp) {
	          var register = isTemp ? this.REGISTER.TEMPERATURE : this.REGISTER.HUMIDITY;

	          io.i2cReadOnce(address, register, READLENGTH, function(data) {
	            var value = uint16(data[0], data[1]);

	            if (isTemp) {
	              computed.temperature = value;
	            } else {
	              computed.humidity = value;
	              this.emit("data", computed);
	            }

	            readCycle(!isTemp);
	          }.bind(this));
	        }.bind(this);

	        io.i2cConfig(opts);

	        // Kick off "read loop"
	        //
	        readCycle(false);
	      }
	    },
	    identifier: {
	      value: function(opts) {
	        var address = opts.address || Drivers["HTU21D"].ADDRESSES.value[0];
	        return "htu-s1d-" + address;
	      }
	    }
	  },
	  // Based on the example code from
	  // http://playground.arduino.cc/Main/MPU-6050
	  // http://www.invensense.com/mems/gyro/mpu6050.html
	  MPU6050: {
	    ADDRESSES: {
	      value: [0x68, 0x69]
	    },
	    REGISTER: {
	      value: {
	        SETUP: [0x6B, 0x00], // += 250
	        READ: 0x3B
	      }
	    },
	    initialize: {
	      value: function(board, opts) {
	        var READLENGTH = 14;
	        var io = board.io;
	        var address = opts.address || this.ADDRESSES[0];

	        var computed = {
	          accelerometer: {},
	          temperature: {},
	          gyro: {}
	        };

	        io.i2cConfig(opts);
	        io.i2cWrite(address, this.REGISTER.SETUP);

	        io.i2cRead(address, this.REGISTER.READ, READLENGTH, function(data) {
	          computed.accelerometer = {
	            x: int16(data[0], data[1]),
	            y: int16(data[2], data[3]),
	            z: int16(data[4], data[5])
	          };

	          computed.temperature = int16(data[6], data[7]);

	          computed.gyro = {
	            x: int16(data[8], data[9]),
	            y: int16(data[10], data[11]),
	            z: int16(data[12], data[13])
	          };

	          this.emit("data", computed);
	        }.bind(this));
	      },
	    },
	    identifier: {
	      value: function(opts) {
	        var address = opts.address || Drivers["MPU6050"].ADDRESSES.value[0];
	        return "mpu-6050-" + address;
	      }
	    }
	  },
	  MPL115A2: {
	    ADDRESSES: {
	      value: [0x60]
	    },
	    REGISTER: {
	      value: {
	        COEFFICIENTS: 0x04,
	        READ: 0x00,
	        STARTCONVERSION: 0x12,
	      }
	    },
	    initialize: {
	      value: function(board, opts) {
	        var READLENGTH = 4;
	        var io = board.io;
	        var address = opts.address || this.ADDRESSES[0];

	        var cof = {
	          a0: null,
	          b1: null,
	          b2: null,
	          c12: null
	        };

	        io.i2cConfig(opts);

	        var pCoefficients = new Promise(function(resolve) {
	          io.i2cReadOnce(address, this.REGISTER.COEFFICIENTS, 8, function(data) {
	            var A0 = int16(data[0], data[1]);
	            var B1 = int16(data[2], data[3]);
	            var B2 = int16(data[4], data[5]);
	            var C12 = int16(data[6], data[7]) >> 2;

	            // Source:
	            // https://github.com/adafruit/Adafruit_MPL115A2
	            // a0 is the pressure offset coefficient
	            // b1 is the pressure sensitivity coefficient
	            // b2 is the temperature coefficient of offset (TCO)
	            // c12 is the temperature coefficient of sensitivity (TCS)
	            cof.a0 = A0 / 8;
	            cof.b1 = B1 / 8192;
	            cof.b2 = B2 / 16384;
	            cof.c12 = C12 / 4194304;

	            resolve();
	          }.bind(this));
	        }.bind(this));

	        pCoefficients.then(function() {
	          io.i2cWrite(address, [this.REGISTER.STARTCONVERSION, 0x00]);

	          io.i2cRead(address, this.REGISTER.READ, READLENGTH, function(data) {
	            var padc = uint16(data[0], data[1]) >> 6;
	            var tadc = uint16(data[2], data[3]) >> 6;

	            var pressure = cof.a0 + (cof.b1 + cof.c12 * tadc) * padc + cof.b2 * tadc;
	            var temperature = tadc;

	            this.emit("data", {
	              pressure: pressure,
	              temperature: temperature,
	            });
	          }.bind(this));
	        }.bind(this));
	      }
	    },
	    identifier: {
	      value: function(opts) {
	        var address = opts.address || Drivers["MPL115A2"].ADDRESSES.value[0];
	        return "mpl115a2-" + address;
	      }
	    }
	  },
	  // Based off of the AdaFruit Arduino library for this chip
	  // https://github.com/adafruit/Adafruit_MPL3115A2_Library
	  MPL3115A2: {
	    ADDRESSES: {
	      value: [0x60]
	    },
	    REGISTER: {
	      value: {
	        STATUS: 0x00,
	        PRESSURE_MSB: 0x01,
	        DATA_CONFIG: 0x13,
	        BAR_IN_MSB: 0x14,
	        BAR_IN_LSB: 0x15,
	        CONTROL: 0x26,
	      }
	    },
	    MASK: {
	      value: {
	        STATUS: {
	          PRESSURE_DATA_READ: 0x04
	        },
	        CONTROL: {
	          SBYB: 0x01,
	          OS128: 0x38,
	          ALTIMETER: 0x80,
	          PRESSURE: 0x00
	        },
	        DATA_CONFIG: {
	          TDEFE: 0x01,
	          PDEFE: 0x02,
	          DREM: 0x04
	        }
	      }
	    },
	    initialize: {
	      value: function(board, opts) {
	        var READLENGTH = 6;
	        var io = board.io;
	        var address = opts.address || this.ADDRESSES[0];
	        var elevation = null;
	        var offset = 0;
	        var isPressure = false;

	        // See http://www.henrylahr.com/?p=99 for implementation approach
	        //
	        var altNow = 0;
	        var computed = {
	          pressure: 0,
	          altitude: 0,
	          temperature: 0
	        };

	        if (typeof opts.elevation !== "undefined") {
	          elevation = opts.elevation;
	        }

	        if (elevation !== null && elevation <= 0) {
	          offset = Math.abs(elevation) + 1;
	          elevation = 1;
	        }

	        var waitForReady = function(next) {
	          io.i2cReadOnce(address, this.REGISTER.STATUS, 1, function(data) {
	            if (data[0] & this.MASK.STATUS.PRESSURE_DATA_READ) {
	              next();
	            } else {
	              setTimeout(function() {
	                waitForReady(next);
	              }, 100);
	            }
	          }.bind(this));
	        }.bind(this);

	        var readValues = function() {
	          var modeMask = isPressure ? this.MASK.CONTROL.PRESSURE : this.MASK.CONTROL.ALTIMETER;
	          var mode = this.MASK.CONTROL.SBYB | this.MASK.CONTROL.OS128 | modeMask;

	          io.i2cWrite(address, this.REGISTER.CONTROL, mode);

	          waitForReady(function() {
	            io.i2cReadOnce(address, this.REGISTER.PRESSURE_MSB, READLENGTH, function(data) {
	              var value = uint24(data[1], data[2], data[3]) >> 4;
	              var temperature = uint16(data[4], data[5]) >> 4;
	              var altVal;

	              computed.temperature = temperature;

	              if (isPressure) {
	                computed.pressure = value;
	                this.emit("data", computed);
	              } else {
	                var m = data[1];
	                var c = data[2];
	                var l = data[3];
	                var fl = (l >> 4) / 16;

	                altVal = (m << 8 | c) + fl;
	                altNow = (altNow * 3 + altVal) / 4;

	                computed.altitude = altNow - offset;
	              }

	              isPressure = !isPressure;

	              readValues();
	            }.bind(this));
	          }.bind(this));
	        }.bind(this);

	        var reads = [];
	        var calibrate = function() {
	          // Clear Oversampling and OST
	          io.i2cWrite(address, this.REGISTER.CONTROL, 0x3B);
	          io.i2cWrite(address, this.REGISTER.CONTROL, 0x39);

	          setTimeout(function() {
	            io.i2cReadOnce(address, this.REGISTER.PRESSURE_MSB, READLENGTH, function(data) {
	              var m = data[1];
	              var c = data[2];
	              var l = data[3];
	              var fl = (l >> 4) / 4;

	              reads.push((m << 10 | c << 2) + fl);

	              if (reads.length === 4) {
	                var curpress = (reads[0] + reads[1] + reads[2] + reads[3]) / 4;
	                var seapress = curpress / Math.pow(1 - elevation * 0.0000225577, 5.255877);

	                // Update Barometric input for Altitude
	                io.i2cWrite(address, this.REGISTER.BAR_IN_MSB, (seapress / 2) >> 8);
	                io.i2cWrite(address, this.REGISTER.BAR_IN_LSB, (seapress / 2) & 0xFF);

	                // Get into Altitude mode
	                // One shot & OST bit
	                io.i2cWrite(address, this.REGISTER.CONTROL, 0xBB);
	                io.i2cWrite(address, this.REGISTER.CONTROL, 0xB9);

	                setTimeout(function() {
	                  io.i2cReadOnce(address, this.REGISTER.PRESSURE_MSB, READLENGTH, function(data) {
	                    var m = data[1];
	                    var c = data[2];
	                    var l = data[3];
	                    var fl = (l >> 4) / 16;

	                    altNow = (m << 8 | c) + fl;

	                    readValues(false);
	                  });
	                }.bind(this), 550);

	              } else {
	                calibrate();
	              }
	            }.bind(this));
	          }.bind(this), 500);
	        }.bind(this);

	        io.i2cConfig(opts);

	        // configure the chip
	        // Set Altitude Offset.
	        io.i2cWriteReg(address, 0x2D, 0x00);

	        io.i2cWriteReg(address, this.REGISTER.BAR_IN_MSB, 0);
	        io.i2cWriteReg(address, this.REGISTER.BAR_IN_LSB, 0);

	        io.i2cWriteReg(address, this.REGISTER.DATA_CONFIG,
	          this.MASK.DATA_CONFIG.TDEFE |
	          this.MASK.DATA_CONFIG.PDEFE |
	          this.MASK.DATA_CONFIG.DREM);

	        if (elevation !== null) {
	          calibrate();
	        } else {
	          readValues();
	        }
	      }
	    },
	    identifier: {
	      value: function(opts) {
	        var address = opts.address || Drivers["MPL3115A2"].ADDRESSES.value[0];
	        return "mpl3115a2-" + address;
	      }
	    }
	  },
	  BMP180: {
	    ADDRESSES: {
	      value: [0x77]
	    },
	    REGISTER: {
	      value: {
	        COEFFICIENTS: 0xAA,
	        READ: 0x00,
	        READ_START: 0xF4,
	        READ_RESULT: 0xF6,
	      }
	    },
	    initialize: {
	      value: function(board, opts) {
	        var io = board.io;
	        var address = opts.address || this.ADDRESSES[0];

	        /**
	         * http://www.adafruit.com/datasheets/BST-BMP180-DS000-09.pdf
	         * Table 1: Operating conditions, output signal and mechanical characteristics
	         *
	         * Pressure Conversion Delay (ms)
	         *
	         * [
	         *   5,   LOW
	         *   8,   STANDARD
	         *   14,  HIGH
	         *   26,  ULTRA
	         *  ]
	         */

	        var mode = opts.mode || 3;
	        var kpDelay = [ 5, 8, 14, 26 ][ mode ];
	        var oss = __.constrain(mode, 0, 3);

	        var cof = {
	          a1: null,
	          a2: null,
	          a3: null,
	          a4: null,
	          a5: null,
	          a6: null,
	          b1: null,
	          b2: null,
	          b5: null,
	          mb: null,
	          mc: null,
	          md: null,
	        };

	        io.i2cConfig(opts);

	        var pCoefficients = new Promise(function(resolve) {
	          io.i2cReadOnce(address, this.REGISTER.COEFFICIENTS, 22, function(data) {
	            // http://www.adafruit.com/datasheets/BST-BMP180-DS000-09.pdf
	            // Pages 11, 15
	            // 3.3 Measurement of pressure and temperature
	            // 3.5 Calculating pressure and temperature
	            cof.a1 = int16(data[0], data[1]);
	            cof.a2 = int16(data[2], data[3]);
	            cof.a3 = int16(data[4], data[5]);
	            cof.a4 = uint16(data[6], data[7]);
	            cof.a5 = uint16(data[8], data[9]);
	            cof.a6 = uint16(data[10], data[11]);
	            cof.b1 = int16(data[12], data[13]);
	            cof.b2 = int16(data[14], data[15]);
	            cof.mb = int16(data[16], data[17]);
	            cof.mc = int16(data[18], data[19]);
	            cof.md = int16(data[20], data[21]);

	            resolve();
	          });
	        }.bind(this));

	        pCoefficients.then(function() {
	          var computed = {
	            pressure: null,
	            temperature: null,
	          };

	          var cycle = 0;

	          // http://www.adafruit.com/datasheets/BST-BMP180-DS000-09.pdf
	          // Pages 11, 15
	          // 3.3 Measurement of pressure and temperature
	          // 3.5 Calculating pressure and temperature
	          var readCycle = function() {

	            // cycle 0: temperature
	            // cycle 1: pressure

	            var isTemperatureCycle = cycle === 0;
	            var component = isTemperatureCycle ? 0x2E : 0x34 + (oss << 6);
	            var numBytes = isTemperatureCycle ? 2 : 3;
	            var delay = isTemperatureCycle ? 5 : kpDelay;


	            io.i2cWriteReg(address, this.REGISTER.READ_START, component);

	            // Once the READ_START register is set,
	            // delay the READ_RESULT request based on the
	            // mode value provided by the user, or default.
	            setTimeout(function() {
	              io.i2cReadOnce(address, this.REGISTER.READ_RESULT, numBytes, function(data) {
	                var compensated, uncompensated;
	                var x1, x2, x3, b3, b4, b6, b7, b6s, bx;

	                if (isTemperatureCycle) {
	                  // TEMPERATURE
	                  uncompensated = int16(data[0], data[1]);

	                  // Compute the true temperature
	                  x1 = ((uncompensated - cof.a6) * cof.a5) >> 15;
	                  x2 = ((cof.mc << 11) / (x1 + cof.md)) >> 0;

	                  // Compute b5, which is used by the pressure cycle
	                  cof.b5 = (x1 + x2) | 0;

	                  // Steps of 0.1C
	                  computed.temperature = ((cof.b5 + 8) >> 4) / 10;
	                } else {
	                  // PRESSURE
	                  uncompensated = uint24(data[0], data[1], data[2]) >> (8 - oss);

	                  b6 = cof.b5 - 4000;
	                  b6s = b6 * b6;
	                  bx = b6s >> 12;

	                  // Intermediary x1 & x2 to calculate x3 for b3
	                  x1 = (cof.b2 * bx) >> 11;
	                  x2 = (cof.a2 * b6) >> 11;
	                  x3 = x1 + x2;
	                  b3 = ((((cof.a1 * 4 + x3) << oss) + 2) / 4) >> 0;

	                  // Intermediary x1 & x2 to calculate x3 for b4
	                  x1 = (cof.a3 * b6) >> 13;
	                  x2 = (cof.b1 * bx) >> 16;
	                  x3 = ((x1 + x2) + 2) >> 2;
	                  b4 = (cof.a4 * (x3 + 32768)) >> 15;
	                  b7 = (uncompensated - b3) * (50000 >> oss);

	                  if (b7 < 0x80000000) {
	                    compensated = (b7 * 2) / b4;
	                  } else {
	                    compensated = (b7 / b4) * 2;
	                  }

	                  compensated >>= 0;

	                  x1 = (compensated >> 8) * (compensated >> 8);
	                  x1 = (x1 * 3038) >> 16;
	                  x2 = (-7357 * compensated) >> 16;

	                  compensated += (x1 + x2 + 3791) >> 4;

	                  // Steps of 1Pa (= 0.01hPa = 0.01mbar) (=> 0.001kPa)
	                  computed.pressure = compensated;
	                }

	                if (++cycle === 2) {
	                  cycle = 0;
	                  this.emit("data", computed);
	                }

	                readCycle();
	              }.bind(this));
	            }.bind(this), delay);
	          }.bind(this);

	          // Kick off "read loop"
	          //
	          readCycle();
	        }.bind(this));
	      }
	    },
	    identifier: {
	      value: function(opts) {
	        var address = opts.address || Drivers["BMP180"].ADDRESSES.value[0];
	        return "bmp180-" + address;
	      }
	    }
	  },
	  SI7020: {
	    ADDRESSES: {
	      value: [0x40]
	    },
	    REGISTER: {
	      value: {
	        HUMIDITY: 0xF5,
	        TEMPERATURE: 0xE3,
	      }
	    },
	    initialize: {
	      value: function(board, opts) {
	        var io = board.io;
	        var address = opts.address || this.ADDRESSES[0];

	        // The "no hold" measurement requires waiting
	        // _at least_ 22ms between register write and
	        // register read. Delay is measured in s:
	        // 22ms = 22000s; recommend 50ms = 50000s
	        opts.delay = 50000;

	        io.i2cConfig(opts);

	        // Reference
	        // https://www.silabs.com/Support%20Documents/TechnicalDocs/Si7020-A20.pdf
	        // P. 19
	        var computed = {
	          temperature: null
	        };

	        io.i2cRead(address, this.REGISTER.TEMPERATURE, 2, function(data) {
	          var raw = int16(data[0], data[1]);

	          // https://www.silabs.com/Support%20Documents/TechnicalDocs/Si7020-A20.pdf
	          // P. 23
	          computed.temperature = (175.25 * raw / 65536) - 46.85;

	          this.emit("data", computed);
	        }.bind(this));
	      }
	    },
	    identifier: {
	      value: function(opts) {
	        var address = opts.address || Drivers["SI7020"].ADDRESSES.value[0];
	        return "si7020-" + address;
	      }
	    },
	  }
	};

	// Otherwise known as...
	Drivers["MPU-6050"] = Drivers.MPU6050;

	Drivers.get = function(board, driverName, opts) {
	  var drivers, driverKey, driver;

	  if (!activeDrivers.has(board)) {
	    activeDrivers.set(board, {});
	  }

	  drivers = activeDrivers.get(board);

	  driverKey = Drivers[driverName].identifier.value(opts);

	  if (!drivers[driverKey]) {
	    driver = new Emitter();
	    Object.defineProperties(driver, Drivers[driverName]);
	    driver.initialize(board, opts);
	    drivers[driverKey] = driver;
	  }

	  return drivers[driverKey];
	};

	Drivers.clear = function() {
	  activeDrivers.clear();
	};

	var Controllers = {
	  /**
	   * MPU-6050 3-axis Gyro/Accelerometer and Temperature
	   *
	   * http://playground.arduino.cc/Main/MPU-6050
	   */

	  MPU6050: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.accelerometer = new Accelerometer(
	          Object.assign({
	            controller: "MPU6050",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.temperature = new Temperature(
	          Object.assign({
	            controller: "MPU6050",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.gyro = new Gyro(
	          Object.assign({
	            controller: "MPU6050",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );
	      }
	    },
	    components: {
	      value: ["accelerometer", "temperature", "gyro"]
	    },
	    accelerometer: {
	      get: function() {
	        return priv.get(this).accelerometer;
	      }
	    },
	    temperature: {
	      get: function() {
	        return priv.get(this).temperature;
	      }
	    },
	    gyro: {
	      get: function() {
	        return priv.get(this).gyro;
	      }
	    }
	  },
	  MPL115A2: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.barometer = new Barometer(
	          Object.assign({
	            controller: "MPL115A2",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.temperature = new Temperature(
	          Object.assign({
	            controller: "MPL115A2",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );
	      }
	    },
	    components: {
	      value: ["barometer", "temperature"]
	    },
	    barometer: {
	      get: function() {
	        return priv.get(this).barometer;
	      }
	    },
	    temperature: {
	      get: function() {
	        return priv.get(this).temperature;
	      }
	    }
	  },
	  HTU21D: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.hygrometer = new Hygrometer(
	          Object.assign({
	            controller: "HTU21D",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.temperature = new Temperature(
	          Object.assign({
	            controller: "HTU21D",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );
	      }
	    },
	    components: {
	      value: ["hygrometer", "temperature"]
	    },
	    hygrometer: {
	      get: function() {
	        return priv.get(this).hygrometer;
	        }
	    },
	    temperature: {
	      get: function() {
	        return priv.get(this).temperature;
	      }
	    }
	  },
	  MPL3115A2: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.barometer = new Barometer(
	          Object.assign({
	            controller: "MPL3115A2",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.altimeter = new Altimeter(
	          Object.assign({
	            controller: "MPL3115A2",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.temperature = new Temperature(
	          Object.assign({
	            controller: "MP3L115A2",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );
	      }
	    },
	    components: {
	      value: ["barometer", "altimeter", "temperature"]
	    },
	    barometer: {
	      get: function() {
	        return priv.get(this).barometer;
	      }
	    },
	    altimeter: {
	      get: function() {
	        return priv.get(this).altimeter;
	      }
	    },
	    temperature: {
	      get: function() {
	        return priv.get(this).temperature;
	      }
	    }
	  },
	  BMP180: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.barometer = new Barometer(
	          Object.assign({
	            controller: "BMP180",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );

	        state.temperature = new Temperature(
	          Object.assign({
	            controller: "BMP180",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );
	      }
	    },
	    components: {
	      value: ["barometer", "temperature", /* "altitude" */]
	    },
	    barometer: {
	      get: function() {
	        return priv.get(this).barometer;
	      }
	    },
	    temperature: {
	      get: function() {
	        return priv.get(this).temperature;
	      }
	    }
	  },
	  SI7020: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        // Eventually humidity will also be exposed.
	        state.temperature = new Temperature(
	          Object.assign({
	            controller: "SI7020",
	            freq: opts.freq,
	            board: this.board,
	          }, opts)
	        );
	      }
	    },
	    components: {
	      value: ["temperature"]
	    },
	    temperature: {
	      get: function() {
	        return priv.get(this).temperature;
	      }
	    }
	  }
	};

	// Otherwise known as...
	Controllers["MPU-6050"] = Controllers.MPU6050;
	Controllers["GY521"] = Controllers["GY-521"] = Controllers.MPU6050;

	function IMU(opts) {

	  if (!(this instanceof IMU)) {
	    return new IMU(opts);
	  }

	  var controller, state;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["MPU6050"];
	  }

	  this.freq = opts.freq || 500;

	  state = {};
	  priv.set(this, state);

	  Board.Controller.call(this, controller, opts);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts);
	  }

	  setInterval(function() {
	    this.emit("data", this);
	  }.bind(this), this.freq);

	  if (this.components && this.components.length > 0) {
	    this.components.forEach(function(component) {
	      if (!(this[component] instanceof Emitter)) {
	        return;
	      }

	      this[component].on("change", function() {
	        this.emit("change", this, component);
	      }.bind(this));
	    }, this);
	  }
	}

	util.inherits(IMU, Emitter);

	IMU.Drivers = Drivers;

	module.exports = IMU;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Emitter = __webpack_require__(8).EventEmitter,
	  util = __webpack_require__(12);

	var Controllers = {
	  MPL3115A2: {
	    requirements: {
	      value: {
	        options: {
	          elevation: {
	            throws: false,
	            message: "Missing `elevation` option. Without a specified base `elevation`, the altitude measurement will be inaccurate. Use the meters value shown on whatismyelevation.com",
	            typeof: "number",
	          }
	        }
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "MPL3115A2", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.altitude);
	        });
	      }
	    },
	    toMeters: {
	      value: function(raw) {
	        // formulas extracted from code example:
	        // https://github.com/adafruit/Adafruit_MPL3115A2_Library
	        return raw;
	      }
	    }
	  }
	};

	var priv = new Map();

	function Altimeter(opts) {
	  var controller, freq, last = 0, raw = 0;
	  var state = {};

	  if (!(this instanceof Altimeter)) {
	    return new Altimeter(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  freq = opts.freq || 25;


	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    throw new Error("Altimeter expects a valid controller");
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toMeters) {
	    this.toMeters = opts.toMeters || function(x) { return x; };
	  }

	  var propDescriptors = {
	    meters: {
	      get: function() {
	        return this.toMeters(raw);
	      }
	    },
	    feet: {
	      get: function() {
	        return this.meters * 3.28084;
	      }
	    }
	  };
	  // Convenience aliases
	  propDescriptors.m = propDescriptors.meters;
	  propDescriptors.ft = propDescriptors.feet;

	  Object.defineProperties(this, propDescriptors);

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === undefined) {
	      return;
	    }

	    var data = {};
	    data.m = data.meters = this.meters;
	    data.ft = data.feet = this.feet;

	    this.emit("data", data);

	    if (this.meters !== last) {
	      last = this.meters;
	      this.emit("change", data);
	    }
	  }.bind(this), freq);
	}

	util.inherits(Altimeter, Emitter);

	module.exports = Altimeter;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);


	var Controllers = {
	  MPL115A2: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "MPL115A2", opts);
	        driver.on("data", function(data) {
	          dataHandler.call(this, data.pressure);
	        }.bind(this));
	      }
	    },
	    // kPa (Kilopascals)
	    toPressure: {
	      value: function(raw) {
	        // http://cache.freescale.com/files/sensors/doc/data_sheet/MPL115A2.pdf
	        // P. 6, Eqn. 2
	        return ((65.0 / 1023.0) * raw) + 50.0;
	      }
	    }
	  },
	  MPL3115A2: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "MPL3115A2", opts);
	        driver.on("data", function(data) {
	          dataHandler.call(this, data.pressure);
	        }.bind(this));
	      }
	    },
	    // kPa (Kilopascals)
	    toPressure: {
	      value: function(raw) {
	        // formulas extracted from code example:
	        // https://github.com/adafruit/Adafruit_MPL3115A2_Library
	        var inches = (raw / 4) / 3377;
	        return inches * 3.39;
	      }
	    }
	  },
	  BMP180: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "BMP180", opts);
	        driver.on("data", function(data) {
	          dataHandler.call(this, data.pressure);
	        }.bind(this));
	      }
	    },
	    // kPa (Kilopascals)
	    toPressure: {
	      value: function(raw) {
	        return raw / 1000;
	      }
	    }
	  }
	};

	/**
	 * Barometer
	 * @constructor
	 *
	 * five.Barometer(opts);
	 *
	 * five.Barometer({
	 *   controller: "CONTROLLER"
	 *   address: 0x00
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Barometer(opts) {
	  if (!(this instanceof Barometer)) {
	    return new Barometer(opts);
	  }

	  var controller = null;
	  var last = null;
	  var raw = null;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  var freq = opts.freq || 25;

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    // controller = Controllers["ANALOG"];
	    throw new Error("Missing Barometer controller");
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toPressure) {
	    this.toPressure = opts.toPressure || function(raw) { return raw; };
	  }

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  Object.defineProperties(this, {
	    pressure: {
	      get: function() {
	        return this.toPressure(raw).toFixed(4);
	      }
	    }
	  });

	  setInterval(function() {
	    if (raw === null) {
	      return;
	    }

	    var data = {
	      pressure: this.pressure
	    };

	    this.emit("data", data);

	    if (this.pressure !== last) {
	      last = this.pressure;
	      this.emit("change", data);
	    }
	  }.bind(this), freq);
	}


	util.inherits(Barometer, Emitter);

	module.exports = Barometer;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Emitter = __webpack_require__(8).EventEmitter,
	  util = __webpack_require__(12);

	// References
	//
	var Controllers = {
	  HTU21D: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "HTU21D", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.humidity);
	        });
	      }
	    },
	    toRelativeHumidity: {
	      value: function(raw) {
	        // Based on the "Relative Humidity Conversion" formula
	        // https://www.adafruit.com/datasheets/1899_HTU21D.pdf
	        return (125.0*(raw/65536)) - 6;
	      }
	    }
	  }
	};

	var priv = new Map();

	function Hygrometer(opts) {
	  var controller, freq, last = 0, raw = 0;

	  if (!(this instanceof Hygrometer)) {
	    return new Hygrometer(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  freq = opts.freq || 25;

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    throw new Error("Missing Hygrometer controller");
	  }

	  priv.set(this, {});

	  Board.Controller.call(this, controller, opts);

	  if (!this.toRelativeHumidity) {
	    this.toRelativeHumidity = opts.toRelativeHumidity || function(x) { return x; };
	  }

	  var propDescriptors = {
	    relativeHumidity: {
	      get: function() {
	        return this.toRelativeHumidity(raw);
	      }
	    }
	  };
	  // Convenience aliases
	  propDescriptors.RH = propDescriptors.relativeHumidity;

	  Object.defineProperties(this, propDescriptors);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === undefined) {
	      return;
	    }

	    var data = {};
	    data.RH = data.relativeHumidity = this.relativeHumidity;

	    this.emit("data", data);

	    if (this.relativeHumidity !== last) {
	      last = this.relativeHumidity;
	      this.emit("change", data);
	    }
	  }.bind(this), freq);
	}

	util.inherits(Hygrometer, Emitter);

	module.exports = Hygrometer;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Emitter = __webpack_require__(8).EventEmitter,
	  util = __webpack_require__(12);

	var CELSIUS_TO_KELVIN = 273.15;

	function analogHandler(opts, dataHandler) {
	  var pin = opts.pin;

	  this.io.pinMode(pin, this.io.MODES.ANALOG);
	  this.io.analogRead(pin, function(data) {
	    dataHandler.call(this, data);
	  }.bind(this));
	}

	var activeDrivers = new Map();

	var Drivers = {
	  DS18B20: {
	    initialize: {
	      value: function(board, opts) {
	        var CONSTANTS = {
	          TEMPERATURE_FAMILY: 0x28,
	          CONVERT_TEMPERATURE_COMMAND: 0x44,
	          READ_SCRATCHPAD_COMMAND: 0xBE,
	          READ_COUNT: 2
	        },
	          pin = opts.pin,
	          freq = opts.freq || 100,
	          getAddress, readTemperature, readOne;

	        getAddress = function(device) {
	          // 64-bit device code
	          // device[0]    => Family Code
	          // device[1..6] => Serial Number (device[1] is LSB)
	          // device[7]    => CRC
	          var i, result = 0;
	          for (i = 6; i > 0; i--) {
	            result = result * 256 + device[i];
	          }
	          return result;
	        };

	        board.io.sendOneWireConfig(pin, true);
	        board.io.sendOneWireSearch(pin, function(err, devices) {
	          if (err) {
	            this.emit("error", err);
	            return;
	          }

	          this.devices = devices.filter(function(device) {
	            return device[0] === CONSTANTS.TEMPERATURE_FAMILY;
	          }, this);

	          if (devices.length === 0) {
	            this.emit("error", new Error("FAILED TO FIND TEMPERATURE DEVICE"));
	            return;
	          }

	          this.devices.forEach(function(device) {
	            this.emit("initialized", getAddress(device));
	          }.bind(this));

	          readTemperature = function() {
	            var devicesToRead, result;

	            // request tempeature conversion
	            if (this.addresses) {
	              devicesToRead = this.devices.filter(function(device) {
	                var address = getAddress(device);
	                return this.addresses.includes(address);
	              }, this);
	            } else {
	              devicesToRead = [this.devices[0]];
	            }

	            devicesToRead.forEach(function(device) {
	              board.io.sendOneWireReset(pin);
	              board.io.sendOneWireWrite(pin, device, CONSTANTS.CONVERT_TEMPERATURE_COMMAND);
	            });

	            // the delay gives the sensor time to do the calculation
	            board.io.sendOneWireDelay(pin, 1);

	            readOne = function() {
	              var device;

	              if (devicesToRead.length === 0) {
	                setTimeout(readTemperature, freq);
	                return;
	              }

	              device = devicesToRead.pop();
	              // read from the scratchpad
	              board.io.sendOneWireReset(pin);

	              board.io.sendOneWireWriteAndRead(pin, device, CONSTANTS.READ_SCRATCHPAD_COMMAND, CONSTANTS.READ_COUNT, function(err, data) {
	                if (err) {
	                  this.emit("error", err);
	                  return;
	                }

	                result = (data[1] << 8) | data[0];
	                this.emit("data", getAddress(device), result);

	                readOne();
	              }.bind(this));
	            }.bind(this);

	            readOne();
	          }.bind(this);

	          readTemperature();
	        }.bind(this));
	      }
	    },
	    register: {
	      value: function(address) {
	        if (!this.addresses) {
	          this.addresses = [];
	        }

	        this.addresses.push(address);
	      }
	    }
	  }
	};

	Drivers.get = function(board, driverName, opts) {
	  var drivers, driver;

	  if (!activeDrivers.has(board)) {
	    activeDrivers.set(board, {});
	  }

	  drivers = activeDrivers.get(board);

	  if (!drivers[driverName]) {
	    driver = new Emitter();
	    Object.defineProperties(driver, Drivers[driverName]);
	    driver.initialize(board, opts);
	    drivers[driverName] = driver;
	  }

	  return drivers[driverName];
	};

	Drivers.clear = function() {
	  activeDrivers.clear();
	};

	// References
	//
	var Controllers = {
	  ANALOG: {
	    initialize: {
	      value: analogHandler
	    }
	  },
	  LM35: {
	    initialize: {
	      value: analogHandler
	    },
	    toCelsius: {
	      value: function(raw) {
	        // http://www.ti.com/lit/ds/symlink/lm35.pdf
	        // VOUT = 1500 mV at 150C
	        // VOUT = 250 mV at 25C
	        // VOUT = 550 mV at 55C

	        var mV = this.aref * 1000 * raw / 1024;

	        // 10mV = 1C
	        return mV / 10;
	      }
	    }
	  },
	  LM335: {
	    initialize: {
	      value: analogHandler
	    },
	    toCelsius: {
	      value: function(raw) {
	        // http://www.ti.com/lit/ds/symlink/lm335.pdf
	        // OUTPUT 10mV/K

	        var mV = this.aref * 1000 * raw / 1024;

	        return (mV / 10) - CELSIUS_TO_KELVIN;
	      }
	    }
	  },

	  //https://www.sparkfun.com/products/10988
	  TMP36: {
	    initialize: {
	      value: analogHandler
	    },
	    toCelsius: {
	      value: function(raw) {
	        // Analog Reference Voltage
	        var mV = this.aref * 1000 * raw / 1024;

	        // tempC = (mV / 10) - 50
	        return (mV / 10) - 50;
	      }
	    }
	  },

	  TMP102: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        this.io.i2cConfig(opts);

	        // http://www.ti.com/lit/ds/sbos397b/sbos397b.pdf
	        // Addressing is unclear.

	        this.io.i2cRead(0x48, 0x00, 2, function(data) {
	          // Based on the example code from https://www.sparkfun.com/products/11931
	          var raw = ((data[0] << 8) | data[1]) >> 4;

	          // The tmp102 does twos compliment but has the negative bit in the wrong spot, so test for it and correct if needed
	          if (raw & (1 << 11)) {
	            raw |= 0xF800; // Set bits 11 to 15 to 1s to get this reading into real twos compliment
	          }

	          // twos compliment
	          raw = raw >> 15 ? ((raw ^ 0xFFFF) + 1) * -1 : raw;

	          dataHandler(raw);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        return raw / 16;
	      }
	    },
	  },
	  // Based on code from Westin Pigott:
	  //    https://github.com/westinpigott/one-wire-temps
	  // And the datasheet:
	  //    http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf
	  // OneWire protocol.  The device needs to be issued a "Convert Temperature"
	  // command which can take up to 10 microseconds to compute, so we need
	  // tell the board to delay 1 millisecond before issuing the "Read Scratchpad" command
	  //
	  // This device requires the OneWire support enabled via ConfigurableFirmata
	  DS18B20: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this),
	          address = opts.address,
	          driver = Drivers.get(this.board, "DS18B20", opts);

	        if (address) {
	          state.address = address;
	          driver.register(address);
	        } else {
	          if (driver.addressless) {
	            this.emit("error", "You cannot have more than one DS18B20 without an address");
	          }
	          driver.addressless = true;
	        }

	        driver.once("initialized", function(dataAddress) {
	          if (!state.address) {
	            state.address = dataAddress;
	          }
	        });

	        driver.on("data", function(dataAddress, data) {
	          if (!address || dataAddress === address) {
	            dataHandler(data);
	          }
	        }.bind(this));
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        return raw / 16.0;
	      }
	    },
	    address: {
	      get: function() {
	        return priv.get(this).address || 0x00;
	      }
	    }
	  },
	  HTU21D: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "HTU21D", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.temperature);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        // Based on the "Temperature Conversion" formula
	        // https://www.adafruit.com/datasheets/1899_HTU21D.pdf
	        return (175.25*raw/65536)-46.85;
	      }
	    }
	  },
	  //http://playground.arduino.cc/Main/MPU-6050
	  MPU6050: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var IMU = __webpack_require__(123);
	        var driver = IMU.Drivers.get(this.board, "MPU6050", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.temperature);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        return (raw / 340.00) + 36.53;
	      }
	    }
	  },
	  MPL115A2: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "MPL115A2", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.temperature);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        // Source:
	        // https://github.com/adafruit/Adafruit_MPL115A2
	        return (raw - 498) / -5.35 + 25.0;
	      }
	    }
	  },
	  MPL3115A2: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "MPL3115A2", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.temperature);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        // formulas extracted from code example:
	        // https://github.com/adafruit/Adafruit_MPL3115A2_Library
	        return raw / 16;
	      }
	    }
	  },
	  GROVE: {
	    initialize: {
	      value: analogHandler
	    },
	    toCelsius: {
	      value: function(raw) {
	        // http://www.seeedstudio.com/wiki/Grove_-_Temperature_Sensor
	        var adcres = 1023;
	        // Beta parameter
	        var beta = 3975;
	        // 10 kOhm (sensor resistance)
	        var rb = 10000;
	        // Ginf = 1/Rinf
	        // var ginf = 120.6685;
	        // Reference Temperature 25C
	        var tempr = 298.15;

	        var rthermistor = (adcres - raw) * rb / raw;
	        var tempc = 1 / (Math.log(rthermistor / rb) / beta + 1 / tempr) - CELSIUS_TO_KELVIN;

	        return tempc;
	      }
	    }
	  },
	  TINKERKIT: {
	    initialize: {
	      value: analogHandler
	    },
	    toCelsius: {
	      value: function(raw) {
	        var adcres = 1023;
	        var beta = 3950;
	        var rb = 10000; // 10 kOhm
	        var ginf = 120.6685; // Ginf = 1/Rinf

	        var rthermistor = rb * (adcres / raw - 1);
	        var tempc = beta / (Math.log(rthermistor * ginf));

	        return tempc - CELSIUS_TO_KELVIN;
	      }
	    }
	  },
	  BMP180: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "BMP180", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.temperature);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	  SI7020: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var Multi = __webpack_require__(123);
	        var driver = Multi.Drivers.get(this.board, "SI7020", opts);
	        driver.on("data", function(data) {
	          dataHandler(data.temperature);
	        });
	      }
	    },
	    toCelsius: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	};

	// Otherwise known as...
	Controllers["MPU-6050"] = Controllers.MPU6050;

	var priv = new Map();

	function Temperature(opts) {
	  var controller, freq, last = 0, raw;

	  if (!(this instanceof Temperature)) {
	    return new Temperature(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  freq = opts.freq || 25;

	  // Analog Reference Voltage (default to board.io.aref || 5)
	  this.aref = opts.aref || this.io.aref || 5;

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["ANALOG"];
	  }

	  priv.set(this, {});

	  Board.Controller.call(this, controller, opts);

	  if (!this.toCelsius) {
	    this.toCelsius = opts.toCelsius || function(x) { return x; };
	  }

	  var propDescriptors = {
	    celsius: {
	      get: function() {
	        return this.toCelsius(raw);
	      }
	    },
	    fahrenheit: {
	      get: function() {
	        return (this.celsius * 9.0 / 5.0) + 32;
	      }
	    },
	    kelvin: {
	      get: function() {
	        return this.celsius + CELSIUS_TO_KELVIN;
	      }
	    }
	  };
	  // Convenience aliases
	  propDescriptors.C = propDescriptors.celsius;
	  propDescriptors.F = propDescriptors.fahrenheit;
	  propDescriptors.K = propDescriptors.kelvin;

	  Object.defineProperties(this, propDescriptors);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === undefined) {
	      return;
	    }

	    var data = {};
	    data.C = data.celsius = this.celsius;
	    data.F = data.fahrenheit = this.fahrenheit;
	    data.K = data.kelvin = this.kelvin;

	    this.emit("data", null, data);

	    if (this.celsius !== last) {
	      last = this.celsius;
	      this.emit("change", null, data);
	    }
	  }.bind(this), freq);
	}

	util.inherits(Temperature, Emitter);

	Temperature.Drivers = Drivers;

	module.exports = Temperature;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12),
	  __ = __webpack_require__(115),
	  sum = __.sum;

	var priv = new Map();
	var axes = ["x", "y", "z"];

	function ToPrecision(val, precision) {
	  return +(val).toPrecision(precision);
	}

	var Controllers = {
	  ANALOG: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var pins = opts.pins || [],
	          sensitivity, resolution,
	          state = priv.get(this),
	          dataPoints = {};

	        if (opts.sensitivity === undefined) {
	          throw new Error("Expected a Sensitivity");
	        }

	        // 4.88mV / (0.167mV/dps * 2)
	        // 0.67 = 4X
	        // 0.167 = 1X
	        sensitivity = opts.sensitivity;
	        resolution = opts.resolution || 4.88;
	        state.K = resolution / sensitivity;

	        pins.forEach(function(pin, index) {
	          this.io.pinMode(pin, this.io.MODES.ANALOG);
	          this.io.analogRead(pin, function(data) {
	            var axis = axes[index];
	            dataPoints[axis] = data;
	            dataHandler(dataPoints);
	          }.bind(this));
	        }, this);
	      }
	    },
	    toNormal: {
	      value: function(raw) {
	        return raw >> 2;
	      }
	    },
	    toDegreesPerSecond: {
	      value: function(raw, rawCenter) {
	        var normal = this.toNormal(raw);
	        var center = this.toNormal(rawCenter);
	        var state = priv.get(this);

	        return ((normal - center) * state.K) | 0;
	      }
	    }
	  },
	  // http://www.invensense.com/mems/gyro/mpu6050.html
	  // Default to the +- 250 which has a 131 LSB/dps
	  MPU6050: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var IMU = __webpack_require__(123);
	        var state = priv.get(this),
	          driver = IMU.Drivers.get(this.board, "MPU-6050", opts);

	        state.sensitivity = opts.sensitivity || 131;

	        driver.on("data", function(data) {
	          dataHandler(data.gyro);
	        });
	      }
	    },
	    toNormal: {
	      value: function(raw) {
	        return (raw >> 11) + 127;
	      }
	    },
	    toDegreesPerSecond: {
	      value: function(raw, rawCenter) {
	        var state = priv.get(this);

	        return (raw - rawCenter) / state.sensitivity;
	      }
	    }
	  }
	};

	// Otherwise known as...
	Controllers["MPU-6050"] = Controllers.MPU6050;

	function Gyro(opts) {
	  if (!(this instanceof Gyro)) {
	    return new Gyro(opts);
	  }

	  var controller = null;
	  var isCalibrated = false;
	  var sampleSize = 100;

	  var state = {
	    x: {
	      angle: 0,
	      value: 0,
	      previous: 0,
	      calibration: [],
	      stash: [0, 0, 0, 0, 0],
	      center: 0,
	      hasValue: false
	    },
	    y: {
	      angle: 0,
	      value: 0,
	      previous: 0,
	      calibration: [],
	      stash: [0, 0, 0, 0, 0],
	      center: 0,
	      hasValue: false
	    },
	    z: {
	      angle: 0,
	      value: 0,
	      previous: 0,
	      calibration: [],
	      stash: [0, 0, 0, 0, 0],
	      center: 0,
	      hasValue: false
	    }
	  };

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["ANALOG"];
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toNormal) {
	    this.toNormal = opts.toNormal || function(raw) { return raw; };
	  }

	  if (!this.toDegreesPerSecond) {
	    this.toDegreesPerSecond = opts.toDegreesPerSecond || function(raw) { return raw; };
	  }

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      var isChange = false;

	      Object.keys(data).forEach(function(axis) {
	        var value = data[axis];
	        var sensor = state[axis];

	        sensor.previous = sensor.value;
	        sensor.stash.shift();
	        sensor.stash.push(value);
	        sensor.hasValue = true;
	        sensor.value = (sum(sensor.stash) / 5) | 0;

	        if (!isCalibrated &&
	          (state.x.calibration.length === sampleSize &&
	            state.y.calibration.length === sampleSize &&
	            (this.z === undefined || state.z.calibration.length === sampleSize))) {

	          isCalibrated = true;
	          state.x.center = (sum(state.x.calibration) / sampleSize) | 0;
	          state.y.center = (sum(state.y.calibration) / sampleSize) | 0;
	          state.z.center = (sum(state.z.calibration) / sampleSize) | 0;

	          state.x.calibration.length = 0;
	          state.y.calibration.length = 0;
	          state.z.calibration.length = 0;
	        } else {
	          if (sensor.calibration.length < sampleSize) {
	            sensor.calibration.push(value);
	          }
	        }

	        if (sensor.previous !== sensor.value) {
	          isChange = true;
	        }
	      }, this);

	      if (isCalibrated) {
	        state.x.angle += this.rate.x / 100;
	        state.y.angle += this.rate.y / 100;
	        state.z.angle += this.rate.z / 100;

	        this.emit("data", {
	          x: this.x,
	          y: this.y,
	          z: this.z
	        });

	        if (isChange) {
	          this.emit("change", {
	            x: this.x,
	            y: this.y,
	            z: this.z
	          });
	        }
	      }
	    }.bind(this));
	  }

	  Object.defineProperties(this, {
	    isCalibrated: {
	      get: function() {
	        return isCalibrated;
	      },
	      set: function(value) {
	        if (typeof value === "boolean") {
	          isCalibrated = value;
	        }
	      }
	    },
	    pitch: {
	      get: function() {
	        return {
	          rate: ToPrecision(this.rate.y, 2),
	          angle: ToPrecision(state.y.angle, 2)
	        };
	      }
	    },
	    roll: {
	      get: function() {
	        return {
	          rate: ToPrecision(this.rate.x, 2),
	          angle: ToPrecision(state.x.angle, 2)
	        };
	      }
	    },
	    yaw: {
	      get: function() {
	        return {
	          rate: this.z !== undefined ? ToPrecision(this.rate.z, 2) : 0,
	          angle: this.z !== undefined ? ToPrecision(state.z.angle, 2) : 0
	        };
	      }
	    },
	    x: {
	      get: function() {
	        return ToPrecision(this.toNormal(state.x.value), 4);
	      }
	    },
	    y: {
	      get: function() {
	        return ToPrecision(this.toNormal(state.y.value), 4);
	      }
	    },
	    z: {
	      get: function() {
	        return state.z.hasValue ? ToPrecision(this.toNormal(state.z.value), 4) : undefined;
	      }
	    },
	    rate: {
	      get: function() {
	        var x = this.toDegreesPerSecond(state.x.value, state.x.center);
	        var y = this.toDegreesPerSecond(state.y.value, state.y.center);
	        var z = state.z.hasValue ?
	          this.toDegreesPerSecond(state.z.value, state.z.center) : 0;

	        return {
	          x: ToPrecision(x, 2),
	          y: ToPrecision(y, 2),
	          z: ToPrecision(z, 2)
	        };
	      }
	    }
	  });
	}

	Object.defineProperties(Gyro, {
	  TK_4X: {
	    value: 0.67
	  },
	  TK_1X: {
	    value: 0.167
	  }
	});


	util.inherits(Gyro, events.EventEmitter);

	Gyro.prototype.recalibrate = function() {
	  this.isCalibrated = false;
	};

	module.exports = Gyro;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// TODO list
	// Use functions as keyFrames
	// Test metronomic on real animation

	// Create jquery FX like queue

	var ease = __webpack_require__(130),
	  Emitter = __webpack_require__(8).EventEmitter,
	  util = __webpack_require__(12),
	  __ = __webpack_require__(115),
	  temporal;

	Animation.DEFAULTS = {
	  cuePoints: [0, 1],
	  duration: 1000,
	  easing: "linear",
	  loop: false,
	  loopback: 0,
	  metronomic: false,
	  currentSpeed: 1,
	  progress: 0,
	  fps: 60,
	  rate: 1000 / 60,
	  paused: false,
	  segments: [],
	  onstart: null,
	  onpause: null,
	  onstop: null,
	  oncomplete: null,
	  onloop: null
	};

	/**
	 * Placeholders for Symbol
	 */
	Animation.normalize = "@@normalize";
	Animation.render = "@@render";

	/**
	 * Animation
	 * @constructor
	 *
	 * @param {target} A Servo or Servo.Array to be animated
	 *
	 * Animating a single servo
	 *
	 *   var servo = new five.Servo(10);
	 *   var animation = new five.Animation(servo);
	 *   animation.enqueue({
	 *     cuePoints: [0, 0.25, 0.75, 1],
	 *     keyFrames: [{degrees: 90}, 60, -120, {degrees: 90}],
	 *     duration: 2000
	 *   });
	 *
	 *
	 * Animating a servo array
	 *
	 *   var a = new five.Servo(9),
	 *     b = new five.Servo(10);
	 *   var servos = new five.Servo.Array([a, b]);
	 *   var animation = new five.Animation(servos);
	 *   animation.enqueue({
	 *     cuePoints: [0, 0.25, 0.75, 1],
	 *     keyFrames: [
	 *       [{degrees: 90}, 60, -120, {degrees: 90}],
	 *       [{degrees: 180}, -120, 90, {degrees: 180}],
	 *     ],
	 *     duration: 2000
	 *   });
	 *
	 */

	function Animation(target) {

	  // Necessary to avoid loading temporal unless necessary
	  if (!temporal) {
	    temporal = __webpack_require__(131);
	  }

	  if (!(this instanceof Animation)) {
	    return new Animation(target);
	  }

	  this.defaultTarget = target;

	  __.extend(this, Animation.DEFAULTS);

	}

	util.inherits(Animation, Emitter);

	/**
	 * Add an animation segment to the animation queue
	 * @param {Object} opts Options: cuePoints, keyFrames, duration,
	 *   easing, loop, metronomic, progress, fps, onstart, onpause,
	 *   onstop, oncomplete, onloop
	 */
	Animation.prototype.enqueue = function(opts) {

	  if (typeof opts.target === "undefined") {
	    opts.target = this.defaultTarget;
	  }

	  __.defaults(opts, Animation.DEFAULTS);
	  this.segments.push(opts);

	  if (!this.paused) {
	    this.next();
	  }

	  return this;

	};

	/**
	 * Plays next segment in queue
	 * Users need not call this. It's automatic
	 */
	Animation.prototype.next = function() {

	  if (this.segments.length > 0) {

	    __.extend(this, this.segments.shift());

	    if (this.onstart) {
	      this.onstart();
	    }

	    this.normalizedKeyFrames = __.cloneDeep(this.keyFrames);
	    this.normalizedKeyFrames = this.target[Animation.normalize](this.normalizedKeyFrames);
	    this.normalizedKeyFrames = this.normalizeKeyframes(this.normalizedKeyFrames, this.cuePoints);

	    if (this.reverse) {
	      this.currentSpeed *= -1;
	    }

	    if (this.currentSpeed !== 0) {
	      this.play();
	    } else {
	      this.paused = true;
	    }
	  } else {
	    this.playLoop.stop();
	  }

	};

	/**
	 * pause
	 *
	 * Pause animation while maintaining progress, speed and segment queue
	 *
	 */

	Animation.prototype.pause = function() {

	  this.emit("animation:pause");

	  this.playLoop.stop();
	  this.paused = true;

	  if (this.onpause) {
	    this.onpause();
	  }

	};

	/**
	 * stop
	 *
	 * Stop all animations
	 *
	 */

	Animation.prototype.stop = function() {

	  this.emit("animation:stop");

	  this.segments = [];
	  temporal.clear();

	  if (this.onstop) {
	    this.onstop();
	  }

	};

	/**
	 * speed
	 *
	 * Get or set the current playback speed
	 *
	 * @param {Number} speed
	 *
	 */

	Animation.prototype.speed = function(speed) {

	  if (typeof speed === "undefined") {
	    return this.currentSpeed;
	  } else {
	    this.currentSpeed = speed;

	    // Find our timeline endpoints and refresh rate
	    this.scaledDuration = this.duration / Math.abs(this.currentSpeed);
	    this.startTime = Date.now() - this.scaledDuration * this.progress;
	    this.endTime = this.startTime + this.scaledDuration;
	    return this;
	  }
	};

	/**
	 * play
	 *
	 * Start a segment
	 */

	Animation.prototype.play = function() {

	  if (this.playLoop) {
	    this.playLoop.stop();
	  }

	  this.paused = false;

	  // Find our timeline endpoints and refresh rate
	  this.scaledDuration = this.duration / Math.abs(this.currentSpeed);
	  this.startTime = Date.now() - this.scaledDuration * this.progress;
	  this.endTime = this.startTime + this.scaledDuration;

	  if (this.fps) {
	    this.rate = 1000 / this.fps;
	  }

	  this.rate = this.rate | 0;

	  this.playLoop = temporal.loop(this.rate, function(loop) {
	    // Note: "this" is bound to the animation object

	    // Find the current timeline progress
	    var progress = this.calculateProgress(loop.calledAt);

	    // Find the left and right cuePoints/keyFrames;
	    var indices = this.findIndices(progress);

	    // Get tweened value
	    var val = this.tweenedValue(indices, progress);

	    // call render function
	    this.target[Animation.render](val);

	    // See if we have reached the end of the animation
	    if ((progress === 1 && !this.reverse) || (progress === this.loopback && this.reverse)) {

	      if (this.loop || (this.metronomic && !this.reverse)) {

	        if (this.onloop) {
	          this.onloop();
	        }

	        if (this.metronomic) {
	          this.reverse = this.reverse ? false : true;
	        }

	        this.normalizedKeyFrames = __.cloneDeep(this.keyFrames);
	        this.normalizedKeyFrames = this.target[Animation.normalize](this.normalizedKeyFrames);
	        this.normalizedKeyFrames = this.normalizeKeyframes();

	        this.progress = this.loopback;
	        this.startTime = Date.now() - this.scaledDuration * this.progress;
	        this.endTime = this.startTime + this.scaledDuration;

	      } else {

	        this.stop();
	        if (this.oncomplete) {
	          this.oncomplete();
	        }
	        this.next();

	      }
	    }

	  }.bind(this));

	};

	Animation.prototype.findIndices = function(progress) {
	  var indices = {
	    left: null,
	    right: null
	  };

	  // Find our current before and after cuePoints
	  indices.right = this.cuePoints.findIndex(function(point) {
	    return point >= progress;
	  });

	  indices.left = indices.right === 0 ? 0 : indices.right - 1;

	  return indices;
	};

	Animation.prototype.calculateProgress = function(calledAt) {
	  var progress = (calledAt - this.startTime) / this.scaledDuration;

	  if (progress > 1) {
	    progress = 1;
	  }

	  this.progress = progress;

	  if (this.reverse) {
	    progress = 1 - progress;
	  }

	  // Ease the timeline
	  // to do: When reverse replace inFoo with outFoo and vice versa. skip inOutFoo
	  progress = ease[this.easing](progress);

	  progress = __.constrain(progress, 0, 1);

	  return progress;
	};

	Animation.prototype.tweenedValue = function(indices, progress) {

	  var tween = {
	    duration: null,
	    progress: null
	  };

	  var result = this.normalizedKeyFrames.map(function(keyFrame) {
	    // Note: "this" is bound to the animation object

	    var memberIndices = {
	      left: null,
	      right: null
	    };

	    // If the keyframe at indices.left is null, move left
	    for (memberIndices.left = indices.left; memberIndices.left > -1; memberIndices.left--) {
	      if (keyFrame[memberIndices.left] !== null) {
	        break;
	      }
	    }

	    // If the keyframe at indices.right is null, move right
	    memberIndices.right = keyFrame.findIndex(function(frame, index) {
	      return index >= indices.right && frame !== null;
	    });

	    // Find our progress for the current tween
	    tween.duration = this.cuePoints[memberIndices.right] - this.cuePoints[memberIndices.left];
	    tween.progress = (progress - this.cuePoints[memberIndices.left]) / tween.duration;

	    // Catch divide by zero
	    if (!Number.isFinite(tween.progress)) {
	      tween.progress = this.reverse ? 0 : 1;
	    }

	    var left = keyFrame[memberIndices.left],
	    right = keyFrame[memberIndices.right];

	    // Apply tween easing to tween.progress
	    // to do: When reverse replace inFoo with outFoo and vice versa. skip inOutFoo
	    tween.progress = ease[right.easing](tween.progress);

	    // Calculate this tween value
	    var calcValue;

	    if (right.position) {
	      // This is a tuple
	      calcValue = right.position.map(function(value, index) {
	        return (value - left.position[index]) *
	        tween.progress + left.position[index];
	      });
	    } else {
	      calcValue = (right.value - left.value) *
	      tween.progress + left.value;
	    }

	    return calcValue;

	  }, this);

	  return result;
	};

	// Make sure our keyframes conform to a standard
	Animation.prototype.normalizeKeyframes = function() {

	  var previousVal,
	    keyFrameSet = this.normalizedKeyFrames,
	    cuePoints = this.cuePoints;

	  // keyFrames can be passed as a single dimensional array if
	  // there is just one servo/device. If the first element is not an
	  // array, nest keyFrameSet so we only have to deal with one format
	  if (!Array.isArray(keyFrameSet[0])) {
	    keyFrameSet = [keyFrameSet];
	  }

	  keyFrameSet.forEach(function(keyFrames) {

	    // Pad the right side of keyFrames arrays with null
	    for (var i = keyFrames.length; i < cuePoints.length; i++) {
	      keyFrames.push(null);
	    }

	    keyFrames.forEach(function(keyFrame, i, source) {

	      if (keyFrame !== null) {

	        // keyFrames need to be converted to objects
	        if (typeof keyFrame !== "object") {
	          keyFrame = {
	            step: keyFrame,
	            easing: "linear"
	          };
	        }

	        // Replace step values
	        if (typeof keyFrame.step !== "undefined") {
	          keyFrame.value = keyFrame.step === false ?
	            previousVal : previousVal + keyFrame.step;
	        }

	        // Set a default easing function
	        if (!keyFrame.easing) {
	          keyFrame.easing = "linear";
	        }

	        // Copy value from another frame
	        if (typeof keyFrame.copyValue !== "undefined") {
	          keyFrame.value = source[keyFrame.copyValue].value;
	        }

	        // Copy everything from another keyframe in this array
	        if (keyFrame.copyFrame) {
	          keyFrame = source[keyFrame.copyFrame];
	        }

	        previousVal = keyFrame.value;

	      } else {

	        if (i === source.length - 1) {
	          keyFrame = {
	            value: previousVal,
	            easing: "linear"
	          };
	        } else {
	          keyFrame = null;
	        }

	      }
	      source[i] = keyFrame;

	    }, this);

	  });
	  return keyFrameSet;
	};

	module.exports = Animation;


/***/ },
/* 130 */
/***/ function(module, exports) {

	
	// easing functions from "Tween.js"

	exports.linear = function(n){
	  return n;
	};

	exports.inQuad = function(n){
	  return n * n;
	};

	exports.outQuad = function(n){
	  return n * (2 - n);
	};

	exports.inOutQuad = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n;
	  return - 0.5 * (--n * (n - 2) - 1);
	};

	exports.inCube = function(n){
	  return n * n * n;
	};

	exports.outCube = function(n){
	  return --n * n * n + 1;
	};

	exports.inOutCube = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n;
	  return 0.5 * ((n -= 2 ) * n * n + 2);
	};

	exports.inQuart = function(n){
	  return n * n * n * n;
	};

	exports.outQuart = function(n){
	  return 1 - (--n * n * n * n);
	};

	exports.inOutQuart = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n;
	  return -0.5 * ((n -= 2) * n * n * n - 2);
	};

	exports.inQuint = function(n){
	  return n * n * n * n * n;
	}

	exports.outQuint = function(n){
	  return --n * n * n * n * n + 1;
	}

	exports.inOutQuint = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n * n;
	  return 0.5 * ((n -= 2) * n * n * n * n + 2);
	};

	exports.inSine = function(n){
	  return 1 - Math.cos(n * Math.PI / 2 );
	};

	exports.outSine = function(n){
	  return Math.sin(n * Math.PI / 2);
	};

	exports.inOutSine = function(n){
	  return .5 * (1 - Math.cos(Math.PI * n));
	};

	exports.inExpo = function(n){
	  return 0 == n ? 0 : Math.pow(1024, n - 1);
	};

	exports.outExpo = function(n){
	  return 1 == n ? n : 1 - Math.pow(2, -10 * n);
	};

	exports.inOutExpo = function(n){
	  if (0 == n) return 0;
	  if (1 == n) return 1;
	  if ((n *= 2) < 1) return .5 * Math.pow(1024, n - 1);
	  return .5 * (-Math.pow(2, -10 * (n - 1)) + 2);
	};

	exports.inCirc = function(n){
	  return 1 - Math.sqrt(1 - n * n);
	};

	exports.outCirc = function(n){
	  return Math.sqrt(1 - (--n * n));
	};

	exports.inOutCirc = function(n){
	  n *= 2
	  if (n < 1) return -0.5 * (Math.sqrt(1 - n * n) - 1);
	  return 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
	};

	exports.inBack = function(n){
	  var s = 1.70158;
	  return n * n * (( s + 1 ) * n - s);
	};

	exports.outBack = function(n){
	  var s = 1.70158;
	  return --n * n * ((s + 1) * n + s) + 1;
	};

	exports.inOutBack = function(n){
	  var s = 1.70158 * 1.525;
	  if ( ( n *= 2 ) < 1 ) return 0.5 * ( n * n * ( ( s + 1 ) * n - s ) );
	  return 0.5 * ( ( n -= 2 ) * n * ( ( s + 1 ) * n + s ) + 2 );
	};

	exports.inBounce = function(n){
	  return 1 - exports.outBounce(1 - n);
	};

	exports.outBounce = function(n){
	  if ( n < ( 1 / 2.75 ) ) {
	    return 7.5625 * n * n;
	  } else if ( n < ( 2 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 1.5 / 2.75 ) ) * n + 0.75;
	  } else if ( n < ( 2.5 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 2.25 / 2.75 ) ) * n + 0.9375;
	  } else {
	    return 7.5625 * ( n -= ( 2.625 / 2.75 ) ) * n + 0.984375;
	  }
	};

	exports.inOutBounce = function(n){
	  if (n < .5) return exports.inBounce(n * 2) * .5;
	  return exports.outBounce(n * 2 - 1) * .5 + .5;
	};

	// aliases

	exports['in-quad'] = exports.inQuad;
	exports['out-quad'] = exports.outQuad;
	exports['in-out-quad'] = exports.inOutQuad;
	exports['in-cube'] = exports.inCube;
	exports['out-cube'] = exports.outCube;
	exports['in-out-cube'] = exports.inOutCube;
	exports['in-quart'] = exports.inQuart;
	exports['out-quart'] = exports.outQuart;
	exports['in-out-quart'] = exports.inOutQuart;
	exports['in-quint'] = exports.inQuint;
	exports['out-quint'] = exports.outQuint;
	exports['in-out-quint'] = exports.inOutQuint;
	exports['in-sine'] = exports.inSine;
	exports['out-sine'] = exports.outSine;
	exports['in-out-sine'] = exports.inOutSine;
	exports['in-expo'] = exports.inExpo;
	exports['out-expo'] = exports.outExpo;
	exports['in-out-expo'] = exports.inOutExpo;
	exports['in-circ'] = exports.inCirc;
	exports['out-circ'] = exports.outCirc;
	exports['in-out-circ'] = exports.inOutCirc;
	exports['in-back'] = exports.inBack;
	exports['out-back'] = exports.outBack;
	exports['in-out-back'] = exports.inOutBack;
	exports['in-bounce'] = exports.inBounce;
	exports['out-bounce'] = exports.outBounce;
	exports['in-out-bounce'] = exports.inOutBounce;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	/*
	 * temporal
	 * https://github.com/rwldrn/temporal
	 *
	 * Copyright (c) 2012 Rick Waldron
	 * Licensed under the MIT license.
	 */
	__webpack_require__(132);

	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);

	// All APIs will be added to `exportable`, which is lastly
	// assigned as the value of module.exports
	var exportable = new Emitter();

	// Object containing callback queues, keys are time in MS
	var queue = {};

	// Actively processing queue
	var isProcessing = false;

	// Task details are stored as a plain object, privately in a Map
	// to avoid being forced to expose the properties directly on the instance.
	//
	// Queue emitters are stored privately in a Map to avoid using
	// |this| alias patterns.
	var priv = new Map();

	var tick = global.setImmediate || process.nextTick;

	/**
	 * Task create a temporal task item
	 * @param {Object} entry Options for entry {time, task}
	 */
	function Task(entry) {
	  if (!(this instanceof Task)) {
	    return new Task(entry);
	  }

	  this.called = 0;
	  this.now = this.calledAt = Date.now();

	  priv.set(this, entry);

	  // Side table property definitions
	  entry.isRunnable = true;
	  entry.later = this.now + entry.time;


	  if (!queue[entry.later]) {
	    queue[entry.later] = [];
	  }

	  // console.log( entry.later, this );
	  queue[entry.later].push(this);
	}

	// Inherit EventEmitter API
	util.inherits(Task, Emitter);

	/**
	 * Task.deriveOp (reduction)
	 * (static)
	 */
	Task.deriveOp = function(p, v) {
	  return v !== "task" ? v : p;
	};


	/**
	 * stop Stop the current behaviour
	 */
	Task.prototype.stop = function() {
	  priv.get(this).isRunnable = false;
	  this.emit("stop");
	};

	function Queue(tasks) {
	  priv.set(this, []);

	  this.add(tasks);
	}

	util.inherits(Queue, Emitter);

	Queue.prototype.stop = function() {
	  priv.get(this).forEach(function(ref) {
	    ref.stop();
	  });

	  this.emit("stop");
	};

	Queue.prototype.add = function(tasks) {
	  var thisq = this;
	  var op, item, task, ref, refs;

	  this.cumulative = this.cumulative || 0;

	  refs = priv.get(this);

	  while (tasks.length) {
	    item = tasks.shift();
	    op = Object.keys(item).reduce(Task.deriveOp, "");
	    // console.log( op, item[ op ] );
	    this.cumulative += item[op];

	    // For the last task, ensure that an "end" event is
	    // emitted after the final callback is called.
	    if (tasks.length === 0) {
	      task = item.task;
	      item.task = function(temporald) {
	        task.call(thisq, temporald);

	        // Emit the end event _from_ within the _last_ task
	        // defined in the Queue tasks. Use the |tasks| array
	        // object as the access key.
	        thisq.emit("end", temporald);

	        // Reset on last one in the queue
	        thisq.cumulative = 0;
	      };
	    }

	    if (op === "loop" && tasks.length === 0) {
	      // When transitioning from a "delay" to a "loop", allow
	      // the loop to iterate the amount of time given,
	      // but still start at the correct offset.
	      ref = exportable.delay(this.cumulative - item[op], function() {
	        ref = exportable.loop(item[op], item.task);

	        refs.push(ref);
	      });
	    } else {
	      ref = exportable[op](this.cumulative, item.task);
	    }

	    refs.push(ref);
	  }
	};

	exportable.queue = function(tasks) {
	  var queue = new Queue(tasks);
	  processQueue();
	  return queue;
	};


	// For more information about this approach:
	//
	//    https://dl.dropbox.com/u/3531958/empirejs/index.html
	//

	var previousTime = Date.now();

	function processQueue() {

	  if (!isProcessing) {
	    isProcessing = true;
	    exportable.emit("busy");
	  }


	  var scheduled = Object.keys(queue);
	  var last = scheduled.length && +scheduled[scheduled.length - 1];
	  var now = Date.now();
	  var entries = [];
	  var callProcessQueue = true;
	  var entry, temporald, i;

	  // Nothing scheduled, don't call processQueue again
	  if (last <= now) {
	    callProcessQueue = false;
	  }

	  for (i = previousTime; i <= now; i++) {
	    // Accumlate entries
	    [].push.apply(entries, queue[i] || []);
	  }

	  if (entries.length) {

	    // console.log( now, entries );
	    // console.log( entries );
	    while (entries.length) {
	      // Shift the entry out of the current list
	      temporald = entries.shift();
	      entry = priv.get(temporald);

	      // Execute the entry's callback, with
	      // "entry" as first arg
	      if (entry.isRunnable) {
	        temporald.called++;
	        temporald.calledAt = now;
	        entry.task.call(temporald, temporald);
	      }

	      // Additional "loop" handling
	      if (entry.type === "loop" && entry.isRunnable) {
	        // There is an active loop, so keep the
	        // processQueue active.
	        callProcessQueue = true;

	        // Calculate the next execution time
	        entry.later = now + entry.time;

	        // Create a queue entry if none exists
	        if (!queue[entry.later]) {
	          queue[entry.later] = [];
	        }

	        if (entry.isRunnable) {
	          // Push the entry into the cue
	          queue[entry.later].push(temporald);
	        }
	      }
	    }

	    // Cleanup
	    for (i = previousTime; i <= now; i++) {
	      delete queue[i];
	    }

	    entries.length = 0;
	  }

	  previousTime = now;

	  if (callProcessQueue) {
	    tick(processQueue);
	  } else {
	    isProcessing = false;
	    exportable.emit("idle");
	  }
	}

	["loop", "delay"].forEach(function(type) {
	  exportable[type] = function(time, operation) {
	    if (typeof time === "function") {
	      operation = time;
	      time = 10;
	    }
	    var task = new Task({
	      time: time,
	      type: type,
	      task: operation
	    });

	    if (!isProcessing) {
	      processQueue();
	    }

	    return task;
	  };
	});

	// Alias "delay" as "wait" or "defer" (back compat with old compulsive API)
	// These aid only in user code that desires clarity in purpose.
	// Certain practical applications might be suited to
	// "defer" or "wait" vs. "delay"
	//
	exportable.wait = exportable.defer = exportable.delay;

	exportable.repeat = function(n, ms, callback) {
	  return exportable.loop(ms, function(context) {
	    callback(context);

	    if (context.called === n) {
	      this.stop();
	    }
	  });
	};

	exportable.clear = function() {
	  isProcessing = false;
	  exportable.removeAllListeners();
	  queue = {};
	};

	module.exports = exportable;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, process) { /*!
	  * https://github.com/paulmillr/es6-shim
	  * @license es6-shim Copyright 2013-2015 by Paul Miller (http://paulmillr.com)
	  *   and contributors,  MIT License
	  * es6-shim: v0.33.6
	  * see https://github.com/paulmillr/es6-shim/blob/0.33.3/LICENSE
	  * Details and documentation:
	  * https://github.com/paulmillr/es6-shim/
	  */

	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/returnExports.js
	(function (root, factory) {
	  /*global define, module, exports */
	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like enviroments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    // Browser globals (root is window)
	    root.returnExports = factory();
	  }
	}(this, function () {
	  'use strict';

	  var _apply = Function.call.bind(Function.apply);
	  var _call = Function.call.bind(Function.call);
	  var isArray = Array.isArray;

	  var not = function notThunker(func) {
	    return function notThunk() { return !_apply(func, this, arguments); };
	  };
	  var throwsError = function (func) {
	    try {
	      func();
	      return false;
	    } catch (e) {
	      return true;
	    }
	  };
	  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
	    try {
	      return func();
	    } catch (e) {
	      return false;
	    }
	  };

	  var isCallableWithoutNew = not(throwsError);
	  var arePropertyDescriptorsSupported = function () {
	    // if Object.defineProperty exists but throws, it's IE 8
	    return !throwsError(function () { Object.defineProperty({}, 'x', { get: function () {} }); });
	  };
	  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
	  var functionsHaveNames = (function foo() {}).name === 'foo';

	  var _forEach = Function.call.bind(Array.prototype.forEach);
	  var _reduce = Function.call.bind(Array.prototype.reduce);
	  var _filter = Function.call.bind(Array.prototype.filter);
	  var _every = Function.call.bind(Array.prototype.every);

	  var createDataProperty = function createDataProperty(object, name, value) {
	    if (supportsDescriptors) {
	      Object.defineProperty(object, name, {
	        configurable: true,
	        enumerable: true,
	        writable: true,
	        value: value
	      });
	    } else {
	      object[name] = value;
	    }
	  };
	  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
	    createDataProperty(object, name, value);
	    if (!ES.SameValue(object[name], value)) {
	      throw new TypeError('property is nonconfigurable');
	    }
	  };
	  var defineProperty = function (object, name, value, force) {
	    if (!force && name in object) { return; }
	    if (supportsDescriptors) {
	      Object.defineProperty(object, name, {
	        configurable: true,
	        enumerable: false,
	        writable: true,
	        value: value
	      });
	    } else {
	      object[name] = value;
	    }
	  };

	  // Define configurable, writable and non-enumerable props
	  // if they dont exist.
	  var defineProperties = function (object, map) {
	    _forEach(Object.keys(map), function (name) {
	      var method = map[name];
	      defineProperty(object, name, method, false);
	    });
	  };

	  // Simple shim for Object.create on ES3 browsers
	  // (unlike real shim, no attempt to support `prototype === null`)
	  var create = Object.create || function (prototype, properties) {
	    var Prototype = function Prototype() {};
	    Prototype.prototype = prototype;
	    var object = new Prototype();
	    if (typeof properties !== 'undefined') {
	      Object.keys(properties).forEach(function (key) {
	        Value.defineByDescriptor(object, key, properties[key]);
	      });
	    }
	    return object;
	  };

	  var supportsSubclassing = function (C, f) {
	    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
	    return valueOrFalseIfThrows(function () {
	      var Sub = function Subclass(arg) {
	        var o = new C(arg);
	        Object.setPrototypeOf(o, Subclass.prototype);
	        return o;
	      };
	      Object.setPrototypeOf(Sub, C);
	      Sub.prototype = create(C.prototype, {
	        constructor: { value: Sub }
	      });
	      return f(Sub);
	    });
	  };

	  var startsWithRejectsRegex = function () {
	    return String.prototype.startsWith && throwsError(function () {
	      /* throws if spec-compliant */
	      '/a/'.startsWith(/a/);
	    });
	  };
	  var startsWithHandlesInfinity = (function () {
	    return String.prototype.startsWith && 'abc'.startsWith('a', Infinity) === false;
	  }());

	  var getGlobal = function () {
		// the only reliable means to get the global object is
		// `Function('return this')()`
		// However, this causes CSP violations in Chrome apps.
	    if (typeof self !== 'undefined') { return self; }
	    if (typeof window !== 'undefined') { return window; }
	    if (typeof global !== 'undefined') { return global; }
		throw new Error('unable to locate global object');
	  };

	  var globals = getGlobal();
	  var globalIsFinite = globals.isFinite;
	  var hasStrictMode = (function () { return this === null; }.call(null));
	  var startsWithIsCompliant = startsWithRejectsRegex() && startsWithHandlesInfinity;
	  var _indexOf = Function.call.bind(String.prototype.indexOf);
	  var _toString = Function.call.bind(Object.prototype.toString);
	  var _concat = Function.call.bind(Array.prototype.concat);
	  var _strSlice = Function.call.bind(String.prototype.slice);
	  var _push = Function.call.bind(Array.prototype.push);
	  var _pushApply = Function.apply.bind(Array.prototype.push);
	  var _shift = Function.call.bind(Array.prototype.shift);
	  var _max = Math.max;
	  var _min = Math.min;
	  var _floor = Math.floor;
	  var _abs = Math.abs;
	  var _log = Math.log;
	  var _sqrt = Math.sqrt;
	  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
	  var ArrayIterator; // make our implementation private
	  var noop = function () {};

	  var Symbol = globals.Symbol || {};
	  var symbolSpecies = Symbol.species || '@@species';

	  var Value = {
	    getter: function (object, name, getter) {
	      if (!supportsDescriptors) {
	        throw new TypeError('getters require true ES5 support');
	      }
	      Object.defineProperty(object, name, {
	        configurable: true,
	        enumerable: false,
	        get: getter
	      });
	    },
	    proxy: function (originalObject, key, targetObject) {
	      if (!supportsDescriptors) {
	        throw new TypeError('getters require true ES5 support');
	      }
	      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
	      Object.defineProperty(targetObject, key, {
	        configurable: originalDescriptor.configurable,
	        enumerable: originalDescriptor.enumerable,
	        get: function getKey() { return originalObject[key]; },
	        set: function setKey(value) { originalObject[key] = value; }
	      });
	    },
	    redefine: function (object, property, newValue) {
	      if (supportsDescriptors) {
	        var descriptor = Object.getOwnPropertyDescriptor(object, property);
	        descriptor.value = newValue;
	        Object.defineProperty(object, property, descriptor);
	      } else {
	        object[property] = newValue;
	      }
	    },
	    defineByDescriptor: function (object, property, descriptor) {
	      if (supportsDescriptors) {
	        Object.defineProperty(object, property, descriptor);
	      } else if ('value' in descriptor) {
	        object[property] = descriptor.value;
	      }
	    },
	    preserveToString: function (target, source) {
	      defineProperty(target, 'toString', source.toString.bind(source), true);
	    }
	  };

	  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
	    Value.preserveToString(replacement, original);
	    if (Object.setPrototypeOf) {
	      // sets up proper prototype chain where possible
	      Object.setPrototypeOf(original, replacement);
	    }
	    _forEach(Object.getOwnPropertyNames(original), function (key) {
	      if (key in noop || keysToSkip[key]) { return; }
	      Value.proxy(original, key, replacement);
	    });
	    replacement.prototype = original.prototype;
	    Value.redefine(original.prototype, 'constructor', replacement);
	  };

	  var defaultSpeciesGetter = function () { return this; };
	  var addDefaultSpecies = function (C) {
	    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
	      Value.getter(C, symbolSpecies, defaultSpeciesGetter);
	    }
	  };
	  var Type = {
	    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
	    object: function (x) { return x !== null && typeof x === 'object'; },
	    string: function (x) { return _toString(x) === '[object String]'; },
	    regex: function (x) { return _toString(x) === '[object RegExp]'; },
	    symbol: function (x) {
	      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
	    }
	  };

	  var numberIsNaN = Number.isNaN || function isNaN(value) {
	    // NaN !== NaN, but they are identical.
	    // NaNs are the only non-reflexive value, i.e., if x !== x,
	    // then x is NaN.
	    // isNaN is broken: it converts its argument to number, so
	    // isNaN('foo') => true
	    return value !== value;
	  };
	  var numberIsFinite = Number.isFinite || function isFinite(value) {
	    return typeof value === 'number' && globalIsFinite(value);
	  };

	  var overrideNative = function overrideNative(object, property, replacement) {
	    var original = object[property];
	    defineProperty(object, property, replacement, true);
	    Value.preserveToString(object[property], original);
	  };

	  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
	  // we're going to use an arbitrary _-prefixed name to make our shims
	  // work properly with each other, even though we don't have full Iterator
	  // support.  That is, `Array.from(map.keys())` will work, but we don't
	  // pretend to export a "real" Iterator interface.
	  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
	  // Firefox ships a partial implementation using the name @@iterator.
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
	  // So use that name if we detect it.
	  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
	    $iterator$ = '@@iterator';
	  }
	  var addIterator = function (prototype, impl) {
	    var implementation = impl || function iterator() { return this; };
	    defineProperty(prototype, $iterator$, implementation);
	    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
	      // implementations are buggy when $iterator$ is a Symbol
	      prototype[$iterator$] = implementation;
	    }
	  };

	  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
	  // can be replaced with require('is-arguments') if we ever use a build process instead
	  var isStandardArguments = function isArguments(value) {
	    return _toString(value) === '[object Arguments]';
	  };
	  var isLegacyArguments = function isArguments(value) {
	    return value !== null &&
	      typeof value === 'object' &&
	      typeof value.length === 'number' &&
	      value.length >= 0 &&
	      _toString(value) !== '[object Array]' &&
	      _toString(value.callee) === '[object Function]';
	  };
	  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

	  var ES = {
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	    Call: function Call(F, V) {
	      var args = arguments.length > 2 ? arguments[2] : [];
	      if (!ES.IsCallable(F)) {
	        throw new TypeError(F + ' is not a function');
	      }
	      return _apply(F, V, args);
	    },

	    RequireObjectCoercible: function (x, optMessage) {
	      /* jshint eqnull:true */
	      if (x == null) {
	        throw new TypeError(optMessage || 'Cannot call method on ' + x);
	      }
	    },

	    TypeIsObject: function (x) {
	      /* jshint eqnull:true */
	      // this is expensive when it returns false; use this function
	      // when you expect it to return true in the common case.
	      return x != null && Object(x) === x;
	    },

	    ToObject: function (o, optMessage) {
	      ES.RequireObjectCoercible(o, optMessage);
	      return Object(o);
	    },

	    IsCallable: function (x) {
	      // some versions of IE say that typeof /abc/ === 'function'
	      return typeof x === 'function' && _toString(x) === '[object Function]';
	    },

	    IsConstructor: function (x) {
	      // We can't tell callables from constructors in ES5
	      return ES.IsCallable(x);
	    },

	    ToInt32: function (x) {
	      return ES.ToNumber(x) >> 0;
	    },

	    ToUint32: function (x) {
	      return ES.ToNumber(x) >>> 0;
	    },

	    ToNumber: function (value) {
	      if (_toString(value) === '[object Symbol]') {
	        throw new TypeError('Cannot convert a Symbol value to a number');
	      }
	      return +value;
	    },

	    ToInteger: function (value) {
	      var number = ES.ToNumber(value);
	      if (numberIsNaN(number)) { return 0; }
	      if (number === 0 || !numberIsFinite(number)) { return number; }
	      return (number > 0 ? 1 : -1) * _floor(_abs(number));
	    },

	    ToLength: function (value) {
	      var len = ES.ToInteger(value);
	      if (len <= 0) { return 0; } // includes converting -0 to +0
	      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
	      return len;
	    },

	    SameValue: function (a, b) {
	      if (a === b) {
	        // 0 === -0, but they are not identical.
	        if (a === 0) { return 1 / a === 1 / b; }
	        return true;
	      }
	      return numberIsNaN(a) && numberIsNaN(b);
	    },

	    SameValueZero: function (a, b) {
	      // same as SameValue except for SameValueZero(+0, -0) == true
	      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
	    },

	    IsIterable: function (o) {
	      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
	    },

	    GetIterator: function (o) {
	      if (isArguments(o)) {
	        // special case support for `arguments`
	        return new ArrayIterator(o, 'value');
	      }
	      var itFn = ES.GetMethod(o, $iterator$);
	      if (!ES.IsCallable(itFn)) {
	        // Better diagnostics if itFn is null or undefined
	        throw new TypeError('value is not an iterable');
	      }
	      var it = _call(itFn, o);
	      if (!ES.TypeIsObject(it)) {
	        throw new TypeError('bad iterator');
	      }
	      return it;
	    },

	    GetMethod: function (o, p) {
	      var func = ES.ToObject(o)[p];
	      if (func === void 0 || func === null) {
	        return void 0;
	      }
	      if (!ES.IsCallable(func)) {
	        throw new TypeError('Method not callable: ' + p);
	      }
	      return func;
	    },

	    IteratorComplete: function (iterResult) {
	      return !!(iterResult.done);
	    },

	    IteratorClose: function (iterator, completionIsThrow) {
	      var returnMethod = ES.GetMethod(iterator, 'return');
	      if (returnMethod === void 0) {
	        return;
	      }
	      var innerResult, innerException;
	      try {
	        innerResult = _call(returnMethod, iterator);
	      } catch (e) {
	        innerException = e;
	      }
	      if (completionIsThrow) {
	        return;
	      }
	      if (innerException) {
	        throw innerException;
	      }
	      if (!ES.TypeIsObject(innerResult)) {
	        throw new TypeError("Iterator's return method returned a non-object.");
	      }
	    },

	    IteratorNext: function (it) {
	      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
	      if (!ES.TypeIsObject(result)) {
	        throw new TypeError('bad iterator');
	      }
	      return result;
	    },

	    IteratorStep: function (it) {
	      var result = ES.IteratorNext(it);
	      var done = ES.IteratorComplete(result);
	      return done ? false : result;
	    },

	    Construct: function (C, args, newTarget, isES6internal) {
	      if (newTarget === void 0) {
	        newTarget = C;
	      }
	      if (!isES6internal) {
	        // Try to use Reflect.construct if available
	        return Reflect.construct(C, args, newTarget);
	      }
	      // OK, we have to fake it.  This will only work if the
	      // C.[[ConstructorKind]] == "base" -- but that's the only
	      // kind we can make in ES5 code anyway.

	      // OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%")
	      var proto = newTarget.prototype;
	      if (!ES.TypeIsObject(proto)) {
	        proto = Object.prototype;
	      }
	      var obj = create(proto);
	      // Call the constructor.
	      var result = ES.Call(C, obj, args);
	      return ES.TypeIsObject(result) ? result : obj;
	    },

	    SpeciesConstructor: function (O, defaultConstructor) {
	      var C = O.constructor;
	      if (C === void 0) {
	        return defaultConstructor;
	      }
	      if (!ES.TypeIsObject(C)) {
	        throw new TypeError('Bad constructor');
	      }
	      var S = C[symbolSpecies];
	      if (S === void 0 || S === null) {
	        return defaultConstructor;
	      }
	      if (!ES.IsConstructor(S)) {
	        throw new TypeError('Bad @@species');
	      }
	      return S;
	    },

	    CreateHTML: function (string, tag, attribute, value) {
	      var S = String(string);
	      var p1 = '<' + tag;
	      if (attribute !== '') {
	        var V = String(value);
	        var escapedV = V.replace(/"/g, '&quot;');
	        p1 += ' ' + attribute + '="' + escapedV + '"';
	      }
	      var p2 = p1 + '>';
	      var p3 = p2 + S;
	      return p3 + '</' + tag + '>';
	    }
	  };

	  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
	    // This is an es5 approximation to es6 construct semantics.  in es6,
	    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
	    // just sets the internal variable NewTarget (in es6 syntax `new.target`)
	    // to Foo and then returns Foo().

	    // Many ES6 object then have constructors of the form:
	    // 1. If NewTarget is undefined, throw a TypeError exception
	    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

	    // So we're going to emulate those first two steps.
	    if (!ES.TypeIsObject(o)) {
	      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
	    }
	    var proto = defaultNewTarget.prototype;
	    if (!ES.TypeIsObject(proto)) {
	      proto = defaultProto;
	    }
	    o = create(proto);
	    for (var name in slots) {
	      if (_hasOwnProperty(slots, name)) {
	        var value = slots[name];
	        defineProperty(o, name, value, true);
	      }
	    }
	    return o;
	  };

	  // Firefox 31 reports this function's length as 0
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
	  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
	    var originalFromCodePoint = String.fromCodePoint;
	    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) { return _apply(originalFromCodePoint, this, arguments); });
	  }

	  var StringShims = {
	    fromCodePoint: function fromCodePoint(codePoints) {
	      var result = [];
	      var next;
	      for (var i = 0, length = arguments.length; i < length; i++) {
	        next = Number(arguments[i]);
	        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
	          throw new RangeError('Invalid code point ' + next);
	        }

	        if (next < 0x10000) {
	          _push(result, String.fromCharCode(next));
	        } else {
	          next -= 0x10000;
	          _push(result, String.fromCharCode((next >> 10) + 0xD800));
	          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
	        }
	      }
	      return result.join('');
	    },

	    raw: function raw(callSite) {
	      var cooked = ES.ToObject(callSite, 'bad callSite');
	      var rawString = ES.ToObject(cooked.raw, 'bad raw value');
	      var len = rawString.length;
	      var literalsegments = ES.ToLength(len);
	      if (literalsegments <= 0) {
	        return '';
	      }

	      var stringElements = [];
	      var nextIndex = 0;
	      var nextKey, next, nextSeg, nextSub;
	      while (nextIndex < literalsegments) {
	        nextKey = String(nextIndex);
	        nextSeg = String(rawString[nextKey]);
	        _push(stringElements, nextSeg);
	        if (nextIndex + 1 >= literalsegments) {
	          break;
	        }
	        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
	        nextSub = String(next);
	        _push(stringElements, nextSub);
	        nextIndex++;
	      }
	      return stringElements.join('');
	    }
	  };
	  defineProperties(String, StringShims);
	  if (String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
	    // IE 11 TP has a broken String.raw implementation
	    overrideNative(String, 'raw', StringShims.raw);
	  }

	  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
	  // Perf: http://jsperf.com/string-repeat2/2
	  var stringRepeat = function repeat(s, times) {
	    if (times < 1) { return ''; }
	    if (times % 2) { return repeat(s, times - 1) + s; }
	    var half = repeat(s, times / 2);
	    return half + half;
	  };
	  var stringMaxLength = Infinity;

	  var StringPrototypeShims = {
	    repeat: function repeat(times) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      var numTimes = ES.ToInteger(times);
	      if (numTimes < 0 || numTimes >= stringMaxLength) {
	        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
	      }
	      return stringRepeat(thisStr, numTimes);
	    },

	    startsWith: function startsWith(searchString) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      if (Type.regex(searchString)) {
	        throw new TypeError('Cannot call method "startsWith" with a regex');
	      }
	      var searchStr = String(searchString);
	      var startArg = arguments.length > 1 ? arguments[1] : void 0;
	      var start = _max(ES.ToInteger(startArg), 0);
	      return _strSlice(thisStr, start, start + searchStr.length) === searchStr;
	    },

	    endsWith: function endsWith(searchString) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      if (Type.regex(searchString)) {
	        throw new TypeError('Cannot call method "endsWith" with a regex');
	      }
	      var searchStr = String(searchString);
	      var thisLen = thisStr.length;
	      var posArg = arguments.length > 1 ? arguments[1] : void 0;
	      var pos = typeof posArg === 'undefined' ? thisLen : ES.ToInteger(posArg);
	      var end = _min(_max(pos, 0), thisLen);
	      return _strSlice(thisStr, end - searchStr.length, end) === searchStr;
	    },

	    includes: function includes(searchString) {
	      if (Type.regex(searchString)) {
	        throw new TypeError('"includes" does not accept a RegExp');
	      }
	      var position;
	      if (arguments.length > 1) {
	        position = arguments[1];
	      }
	      // Somehow this trick makes method 100% compat with the spec.
	      return _indexOf(this, searchString, position) !== -1;
	    },

	    codePointAt: function codePointAt(pos) {
	      ES.RequireObjectCoercible(this);
	      var thisStr = String(this);
	      var position = ES.ToInteger(pos);
	      var length = thisStr.length;
	      if (position >= 0 && position < length) {
	        var first = thisStr.charCodeAt(position);
	        var isEnd = (position + 1 === length);
	        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
	        var second = thisStr.charCodeAt(position + 1);
	        if (second < 0xDC00 || second > 0xDFFF) { return first; }
	        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
	      }
	    }
	  };
	  defineProperties(String.prototype, StringPrototypeShims);

	  if ('a'.includes('a', Infinity) !== false) {
	    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
	  }

	  var hasStringTrimBug = '\u0085'.trim().length !== 1;
	  if (hasStringTrimBug) {
	    delete String.prototype.trim;
	    // whitespace from: http://es5.github.io/#x15.5.4.20
	    // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
	    var ws = [
	      '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	      '\u2029\uFEFF'
	    ].join('');
	    var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
	    defineProperties(String.prototype, {
	      trim: function trim() {
	        if (typeof this === 'undefined' || this === null) {
	          throw new TypeError("can't convert " + this + ' to object');
	        }
	        return String(this).replace(trimRegexp, '');
	      }
	    });
	  }

	  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype-@@iterator
	  var StringIterator = function (s) {
	    ES.RequireObjectCoercible(s);
	    this._s = String(s);
	    this._i = 0;
	  };
	  StringIterator.prototype.next = function () {
	    var s = this._s, i = this._i;
	    if (typeof s === 'undefined' || i >= s.length) {
	      this._s = void 0;
	      return { value: void 0, done: true };
	    }
	    var first = s.charCodeAt(i), second, len;
	    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
	      len = 1;
	    } else {
	      second = s.charCodeAt(i + 1);
	      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
	    }
	    this._i = i + len;
	    return { value: s.substr(i, len), done: false };
	  };
	  addIterator(StringIterator.prototype);
	  addIterator(String.prototype, function () {
	    return new StringIterator(this);
	  });

	  if (!startsWithIsCompliant) {
	    // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
	    overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
	    overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
	  }

	  var ArrayShims = {
	    from: function from(items) {
	      var C = this;
	      var mapFn = arguments.length > 1 ? arguments[1] : void 0;
	      var mapping, T;
	      if (mapFn === void 0) {
	        mapping = false;
	      } else {
	        if (!ES.IsCallable(mapFn)) {
	          throw new TypeError('Array.from: when provided, the second argument must be a function');
	        }
	        T = arguments.length > 2 ? arguments[2] : void 0;
	        mapping = true;
	      }

	      // Note that that Arrays will use ArrayIterator:
	      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
	      var usingIterator = isArguments(items) || ES.GetMethod(items, $iterator$);

	      var length, result, i;
	      if (usingIterator !== void 0) {
	        result = ES.IsConstructor(C) ? Object(new C()) : [];
	        var iterator = ES.GetIterator(items);
	        var next, nextValue;

	        i = 0;
	        while (true) {
	          next = ES.IteratorStep(iterator);
	          if (next === false) {
	            break;
	          }
	          nextValue = next.value;
	          try {
	            if (mapping) {
	              nextValue = T !== undefined ? _call(mapFn, T, nextValue, i) : mapFn(nextValue, i);
	            }
	            result[i] = nextValue;
	          } catch (e) {
	            ES.IteratorClose(iterator, true);
	            throw e;
	          }
	          i += 1;
	        }
	        length = i;
	      } else {
	        var arrayLike = ES.ToObject(items);
	        length = ES.ToLength(arrayLike.length);
	        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
	        var value;
	        for (i = 0; i < length; ++i) {
	          value = arrayLike[i];
	          if (mapping) {
	            value = T !== undefined ? _call(mapFn, T, value, i) : mapFn(value, i);
	          }
	          result[i] = value;
	        }
	      }

	      result.length = length;
	      return result;
	    },

	    of: function of() {
	      var len = arguments.length;
	      var C = this;
	      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
	      for (var k = 0; k < len; ++k) {
	        createDataPropertyOrThrow(A, k, arguments[k]);
	      }
	      A.length = len;
	      return A;
	    }
	  };
	  defineProperties(Array, ArrayShims);
	  addDefaultSpecies(Array);

	  // Given an argument x, it will return an IteratorResult object,
	  // with value set to x and done to false.
	  // Given no arguments, it will return an iterator completion object.
	  var iteratorResult = function (x) {
	    return { value: x, done: arguments.length === 0 };
	  };

	  // Our ArrayIterator is private; see
	  // https://github.com/paulmillr/es6-shim/issues/252
	  ArrayIterator = function (array, kind) {
	      this.i = 0;
	      this.array = array;
	      this.kind = kind;
	  };

	  defineProperties(ArrayIterator.prototype, {
	    next: function () {
	      var i = this.i, array = this.array;
	      if (!(this instanceof ArrayIterator)) {
	        throw new TypeError('Not an ArrayIterator');
	      }
	      if (typeof array !== 'undefined') {
	        var len = ES.ToLength(array.length);
	        for (; i < len; i++) {
	          var kind = this.kind;
	          var retval;
	          if (kind === 'key') {
	            retval = i;
	          } else if (kind === 'value') {
	            retval = array[i];
	          } else if (kind === 'entry') {
	            retval = [i, array[i]];
	          }
	          this.i = i + 1;
	          return { value: retval, done: false };
	        }
	      }
	      this.array = void 0;
	      return { value: void 0, done: true };
	    }
	  });
	  addIterator(ArrayIterator.prototype);

	  var ObjectIterator = function (object, kind) {
	    defineProperties(this, {
	      object: object,
	      array: getAllKeys(object),
	      kind: kind
	    });
	  };

	  var getAllKeys = function getAllKeys(object) {
	    var keys = [];

	    for (var key in object) {
	      _push(keys, key);
	    }

	    return keys;
	  };

	  defineProperties(ObjectIterator.prototype, {
	    next: function next() {
	      var key;
	      var array = this.array;

	      if (!(this instanceof ObjectIterator)) {
	        throw new TypeError('Not an ObjectIterator');
	      }

	      // Find next key in the object
	      while (array.length > 0) {
	        key = _shift(array);

	        // The candidate key isn't defined on object.
	        // Must have been deleted, or object[[Prototype]]
	        // has been modified.
	        if (!(key in this.object)) {
	          continue;
	        }

	        if (this.kind === 'key') {
	          return iteratorResult(key);
	        } else if (this.kind === 'value') {
	          return iteratorResult(this.object[key]);
	        } else {
	          return iteratorResult([key, this.object[key]]);
	        }
	      }

	      return iteratorResult();
	    }
	  });
	  addIterator(ObjectIterator.prototype);

	  // note: this is positioned here because it depends on ArrayIterator
	  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
	    // Detects a bug in Webkit nightly r181886
	    var Foo = function Foo(len) { this.length = len; };
	    Foo.prototype = [];
	    var fooArr = Array.of.apply(Foo, [1, 2]);
	    return fooArr instanceof Foo && fooArr.length === 2;
	  }());
	  if (!arrayOfSupportsSubclassing) {
	    overrideNative(Array, 'of', ArrayShims.of);
	  }

	  var ArrayPrototypeShims = {
	    copyWithin: function copyWithin(target, start) {
	      var end = arguments[2]; // copyWithin.length must be 2
	      var o = ES.ToObject(this);
	      var len = ES.ToLength(o.length);
	      var relativeTarget = ES.ToInteger(target);
	      var relativeStart = ES.ToInteger(start);
	      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
	      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
	      end = typeof end === 'undefined' ? len : ES.ToInteger(end);
	      var fin = end < 0 ? _max(len + end, 0) : _min(end, len);
	      var count = _min(fin - from, len - to);
	      var direction = 1;
	      if (from < to && to < (from + count)) {
	        direction = -1;
	        from += count - 1;
	        to += count - 1;
	      }
	      while (count > 0) {
	        if (_hasOwnProperty(o, from)) {
	          o[to] = o[from];
	        } else {
	          delete o[from];
	        }
	        from += direction;
	        to += direction;
	        count -= 1;
	      }
	      return o;
	    },

	    fill: function fill(value) {
	      var start = arguments.length > 1 ? arguments[1] : void 0;
	      var end = arguments.length > 2 ? arguments[2] : void 0;
	      var O = ES.ToObject(this);
	      var len = ES.ToLength(O.length);
	      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
	      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

	      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
	      var relativeEnd = end < 0 ? len + end : end;

	      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
	        O[i] = value;
	      }
	      return O;
	    },

	    find: function find(predicate) {
	      var list = ES.ToObject(this);
	      var length = ES.ToLength(list.length);
	      if (!ES.IsCallable(predicate)) {
	        throw new TypeError('Array#find: predicate must be a function');
	      }
	      var thisArg = arguments.length > 1 ? arguments[1] : null;
	      for (var i = 0, value; i < length; i++) {
	        value = list[i];
	        if (thisArg) {
	          if (_call(predicate, thisArg, value, i, list)) { return value; }
	        } else if (predicate(value, i, list)) {
	          return value;
	        }
	      }
	    },

	    findIndex: function findIndex(predicate) {
	      var list = ES.ToObject(this);
	      var length = ES.ToLength(list.length);
	      if (!ES.IsCallable(predicate)) {
	        throw new TypeError('Array#findIndex: predicate must be a function');
	      }
	      var thisArg = arguments.length > 1 ? arguments[1] : null;
	      for (var i = 0; i < length; i++) {
	        if (thisArg) {
	          if (_call(predicate, thisArg, list[i], i, list)) { return i; }
	        } else if (predicate(list[i], i, list)) {
	          return i;
	        }
	      }
	      return -1;
	    },

	    keys: function keys() {
	      return new ArrayIterator(this, 'key');
	    },

	    values: function values() {
	      return new ArrayIterator(this, 'value');
	    },

	    entries: function entries() {
	      return new ArrayIterator(this, 'entry');
	    }
	  };
	  // Safari 7.1 defines Array#keys and Array#entries natively,
	  // but the resulting ArrayIterator objects don't have a "next" method.
	  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
	    delete Array.prototype.keys;
	  }
	  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
	    delete Array.prototype.entries;
	  }

	  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
	  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
	    defineProperties(Array.prototype, {
	      values: Array.prototype[$iterator$]
	    });
	    if (Type.symbol(Symbol.unscopables)) {
	      Array.prototype[Symbol.unscopables].values = true;
	    }
	  }
	  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
	  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
	    var originalArrayPrototypeValues = Array.prototype.values;
	    overrideNative(Array.prototype, 'values', function values() { return _call(originalArrayPrototypeValues, this); });
	    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
	  }
	  defineProperties(Array.prototype, ArrayPrototypeShims);

	  addIterator(Array.prototype, function () { return this.values(); });
	  // Chrome defines keys/values/entries on Array, but doesn't give us
	  // any way to identify its iterator.  So add our own shimmed field.
	  if (Object.getPrototypeOf) {
	    addIterator(Object.getPrototypeOf([].values()));
	  }

	  // note: this is positioned here because it relies on Array#entries
	  var arrayFromSwallowsNegativeLengths = (function () {
	    // Detects a Firefox bug in v32
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
	    return valueOrFalseIfThrows(function () { return Array.from({ length: -1 }).length === 0; });
	  }());
	  var arrayFromHandlesIterables = (function () {
	    // Detects a bug in Webkit nightly r181886
	    var arr = Array.from([0].entries());
	    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
	  }());
	  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
	    overrideNative(Array, 'from', ArrayShims.from);
	  }
	  var arrayFromHandlesUndefinedMapFunction = (function () {
	    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
	    // but the spec doesn't care if it's provided or not - undefined doesn't throw.
	    return valueOrFalseIfThrows(function () { return Array.from([0], undefined); });
	  }());
	  if (!arrayFromHandlesUndefinedMapFunction) {
	    var origArrayFrom = Array.from;
	    overrideNative(Array, 'from', function from(items) {
	      if (arguments.length > 0 && typeof arguments[1] !== 'undefined') {
	        return _apply(origArrayFrom, this, arguments);
	      } else {
	        return _call(origArrayFrom, this, items);
	      }
	    });
	  }

	  var toLengthsCorrectly = function (method, reversed) {
	    var obj = { length: -1 };
	    obj[reversed ? ((-1 >>> 0) - 1) : 0] = true;
	    return valueOrFalseIfThrows(function () {
	      _call(method, obj, function () {
	        // note: in nonconforming browsers, this will be called
	        // -1 >>> 0 times, which is 4294967295, so the throw matters.
	        throw new RangeError('should not reach here');
	      }, []);
	    });
	  };
	  if (!toLengthsCorrectly(Array.prototype.forEach)) {
	    var originalForEach = Array.prototype.forEach;
	    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
	      return _apply(originalForEach, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.map)) {
	    var originalMap = Array.prototype.map;
	    overrideNative(Array.prototype, 'map', function map(callbackFn) {
	      return _apply(originalMap, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.filter)) {
	    var originalFilter = Array.prototype.filter;
	    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
	      return _apply(originalFilter, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.some)) {
	    var originalSome = Array.prototype.some;
	    overrideNative(Array.prototype, 'some', function some(callbackFn) {
	      return _apply(originalSome, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.every)) {
	    var originalEvery = Array.prototype.every;
	    overrideNative(Array.prototype, 'every', function every(callbackFn) {
	      return _apply(originalEvery, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.reduce)) {
	    var originalReduce = Array.prototype.reduce;
	    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
	      return _apply(originalReduce, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }
	  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
	    var originalReduceRight = Array.prototype.reduceRight;
	    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
	      return _apply(originalReduceRight, this.length >= 0 ? this : [], arguments);
	    }, true);
	  }

	  if (Number('0o10') !== 8 || Number('0b10') !== 2) {
	    var OrigNumber = Number;
	    var binaryRegex = /^0b/i;
	    var octalRegex = /^0o/i;
	    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
	    var isBinary = binaryRegex.test.bind(binaryRegex);
	    var isOctal = octalRegex.test.bind(octalRegex);
	    var toPrimitive = function (O) { // need to replace this with `es-to-primitive/es6`
	      var result;
	      if (typeof O.valueOf === 'function') {
	        result = O.valueOf();
	        if (Type.primitive(result)) {
	          return result;
	        }
	      }
	      if (typeof O.toString === 'function') {
	        result = O.toString();
	        if (Type.primitive(result)) {
	          return result;
	        }
	      }
	      throw new TypeError('No default value');
	    };
	    var NumberShim = (function () {
	      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
	      return function Number(value) {
	        var primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
	        if (typeof primValue === 'string') {
	          if (isBinary(primValue)) {
	            primValue = parseInt(_strSlice(primValue, 2), 2);
	          } else if (isOctal(primValue)) {
	            primValue = parseInt(_strSlice(primValue, 2), 8);
	          }
	        }
	        if (this instanceof Number) {
	          return new OrigNumber(primValue);
	        }
	        /* jshint newcap: false */
	        return OrigNumber(primValue);
	        /* jshint newcap: true */
	      };
	    }());
	    wrapConstructor(OrigNumber, NumberShim, {});
	    /*globals Number: true */
	    Number = NumberShim;
	    Value.redefine(globals, 'Number', NumberShim);
	    /*globals Number: false */
	  }

	  var maxSafeInteger = Math.pow(2, 53) - 1;
	  defineProperties(Number, {
	    MAX_SAFE_INTEGER: maxSafeInteger,
	    MIN_SAFE_INTEGER: -maxSafeInteger,
	    EPSILON: 2.220446049250313e-16,

	    parseInt: globals.parseInt,
	    parseFloat: globals.parseFloat,

	    isFinite: numberIsFinite,

	    isInteger: function isInteger(value) {
	      return numberIsFinite(value) && ES.ToInteger(value) === value;
	    },

	    isSafeInteger: function isSafeInteger(value) {
	      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
	    },

	    isNaN: numberIsNaN
	  });
	  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
	  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

	  // Work around bugs in Array#find and Array#findIndex -- early
	  // implementations skipped holes in sparse arrays. (Note that the
	  // implementations of find/findIndex indirectly use shimmed
	  // methods of Number, so this test has to happen down here.)
	  /*jshint elision: true */
	  if (![, 1].find(function (item, idx) { return idx === 0; })) {
	    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
	  }
	  if ([, 1].findIndex(function (item, idx) { return idx === 0; }) !== 0) {
	    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
	  }
	  /*jshint elision: false */

	  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
	  var sliceArgs = function sliceArgs() {
	    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
	    var initial = Number(this);
	    var len = arguments.length;
	    var desiredArgCount = len - initial;
	    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
	    for (var i = initial; i < len; ++i) {
	      args[i - initial] = arguments[i];
	    }
	    return args;
	  };
	  var assignTo = function assignTo(source) {
	    return function assignToSource(target, key) {
	      target[key] = source[key];
	      return target;
	    };
	  };
	  var assignReducer = function (target, source) {
	    var keys = Object.keys(Object(source));
	    var symbols;
	    if (ES.IsCallable(Object.getOwnPropertySymbols)) {
	      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
	    }
	    return _reduce(_concat(keys, symbols || []), assignTo(source), target);
	  };

	  var ObjectShims = {
	    // 19.1.3.1
	    assign: function (target, source) {
	      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
	      return _reduce(_apply(sliceArgs, 1, arguments), assignReducer, to);
	    },

	    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
	    is: function is(a, b) {
	      return ES.SameValue(a, b);
	    }
	  };
	  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
	    // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	    // which is 72% slower than our shim, and Firefox 40's native implementation.
	    var thrower = Object.preventExtensions({ 1: 2 });
	    try {
	      Object.assign(thrower, 'xy');
	    } catch (e) {
	      return thrower[1] === 'y';
	    }
	  }());
	  if (assignHasPendingExceptions) {
	    overrideNative(Object, 'assign', ObjectShims.assign);
	  }
	  defineProperties(Object, ObjectShims);

	  if (supportsDescriptors) {
	    var ES5ObjectShims = {
	      // 19.1.3.9
	      // shim from https://gist.github.com/WebReflection/5593554
	      setPrototypeOf: (function (Object, magic) {
	        var set;

	        var checkArgs = function (O, proto) {
	          if (!ES.TypeIsObject(O)) {
	            throw new TypeError('cannot set prototype on a non-object');
	          }
	          if (!(proto === null || ES.TypeIsObject(proto))) {
	            throw new TypeError('can only set prototype to an object or null' + proto);
	          }
	        };

	        var setPrototypeOf = function (O, proto) {
	          checkArgs(O, proto);
	          _call(set, O, proto);
	          return O;
	        };

	        try {
	          // this works already in Firefox and Safari
	          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
	          _call(set, {}, null);
	        } catch (e) {
	          if (Object.prototype !== {}[magic]) {
	            // IE < 11 cannot be shimmed
	            return;
	          }
	          // probably Chrome or some old Mobile stock browser
	          set = function (proto) {
	            this[magic] = proto;
	          };
	          // please note that this will **not** work
	          // in those browsers that do not inherit
	          // __proto__ by mistake from Object.prototype
	          // in these cases we should probably throw an error
	          // or at least be informed about the issue
	          setPrototypeOf.polyfill = setPrototypeOf(
	            setPrototypeOf({}, null),
	            Object.prototype
	          ) instanceof Object;
	          // setPrototypeOf.polyfill === true means it works as meant
	          // setPrototypeOf.polyfill === false means it's not 100% reliable
	          // setPrototypeOf.polyfill === undefined
	          // or
	          // setPrototypeOf.polyfill ==  null means it's not a polyfill
	          // which means it works as expected
	          // we can even delete Object.prototype.__proto__;
	        }
	        return setPrototypeOf;
	      }(Object, '__proto__'))
	    };

	    defineProperties(Object, ES5ObjectShims);
	  }

	  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
	  // but Object.create(null) does.
	  if (Object.setPrototypeOf && Object.getPrototypeOf &&
	      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
	      Object.getPrototypeOf(Object.create(null)) === null) {
	    (function () {
	      var FAKENULL = Object.create(null);
	      var gpo = Object.getPrototypeOf, spo = Object.setPrototypeOf;
	      Object.getPrototypeOf = function (o) {
	        var result = gpo(o);
	        return result === FAKENULL ? null : result;
	      };
	      Object.setPrototypeOf = function (o, p) {
	        var proto = p === null ? FAKENULL : p;
	        return spo(o, proto);
	      };
	      Object.setPrototypeOf.polyfill = false;
	    }());
	  }

	  var objectKeysAcceptsPrimitives = !throwsError(function () { Object.keys('foo'); });
	  if (!objectKeysAcceptsPrimitives) {
	    var originalObjectKeys = Object.keys;
	    overrideNative(Object, 'keys', function keys(value) {
	      return originalObjectKeys(ES.ToObject(value));
	    });
	  }

	  if (Object.getOwnPropertyNames) {
	    var objectGOPNAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyNames('foo'); });
	    if (!objectGOPNAcceptsPrimitives) {
	      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
	      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
	      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
	        var val = ES.ToObject(value);
	        if (_toString(val) === '[object Window]') {
	          try {
	            return originalObjectGetOwnPropertyNames(val);
	          } catch (e) {
	            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
	            return _concat([], cachedWindowNames);
	          }
	        }
	        return originalObjectGetOwnPropertyNames(val);
	      });
	    }
	  }
	  if (Object.getOwnPropertyDescriptor) {
	    var objectGOPDAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyDescriptor('foo', 'bar'); });
	    if (!objectGOPDAcceptsPrimitives) {
	      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
	        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
	      });
	    }
	  }
	  if (Object.seal) {
	    var objectSealAcceptsPrimitives = !throwsError(function () { Object.seal('foo'); });
	    if (!objectSealAcceptsPrimitives) {
	      var originalObjectSeal = Object.seal;
	      overrideNative(Object, 'seal', function seal(value) {
	        if (!Type.object(value)) { return value; }
	        return originalObjectSeal(value);
	      });
	    }
	  }
	  if (Object.isSealed) {
	    var objectIsSealedAcceptsPrimitives = !throwsError(function () { Object.isSealed('foo'); });
	    if (!objectIsSealedAcceptsPrimitives) {
	      var originalObjectIsSealed = Object.isSealed;
	      overrideNative(Object, 'isSealed', function isSealed(value) {
	        if (!Type.object(value)) { return true; }
	        return originalObjectIsSealed(value);
	      });
	    }
	  }
	  if (Object.freeze) {
	    var objectFreezeAcceptsPrimitives = !throwsError(function () { Object.freeze('foo'); });
	    if (!objectFreezeAcceptsPrimitives) {
	      var originalObjectFreeze = Object.freeze;
	      overrideNative(Object, 'freeze', function freeze(value) {
	        if (!Type.object(value)) { return value; }
	        return originalObjectFreeze(value);
	      });
	    }
	  }
	  if (Object.isFrozen) {
	    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { Object.isFrozen('foo'); });
	    if (!objectIsFrozenAcceptsPrimitives) {
	      var originalObjectIsFrozen = Object.isFrozen;
	      overrideNative(Object, 'isFrozen', function isFrozen(value) {
	        if (!Type.object(value)) { return true; }
	        return originalObjectIsFrozen(value);
	      });
	    }
	  }
	  if (Object.preventExtensions) {
	    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { Object.preventExtensions('foo'); });
	    if (!objectPreventExtensionsAcceptsPrimitives) {
	      var originalObjectPreventExtensions = Object.preventExtensions;
	      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
	        if (!Type.object(value)) { return value; }
	        return originalObjectPreventExtensions(value);
	      });
	    }
	  }
	  if (Object.isExtensible) {
	    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { Object.isExtensible('foo'); });
	    if (!objectIsExtensibleAcceptsPrimitives) {
	      var originalObjectIsExtensible = Object.isExtensible;
	      overrideNative(Object, 'isExtensible', function isExtensible(value) {
	        if (!Type.object(value)) { return false; }
	        return originalObjectIsExtensible(value);
	      });
	    }
	  }
	  if (Object.getPrototypeOf) {
	    var objectGetProtoAcceptsPrimitives = !throwsError(function () { Object.getPrototypeOf('foo'); });
	    if (!objectGetProtoAcceptsPrimitives) {
	      var originalGetProto = Object.getPrototypeOf;
	      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
	        return originalGetProto(ES.ToObject(value));
	      });
	    }
	  }

	  if (!RegExp.prototype.flags && supportsDescriptors) {
	    var regExpFlagsGetter = function flags() {
	      if (!ES.TypeIsObject(this)) {
	        throw new TypeError('Method called on incompatible type: must be an object.');
	      }
	      var result = '';
	      if (this.global) {
	        result += 'g';
	      }
	      if (this.ignoreCase) {
	        result += 'i';
	      }
	      if (this.multiline) {
	        result += 'm';
	      }
	      if (this.unicode) {
	        result += 'u';
	      }
	      if (this.sticky) {
	        result += 'y';
	      }
	      return result;
	    };

	    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
	  }

	  var regExpSupportsFlagsWithRegex = valueOrFalseIfThrows(function () {
	    return String(new RegExp(/a/g, 'i')) === '/a/i';
	  });

	  if (!regExpSupportsFlagsWithRegex && supportsDescriptors) {
	    var OrigRegExp = RegExp;
	    var RegExpShim = function RegExp(pattern, flags) {
	      var calledWithNew = this instanceof RegExp;
	      if (!calledWithNew && (Type.regex(pattern) || (pattern && pattern.constructor === RegExp))) {
	        return pattern;
	      }
	      if (Type.regex(pattern) && Type.string(flags)) {
	        return new RegExp(pattern.source, flags);
	      }
	      return new OrigRegExp(pattern, flags);
	    };
	    wrapConstructor(OrigRegExp, RegExpShim, {
	      $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
	    });
	    /*globals RegExp: true */
	    RegExp = RegExpShim;
	    Value.redefine(globals, 'RegExp', RegExpShim);
	    /*globals RegExp: false */
	  }

	  if (supportsDescriptors) {
	    var regexGlobals = {
	      input: '$_',
	      lastMatch: '$&',
	      lastParen: '$+',
	      leftContext: '$`',
	      rightContext: '$\''
	    };
	    _forEach(Object.keys(regexGlobals), function (prop) {
	      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
	        Value.getter(RegExp, regexGlobals[prop], function get() {
	          return RegExp[prop];
	        });
	      }
	    });
	  }
	  addDefaultSpecies(RegExp);

	  var inverseEpsilon = 1 / Number.EPSILON;
	  var roundTiesToEven = function roundTiesToEven(n) {
	    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
	    return (n + inverseEpsilon) - inverseEpsilon;
	  };
	  var BINARY_32_EPSILON = Math.pow(2, -23);
	  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
	  var BINARY_32_MIN_VALUE = Math.pow(2, -126);
	  var numberCLZ = Number.prototype.clz;
	  delete Number.prototype.clz; // Safari 8 has Number#clz

	  var MathShims = {
	    acosh: function acosh(value) {
	      var x = Number(value);
	      if (Number.isNaN(x) || value < 1) { return NaN; }
	      if (x === 1) { return 0; }
	      if (x === Infinity) { return x; }
	      return _log(x / Math.E + _sqrt(x + 1) * _sqrt(x - 1) / Math.E) + 1;
	    },

	    asinh: function asinh(value) {
	      var x = Number(value);
	      if (x === 0 || !globalIsFinite(x)) {
	        return x;
	      }
	      return x < 0 ? -Math.asinh(-x) : _log(x + _sqrt(x * x + 1));
	    },

	    atanh: function atanh(value) {
	      var x = Number(value);
	      if (Number.isNaN(x) || x < -1 || x > 1) {
	        return NaN;
	      }
	      if (x === -1) { return -Infinity; }
	      if (x === 1) { return Infinity; }
	      if (x === 0) { return x; }
	      return 0.5 * _log((1 + x) / (1 - x));
	    },

	    cbrt: function cbrt(value) {
	      var x = Number(value);
	      if (x === 0) { return x; }
	      var negate = x < 0, result;
	      if (negate) { x = -x; }
	      if (x === Infinity) {
	        result = Infinity;
	      } else {
	        result = Math.exp(_log(x) / 3);
	        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
	        result = (x / (result * result) + (2 * result)) / 3;
	      }
	      return negate ? -result : result;
	    },

	    clz32: function clz32(value) {
	      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
	      var x = Number(value);
	      var number = ES.ToUint32(x);
	      if (number === 0) {
	        return 32;
	      }
	      return numberCLZ ? _call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * Math.LOG2E);
	    },

	    cosh: function cosh(value) {
	      var x = Number(value);
	      if (x === 0) { return 1; } // +0 or -0
	      if (Number.isNaN(x)) { return NaN; }
	      if (!globalIsFinite(x)) { return Infinity; }
	      if (x < 0) { x = -x; }
	      if (x > 21) { return Math.exp(x) / 2; }
	      return (Math.exp(x) + Math.exp(-x)) / 2;
	    },

	    expm1: function expm1(value) {
	      var x = Number(value);
	      if (x === -Infinity) { return -1; }
	      if (!globalIsFinite(x) || x === 0) { return x; }
	      if (_abs(x) > 0.5) {
	        return Math.exp(x) - 1;
	      }
	      // A more precise approximation using Taylor series expansion
	      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
	      var t = x;
	      var sum = 0;
	      var n = 1;
	      while (sum + t !== sum) {
	        sum += t;
	        n += 1;
	        t *= x / n;
	      }
	      return sum;
	    },

	    hypot: function hypot(x, y) {
	      var result = 0;
	      var largest = 0;
	      for (var i = 0; i < arguments.length; ++i) {
	        var value = _abs(Number(arguments[i]));
	        if (largest < value) {
	          result *= (largest / value) * (largest / value);
	          result += 1;
	          largest = value;
	        } else {
	          result += (value > 0 ? (value / largest) * (value / largest) : value);
	        }
	      }
	      return largest === Infinity ? Infinity : largest * _sqrt(result);
	    },

	    log2: function log2(value) {
	      return _log(value) * Math.LOG2E;
	    },

	    log10: function log10(value) {
	      return _log(value) * Math.LOG10E;
	    },

	    log1p: function log1p(value) {
	      var x = Number(value);
	      if (x < -1 || Number.isNaN(x)) { return NaN; }
	      if (x === 0 || x === Infinity) { return x; }
	      if (x === -1) { return -Infinity; }

	      return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
	    },

	    sign: function sign(value) {
	      var number = Number(value);
	      if (number === 0) { return number; }
	      if (Number.isNaN(number)) { return number; }
	      return number < 0 ? -1 : 1;
	    },

	    sinh: function sinh(value) {
	      var x = Number(value);
	      if (!globalIsFinite(x) || x === 0) { return x; }

	      if (_abs(x) < 1) {
	        return (Math.expm1(x) - Math.expm1(-x)) / 2;
	      }
	      return (Math.exp(x - 1) - Math.exp(-x - 1)) * Math.E / 2;
	    },

	    tanh: function tanh(value) {
	      var x = Number(value);
	      if (Number.isNaN(x) || x === 0) { return x; }
	      if (x === Infinity) { return 1; }
	      if (x === -Infinity) { return -1; }
	      var a = Math.expm1(x);
	      var b = Math.expm1(-x);
	      if (a === Infinity) { return 1; }
	      if (b === Infinity) { return -1; }
	      return (a - b) / (Math.exp(x) + Math.exp(-x));
	    },

	    trunc: function trunc(value) {
	      var x = Number(value);
	      return x < 0 ? -_floor(-x) : _floor(x);
	    },

	    imul: function imul(x, y) {
	      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
	      var a = ES.ToUint32(x);
	      var b = ES.ToUint32(y);
	      var ah = (a >>> 16) & 0xffff;
	      var al = a & 0xffff;
	      var bh = (b >>> 16) & 0xffff;
	      var bl = b & 0xffff;
	      // the shift by 0 fixes the sign on the high part
	      // the final |0 converts the unsigned value into a signed value
	      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
	    },

	    fround: function fround(x) {
	      var v = Number(x);
	      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
	        return v;
	      }
	      var sign = Math.sign(v);
	      var abs = _abs(v);
	      if (abs < BINARY_32_MIN_VALUE) {
	        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
	      }
	      // Veltkamp's splitting (?)
	      var a = (1 + BINARY_32_EPSILON / Number.EPSILON) * abs;
	      var result = a - (a - abs);
	      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
	        return sign * Infinity;
	      }
	      return sign * result;
	    }
	  };
	  defineProperties(Math, MathShims);
	  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
	  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
	  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
	  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
	  // Chrome 40 has an imprecise Math.tanh with very small numbers
	  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
	  // Chrome 40 loses Math.acosh precision with high numbers
	  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
	  // Firefox 38 on Windows
	  defineProperty(Math, 'cbrt', MathShims.cbrt, Math.abs(1 - Math.cbrt(1e-300) / 1e-100) / Number.EPSILON > 8);
	  // node 0.11 has an imprecise Math.sinh with very small numbers
	  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
	  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
	  var expm1OfTen = Math.expm1(10);
	  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);

	  var origMathRound = Math.round;
	  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
	  var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;

	  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
	  // This behavior should be governed by "round to nearest, ties to even mode"
	  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-number-type
	  // These are the boundary cases where it breaks.
	  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
	  var largestPositiveNumberWhereRoundBreaks = 2 * inverseEpsilon - 1;
	  var roundDoesNotIncreaseIntegers = [smallestPositiveNumberWhereRoundBreaks, largestPositiveNumberWhereRoundBreaks].every(function (num) {
	    return Math.round(num) === num;
	  });
	  defineProperty(Math, 'round', function round(x) {
	    var floor = _floor(x);
	    var ceil = floor === -1 ? -0 : floor + 1;
	    return x - floor < 0.5 ? floor : ceil;
	  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
	  Value.preserveToString(Math.round, origMathRound);

	  var origImul = Math.imul;
	  if (Math.imul(0xffffffff, 5) !== -5) {
	    // Safari 6.1, at least, reports "0" for this value
	    Math.imul = MathShims.imul;
	    Value.preserveToString(Math.imul, origImul);
	  }
	  if (Math.imul.length !== 2) {
	    // Safari 8.0.4 has a length of 1
	    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
	    overrideNative(Math, 'imul', function imul(x, y) {
	      return _apply(origImul, Math, arguments);
	    });
	  }

	  // Promises
	  // Simplest possible implementation; use a 3rd-party library if you
	  // want the best possible speed and/or long stack traces.
	  var PromiseShim = (function () {
	    var setTimeout = globals.setTimeout;
	    // some environments don't have setTimeout - no way to shim here.
	    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

	    ES.IsPromise = function (promise) {
	      if (!ES.TypeIsObject(promise)) {
	        return false;
	      }
	      if (typeof promise._promise === 'undefined') {
	        return false; // uninitialized, or missing our hidden field.
	      }
	      return true;
	    };

	    // "PromiseCapability" in the spec is what most promise implementations
	    // call a "deferred".
	    var PromiseCapability = function (C) {
	      if (!ES.IsConstructor(C)) {
	        throw new TypeError('Bad promise constructor');
	      }
	      var capability = this;
	      var resolver = function (resolve, reject) {
	        if (capability.resolve !== void 0 || capability.reject !== void 0) {
	          throw new TypeError('Bad Promise implementation!');
	        }
	        capability.resolve = resolve;
	        capability.reject = reject;
	      };
	      capability.promise = new C(resolver);
	      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
	        throw new TypeError('Bad promise constructor');
	      }
	    };

	    // find an appropriate setImmediate-alike
	    var makeZeroTimeout;
	    /*global window */
	    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
	      makeZeroTimeout = function () {
	        // from http://dbaron.org/log/20100309-faster-timeouts
	        var timeouts = [];
	        var messageName = 'zero-timeout-message';
	        var setZeroTimeout = function (fn) {
	          _push(timeouts, fn);
	          window.postMessage(messageName, '*');
	        };
	        var handleMessage = function (event) {
	          if (event.source === window && event.data === messageName) {
	            event.stopPropagation();
	            if (timeouts.length === 0) { return; }
	            var fn = _shift(timeouts);
	            fn();
	          }
	        };
	        window.addEventListener('message', handleMessage, true);
	        return setZeroTimeout;
	      };
	    }
	    var makePromiseAsap = function () {
	      // An efficient task-scheduler based on a pre-existing Promise
	      // implementation, which we can use even if we override the
	      // global Promise below (in order to workaround bugs)
	      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
	      var P = globals.Promise;
	      return P && P.resolve && function (task) {
	        return P.resolve().then(task);
	      };
	    };
	    /*global process */
	    var enqueue = ES.IsCallable(globals.setImmediate) ?
	      globals.setImmediate.bind(globals) :
	      typeof process === 'object' && process.nextTick ? process.nextTick :
	      makePromiseAsap() ||
	      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() :
	      function (task) { setTimeout(task, 0); }); // fallback

	    // Constants for Promise implementation
	    var PROMISE_IDENTITY = 1;
	    var PROMISE_THROWER = 2;
	    var PROMISE_PENDING = 3;
	    var PROMISE_FULFILLED = 4;
	    var PROMISE_REJECTED = 5;

	    var promiseReactionJob = function (reaction, argument) {
	      var promiseCapability = reaction.capabilities;
	      var handler = reaction.handler;
	      var handlerResult, handlerException = false, f;
	      if (handler === PROMISE_IDENTITY) {
	        handlerResult = argument;
	      } else if (handler === PROMISE_THROWER) {
	        handlerResult = argument;
	        handlerException = true;
	      } else {
	        try {
	          handlerResult = handler(argument);
	        } catch (e) {
	          handlerResult = e;
	          handlerException = true;
	        }
	      }
	      f = handlerException ? promiseCapability.reject : promiseCapability.resolve;
	      f(handlerResult);
	    };

	    var triggerPromiseReactions = function (reactions, argument) {
	      _forEach(reactions, function (reaction) {
	        enqueue(function () {
	          promiseReactionJob(reaction, argument);
	        });
	      });
	    };

	    var fulfillPromise = function (promise, value) {
	      var _promise = promise._promise;
	      var reactions = _promise.fulfillReactions;
	      _promise.result = value;
	      _promise.fulfillReactions = void 0;
	      _promise.rejectReactions = void 0;
	      _promise.state = PROMISE_FULFILLED;
	      triggerPromiseReactions(reactions, value);
	    };

	    var rejectPromise = function (promise, reason) {
	      var _promise = promise._promise;
	      var reactions = _promise.rejectReactions;
	      _promise.result = reason;
	      _promise.fulfillReactions = void 0;
	      _promise.rejectReactions = void 0;
	      _promise.state = PROMISE_REJECTED;
	      triggerPromiseReactions(reactions, reason);
	    };

	    var createResolvingFunctions = function (promise) {
	      var alreadyResolved = false;
	      var resolve = function (resolution) {
	        var then;
	        if (alreadyResolved) { return; }
	        alreadyResolved = true;
	        if (resolution === promise) {
	          return rejectPromise(promise, new TypeError('Self resolution'));
	        }
	        if (!ES.TypeIsObject(resolution)) {
	          return fulfillPromise(promise, resolution);
	        }
	        try {
	          then = resolution.then;
	        } catch (e) {
	          return rejectPromise(promise, e);
	        }
	        if (!ES.IsCallable(then)) {
	          return fulfillPromise(promise, resolution);
	        }
	        enqueue(function () {
	          promiseResolveThenableJob(promise, resolution, then);
	        });
	      };
	      var reject = function (reason) {
	        if (alreadyResolved) { return; }
	        alreadyResolved = true;
	        return rejectPromise(promise, reason);
	      };
	      return { resolve: resolve, reject: reject };
	    };

	    var promiseResolveThenableJob = function (promise, thenable, then) {
	      var resolvingFunctions = createResolvingFunctions(promise);
	      var resolve = resolvingFunctions.resolve;
	      var reject = resolvingFunctions.reject;
	      try {
	        _call(then, thenable, resolve, reject);
	      } catch (e) {
	        reject(e);
	      }
	    };

	    // This is a common step in many Promise methods
	    var getPromiseSpecies = function (C) {
	      if (!ES.TypeIsObject(C)) {
	        throw new TypeError('Promise is not object');
	      }
	      var S = C[symbolSpecies];
	      if (S !== void 0 && S !== null) {
	        return S;
	      }
	      return C;
	    };

	    var Promise = function Promise(resolver) {
	      if (!(this instanceof Promise)) {
	        throw new TypeError('Constructor Promise requires "new"');
	      }
	      if (this && this._promise) {
	        throw new TypeError('Bad construction');
	      }
	      // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
	      if (!ES.IsCallable(resolver)) {
	        throw new TypeError('not a valid resolver');
	      }
	      var promise = emulateES6construct(this, Promise, Promise$prototype, {
	        _promise: {
	          result: void 0,
	          state: PROMISE_PENDING,
	          fulfillReactions: [],
	          rejectReactions: []
	        }
	      });
	      var resolvingFunctions = createResolvingFunctions(promise);
	      var reject = resolvingFunctions.reject;
	      try {
	        resolver(resolvingFunctions.resolve, reject);
	      } catch (e) {
	        reject(e);
	      }
	      return promise;
	    };
	    var Promise$prototype = Promise.prototype;

	    var _promiseAllResolver = function (index, values, capability, remaining) {
	      var alreadyCalled = false;
	      return function (x) {
	        if (alreadyCalled) { return; }
	        alreadyCalled = true;
	        values[index] = x;
	        if ((--remaining.count) === 0) {
	          var resolve = capability.resolve;
	          resolve(values); // call w/ this===undefined
	        }
	      };
	    };

	    var performPromiseAll = function (iteratorRecord, C, resultCapability) {
	      var it = iteratorRecord.iterator;
	      var values = [], remaining = { count: 1 }, next, nextValue;
	      var index = 0;
	      while (true) {
	        try {
	          next = ES.IteratorStep(it);
	          if (next === false) {
	            iteratorRecord.done = true;
	            break;
	          }
	          nextValue = next.value;
	        } catch (e) {
	          iteratorRecord.done = true;
	          throw e;
	        }
	        values[index] = void 0;
	        var nextPromise = C.resolve(nextValue);
	        var resolveElement = _promiseAllResolver(
	          index, values, resultCapability, remaining
	        );
	        remaining.count++;
	        nextPromise.then(resolveElement, resultCapability.reject);
	        index += 1;
	      }
	      if ((--remaining.count) === 0) {
	        var resolve = resultCapability.resolve;
	        resolve(values); // call w/ this===undefined
	      }
	      return resultCapability.promise;
	    };

	    var performPromiseRace = function (iteratorRecord, C, resultCapability) {
	      var it = iteratorRecord.iterator, next, nextValue, nextPromise;
	      while (true) {
	        try {
	          next = ES.IteratorStep(it);
	          if (next === false) {
	            // NOTE: If iterable has no items, resulting promise will never
	            // resolve; see:
	            // https://github.com/domenic/promises-unwrapping/issues/75
	            // https://bugs.ecmascript.org/show_bug.cgi?id=2515
	            iteratorRecord.done = true;
	            break;
	          }
	          nextValue = next.value;
	        } catch (e) {
	          iteratorRecord.done = true;
	          throw e;
	        }
	        nextPromise = C.resolve(nextValue);
	        nextPromise.then(resultCapability.resolve, resultCapability.reject);
	      }
	      return resultCapability.promise;
	    };

	    defineProperties(Promise, {
	      all: function all(iterable) {
	        var C = getPromiseSpecies(this);
	        var capability = new PromiseCapability(C);
	        var iterator, iteratorRecord;
	        try {
	          iterator = ES.GetIterator(iterable);
	          iteratorRecord = { iterator: iterator, done: false };
	          return performPromiseAll(iteratorRecord, C, capability);
	        } catch (e) {
	          if (iteratorRecord && !iteratorRecord.done) {
	            try {
	              ES.IteratorClose(iterator, true);
	            } catch (ee) {
	              e = ee;
	            }
	          }
	          var reject = capability.reject;
	          reject(e);
	          return capability.promise;
	        }
	      },

	      race: function race(iterable) {
	        var C = getPromiseSpecies(this);
	        var capability = new PromiseCapability(C);
	        var iterator, iteratorRecord;
	        try {
	          iterator = ES.GetIterator(iterable);
	          iteratorRecord = { iterator: iterator, done: false };
	          return performPromiseRace(iteratorRecord, C, capability);
	        } catch (e) {
	          if (iteratorRecord && !iteratorRecord.done) {
	            try {
	              ES.IteratorClose(iterator, true);
	            } catch (ee) {
	              e = ee;
	            }
	          }
	          var reject = capability.reject;
	          reject(e);
	          return capability.promise;
	        }
	      },

	      reject: function reject(reason) {
	        var C = this;
	        var capability = new PromiseCapability(C);
	        var rejectFunc = capability.reject;
	        rejectFunc(reason); // call with this===undefined
	        return capability.promise;
	      },

	      resolve: function resolve(v) {
	        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
	        var C = this;
	        if (ES.IsPromise(v)) {
	          var constructor = v.constructor;
	          if (constructor === C) { return v; }
	        }
	        var capability = new PromiseCapability(C);
	        var resolveFunc = capability.resolve;
	        resolveFunc(v); // call with this===undefined
	        return capability.promise;
	      }
	    });

	    defineProperties(Promise$prototype, {
	      'catch': function (onRejected) {
	        return this.then(void 0, onRejected);
	      },

	      then: function then(onFulfilled, onRejected) {
	        var promise = this;
	        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
	        var C = ES.SpeciesConstructor(promise, Promise);
	        var resultCapability = new PromiseCapability(C);
	        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
	        if (!ES.IsCallable(onFulfilled)) {
	          onFulfilled = PROMISE_IDENTITY;
	        }
	        if (!ES.IsCallable(onRejected)) {
	          onRejected = PROMISE_THROWER;
	        }
	        var fulfillReaction = { capabilities: resultCapability, handler: onFulfilled };
	        var rejectReaction = { capabilities: resultCapability, handler: onRejected };
	        var _promise = promise._promise, value;
	        if (_promise.state === PROMISE_PENDING) {
	          _push(_promise.fulfillReactions, fulfillReaction);
	          _push(_promise.rejectReactions, rejectReaction);
	        } else if (_promise.state === PROMISE_FULFILLED) {
	          value = _promise.result;
	          enqueue(function () {
	            promiseReactionJob(fulfillReaction, value);
	          });
	        } else if (_promise.state === PROMISE_REJECTED) {
	          value = _promise.result;
	          enqueue(function () {
	            promiseReactionJob(rejectReaction, value);
	          });
	        } else {
	          throw new TypeError('unexpected Promise state');
	        }
	        return resultCapability.promise;
	      }
	    });

	    return Promise;
	  }());

	  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
	  if (globals.Promise) {
	    delete globals.Promise.accept;
	    delete globals.Promise.defer;
	    delete globals.Promise.prototype.chain;
	  }

	  if (typeof PromiseShim === 'function') {
	    // export the Promise constructor.
	    defineProperties(globals, { Promise: PromiseShim });
	    // In Chrome 33 (and thereabouts) Promise is defined, but the
	    // implementation is buggy in a number of ways.  Let's check subclassing
	    // support to see if we have a buggy implementation.
	    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
	      return S.resolve(42).then(function () {}) instanceof S;
	    });
	    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () { globals.Promise.reject(42).then(null, 5).then(null, noop); });
	    var promiseRequiresObjectContext = throwsError(function () { globals.Promise.call(3, noop); });
	    // Promise.resolve() was errata'ed late in the ES6 process.
	    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
	    //      https://code.google.com/p/v8/issues/detail?id=4161
	    // It serves as a proxy for a number of other bugs in early Promise
	    // implementations.
	    var promiseResolveBroken = (function (Promise) {
	      var p = Promise.resolve(5);
	      p.constructor = {};
	      var p2 = Promise.resolve(p);
	      return (p === p2); // This *should* be false!
	    }(globals.Promise));
	    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
	        !promiseRequiresObjectContext || promiseResolveBroken) {
	      /*globals Promise: true */
	      Promise = PromiseShim;
	      /*globals Promise: false */
	      overrideNative(globals, 'Promise', PromiseShim);
	    }
	    addDefaultSpecies(Promise);
	  }

	  // Map and Set require a true ES5 environment
	  // Their fast path also requires that the environment preserve
	  // property insertion order, which is not guaranteed by the spec.
	  var testOrder = function (a) {
	    var b = Object.keys(_reduce(a, function (o, k) {
	      o[k] = true;
	      return o;
	    }, {}));
	    return a.join(':') === b.join(':');
	  };
	  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
	  // some engines (eg, Chrome) only preserve insertion order for string keys
	  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

	  if (supportsDescriptors) {

	    var fastkey = function fastkey(key) {
	      if (!preservesInsertionOrder) {
	        return null;
	      }
	      var type = typeof key;
	      if (type === 'undefined' || key === null) {
	        return '^' + String(key);
	      } else if (type === 'string') {
	        return '$' + key;
	      } else if (type === 'number') {
	        // note that -0 will get coerced to "0" when used as a property key
	        if (!preservesNumericInsertionOrder) {
	          return 'n' + key;
	        }
	        return key;
	      } else if (type === 'boolean') {
	        return 'b' + key;
	      }
	      return null;
	    };

	    var emptyObject = function emptyObject() {
	      // accomodate some older not-quite-ES5 browsers
	      return Object.create ? Object.create(null) : {};
	    };

	    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
	      if (isArray(iterable) || Type.string(iterable)) {
	        _forEach(iterable, function (entry) {
	          map.set(entry[0], entry[1]);
	        });
	      } else if (iterable instanceof MapConstructor) {
	        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
	          map.set(key, value);
	        });
	      } else {
	        var iter, adder;
	        if (iterable !== null && typeof iterable !== 'undefined') {
	          adder = map.set;
	          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
	          iter = ES.GetIterator(iterable);
	        }
	        if (typeof iter !== 'undefined') {
	          while (true) {
	            var next = ES.IteratorStep(iter);
	            if (next === false) { break; }
	            var nextItem = next.value;
	            try {
	              if (!ES.TypeIsObject(nextItem)) {
	                throw new TypeError('expected iterable of pairs');
	              }
	              _call(adder, map, nextItem[0], nextItem[1]);
	            } catch (e) {
	              ES.IteratorClose(iter, true);
	              throw e;
	            }
	          }
	        }
	      }
	    };
	    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
	      if (isArray(iterable) || Type.string(iterable)) {
	        _forEach(iterable, function (value) {
	          set.add(value);
	        });
	      } else if (iterable instanceof SetConstructor) {
	        _call(SetConstructor.prototype.forEach, iterable, function (value) {
	          set.add(value);
	        });
	      } else {
	        var iter, adder;
	        if (iterable !== null && typeof iterable !== 'undefined') {
	          adder = set.add;
	          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
	          iter = ES.GetIterator(iterable);
	        }
	        if (typeof iter !== 'undefined') {
	          while (true) {
	            var next = ES.IteratorStep(iter);
	            if (next === false) { break; }
	            var nextValue = next.value;
	            try {
	              _call(adder, set, nextValue);
	            } catch (e) {
	              ES.IteratorClose(iter, true);
	              throw e;
	            }
	          }
	        }
	      }
	    };

	    var collectionShims = {
	      Map: (function () {

	        var empty = {};

	        var MapEntry = function MapEntry(key, value) {
	          this.key = key;
	          this.value = value;
	          this.next = null;
	          this.prev = null;
	        };

	        MapEntry.prototype.isRemoved = function isRemoved() {
	          return this.key === empty;
	        };

	        var isMap = function isMap(map) {
	          return !!map._es6map;
	        };

	        var requireMapSlot = function requireMapSlot(map, method) {
	          if (!ES.TypeIsObject(map) || !isMap(map)) {
	            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + String(map));
	          }
	        };

	        var MapIterator = function MapIterator(map, kind) {
	          requireMapSlot(map, '[[MapIterator]]');
	          this.head = map._head;
	          this.i = this.head;
	          this.kind = kind;
	        };

	        MapIterator.prototype = {
	          next: function next() {
	            var i = this.i, kind = this.kind, head = this.head, result;
	            if (typeof this.i === 'undefined') {
	              return { value: void 0, done: true };
	            }
	            while (i.isRemoved() && i !== head) {
	              // back up off of removed entries
	              i = i.prev;
	            }
	            // advance to next unreturned element.
	            while (i.next !== head) {
	              i = i.next;
	              if (!i.isRemoved()) {
	                if (kind === 'key') {
	                  result = i.key;
	                } else if (kind === 'value') {
	                  result = i.value;
	                } else {
	                  result = [i.key, i.value];
	                }
	                this.i = i;
	                return { value: result, done: false };
	              }
	            }
	            // once the iterator is done, it is done forever.
	            this.i = void 0;
	            return { value: void 0, done: true };
	          }
	        };
	        addIterator(MapIterator.prototype);

	        var MapShim = function Map() {
	          if (!(this instanceof Map)) {
	            throw new TypeError('Constructor Map requires "new"');
	          }
	          if (this && this._es6map) {
	            throw new TypeError('Bad construction');
	          }
	          var map = emulateES6construct(this, Map, Map$prototype, {
	            _es6map: true,
	            _head: null,
	            _storage: emptyObject(),
	            _size: 0
	          });

	          var head = new MapEntry(null, null);
	          // circular doubly-linked list.
	          head.next = head.prev = head;
	          map._head = head;

	          // Optionally initialize map from iterable
	          if (arguments.length > 0) {
	            addIterableToMap(Map, map, arguments[0]);
	          }
	          return map;
	        };
	        var Map$prototype = MapShim.prototype;

	        Value.getter(Map$prototype, 'size', function () {
	          if (typeof this._size === 'undefined') {
	            throw new TypeError('size method called on incompatible Map');
	          }
	          return this._size;
	        });

	        defineProperties(Map$prototype, {
	          get: function get(key) {
	            requireMapSlot(this, 'get');
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              var entry = this._storage[fkey];
	              if (entry) {
	                return entry.value;
	              } else {
	                return;
	              }
	            }
	            var head = this._head, i = head;
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                return i.value;
	              }
	            }
	          },

	          has: function has(key) {
	            requireMapSlot(this, 'has');
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              return typeof this._storage[fkey] !== 'undefined';
	            }
	            var head = this._head, i = head;
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                return true;
	              }
	            }
	            return false;
	          },

	          set: function set(key, value) {
	            requireMapSlot(this, 'set');
	            var head = this._head, i = head, entry;
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              if (typeof this._storage[fkey] !== 'undefined') {
	                this._storage[fkey].value = value;
	                return this;
	              } else {
	                entry = this._storage[fkey] = new MapEntry(key, value);
	                i = head.prev;
	                // fall through
	              }
	            }
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                i.value = value;
	                return this;
	              }
	            }
	            entry = entry || new MapEntry(key, value);
	            if (ES.SameValue(-0, key)) {
	              entry.key = +0; // coerce -0 to +0 in entry
	            }
	            entry.next = this._head;
	            entry.prev = this._head.prev;
	            entry.prev.next = entry;
	            entry.next.prev = entry;
	            this._size += 1;
	            return this;
	          },

	          'delete': function (key) {
	            requireMapSlot(this, 'delete');
	            var head = this._head, i = head;
	            var fkey = fastkey(key);
	            if (fkey !== null) {
	              // fast O(1) path
	              if (typeof this._storage[fkey] === 'undefined') {
	                return false;
	              }
	              i = this._storage[fkey].prev;
	              delete this._storage[fkey];
	              // fall through
	            }
	            while ((i = i.next) !== head) {
	              if (ES.SameValueZero(i.key, key)) {
	                i.key = i.value = empty;
	                i.prev.next = i.next;
	                i.next.prev = i.prev;
	                this._size -= 1;
	                return true;
	              }
	            }
	            return false;
	          },

	          clear: function clear() {
	            requireMapSlot(this, 'clear');
	            this._size = 0;
	            this._storage = emptyObject();
	            var head = this._head, i = head, p = i.next;
	            while ((i = p) !== head) {
	              i.key = i.value = empty;
	              p = i.next;
	              i.next = i.prev = head;
	            }
	            head.next = head.prev = head;
	          },

	          keys: function keys() {
	            requireMapSlot(this, 'keys');
	            return new MapIterator(this, 'key');
	          },

	          values: function values() {
	            requireMapSlot(this, 'values');
	            return new MapIterator(this, 'value');
	          },

	          entries: function entries() {
	            requireMapSlot(this, 'entries');
	            return new MapIterator(this, 'key+value');
	          },

	          forEach: function forEach(callback) {
	            requireMapSlot(this, 'forEach');
	            var context = arguments.length > 1 ? arguments[1] : null;
	            var it = this.entries();
	            for (var entry = it.next(); !entry.done; entry = it.next()) {
	              if (context) {
	                _call(callback, context, entry.value[1], entry.value[0], this);
	              } else {
	                callback(entry.value[1], entry.value[0], this);
	              }
	            }
	          }
	        });
	        addIterator(Map$prototype, Map$prototype.entries);

	        return MapShim;
	      }()),

	      Set: (function () {
	        var isSet = function isSet(set) {
	          return set._es6set && typeof set._storage !== 'undefined';
	        };
	        var requireSetSlot = function requireSetSlot(set, method) {
	          if (!ES.TypeIsObject(set) || !isSet(set)) {
	            // https://github.com/paulmillr/es6-shim/issues/176
	            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + String(set));
	          }
	        };

	        // Creating a Map is expensive.  To speed up the common case of
	        // Sets containing only string or numeric keys, we use an object
	        // as backing storage and lazily create a full Map only when
	        // required.
	        var SetShim = function Set() {
	          if (!(this instanceof Set)) {
	            throw new TypeError('Constructor Set requires "new"');
	          }
	          if (this && this._es6set) {
	            throw new TypeError('Bad construction');
	          }
	          var set = emulateES6construct(this, Set, Set$prototype, {
	            _es6set: true,
	            '[[SetData]]': null,
	            _storage: emptyObject()
	          });
	          if (!set._es6set) {
	            throw new TypeError('bad set');
	          }

	          // Optionally initialize Set from iterable
	          if (arguments.length > 0) {
	            addIterableToSet(Set, set, arguments[0]);
	          }
	          return set;
	        };
	        var Set$prototype = SetShim.prototype;

	        // Switch from the object backing storage to a full Map.
	        var ensureMap = function ensureMap(set) {
	          if (!set['[[SetData]]']) {
	            var m = set['[[SetData]]'] = new collectionShims.Map();
	            _forEach(Object.keys(set._storage), function (k) {
	              if (k === '^null') {
	                k = null;
	              } else if (k === '^undefined') {
	                k = void 0;
	              } else {
	                var first = k.charAt(0);
	                if (first === '$') {
	                  k = _strSlice(k, 1);
	                } else if (first === 'n') {
	                  k = +_strSlice(k, 1);
	                } else if (first === 'b') {
	                  k = k === 'btrue';
	                } else {
	                  k = +k;
	                }
	              }
	              m.set(k, k);
	            });
	            set._storage = null; // free old backing storage
	          }
	        };

	        Value.getter(SetShim.prototype, 'size', function () {
	          requireSetSlot(this, 'size');
	          ensureMap(this);
	          return this['[[SetData]]'].size;
	        });

	        defineProperties(SetShim.prototype, {
	          has: function has(key) {
	            requireSetSlot(this, 'has');
	            var fkey;
	            if (this._storage && (fkey = fastkey(key)) !== null) {
	              return !!this._storage[fkey];
	            }
	            ensureMap(this);
	            return this['[[SetData]]'].has(key);
	          },

	          add: function add(key) {
	            requireSetSlot(this, 'add');
	            var fkey;
	            if (this._storage && (fkey = fastkey(key)) !== null) {
	              this._storage[fkey] = true;
	              return this;
	            }
	            ensureMap(this);
	            this['[[SetData]]'].set(key, key);
	            return this;
	          },

	          'delete': function (key) {
	            requireSetSlot(this, 'delete');
	            var fkey;
	            if (this._storage && (fkey = fastkey(key)) !== null) {
	              var hasFKey = _hasOwnProperty(this._storage, fkey);
	              return (delete this._storage[fkey]) && hasFKey;
	            }
	            ensureMap(this);
	            return this['[[SetData]]']['delete'](key);
	          },

	          clear: function clear() {
	            requireSetSlot(this, 'clear');
	            if (this._storage) {
	              this._storage = emptyObject();
	            } else {
	              this['[[SetData]]'].clear();
	            }
	          },

	          values: function values() {
	            requireSetSlot(this, 'values');
	            ensureMap(this);
	            return this['[[SetData]]'].values();
	          },

	          entries: function entries() {
	            requireSetSlot(this, 'entries');
	            ensureMap(this);
	            return this['[[SetData]]'].entries();
	          },

	          forEach: function forEach(callback) {
	            requireSetSlot(this, 'forEach');
	            var context = arguments.length > 1 ? arguments[1] : null;
	            var entireSet = this;
	            ensureMap(entireSet);
	            this['[[SetData]]'].forEach(function (value, key) {
	              if (context) {
	                _call(callback, context, key, key, entireSet);
	              } else {
	                callback(key, key, entireSet);
	              }
	            });
	          }
	        });
	        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
	        addIterator(SetShim.prototype, SetShim.prototype.values);

	        return SetShim;
	      }())
	    };

	    if (globals.Map || globals.Set) {
	      // Safari 8, for example, doesn't accept an iterable.
	      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
	      if (!mapAcceptsArguments) {
	        var OrigMapNoArgs = globals.Map;
	        globals.Map = function Map() {
	          if (!(this instanceof Map)) {
	            throw new TypeError('Constructor Map requires "new"');
	          }
	          var m = new OrigMapNoArgs();
	          if (arguments.length > 0) {
	            addIterableToMap(Map, m, arguments[0]);
	          }
	          Object.setPrototypeOf(m, globals.Map.prototype);
	          defineProperty(m, 'constructor', Map, true);
	          return m;
	        };
	        globals.Map.prototype = create(OrigMapNoArgs.prototype);
	        Value.preserveToString(globals.Map, OrigMapNoArgs);
	      }
	      var testMap = new Map();
	      var mapUsesSameValueZero = (function (m) {
	        m['delete'](0);
	        m['delete'](-0);
	        m.set(0, 3);
	        m.get(-0, 4);
	        return m.get(0) === 3 && m.get(-0) === 4;
	      }(testMap));
	      var mapSupportsChaining = testMap.set(1, 2) === testMap;
	      if (!mapUsesSameValueZero || !mapSupportsChaining) {
	        var origMapSet = Map.prototype.set;
	        overrideNative(Map.prototype, 'set', function set(k, v) {
	          _call(origMapSet, this, k === 0 ? 0 : k, v);
	          return this;
	        });
	      }
	      if (!mapUsesSameValueZero) {
	        var origMapGet = Map.prototype.get;
	        var origMapHas = Map.prototype.has;
	        defineProperties(Map.prototype, {
	          get: function get(k) {
	            return _call(origMapGet, this, k === 0 ? 0 : k);
	          },
	          has: function has(k) {
	            return _call(origMapHas, this, k === 0 ? 0 : k);
	          }
	        }, true);
	        Value.preserveToString(Map.prototype.get, origMapGet);
	        Value.preserveToString(Map.prototype.has, origMapHas);
	      }
	      var testSet = new Set();
	      var setUsesSameValueZero = (function (s) {
	        s['delete'](0);
	        s.add(-0);
	        return !s.has(0);
	      }(testSet));
	      var setSupportsChaining = testSet.add(1) === testSet;
	      if (!setUsesSameValueZero || !setSupportsChaining) {
	        var origSetAdd = Set.prototype.add;
	        Set.prototype.add = function add(v) {
	          _call(origSetAdd, this, v === 0 ? 0 : v);
	          return this;
	        };
	        Value.preserveToString(Set.prototype.add, origSetAdd);
	      }
	      if (!setUsesSameValueZero) {
	        var origSetHas = Set.prototype.has;
	        Set.prototype.has = function has(v) {
	          return _call(origSetHas, this, v === 0 ? 0 : v);
	        };
	        Value.preserveToString(Set.prototype.has, origSetHas);
	        var origSetDel = Set.prototype['delete'];
	        Set.prototype['delete'] = function SetDelete(v) {
	          return _call(origSetDel, this, v === 0 ? 0 : v);
	        };
	        Value.preserveToString(Set.prototype['delete'], origSetDel);
	      }
	      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
	        var m = new M([]);
	        // Firefox 32 is ok with the instantiating the subclass but will
	        // throw when the map is used.
	        m.set(42, 42);
	        return m instanceof M;
	      });
	      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible
	      var mapRequiresNew = (function () {
	        try {
	          return !(globals.Map() instanceof globals.Map);
	        } catch (e) {
	          return e instanceof TypeError;
	        }
	      }());
	      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
	        var OrigMap = globals.Map;
	        globals.Map = function Map() {
	          if (!(this instanceof Map)) {
	            throw new TypeError('Constructor Map requires "new"');
	          }
	          var m = new OrigMap();
	          if (arguments.length > 0) {
	            addIterableToMap(Map, m, arguments[0]);
	          }
	          Object.setPrototypeOf(m, Map.prototype);
	          defineProperty(m, 'constructor', Map, true);
	          return m;
	        };
	        globals.Map.prototype = OrigMap.prototype;
	        Value.preserveToString(globals.Map, OrigMap);
	      }
	      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
	        var s = new S([]);
	        s.add(42, 42);
	        return s instanceof S;
	      });
	      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible
	      var setRequiresNew = (function () {
	        try {
	          return !(globals.Set() instanceof globals.Set);
	        } catch (e) {
	          return e instanceof TypeError;
	        }
	      }());
	      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
	        var OrigSet = globals.Set;
	        globals.Set = function Set() {
	          if (!(this instanceof Set)) {
	            throw new TypeError('Constructor Set requires "new"');
	          }
	          var s = new OrigSet();
	          if (arguments.length > 0) {
	            addIterableToSet(Set, s, arguments[0]);
	          }
	          Object.setPrototypeOf(s, Set.prototype);
	          defineProperty(s, 'constructor', Set, true);
	          return s;
	        };
	        globals.Set.prototype = OrigSet.prototype;
	        Value.preserveToString(globals.Set, OrigSet);
	      }
	      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
	        return (new Map()).keys().next().done;
	      });
	      /*
	        - In Firefox < 23, Map#size is a function.
	        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
	        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
	        - In Firefox 24, Map and Set do not implement forEach
	        - In Firefox 25 at least, Map and Set are callable without "new"
	      */
	      if (
	        typeof globals.Map.prototype.clear !== 'function' ||
	        new globals.Set().size !== 0 ||
	        new globals.Map().size !== 0 ||
	        typeof globals.Map.prototype.keys !== 'function' ||
	        typeof globals.Set.prototype.keys !== 'function' ||
	        typeof globals.Map.prototype.forEach !== 'function' ||
	        typeof globals.Set.prototype.forEach !== 'function' ||
	        isCallableWithoutNew(globals.Map) ||
	        isCallableWithoutNew(globals.Set) ||
	        typeof (new globals.Map().keys().next) !== 'function' || // Safari 8
	        mapIterationThrowsStopIterator || // Firefox 25
	        !mapSupportsSubclassing
	      ) {
	        delete globals.Map; // necessary to overwrite in Safari 8
	        delete globals.Set; // necessary to overwrite in Safari 8
	        defineProperties(globals, {
	          Map: collectionShims.Map,
	          Set: collectionShims.Set
	        }, true);
	      }

	      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
	        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
	        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
	      }

	      // Shim incomplete iterator implementations.
	      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
	      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

	      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
	        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
	        var anonymousSetHas = globals.Set.prototype.has;
	        overrideNative(globals.Set.prototype, 'has', function has(key) {
	          return _call(anonymousSetHas, this, key);
	        });
	      }
	    }
	    defineProperties(globals, collectionShims);
	    addDefaultSpecies(globals.Map);
	    addDefaultSpecies(globals.Set);
	  }

	  // Reflect
	  if (!globals.Reflect) {
	    defineProperty(globals, 'Reflect', {});
	  }
	  var Reflect = globals.Reflect;

	  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
	    if (!ES.TypeIsObject(target)) {
	      throw new TypeError('target must be an object');
	    }
	  };

	  // Some Reflect methods are basically the same as
	  // those on the Object global, except that a TypeError is thrown if
	  // target isn't an object. As well as returning a boolean indicating
	  // the success of the operation.
	  var ReflectShims = {
	    // Apply method in a functional form.
	    apply: function apply() {
	      return _apply(ES.Call, null, arguments);
	    },

	    // New operator in a functional form.
	    construct: function construct(constructor, args) {
	      if (!ES.IsConstructor(constructor)) {
	        throw new TypeError('First argument must be a constructor.');
	      }
	      var newTarget = (arguments.length < 3) ? constructor : arguments[2];
	      if (!ES.IsConstructor(newTarget)) {
	        throw new TypeError('new.target must be a constructor.');
	      }
	      return ES.Construct(constructor, args, newTarget, 'internal');
	    },

	    // When deleting a non-existent or configurable property,
	    // true is returned.
	    // When attempting to delete a non-configurable property,
	    // it will return false.
	    deleteProperty: function deleteProperty(target, key) {
	      throwUnlessTargetIsObject(target);
	      if (supportsDescriptors) {
	        var desc = Object.getOwnPropertyDescriptor(target, key);

	        if (desc && !desc.configurable) {
	          return false;
	        }
	      }

	      // Will return true.
	      return delete target[key];
	    },

	    enumerate: function enumerate(target) {
	      throwUnlessTargetIsObject(target);
	      return new ObjectIterator(target, 'key');
	    },

	    has: function has(target, key) {
	      throwUnlessTargetIsObject(target);
	      return key in target;
	    }
	  };

	  if (Object.getOwnPropertyNames) {
	    Object.assign(ReflectShims, {
	      // Basically the result of calling the internal [[OwnPropertyKeys]].
	      // Concatenating propertyNames and propertySymbols should do the trick.
	      // This should continue to work together with a Symbol shim
	      // which overrides Object.getOwnPropertyNames and implements
	      // Object.getOwnPropertySymbols.
	      ownKeys: function ownKeys(target) {
	        throwUnlessTargetIsObject(target);
	        var keys = Object.getOwnPropertyNames(target);

	        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
	          _pushApply(keys, Object.getOwnPropertySymbols(target));
	        }

	        return keys;
	      }
	    });
	  }

	  var callAndCatchException = function ConvertExceptionToBoolean(func) {
	    return !throwsError(func);
	  };

	  if (Object.preventExtensions) {
	    Object.assign(ReflectShims, {
	      isExtensible: function isExtensible(target) {
	        throwUnlessTargetIsObject(target);
	        return Object.isExtensible(target);
	      },
	      preventExtensions: function preventExtensions(target) {
	        throwUnlessTargetIsObject(target);
	        return callAndCatchException(function () {
	          Object.preventExtensions(target);
	        });
	      }
	    });
	  }

	  if (supportsDescriptors) {
	    var internalGet = function get(target, key, receiver) {
	      var desc = Object.getOwnPropertyDescriptor(target, key);

	      if (!desc) {
	        var parent = Object.getPrototypeOf(target);

	        if (parent === null) {
	          return undefined;
	        }

	        return internalGet(parent, key, receiver);
	      }

	      if ('value' in desc) {
	        return desc.value;
	      }

	      if (desc.get) {
	        return _call(desc.get, receiver);
	      }

	      return undefined;
	    };

	    var internalSet = function set(target, key, value, receiver) {
	      var desc = Object.getOwnPropertyDescriptor(target, key);

	      if (!desc) {
	        var parent = Object.getPrototypeOf(target);

	        if (parent !== null) {
	          return internalSet(parent, key, value, receiver);
	        }

	        desc = {
	          value: void 0,
	          writable: true,
	          enumerable: true,
	          configurable: true
	        };
	      }

	      if ('value' in desc) {
	        if (!desc.writable) {
	          return false;
	        }

	        if (!ES.TypeIsObject(receiver)) {
	          return false;
	        }

	        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

	        if (existingDesc) {
	          return Reflect.defineProperty(receiver, key, {
	            value: value
	          });
	        } else {
	          return Reflect.defineProperty(receiver, key, {
	            value: value,
	            writable: true,
	            enumerable: true,
	            configurable: true
	          });
	        }
	      }

	      if (desc.set) {
	        _call(desc.set, receiver, value);
	        return true;
	      }

	      return false;
	    };

	    Object.assign(ReflectShims, {
	      defineProperty: function defineProperty(target, propertyKey, attributes) {
	        throwUnlessTargetIsObject(target);
	        return callAndCatchException(function () {
	          Object.defineProperty(target, propertyKey, attributes);
	        });
	      },

	      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	        throwUnlessTargetIsObject(target);
	        return Object.getOwnPropertyDescriptor(target, propertyKey);
	      },

	      // Syntax in a functional form.
	      get: function get(target, key) {
	        throwUnlessTargetIsObject(target);
	        var receiver = arguments.length > 2 ? arguments[2] : target;

	        return internalGet(target, key, receiver);
	      },

	      set: function set(target, key, value) {
	        throwUnlessTargetIsObject(target);
	        var receiver = arguments.length > 3 ? arguments[3] : target;

	        return internalSet(target, key, value, receiver);
	      }
	    });
	  }

	  if (Object.getPrototypeOf) {
	    var objectDotGetPrototypeOf = Object.getPrototypeOf;
	    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
	      throwUnlessTargetIsObject(target);
	      return objectDotGetPrototypeOf(target);
	    };
	  }

	  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
	    var willCreateCircularPrototype = function (object, proto) {
	      while (proto) {
	        if (object === proto) {
	          return true;
	        }
	        proto = ReflectShims.getPrototypeOf(proto);
	      }
	      return false;
	    };

	    Object.assign(ReflectShims, {
	      // Sets the prototype of the given object.
	      // Returns true on success, otherwise false.
	      setPrototypeOf: function setPrototypeOf(object, proto) {
	        throwUnlessTargetIsObject(object);
	        if (proto !== null && !ES.TypeIsObject(proto)) {
	          throw new TypeError('proto must be an object or null');
	        }

	        // If they already are the same, we're done.
	        if (proto === Reflect.getPrototypeOf(object)) {
	          return true;
	        }

	        // Cannot alter prototype if object not extensible.
	        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
	          return false;
	        }

	        // Ensure that we do not create a circular prototype chain.
	        if (willCreateCircularPrototype(object, proto)) {
	          return false;
	        }

	        Object.setPrototypeOf(object, proto);

	        return true;
	      }
	    });
	  }
	  var defineOrOverrideReflectProperty = function (key, shim) {
	    if (!ES.IsCallable(globals.Reflect[key])) {
	      defineProperty(globals.Reflect, key, shim);
	    } else {
	      var acceptsPrimitives = valueOrFalseIfThrows(function () {
	        globals.Reflect[key](1);
	        globals.Reflect[key](NaN);
	        globals.Reflect[key](true);
	        return true;
	      });
	      if (acceptsPrimitives) {
	        overrideNative(globals.Reflect, key, shim);
	      }
	    }
	  };
	  Object.keys(ReflectShims).forEach(function (key) {
	    defineOrOverrideReflectProperty(key, ReflectShims[key]);
	  });
	  if (functionsHaveNames && globals.Reflect.getPrototypeOf.name !== 'getPrototypeOf') {
	    var originalReflectGetProto = globals.Reflect.getPrototypeOf;
	    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
	      return _call(originalReflectGetProto, globals.Reflect, target);
	    });
	  }
	  if (globals.Reflect.setPrototypeOf) {
	    if (valueOrFalseIfThrows(function () {
	      globals.Reflect.setPrototypeOf(1, {});
	      return true;
	    })) {
	      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
	    }
	  }
	  if (globals.Reflect.defineProperty) {
	    if (!valueOrFalseIfThrows(function () {
	      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
	      // "extensible" fails on Edge 0.12
	      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
	      return basic && extensible;
	    })) {
	      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
	    }
	  }
	  if (globals.Reflect.construct) {
	    if (!valueOrFalseIfThrows(function () {
	      var F = function F() {};
	      return globals.Reflect.construct(function () {}, [], F) instanceof F;
	    })) {
	      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
	    }
	  }

	  if (String(new Date(NaN)) !== 'Invalid Date') {
	    var dateToString = Date.prototype.toString;
	    var shimmedDateToString = function toString() {
	      var valueOf = +this;
	      if (valueOf !== valueOf) {
	        return 'Invalid Date';
	      }
	      return _call(dateToString, this);
	    };
	    overrideNative(Date.prototype, 'toString', shimmedDateToString);
	  }

	  // Annex B HTML methods
	  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-additional-properties-of-the-string.prototype-object
	  var stringHTMLshims = {
	    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
	    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
	    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
	    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
	    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
	    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
	    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
	    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
	    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
	    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
	    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
	    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
	    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
	  };
	  _forEach(Object.keys(stringHTMLshims), function (key) {
	    var method = String.prototype[key];
	    var shouldOverwrite = false;
	    if (ES.IsCallable(method)) {
	      var output = _call(method, '', ' " ');
	      var quotesCount = _concat([], output.match(/"/g)).length;
	      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
	    } else {
	      shouldOverwrite = true;
	    }
	    if (shouldOverwrite) {
	      overrideNative(String.prototype, key, stringHTMLshims[key]);
	    }
	  });

	  var JSONstringifiesSymbols = (function () {
	    // Microsoft Edge v0.12 stringifies Symbols incorrectly
	    if (!Type.symbol(Symbol.iterator)) { return false; } // Symbols are not supported
	    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
	    if (!stringify) { return false; } // JSON.stringify is not supported
	    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
	    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
	    var obj = { a: Symbol() };
	    obj[Symbol()] = true;
	    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
	    return false;
	  }());
	  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
	    // Chrome 45 throws on stringifying object symbols
	    if (!Type.symbol(Symbol.iterator)) { return true; } // Symbols are not supported
	    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
	  });
	  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
	    var origStringify = JSON.stringify;
	    overrideNative(JSON, 'stringify', function stringify(value) {
	      if (typeof value === 'symbol') { return; }
	      var replacer;
	      if (arguments.length > 1) {
	        replacer = arguments[1];
	      }
	      var args = [value];
	      if (!isArray(replacer)) {
	        var replaceFn = ES.IsCallable(replacer) ? replacer : null;
	        var wrappedReplacer = function (key, val) {
	          var parsedValue = replacer ? _call(replacer, this, key, val) : val;
	          if (typeof parsedValue !== 'symbol') {
	            if (Type.symbol(parsedValue)) {
	              return assignTo({})(parsedValue);
	            } else {
	              return parsedValue;
	            }
	          }
	        };
	        args.push(wrappedReplacer);
	      } else {
	        // create wrapped replacer that handles an array replacer?
	        args.push(replacer);
	      }
	      if (arguments.length > 2) {
	        args.push(arguments[2]);
	      }
	      return origStringify.apply(this, args);
	    });
	  }

	  return globals;
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var EVS = __webpack_require__(134);
	var Pins = Board.Pins;
	var __ = __webpack_require__(115);
	var events = __webpack_require__(8);
	var util = __webpack_require__(12);

	// Button instance private data
	var priv = new Map();
	var aliases = {
	  down: ["down", "press", "tap", "impact", "hit"],
	  up: ["up", "release"]
	};



	var Controllers = {
	  DEFAULT: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        if (Pins.isFirmata(this) && typeof opts.pinValue === "string" && opts.pinValue[0] === "A") {
	          opts.pinValue = this.io.analogPins[+opts.pinValue.slice(1)];
	        }

	        this.pin = Number.isNaN(+opts.pinValue) ? opts.pinValue : +opts.pinValue;

	        this.io.pinMode(this.pin, this.io.MODES.INPUT);

	        // Enable the pullup resistor after setting pin mode
	        if (this.pullup) {
	          this.io.digitalWrite(this.pin, this.io.HIGH);
	        }

	        this.io.digitalRead(this.pin, function(data) {
	          if (data !== state.last) {
	            dataHandler(data);
	          }
	        });
	      }
	    },
	    toBoolean: {
	      value: function(raw) {
	        return raw === this.downValue;
	      }
	    }
	  },
	  EVS_EV3: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        state.previous = 0;
	        state.shield = EVS.shieldPort(opts.pin);
	        state.register = EVS.Touch;

	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, EVS.Type_EV3_TOUCH);
	        state.ev3.read(state.shield, EVS.Touch, EVS.Touch_Bytes, function(data) {
	          var value = data[0];
	          // Since i2cRead is continuous regardless of the reading,
	          // and digitalRead is continuous but only called for changes
	          // in reading value, we need to suppress repeated calls to
	          // dataHandler by limiting to only changed values.
	          if (state.previous !== value) {
	            dataHandler(value);
	          }
	          state.previous = value;
	        });
	      }
	    },
	    toBoolean: {
	      value: function(raw) {
	        return raw === this.downValue;
	      }
	    }
	  },
	  EVS_NXT: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        state.previous = 0;
	        state.shield = EVS.shieldPort(opts.pin);

	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, EVS.Type_ANALOG);
	        state.ev3.read(state.shield, state.shield.analog, EVS.Analog_Bytes, function(data) {
	          var value = data[0] | (data[1] << 8);
	          // Since i2cRead is continuous regardless of the reading,
	          // and digitalRead is continuous but only called for changes
	          // in reading value, we need to suppress repeated calls to
	          // dataHandler by limiting to only changed values.
	          value = value < 300 ? 1 : 0;

	          if (state.previous !== value) {
	            dataHandler(value);
	          }
	          state.previous = value;
	        });
	      }
	    },
	    toBoolean: {
	      value: function(raw) {
	        return raw === this.downValue;
	      }
	    }
	  }
	};

	/**
	 * Button
	 * @constructor
	 *
	 * five.Button();
	 *
	 * five.Button({
	 *   pin: 10
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Button(opts) {
	  if (!(this instanceof Button)) {
	    return new Button(opts);
	  }

	  var pinValue;
	  var raw;
	  var invert = false;
	  var downValue = 1;
	  var upValue = 0;
	  var controller = null;
	  var state = {
	    interval: null,
	    last: null
	  };

	  // Create a 5 ms debounce boundary on event triggers
	  // this avoids button events firing on
	  // press noise and false positives
	  var trigger = __.debounce(function(key) {
	    aliases[key].forEach(function(type) {
	      this.emit(type, null);
	    }, this);
	  }, 7);

	  pinValue = typeof opts === "object" ? opts.pin : opts;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  opts.pinValue = pinValue;

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers.DEFAULT;
	  }

	  Board.Controller.call(this, controller, opts);

	  // `holdtime` is used by an interval to determine
	  // if the button has been released within a specified
	  // time frame, in milliseconds.
	  this.holdtime = opts.holdtime || 500;

	  // `opts.isPullup` is included as part of an effort to
	  // phase out "isFoo" options properties
	  this.pullup = opts.pullup || opts.isPullup || false;

	  // Turns out some button circuits will send
	  // 0 for up and 1 for down, and some the inverse,
	  // so we can invert our function with this option.
	  // Default to invert in pullup mode, but use opts.invert
	  // if explicitly defined (even if false)
	  invert = typeof opts.invert !== "undefined" ?
	    opts.invert : (this.pullup || false);

	  if (invert) {
	    downValue = downValue ^ 1;
	    upValue = upValue ^ 1;
	  }

	  state.last = upValue;

	  // Create a "state" entry for privately
	  // storing the state of the button
	  priv.set(this, state);

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return Number(this.isDown);
	      }
	    },
	    invert: {
	      get: function() {
	        return invert;
	      },
	      set: function(value) {
	        invert = value;
	        downValue = invert ? 0 : 1;
	        upValue = invert ? 1 : 0;

	        state.last = upValue;
	      }
	    },
	    downValue: {
	      get: function() {
	        return downValue;
	      },
	      set: function(value) {
	        downValue = value;
	        upValue = value ^ 1;
	        invert = value ? true : false;

	        state.last = upValue;
	      }
	    },
	    upValue: {
	      get: function() {
	        return upValue;
	      },
	      set: function(value) {
	        upValue = value;
	        downValue = value ^ 1;
	        invert = value ? true : false;

	        state.last = downValue;
	      }
	    },
	    isDown: {
	      get: function() {
	        return this.toBoolean(raw);
	      }
	    }
	  });


	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      var err = null;

	      // Update the raw data value, which
	      // is used by isDown = toBoolean()
	      raw = data;

	      if (!this.isDown) {
	        if (state.interval) {
	          clearInterval(state.interval);
	        }
	        trigger.call(this, "up");
	      }

	      if (this.isDown) {
	        trigger.call(this, "down");

	        state.interval = setInterval(function() {
	          if (this.isDown) {
	            this.emit("hold", err);
	          }
	        }.bind(this), this.holdtime);
	      }

	      state.last = data;
	    }.bind(this));
	  }
	}

	util.inherits(Button, events.EventEmitter);


	/**
	 * Fired when the button is pressed down
	 *
	 * @event
	 * @name down
	 * @memberOf Button
	 */

	/**
	 * Fired when the button is held
	 *
	 * @event
	 * @name hold
	 * @memberOf Button
	 */

	/**
	 * Fired when the button is released
	 *
	 * @event
	 * @name up
	 * @memberOf Button
	 */


	module.exports = Button;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var Emitter = __webpack_require__(8).EventEmitter;
	var shared;

	function Bank(options) {
	  this.address = options.address;
	  this.io = options.io;
	  this.io.i2cConfig();
	}

	Bank.prototype.read = function(register, numBytes, callback) {
	  if (register) {
	    this.io.i2cRead(this.address, register, numBytes, callback);
	  } else {
	    this.io.i2cRead(this.address, numBytes, callback);
	  }
	};

	Bank.prototype.write = function(register, bytes) {
	  if (!Array.isArray(bytes)) {
	    bytes = [bytes];
	  }
	  this.io.i2cWrite(this.address, register, bytes);
	};

	// http://www.nr.edu/csc200/labs-ev3/ev3-user-guide-EN.pdf

	function EVS(options) {
	  if (shared) {
	    return shared;
	  }

	  this.bank = {
	    a: new Bank({
	      address: EVS.BANK_A,
	      io: options.io,
	    }),
	    b: new Bank({
	      address: EVS.BANK_B,
	      io: options.io,
	    })
	  };

	  shared = this;
	}

	EVS.shieldPort = function(pin) {
	  var port = EVS[pin];

	  if (port === undefined) {
	    throw new Error("Invalid EVShield pin name");
	  }

	  var address, analog, bank, motor, mode, offset, sensor;
	  var endsWithS1 = false;

	  if (pin.startsWith("BA")) {
	    address = EVS.BANK_A;
	    bank = "a";
	  } else {
	    address = EVS.BANK_B;
	    bank = "b";
	  }

	  if (pin.includes("M")) {
	    motor = pin.endsWith("M1") ? EVS.S1 : EVS.S2;
	  }

	  if (pin.includes("S")) {
	    endsWithS1 = pin.endsWith("S1");

	    // Used for reading 2 byte integer values from raw sensors
	    analog = endsWithS1 ? EVS.S1_ANALOG : EVS.S2_ANALOG;
	    // Sensor Mode (1 or 2?)
	    mode = endsWithS1 ? EVS.S1_MODE : EVS.S2_MODE;
	    // Used for read registers
	    offset = endsWithS1 ? EVS.S1_OFFSET : EVS.S2_OFFSET;
	    // Used to address "sensor type"
	    sensor = endsWithS1 ? EVS.S1 : EVS.S2;
	  }

	  return {
	    address: address,
	    analog: analog,
	    bank: bank,
	    mode: mode,
	    motor: motor,
	    offset: offset,
	    port: port,
	    sensor: sensor,
	  };
	};

	EVS.isRawSensor = function(port) {
	  return port.analog === EVS.S1_ANALOG || port.analog === EVS.S2_ANALOG;
	};

	EVS.prototype = Object.create(Emitter.prototype, {
	  constructor: {
	    value: EVS
	  }
	});

	EVS.prototype.setup = function(port, type) {
	  this.bank[port.bank].write(port.mode, [type]);
	};

	EVS.prototype.read = function(port, register, numBytes, callback) {

	  if (port.sensor && port.offset && !EVS.isRawSensor(port)) {
	    register += port.offset;
	  }

	  this.bank[port.bank].read(register, numBytes, callback);
	};

	EVS.prototype.write = function(port, register, data) {
	  this.bank[port.bank].write(register, data);
	};

	/*
	 * Shield Registers
	 */

	EVS.BAS1 = 0x01;
	EVS.BAS2 = 0x02;
	EVS.BBS1 = 0x03;
	EVS.BBS2 = 0x04;

	EVS.BAM1 = 0x05;
	EVS.BAM2 = 0x06;
	EVS.BBM1 = 0x07;
	EVS.BBM2 = 0x08;

	EVS.BANK_A = 0x1A;
	EVS.BANK_B = 0x1B;

	EVS.S1 = 0x01;
	EVS.S2 = 0x02;

	EVS.M1 = 0x01;
	EVS.M2 = 0x02;
	EVS.MM = 0x03;

	EVS.Type_NONE = 0x00;
	EVS.Type_SWITCH = 0x01;
	EVS.Type_ANALOG = 0x02;

	EVS.Type_I2C = 0x09;

	/*
	 * Sensor Mode NXT
	 */
	EVS.Type_NXT_LIGHT_REFLECTED = 0x03;
	EVS.Type_NXT_LIGHT = 0x04;
	EVS.Type_NXT_COLOR = 0x0D;
	EVS.Type_NXT_COLOR_RGBRAW = 0x04;
	EVS.Type_NXT_COLORRED = 0x0E;
	EVS.Type_NXT_COLORGREEN = 0x0F;
	EVS.Type_NXT_COLORBLUE = 0x10;
	EVS.Type_NXT_COLORNONE = 0x11;


	EVS.Type_DATABIT0_HIGH = 0x40;

	/*
	 * Sensor Port Controls
	 */
	EVS.S1_MODE = 0x6F;
	// EVS.S1_EV3_MODE = 0x6F;
	EVS.S1_ANALOG = 0x70;
	EVS.S1_OFFSET = 0;

	EVS.S2_MODE = 0xA3;
	// EVS.S2_EV3_MODE = 0x6F;
	EVS.S2_ANALOG = 0xA4;
	EVS.S2_OFFSET = 52;

	/*
	 * Sensor Mode EV3
	 */
	EVS.Type_EV3_LIGHT_REFLECTED = 0x00;
	EVS.Type_EV3_LIGHT = 0x01;
	EVS.Type_EV3_COLOR = 0x02;
	EVS.Type_EV3_COLOR_REFRAW = 0x03;
	EVS.Type_EV3_COLOR_RGBRAW = 0x04;
	EVS.Type_EV3_TOUCH = 0x12;
	EVS.Type_EV3 = 0x13;

	/*
	 * Sensor Read Registers
	 */
	EVS.Light = 0x83;
	EVS.Bump = 0x84;
	EVS.ColorMeasure = 0x83;
	EVS.Proximity = 0x83;
	EVS.Touch = 0x83;
	EVS.Ultrasonic = 0x81;
	EVS.Mode = 0x81;

	/*
	 * Sensor Read Byte Counts
	 */
	EVS.Light_Bytes = 2;
	EVS.Analog_Bytes = 2;
	EVS.Bump_Bytes = 1;
	EVS.ColorMeasure_Bytes = 2;
	EVS.Proximity_Bytes = 2;
	EVS.Touch_Bytes = 1;


	/*
	 * Motor selection
	 */
	EVS.Motor_1 = 0x01;
	EVS.Motor_2 = 0x02;
	EVS.Motor_Both = 0x03;

	/*
	 * Motor next action
	 */
	// stop and let the motor coast.
	EVS.Motor_Next_Action_Float = 0x00;
	// apply brakes, and resist change to tachometer, but if tach position is forcibly changed, do not restore position
	EVS.Motor_Next_Action_Brake = 0x01;
	// apply brakes, and restore externally forced change to tachometer
	EVS.Motor_Next_Action_BrakeHold = 0x02;

	EVS.Motor_Stop = 0x60;
	EVS.Motor_Reset = 0x52;

	/*
	 * Motor direction
	 */

	EVS.Motor_Reverse = 0x00;
	EVS.Motor_Forward = 0x01;

	/*
	 * Motor Tachometer movement
	 */

	// Move the tach to absolute value provided
	EVS.Motor_Move_Absolute = 0x00;
	// Move the tach relative to previous position
	EVS.Motor_Move_Relative = 0x01;

	/*
	 * Motor completion
	 */

	EVS.Motor_Completion_Dont_Wait = 0x00;
	EVS.Motor_Completion_Wait_For = 0x01;

	/*
	 * 0-100
	 */
	EVS.Speed_Full = 90;
	EVS.Speed_Medium = 60;
	EVS.Speed_Slow = 25;

	/*
	 * Motor Port Controls
	 */
	EVS.CONTROL_SPEED = 0x01;
	EVS.CONTROL_RAMP = 0x02;
	EVS.CONTROL_RELATIVE = 0x04;
	EVS.CONTROL_TACHO = 0x08;
	EVS.CONTROL_BRK = 0x10;
	EVS.CONTROL_ON = 0x20;
	EVS.CONTROL_TIME = 0x40;
	EVS.CONTROL_GO = 0x80;

	EVS.STATUS_SPEED = 0x01;
	EVS.STATUS_RAMP = 0x02;
	EVS.STATUS_MOVING = 0x04;
	EVS.STATUS_TACHO = 0x08;
	EVS.STATUS_BREAK = 0x10;
	EVS.STATUS_OVERLOAD = 0x20;
	EVS.STATUS_TIME = 0x40;
	EVS.STATUS_STALL = 0x80;

	EVS.COMMAND = 0x41;
	EVS.VOLTAGE = 0x6E;

	EVS.SETPT_M1 = 0x42;
	EVS.SPEED_M1 = 0x46;
	EVS.TIME_M1 = 0x47;
	EVS.CMD_B_M1 = 0x48;
	EVS.CMD_A_M1 = 0x49;

	EVS.SETPT_M2 = 0x4A;
	EVS.SPEED_M2 = 0x4E;
	EVS.TIME_M2 = 0x4F;
	EVS.CMD_B_M2 = 0x50;
	EVS.CMD_A_M2 = 0x51;


	/*
	 * Motor Read registers.
	 */
	EVS.POSITION_M1 = 0x52;
	EVS.POSITION_M2 = 0x56;
	EVS.STATUS_M1 = 0x5A;
	EVS.STATUS_M2 = 0x5B;
	EVS.TASKS_M1 = 0x5C;
	EVS.TASKS_M2 = 0x5D;

	EVS.ENCODER_PID = 0x5E;
	EVS.SPEED_PID = 0x64;
	EVS.PASS_COUNT = 0x6A;
	EVS.TOLERANCE = 0x6B;

	/*
	 * Built-in components
	 */
	EVS.BTN_PRESS = 0xDA;
	EVS.RGB_LED = 0xD7;
	EVS.CENTER_RGB_LED = 0xDE;



	module.exports = EVS;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var EVS = __webpack_require__(134);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var __ = __webpack_require__(115);
	var priv = new Map();


	function analogHandler(opts, dataHandler) {
	  this.io.pinMode(this.pin, this.io.MODES.ANALOG);
	  this.io.analogRead(this.pin, function(data) {
	    dataHandler.call(this, data);
	  }.bind(this));
	}

	function pad(value, length) {
	  return Array(length - String(value).length + 1).join("0") + value;
	}

	var Controllers = {
	  // This is a placeholder...
	  DEFAULT: {
	    initialize: {
	      value: analogHandler
	    },
	    toRGB: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	  EVS_EV3: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        if (opts.mode) {
	          opts.mode = opts.mode.toUpperCase();
	        }

	        state.mode = opts.mode === "RAW" ? EVS.Type_EV3_COLOR_RGBRAW : EVS.Type_EV3_COLOR;
	        state.bytes = state.mode === EVS.Type_EV3_COLOR_RGBRAW ? 6 : 2;

	        // Do not change the order of these items. They are listed such that the
	        // index corresponds to the color code produced by the EV3 color sensor.
	        // The range is very limited.
	        state.colors = [
	          [],
	          [0, 0, 0],
	          [0, 0, 255],
	          [0, 128, 0],
	          [255, 255, 0],
	          [255, 0, 0],
	          [255, 255, 255],
	          [139, 69, 19],
	        ];

	        state.shield = EVS.shieldPort(opts.pin);
	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));

	        state.ev3.setup(state.shield, EVS.Type_EV3);
	        state.ev3.write(state.shield, 0x81 + state.shield.offset, state.mode);
	        state.ev3.read(state.shield, EVS.ColorMeasure, state.bytes, function(data) {
	          var value = "";
	          if (state.bytes === 2) {
	            value += String((data[0] | (data[1] << 8)) || 1);
	          } else {
	            for (var i = 0; i < 3; i++) {
	              value += pad(data[i * 2].toString(16), 2);
	            }
	          }
	          dataHandler(value);
	        });
	      }
	    },
	    toRGB: {
	      value: function(raw) {
	        var state = priv.get(this);

	        if (state.mode === EVS.Type_EV3_COLOR) {
	          return raw > 0 && raw < 8 ? state.colors[raw] : state.colors[0];
	        } else {
	          raw = String(raw);
	          return [0, 0, 0].map(function(zero, index) {
	            return parseInt(raw.slice(index * 2, index * 2 + 2), 16);
	          });
	        }
	      }
	    }
	  },
	  EVS_NXT: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        if (opts.mode) {
	          opts.mode = opts.mode.toUpperCase();
	        }

	        state.mode = opts.mode === "RAW" ? EVS.Type_NXT_COLOR_RGBRAW : EVS.Type_NXT_COLOR;
	        state.bytes = state.mode === EVS.Type_NXT_COLOR_RGBRAW ? 10 : 1;

	        if (state.mode === EVS.Type_NXT_COLOR_RGBRAW) {
	          throw new Error("Raw RGB is not currently supported for the NXT.");
	        }

	        // Do not change the order of these items. They are listed such that the
	        // index corresponds to the color code produced by the EV3 color sensor.
	        // The range is very limited.
	        state.colors = [
	          [],
	          [0, 0, 0],
	          [0, 0, 255],
	          [0, 128, 0],
	          [255, 255, 0],
	          [255, 0, 0],
	          [255, 255, 255],
	        ];

	        state.shield = EVS.shieldPort(opts.pin);
	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, EVS.Type_NXT_COLOR);
	        state.ev3.read(state.shield, 0x70 + state.shield.offset, state.bytes, function(data) {
	          var value = "";

	          if (state.bytes === 1) {
	            value += String(data[0]);
	          } else {

	            // One day I'll figure this out :|
	            // There is a lot of documentation that
	            // claims this is possible, but I couldn't
	            // figure out how to make sense of the
	            // data that's returned.
	            //
	            // http://www.mathworks.com/help/supportpkg/legomindstormsnxt/ref/legomindstormsnxtcolorsensor.html#zmw57dd0e700
	            // https://msdn.microsoft.com/en-us/library/ff631052.aspx
	            // http://www.lejos.org/nxt/nxj/api/lejos/nxt/ColorSensor.html
	            // http://www.robotc.net/forums/viewtopic.php?f=52&t=6939
	            // http://code.metager.de/source/xref/lejos/classes/src/lejos/nxt/SensorPort.java#calData
	            // http://code.metager.de/source/xref/lejos/classes/src/lejos/nxt/SensorPort.java#SP_MODE_INPUT
	            // http://code.metager.de/source/xref/lejos/classes/src/lejos/nxt/SensorPort.java#416
	          }

	          // if (data[4] !== 0) {
	            dataHandler(value);
	          // }
	        });
	      }
	    },
	    toRGB: {
	      value: function(raw) {
	        var state = priv.get(this);

	        if (state.mode === EVS.Type_NXT_COLOR) {
	          return raw > 0 && raw < 7 ? state.colors[raw] : state.colors[0];
	        } else {
	          raw = String(raw);
	          return [0, 0, 0].map(function(zero, index) {
	            return parseInt(raw.slice(index * 2, index * 2 + 2), 16);
	          });
	        }
	      }
	    }
	  },
	  ISL29125: {
	    // http://www.intersil.com/content/dam/Intersil/documents/isl2/isl29125.pdf
	    REGISTER: {
	      value: {
	        RESET: 0x00,
	        // mode/lux range
	        CONFIG1: 0x01,
	        // ir adjust/filtering
	        CONFIG2: 0x02,
	        // interrupt control
	        CONFIG3: 0x03,
	        // Same as "GREEN DATA - LOW BYTE"
	        READ: 0x09
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        // Cannot change address, so all values const/closed.
	        var address = 0x44;

	        // TODO: make configs user "definable"

	        this.io.i2cConfig();

	        // Reset chip
	        this.io.i2cWriteReg(address, this.REGISTER.RESET, 0x46);

	        // RGB | 10K Lux | 12bits
	        this.io.i2cWriteReg(address, this.REGISTER.CONFIG1, 0x05 | 0x08 | 0x00);

	        // High adjust
	        this.io.i2cWriteReg(address, this.REGISTER.CONFIG2, 0x3F);

	        // No Interrupts
	        this.io.i2cWriteReg(address, this.REGISTER.CONFIG3, 0x00);

	        this.io.i2cRead(address, this.REGISTER.READ, 6, function(data) {
	          var value = "";

	          // Register order: GLSB, GMSB, RLSB, RMSB, BLSB, BMSB
	          var g = (data[1] << 8) | data[0];
	          var r = (data[3] << 8) | data[2];
	          var b = (data[5] << 8) | data[4];

	          var rgb = [r >> 2, g >> 2, b >> 2].map(function(value) {
	            return __.constrain(value, 0, 255);
	          });

	          for (var i = 0; i < 3; i++) {
	            value += pad(rgb[i].toString(16), 2);
	          }

	          dataHandler(value);
	        });
	      }
	    },
	    toRGB: {
	      value: function(raw) {
	        raw = String(raw);
	        return [0, 0, 0].map(function(zero, index) {
	          return parseInt(raw.slice(index * 2, index * 2 + 2), 16);
	        });
	      }
	    }
	  },
	};


	var colorNames = ["red", "green", "blue"];


	/**
	 * Color
	 * @constructor
	 *
	 */

	function Color(opts) {

	  if (!(this instanceof Color)) {
	    return new Color(opts);
	  }

	  var controller = null;
	  var state = {};
	  var freq = opts.freq || 25;
	  var raw = 0;
	  var last = null;

	  Board.Device.call(
	    this, opts = Board.Options(opts)
	  );

	  if (typeof opts.controller === "string") {
	    controller = Controllers[opts.controller];
	  } else {
	    controller = opts.controller || Controllers.DEFAULT;
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toRGB) {
	    this.toRGB = opts.toRGB || function(x) {
	      return x;
	    };
	  }

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return raw;
	      }
	    },
	    rgb: {
	      get: function() {
	        return this.toRGB(raw).reduce(function(accum, value, index) {
	          accum[colorNames[index]] = value;
	          return accum;
	        }, {});
	      }
	    }
	  });

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === undefined) {
	      return;
	    }

	    var data = {
	      rgb: this.rgb,
	    };

	    this.emit("data", data);

	    if (raw !== last) {
	      last = raw;
	      this.emit("change", data);
	    }
	  }.bind(this), freq);
	}

	util.inherits(Color, Emitter);

	Color.hexCode = function(rgb) {
	  if (rgb.red === undefined || rgb.green === undefined || rgb.blue === undefined) {
	    return null;
	  }
	  return rgb.length === 0 ? "unknown" : colorNames.reduce(function(accum, name) {
	    return accum += pad(rgb[name].toString(16), 2);
	  }, "");
	};




	module.exports = Color;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Emitter = __webpack_require__(8).EventEmitter,
	  util = __webpack_require__(12),
	  __ = __webpack_require__(115),
	  int16 = __.int16;


	var priv = new Map();

	var Controllers = {

	  /**
	   * HMC5883L: 3-Axis Compass Module
	   * 0x1E
	   *
	   * https://sites.google.com/site/parallaxinretailstores/home/compass-module-3-axis-hmc5883l
	   *
	   * http://www51.honeywell.com/aero/common/documents/myaerospacecatalog-documents/Defense_Brochures-documents/HMC5883L_3-Axis_Digital_Compass_IC.pdf
	   * P. 10,11,12,13
	   *
	   * http://www.memsense.com/docs/MTD-0801_1_0_Calculating_Heading_Elevation_Bank_Angle.pdf
	   *
	   * https://www.loveelectronics.co.uk/Tutorials/13/tilt-compensated-compass-arduino-tutorial
	   *
	   */
	  HMC5883L: {
	    REGISTER: {
	      value: {
	        // Configuration Register A
	        CRA: 0x00,
	        // Configuration Register B
	        // This may change, depending on gauss
	        CRB: 0x01,
	        MEASUREMENT: 0x02,
	        READ: 0x03
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);
	        var address = 0x1E;
	        var READLENGTH = 6;

	        state.scale = 1;
	        state.register = 0x40;

	        Object.assign(state, new Compass.Scale(opts.gauss || 0.88));

	        this.io.i2cConfig(opts);

	        // Set CRA
	        this.io.i2cWrite(address, this.REGISTER.CRA, 0x70);

	        // Set CRB
	        this.io.i2cWrite(address, this.REGISTER.CRB, state.register);

	        // Measurement: Continuous
	        this.io.i2cWrite(address, this.REGISTER.MEASUREMENT, 0x00);

	        // Initialize continuous read
	        this.io.i2cRead(address, this.REGISTER.READ, READLENGTH, function(bytes) {
	          dataHandler.call(this, {
	            x: int16(bytes[0], bytes[1]),
	            y: int16(bytes[4], bytes[5]),
	            z: int16(bytes[2], bytes[3]),
	          });
	        }.bind(this));
	      }
	    },
	    toScaledHeading: {
	      value: function(data) {
	        var x = data.x * data.scale;
	        var y = data.y * data.scale;

	        return ToHeading(x, y);
	      }
	    }
	  },

	  /**
	   * HMC6352: 2-Axis Compass Module
	   * 0x42
	   *
	   * http://www.sparkfun.com/datasheets/Components/HMC6352.pdf
	   * http://bildr.org/2011/01/hmc6352/
	   */
	  HMC6352: {
	    REGISTER: {
	      value: {
	        READ: 0x41
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);
	        var address = 0x42 >> 1; // 0x42 >> 1
	        var READLENGTH = 2;

	        state.scale = 1;

	        opts.delay = 10;

	        this.io.i2cConfig(opts);

	        this.io.i2cWrite(address, this.REGISTER.READ);

	        // Initialize continuous read
	        this.io.i2cRead(address, this.REGISTER.READ, READLENGTH, function(bytes) {
	          dataHandler.call(this, {
	            x: (((bytes[0] << 8) + bytes[1]) / 10) | 0,
	            y: null,
	            z: null,
	          });
	        }.bind(this));
	      }
	    },
	    toScaledHeading: {
	      value: function(data) {
	        return data.x * data.scale;
	      }
	    }
	  },
	};


	/**
	 * Compass
	 * @constructor
	 *
	 * five.Compass();
	 *
	 * five.Compass({
	 *  controller: "HMC5883L",
	 *  freq: 50,
	 * });
	 *
	 *
	 * Device Shorthands:
	 *
	 * "HMC5883L": new five.Magnetometer()
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Compass(opts) {

	  if (!(this instanceof Compass)) {
	    return new Compass(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  var freq = opts.freq || 25;
	  var controller = null;
	  var raw = null;
	  var state = {
	    x: 0,
	    y: 0,
	    z: 0,
	    scale: 0,
	    register: 0,
	    heading: 0
	  };

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller === null || typeof controller !== "object") {
	    throw new Error("Missing valid Compass controller");
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toScaledHeading) {
	    this.toScaledHeading = opts.toScaledHeading || function(raw) { return raw; };
	  }

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === null) {
	      return;
	    }
	    var isChange = false;

	    state.x = raw.x;
	    state.y = raw.y;
	    state.z = raw.z;

	    var heading = this.heading;

	    if (heading !== state.heading) {
	      state.heading = heading;
	      isChange = true;
	    }

	    this.emit("data", {
	      heading: state.heading
	    });

	    if (isChange) {
	      this.emit("change", {
	        heading: state.heading
	      });
	    }
	  }.bind(this), freq);
	}


	util.inherits(Compass, Emitter);


	Object.defineProperties(Compass.prototype, {
	  /**
	   * [read-only] Bearing information
	   * @name bearing
	   * @property
	   * @type Object
	   *
	   *
	      name
	      abbr
	      low
	      mid
	      high
	      heading
	   *
	   */

	  bearing: {
	    get: function() {
	      var length = Compass.Points.length;
	      var heading = Math.floor(this.heading);
	      var point;

	      for (var i = 0; i < length; i++) {
	        point = Compass.Points[i];

	        if (point.range.includes(heading)) {
	          // Specify fields to return to avoid returning the
	          // range array (too much noisy data)
	          return {
	            name: point.point,
	            abbr: point.abbr,
	            low: point.low,
	            mid: point.mid,
	            high: point.high,
	            heading: heading
	          };
	        }
	      }
	    }
	  },

	  /**
	   * [read-only] Heading (azimuth)
	   * @name heading
	   * @property
	   * @type number
	   */
	  heading: {
	    get: function() {
	      var state = priv.get(this);
	      return this.toScaledHeading(state);
	    }
	  }
	});


	function ToHeading(x, y) {
	  /**
	   *
	   * Applications of Magnetoresistive Sensors in Navigation Systems
	   * by Michael J. Caruso of Honeywell Inc.
	   * http://www.ssec.honeywell.com/position-sensors/datasheets/sae.pdf
	   *
	   *
	   * Azimuth (x=0, y<0)   = 90.0 (3)
	   * Azimuth (x=0, y>0)   = 270.0
	   * Azimuth (x<0)        = 180 - [arcTan(y/x)]*180/PI
	   * Azimuth (x>0, y<0)   = - [arcTan(y/x)]*180/PI
	   * Azimuth (x>0, y>0)   = 360 - [arcTan(y/x)]*180/PI
	   *
	   *
	   *
	   *
	   *
	   */
	  /**
	   *
	   *
	   * http://bildr.org/2012/02/hmc5883l_arduino/
	   * @type {[type]}
	   * Copyright (C) 2011 Love Electronics (loveelectronics.co.uk)

	   This program is free software: you can redistribute it and/or modify it under the terms of the version 3 GNU General Public License as published by the Free Software Foundation.

	   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

	   You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.

	   */

	  var heading = Math.atan2(y, x);

	  if (heading < 0) {
	    heading += 2 * Math.PI;
	  }

	  if (heading > 2 * Math.PI) {
	    heading -= 2 * Math.PI;
	  }

	  return heading * (180 / Math.PI);
	}


	/**
	 * Compass.scale Set the scale gauss for compass readings
	 * @param  {Number} gauss [description]
	 * @return {register}       [description]
	 *
	 * Ported from:
	 * http://bildr.org/2012/02/hmc5883l_arduino/
	 */

	Compass.Scale = function(gauss) {

	  if (gauss === 0.88) {
	    this.register = 0x00;
	    this.scale = 0.73;
	  } else if (gauss === 1.3) {
	    this.register = 0x01;
	    this.scale = 0.92;
	  } else if (gauss === 1.9) {
	    this.register = 0x02;
	    this.scale = 1.22;
	  } else if (gauss === 2.5) {
	    this.register = 0x03;
	    this.scale = 1.52;
	  } else if (gauss === 4.0) {
	    this.register = 0x04;
	    this.scale = 2.27;
	  } else if (gauss === 4.7) {
	    this.register = 0x05;
	    this.scale = 2.56;
	  } else if (gauss === 5.6) {
	    this.register = 0x06;
	    this.scale = 3.03;
	  } else if (gauss === 8.1) {
	    this.register = 0x07;
	    this.scale = 4.35;
	  } else {
	    this.register = 0x00;
	    this.scale = 1;
	  }

	  // Setting is in the top 3 bits of the register.
	  this.register = this.register << 5;
	};


	/**
	 * Compass.Points
	 *
	 * 32 Point Compass
	 * +1 for North
	 *
	 */

	Compass.Points = [{
	  point: "North",
	  abbr: "N",
	  low: 354.38,
	  mid: 360,
	  high: 360
	}, {
	  point: "North",
	  abbr: "N",
	  low: 0,
	  mid: 0,
	  high: 5.62
	}, {
	  point: "North by East",
	  abbr: "NbE",
	  low: 5.63,
	  mid: 11.25,
	  high: 16.87
	}, {
	  point: "North-NorthEast",
	  abbr: "NNE",
	  low: 16.88,
	  mid: 22.5,
	  high: 28.12
	}, {
	  point: "NorthEast by North",
	  abbr: "NEbN",
	  low: 28.13,
	  mid: 33.75,
	  high: 39.37
	}, {
	  point: "NorthEast",
	  abbr: "NE",
	  low: 39.38,
	  mid: 45,
	  high: 50.62
	}, {
	  point: "NorthEast by East",
	  abbr: "NEbE",
	  low: 50.63,
	  mid: 56.25,
	  high: 61.87
	}, {
	  point: "East-NorthEast",
	  abbr: "ENE",
	  low: 61.88,
	  mid: 67.5,
	  high: 73.12
	}, {
	  point: "East by North",
	  abbr: "EbN",
	  low: 73.13,
	  mid: 78.75,
	  high: 84.37
	}, {
	  point: "East",
	  abbr: "E",
	  low: 84.38,
	  mid: 90,
	  high: 95.62
	}, {
	  point: "East by South",
	  abbr: "EbS",
	  low: 95.63,
	  mid: 101.25,
	  high: 106.87
	}, {
	  point: "East-SouthEast",
	  abbr: "ESE",
	  low: 106.88,
	  mid: 112.5,
	  high: 118.12
	}, {
	  point: "SouthEast by East",
	  abbr: "SEbE",
	  low: 118.13,
	  mid: 123.75,
	  high: 129.37
	}, {
	  point: "SouthEast",
	  abbr: "SE",
	  low: 129.38,
	  mid: 135,
	  high: 140.62
	}, {
	  point: "SouthEast by South",
	  abbr: "SEbS",
	  low: 140.63,
	  mid: 146.25,
	  high: 151.87
	}, {
	  point: "South-SouthEast",
	  abbr: "SSE",
	  low: 151.88,
	  mid: 157.5,
	  high: 163.12
	}, {
	  point: "South by East",
	  abbr: "SbE",
	  low: 163.13,
	  mid: 168.75,
	  high: 174.37
	}, {
	  point: "South",
	  abbr: "S",
	  low: 174.38,
	  mid: 180,
	  high: 185.62
	}, {
	  point: "South by West",
	  abbr: "SbW",
	  low: 185.63,
	  mid: 191.25,
	  high: 196.87
	}, {
	  point: "South-SouthWest",
	  abbr: "SSW",
	  low: 196.88,
	  mid: 202.5,
	  high: 208.12
	}, {
	  point: "SouthWest by South",
	  abbr: "SWbS",
	  low: 208.13,
	  mid: 213.75,
	  high: 219.37
	}, {
	  point: "SouthWest",
	  abbr: "SW",
	  low: 219.38,
	  mid: 225,
	  high: 230.62
	}, {
	  point: "SouthWest by West",
	  abbr: "SWbW",
	  low: 230.63,
	  mid: 236.25,
	  high: 241.87
	}, {
	  point: "West-SouthWest",
	  abbr: "WSW",
	  low: 241.88,
	  mid: 247.5,
	  high: 253.12
	}, {
	  point: "West by South",
	  abbr: "WbS",
	  low: 253.13,
	  mid: 258.75,
	  high: 264.37
	}, {
	  point: "West",
	  abbr: "W",
	  low: 264.38,
	  mid: 270,
	  high: 275.62
	}, {
	  point: "West by North",
	  abbr: "WbN",
	  low: 275.63,
	  mid: 281.25,
	  high: 286.87
	}, {
	  point: "West-NorthWest",
	  abbr: "WNW",
	  low: 286.88,
	  mid: 292.5,
	  high: 298.12
	}, {
	  point: "NorthWest by West",
	  abbr: "NWbW",
	  low: 298.13,
	  mid: 303.75,
	  high: 309.37
	}, {
	  point: "NorthWest",
	  abbr: "NW",
	  low: 309.38,
	  mid: 315.00,
	  high: 320.62
	}, {
	  point: "NorthWest by North",
	  abbr: "NWbN",
	  low: 320.63,
	  mid: 326.25,
	  high: 331.87
	}, {
	  point: "North-NorthWest",
	  abbr: "NNW",
	  low: 331.88,
	  mid: 337.5,
	  high: 343.12
	}, {
	  point: "North by West",
	  abbr: "NbW",
	  low: 343.13,
	  mid: 348.75,
	  high: 354.37
	}];

	// Add ranges to each compass point record
	Compass.Points.forEach(function(point, k) {
	  this[k].range = __.range(Math.floor(point.low), Math.floor(point.high));
	}, Compass.Points);



	/**
	 * Fires once every N ms, equal to value of `freq`. Defaults to 66ms
	 *
	 * @event
	 * @name read
	 * @memberOf Compass
	 */


	/**
	 * Fires when the calculated heading has changed
	 *
	 * @event
	 * @name headingchange
	 * @memberOf Compass
	 */


	module.exports = Compass;


	// http://en.wikipedia.org/wiki/Relative_direction


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var Sensor = __webpack_require__(138),
	  util = __webpack_require__(12);


	// References
	//  - http://www.acroname.com/articles/linearizing-sharp-ranger.html
	//  - http://luckylarry.co.uk/arduino-projects/arduino-using-a-sharp-ir-sensor-for-distance-calculation/
	//  - http://forum.arduino.cc/index.php?topic=63433.0
	//  - https://github.com/pjwerneck/Diaspar/blob/master/robots/sensors/sharp_table.py
	//
	//
	var Controllers = {
	  GP2Y0A21YK: {
	    // https://www.sparkfun.com/products/242
	    initialize: {
	      value: function(opts) {
	        Sensor.call(this, opts);
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return +(12343.85 * Math.pow(raw, -1.15)).toFixed(2);
	      }
	    }
	  },
	  GP2D120XJ00F: {
	    // https://www.sparkfun.com/products/8959
	    initialize: {
	      value: function(opts) {
	        Sensor.call(this, opts);
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return +((2914 / (raw + 5)) - 1).toFixed(2);
	      }
	    }
	  },
	  GP2Y0A02YK0F: {
	    // https://www.sparkfun.com/products/8958
	    // 15cm - 150cm
	    initialize: {
	      value: function(opts) {
	        Sensor.call(this, opts);
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return +(10650.08 * Math.pow(raw, -0.935) - 10).toFixed(2);
	      }
	    }
	  },
	  GP2Y0A41SK0F: {
	    // https://www.sparkfun.com/products/12728
	    // 4cm - 30cm
	    initialize: {
	      value: function(opts) {
	        Sensor.call(this, opts);
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return +(2076 / (raw - 11)).toFixed(2);
	      }
	    }
	  }
	};

	// Otherwise known as...
	Controllers["2Y0A21"] = Controllers.GP2Y0A21YK;
	Controllers["2D120X"] = Controllers.GP2D120XJ00F;
	Controllers["2Y0A02"] = Controllers.GP2Y0A02YK0F;
	Controllers["OA41SK"] = Controllers.GP2Y0A41SK0F;

	// As shown here: http://www.acroname.com/articles/sharp.html
	Controllers["0A21"] = Controllers.GP2Y0A21YK;
	Controllers["0A02"] = Controllers.GP2Y0A02YK0F;

	/**
	 * IR.Distance
	 *
	 * @deprecated
	 * @constructor
	 *
	 * five.IR.Distance("A0");
	 *
	 * five.IR.Distance({
	 *  device: "GP2Y0A41SK0F",
	 *  pin: "A0",
	 *  freq: 100
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Distance(opts) {

	  if (!(this instanceof Distance)) {
	    return new Distance(opts);
	  }

	  var controller = null;

	  if (typeof opts.controller === "string") {
	    controller = Controllers[opts.controller];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["GP2Y0A21YK"];
	  }

	  Object.defineProperties(this, controller);

	  if (!this.toCm) {
	    this.toCm = opts.toCm || function(x) {
	      return x;
	    };
	  }

	  Object.defineProperties(this, {
	    /**
	     * [read-only] Calculated centimeter value
	     * @property centimeters
	     * @type Number
	     */
	    centimeters: {
	      get: function() {
	        return this.toCm(this.value);
	      }
	    },
	    cm: {
	      get: function() {
	        return this.centimeters;
	      }
	    },
	    /**
	     * [read-only] Calculated inch value
	     * @property inches
	     * @type Number
	     */
	    inches: {
	      get: function() {
	        return +(this.centimeters * 0.39).toFixed(2);
	      }
	    },
	    in : {
	      get: function() {
	        return this.inches;
	      }
	    },
	  });

	  if (typeof this.initialize === "function") {
	    this.initialize(opts);
	  }
	}

	Distance.Controllers = [
	  "2Y0A21", "GP2Y0A21YK",
	  "2D120X", "GP2D120XJ00F",
	  "2Y0A02", "GP2Y0A02YK0F",
	  "OA41SK", "GP2Y0A41SK0F",
	  "0A21", "GP2Y0A21YK",
	  "0A02", "GP2Y0A02YK0F",
	];

	util.inherits(Distance, Sensor);

	module.exports = Distance;


	// http://www.acroname.com/robotics/info/articles/sharp/sharp.html


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12),
	  within = __webpack_require__(139),
	  __ = __webpack_require__(115);

	// Sensor instance private data
	var priv = new Map(),
	  aliases = {
	    change: [
	      // Generic sensor value change
	      "change",
	      // Slider sensors (alias)
	      "slide",
	      // Soft Potentiometer (alias)
	      "touch",
	      // Force Sensor (alias)
	      "force",
	      // Flex Sensor (alias)
	      "bend"
	    ]
	  },
	  IS_TEST_MODE = !!process.env.IS_TEST_MODE;

	// To reduce noise in sensor readings, sort collected samples
	// from high to low and select the value in the center.
	function arrayMedian(input) {
	  var half, len, sorted;
	  // faster than default comparitor (even for small n)
	  sorted = input.sort(function(a, b) {
	    return a - b;
	  });
	  len = sorted.length;
	  half = Math.floor(len / 2);

	  // If the length is odd, return the midpoint m
	  // If the length is even, return average of m & m + 1
	  return len % 2 ? sorted[half] : (sorted[half - 1] + sorted[half]) / 2;
	} // ./arrayMedian(input)

	/**
	 * Sensor
	 * @constructor
	 *
	 * @description Generic analog or digital sensor constructor
	 *
	 * @param {Object} opts Options: pin, freq, range
	 */

	function Sensor(opts) {

	  if (!(this instanceof Sensor)) {
	    return new Sensor(opts);
	  }

	  var value, last, min, max, samples, state, median, eventProcessing;

	  value = null;
	  min = 1023;
	  max = 0;
	  last = -min;
	  samples = [];
	  median = NaN;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (!opts.type) {
	    opts.type = "analog";
	  }

	  // Set the pin to ANALOG (INPUT) mode
	  this.mode = opts.type === "digital" ?
	    this.io.MODES.INPUT :
	    this.io.MODES.ANALOG;

	  this.io.pinMode(this.pin, this.mode);

	  // Create a "state" entry for privately
	  // storing the state of the sensor
	  state = {
	    enabled: typeof opts.enabled === "undefined" ? true : opts.enabled,
	    booleanBarrier: opts.type === "digital" ? 0 : 512,
	    intervalId: null,
	    scale: null,
	    value: 0,
	    freq: opts.freq || 25,
	    previousFreq: opts.freq || 25,
	  };
	  // Put a reference where the prototype methods defined in this file have access
	  priv.set(this, state);

	  // Sensor instance properties
	  this.range = opts.range || [0, 1023];
	  this.limit = opts.limit || null;
	  this.threshold = opts.threshold === undefined ? 1 : opts.threshold;
	  this.isScaled = false;

	  // Read event loop
	  this.io[opts.type + "Read"](this.pin, function(data) {
	    // Update the instance-local `value` value.
	    // This is shared by the accessors defined below.
	    value = data;

	    // Only append to the samples when noise filtering can/will be used
	    if (opts.type !== "digital") {
	      samples.push(value);
	    }
	  }.bind(this));

	  // Throttle
	  // TODO: The event (interval) processing function should be outside of the Sensor
	  // constructor function (with appropriate passed (and bound?) arguments), to
	  // avoid creating a separate copy (of the function) for each Sensor instance.
	  eventProcessing = function() {
	    var err, boundary;

	    err = null;

	    // For digital sensors, skip the analog
	    // noise filtering provided below.
	    if (opts.type === "digital") {
	      this.emit("data", err, value);

	      if (last !== value) {
	        aliases.change.forEach(function(change) {
	          this.emit(change, err, value);
	        }, this);
	        // Update the instance-local `last` value.
	        last = value;
	      }
	      return;
	    }

	    // Keep the previous calculated value if there were no new readings
	    if (samples.length > 0) {
	      // Filter the accumulated sample values to reduce analog reading noise
	      median = arrayMedian(samples);
	    }
	    // @DEPRECATE
	    this.emit("read", err, median);
	    // The "read" event has been deprecated in
	    // favor of a "data" event.
	    this.emit("data", err, median);

	    // If the filtered (median) value for this interval is at least  the
	    // configured threshold from last, fire change events
	    if (median <= (last - this.threshold) || median >= (last + this.threshold)) {
	      // Include all aliases
	      aliases.change.forEach(function(change) {
	        this.emit(change, err, median);
	      }, this);
	      // Update the instance-local `last` value (only) when a new change event
	      // has been emitted.  For comparison in the next interval
	      last = median;
	    }

	    if (this.limit) {
	      if (median <= this.limit[0]) {
	        boundary = "lower";
	      }
	      if (median >= this.limit[1]) {
	        boundary = "upper";
	      }

	      if (boundary) {
	        this.emit("limit", err, {
	          boundary: boundary,
	          value: median
	        });
	        this.emit("limit:" + boundary, err, median);
	      }
	    }

	    // Reset samples
	    samples.length = 0;
	  }.bind(this); // ./function eventProcessing()


	  Object.defineProperties(this, {
	    raw: {
	      get: function() {
	        return value;
	      }
	    },
	    analog: {
	      get: function() {
	        if (opts.type === "digital") {
	          return value;
	        }

	        return value === null ? null :
	          Board.map(this.raw, 0, 1023, 0, 255) | 0;
	      }
	    },
	    constrained: {
	      get: function() {
	        if (opts.type === "digital") {
	          return value;
	        }

	        return value === null ? null :
	          Board.constrain(this.raw, 0, 255);
	      }
	    },
	    boolean: {
	      get: function() {
	        return this.value > priv.get(this).booleanBarrier ?
	          true : false;
	      }
	    },
	    scaled: {
	      get: function() {
	        var mapped, constrain;

	        if (state.scale && value !== null) {
	          if (opts.type === "digital") {
	            // Value is either 0 or 1, use as an index
	            // to return the scaled value.
	            return state.scale[value];
	          }

	          mapped = Board.fmap(value, this.range[0], this.range[1], state.scale[0], state.scale[1]);
	          constrain = Board.constrain(mapped, state.scale[0], state.scale[1]);

	          return constrain;
	        }
	        return this.constrained;
	      }
	    },
	    freq: {
	      get: function() {
	        return state.freq;
	      },
	      set: function(newFreq) {
	        state.freq = newFreq;
	        if (state.intervalId) {
	          clearInterval(state.intervalId);
	        }

	        if (state.freq !== null) {
	          state.intervalId = setInterval(eventProcessing, newFreq);
	        }
	      }
	    },
	    value: {
	      get: function() {
	        if (state.scale) {
	          this.isScaled = true;
	          return this.scaled;
	        }

	        return value;
	      }
	    }
	  });

	  if (IS_TEST_MODE) {
	    Object.defineProperties(this, {
	      state: {
	        get: function() {
	          return priv.get(this);
	        }
	      }
	    });
	  }

	  // Set the freq property only after the get and set functions are defined
	  // and only if the sensor is not `enabled: false`
	  if (state.enabled) {
	    this.freq = state.freq;
	  }
	}

	util.inherits(Sensor, events.EventEmitter);

	/**
	 * EXPERIMENTAL
	 *
	 * within When value is within the provided range, execute callback
	 *
	 * @param {Number} range Upperbound, converted into an array,
	 *                       where 0 is lowerbound
	 * @param {Function} callback Callback to execute when value falls inside range
	 * @return {Object} instance
	 *
	 *
	 * @param {Array} range Lower to Upper bounds [ low, high ]
	 * @param {Function} callback Callback to execute when value falls inside range
	 * @return {Object} instance
	 *
	 */
	__.mixin(Sensor.prototype, within);

	/**
	 * enable Enable a disabled sensor.
	 *
	 * @return {Object} instance
	 *
	 */
	Sensor.prototype.enable = function() {
	  var state = priv.get(this);

	  if (!state.enabled) {
	    this.freq = state.freq || state.previousFreq;
	  }

	  return this;
	};

	/**
	 * disable Disable an enabled sensor.
	 *
	 * @return {Object} instance
	 *
	 */
	Sensor.prototype.disable = function() {
	  var state = priv.get(this);

	  if (state.enabled) {
	    state.enabled = false;
	    state.previousFreq = state.freq;
	    this.freq = null;
	  }

	  return this;
	};

	/**
	 * scale/scaleTo Set a value scaling range
	 *
	 * @param  {Number} low  Lowerbound
	 * @param  {Number} high Upperbound
	 * @return {Object} instance
	 *
	 * @param  {Array} [ low, high]  Lowerbound
	 * @return {Object} instance
	 *
	 */
	Sensor.prototype.scale = function(low, high) {
	  this.isScaled = true;

	  priv.get(this).scale = Array.isArray(low) ?
	    low : [low, high];

	  return this;
	};

	Sensor.prototype.scaleTo = Sensor.prototype.scale;

	/**
	 * booleanAt Set a midpoint barrier value used to calculate returned value of
	 *           .boolean property.
	 *
	 * @param  {Number} barrier
	 * @return {Object} instance
	 *
	 */

	Sensor.prototype.booleanAt = function(barrier) {
	  priv.get(this).booleanBarrier = barrier;
	  return this;
	};

	module.exports = Sensor;

	// Reference
	// http://itp.nyu.edu/physcomp/Labs/Servo
	// http://arduinobasics.blogspot.com/2011/05/arduino-uno-flex-sensor-and-leds.html

	// TODO:
	// Update comments/docs

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 139 */
/***/ function(module, exports) {

	var mixins = {

	  within: function(range, unit, callback) {
	    var upper;

	    if (typeof range === "number") {
	      upper = range;
	      range = [0, upper];
	    }

	    if (!Array.isArray(range)) {
	      this.emit("error", {
	        message: "range must be an array"
	      });
	      return;
	    }

	    if (typeof unit === "function") {
	      callback = unit;
	      unit = "value";
	    }

	    if (typeof this[unit] === "undefined") {
	      return this;
	    }

	    // Use the continuous read event for high resolution
	    this.on("data", function() {
	      var value = this[unit] | 0;
	      if (value >= range[0] && value <= range[1]) {
	        callback.call(this, null, value);
	      }
	    }.bind(this));

	    return this;
	  }
	};

	module.exports = mixins;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var Pins = Board.Pins;
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var Collection = __webpack_require__(114);
	var __ = __webpack_require__(115);
	var nanosleep = __webpack_require__(141).nano;

	var priv = new Map();


	var Controllers = {
	  PCA9685: {
	    REGISTER: {
	      value: {
	        PCA9685_MODE1: 0x0,
	        PCA9685_PRESCALE: 0xFE,
	        LED0_ON_L: 0x6
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        this.address = opts.address || 0x40;
	        this.pwmRange = opts.pwmRange || [544, 2400];

	        if (!this.board.Drivers[this.address]) {
	          this.io.i2cConfig(opts);
	          this.board.Drivers[this.address] = {
	            initialized: false
	          };

	          // Reset
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0x00);
	          // Sleep
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0x10);
	          // Set prescalar
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_PRESCALE, 0x70);
	          // Wake up
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0x00);
	          // Wait 5 nanoseconds for restart
	          nanosleep(5);
	          // Auto-increment
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0xa1);

	          this.board.Drivers[this.address].initialized = true;
	        }
	      }
	    },
	    write: {
	      writable: true,
	      value: function(pin, degrees) {
	        var on = 0;
	        var off = __.map(degrees, 0, 180, this.pwmRange[0] / 4, this.pwmRange[1] / 4);

	        this.io.i2cWrite(this.address, [this.REGISTER.LED0_ON_L + 4 * pin, on, on >> 8, off, off >> 8]);
	      }
	    }
	  },
	  DEFAULT: {
	    initialize: {
	      value: function(opts) {

	        // When in debug mode, if pin is not a PWM pin, emit an error
	        if (opts.debug && !this.board.pins.isServo(this.pin)) {
	          Board.Pins.Error({
	            pin: this.pin,
	            type: "PWM",
	            via: "Servo",
	          });
	        }

	        this.io.servoConfig(this.pin, this.pwmRange[0], this.pwmRange[1]);
	      }
	    },
	    write: {
	      writable: true,
	      value: function(pin, degrees) {
	        this.io.servoWrite(pin, degrees);
	      }
	    }
	  }
	};

	var Devices = {
	  FORWARD: {
	    deviceName: {
	      get: function() {
	        return "FORWARD";
	      }
	    },
	    dir: {
	      value: function(speed, dir) {
	        if (dir.name === "forward") {
	          return this.speed(speed);
	        }
	      }
	    }
	  },
	  FORWARD_REVERSE: {
	    deviceName: {
	      get: function() {
	        return "FORWARD_REVERSE";
	      }
	    },
	    dir: {
	      value: function(speed, dir) {
	        if (dir.name === "forward") {
	          return this.speed(__.fscale(speed, 0, 100, this.neutral, this.range[1]));
	        } else {
	          return this.speed(__.fscale(speed, 0, 100, this.neutral, this.range[0]));
	        }
	      }
	    }
	  },
	  FORWARD_BRAKE_REVERSE: {
	    deviceName: {
	      get: function() {
	        return "FORWARD_BRAKE_REVERSE";
	      }
	    },
	    dir: {
	      value: function(speed, dir) {

	        /*
	          As far as I can tell, this isn't possible.

	          To enable reverse, the brakes must first be applied,
	          but it's not nearly as simple as it sounds since there
	          appears to be a timing factor that differs across
	          speed controllers.
	         */

	        if (dir.name === "forward") {
	          this.speed(__.fscale(speed, 0, 100, this.neutral, this.range[1]));
	        } else {
	          this.speed(__.fscale(speed, 0, 100, this.neutral, this.range[0]));
	        }
	      }
	    }
	  }
	};

	/**
	 * ESC
	 * @constructor
	 *
	 * @param {Object} opts Options: pin, range
	 * @param {Number} pin  Pin number
	 */

	function ESC(opts) {
	  if (!(this instanceof ESC)) {
	    return new ESC(opts);
	  }

	  var pinValue;
	  var device;
	  var controller;
	  var state = {
	    // All speed history for this ESC
	    // history = [
	    //   {
	    //     timestamp: Date.now(),
	    //     speed: speed
	    //   }
	    // ];
	    history: [],
	    value: 0
	  };

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  priv.set(this, state);

	  this.startAt = typeof opts.startAt !== "undefined" ? opts.startAt : null;
	  this.neutral = opts.neutral;
	  this.range = opts.range || [0, 100];
	  this.pwmRange = opts.pwmRange || [544, 2400];
	  this.interval = null;

	  // StandardFirmata on Arduino allows controlling
	  // servos from analog pins.
	  // If we're currently operating with an Arduino
	  // and the user has provided an analog pin name
	  // (eg. "A0", "A5" etc.), parse out the numeric
	  // value and capture the fully qualified analog
	  // pin number.
	  if (typeof opts.controller === "undefined" && Pins.isFirmata(this)) {
	    if (typeof pinValue === "string" && pinValue[0] === "A") {
	      pinValue = this.io.analogPins[+pinValue.slice(1)];
	    }

	    pinValue = +pinValue;

	    // If the board's default pin normalization
	    // came up with something different, use the
	    // the local value.
	    if (!Number.isNaN(pinValue) && this.pin !== pinValue) {
	      this.pin = pinValue;
	    }
	  }

	  // Allow users to pass in custom device types
	  device = typeof opts.device === "string" ?
	    Devices[opts.device] : opts.device;

	  if (!device) {
	    device = Devices.FORWARD;
	  }

	  /**
	   * Used for adding special controllers (i.e. PCA9685)
	   **/
	  controller = typeof opts.controller === "string" ?
	    Controllers[opts.controller] : opts.controller;

	  if (!controller) {
	    controller = Controllers.DEFAULT;
	  }

	  Object.defineProperties(this, Object.assign({}, device, controller, {
	    value: {
	      get: function() {
	        return state.value;
	      }
	    },
	    history: {
	      get: function() {
	        return state.history.slice(-5);
	      }
	    },
	    last: {
	      get: function() {
	        return state.history[state.history.length - 1] || { last: null };
	      }
	    }
	  }));

	  this.initialize(opts);

	  if (this.deviceName !== "FORWARD") {
	    if (Number.isNaN(+this.neutral)) {
	      throw new Error("Directional speed controllers require a neutral point from 0-100 (number)");
	    }

	    this.startAt = this.neutral;
	  }

	  // Match either null or undefined, but not 0
	  if (this.startAt !== null && this.startAt !== undefined) {
	    this.speed(this.startAt);
	  }
	}

	util.inherits(ESC, Emitter);

	/**
	 * speed
	 *
	 * Set the ESC's speed
	 *
	 * @param  {Float} speed 0...100 (full range)
	 *
	 * @return {ESC} instance
	 */

	ESC.prototype.speed = function(speed) {
	  var state = priv.get(this);
	  var history = state.history;
	  var noInterval = false;
	  var steps = 0;
	  var lspeed, hspeed;

	  speed = __.constrain(speed, this.range[0], this.range[1]);

	  if (this.interval) {
	    // Bail out if speed is the same as whatever was
	    // last _provided_
	    if (this.value === speed) {
	      return this;
	    } else {
	      clearInterval(this.interval);
	      this.interval = null;
	    }
	  }

	  state.value = speed;

	  // This is the very first speed command being received.
	  // Safe to assume that the ESC and Brushless motor are
	  // not yet moving.
	  if (history.length === 0) {
	    noInterval = true;
	  }

	  // Bail out if speed is the same as whatever was
	  // last _written_

	  if (this.last.speed === speed) {
	    return this;
	  }

	  lspeed = this.last.speed;
	  hspeed = speed;
	  steps = Math.ceil(Math.abs(lspeed - hspeed));

	  if (!steps || steps === 1) {
	    noInterval = true;
	  }

	  if (noInterval) {
	    this.write(this.pin, __.fscale(speed, 0, 100, 0, 180));

	    history.push({
	      timestamp: Date.now(),
	      speed: speed
	    });
	    return this;
	  }

	  var throttle = lspeed;

	  this.interval = setInterval(function() {

	    if (hspeed > throttle) {
	      throttle++;
	    } else {
	      throttle--;
	    }

	    this.write(this.pin, (throttle * 180 / 100));

	    history.push({
	      timestamp: Date.now(),
	      speed: throttle
	    });

	    if (steps) {
	      steps--;

	      if (!steps) {
	        clearInterval(this.interval);
	        this.interval = null;
	      }
	    }
	  }.bind(this), 1);

	  return this;
	};


	/**
	 * brake Stop the ESC by hitting the brakes ;)
	 * @return {Object} instance
	 */
	ESC.prototype.brake = function() {
	  var state = priv.get(this);
	  var speed = this.neutral || 0;

	  this.speed(speed);

	  state.history.push({
	    timestamp: Date.now(),
	    speed: speed
	  });

	  return this;
	};

	[
	  /**
	   * forward Set forward speed
	   * fwd Set forward speed
	   *
	   * @param  {Number} 0-100, 0 is stopped, 100 is fastest
	   * @return {Object} this
	   */
	  {
	    name: "forward",
	    abbr: "fwd",
	    value: 1
	  },
	  /**
	   * reverse Set revese speed
	   * rev Set revese speed
	   *
	   * @param  {Number} 0-100, 0 is stopped, 100 is fastest
	   * @return {Object} this
	   */
	  {
	    name: "reverse",
	    abbr: "rev",
	    value: 0
	  }
	].forEach(function(dir) {
	  var method = function(speed) {
	    this.dir(speed, dir);
	    return this;
	  };

	  ESC.prototype[dir.name] = ESC.prototype[dir.abbr] = method;
	});


	/**
	 * stop Stop the ESC
	 * @return {Object} instance
	 */
	ESC.prototype.stop = function() {
	  var state = priv.get(this);
	  var history = state.history;
	  var speed = this.type === "bidirectional" ? this.neutral : 0;

	  this.write(this.pin, __.fscale(speed, 0, 100, 0, 180));

	  history.push({
	    timestamp: Date.now(),
	    speed: speed
	  });

	  return this;
	};

	/**
	 * ESC.Array()
	 * new ESC.Array()
	 *
	 * Constructs an Array-like instance of all escs
	 */
	function ESCs(numsOrObjects) {
	  if (!(this instanceof ESCs)) {
	    return new ESCs(numsOrObjects);
	  }

	  Object.defineProperty(this, "type", {
	    value: ESC
	  });

	  Collection.call(this, numsOrObjects);
	}

	ESCs.prototype = Object.create(Collection.prototype, {
	  constructor: {
	    value: ESCs
	  }
	});

	/**
	 *
	 * ESCs, speed(0-100%)
	 *
	 * set all escs to the specified speed from 0-100%
	 *
	 * eg. array.min();

	 * ESCs, min()
	 *
	 * set all escs to the minimum throttle
	 *
	 * eg. array.min();

	 * ESCs, max()
	 *
	 * set all escs to the maximum throttle
	 *
	 * eg. array.max();

	 * ESCs, stop()
	 *
	 * stop all escs
	 *
	 * eg. array.stop();
	 */

	Object.keys(ESC.prototype).forEach(function(method) {
	  // Create ESCs wrappers for each method listed.
	  // This will allow us control over all ESC instances
	  // simultaneously.
	  ESCs.prototype[method] = function() {
	    var length = this.length;

	    for (var i = 0; i < length; i++) {
	      this[i][method].apply(this[i], arguments);
	    }
	    return this;
	  };
	});

	if (IS_TEST_MODE) {
	  ESC.purge = function() {
	    priv.clear();
	  };
	}

	// Assign ESCs Collection class as static "method" of ESC.
	ESC.Array = ESCs;

	module.exports = ESC;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {module.exports = {
	  nano: function(ns) {
	    var start = process.hrtime();
	    while (process.hrtime() < start + ns) {}
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var nanosleep = __webpack_require__(141).nano;
	var __ = __webpack_require__(115);
	var priv = new Map();
	var used = new Map();

	function Base() {
	  Emitter.call(this);

	  this.HIGH = 1;
	  this.LOW = 0;
	  this.isReady = false;

	  this.MODES = {};
	  this.pins = [];
	  this.analogPins = [];
	}

	util.inherits(Base, Emitter);

	var Controllers = {
	  // http://www.adafruit.com/datasheets/mcp23017.pdf
	  MCP23017: {
	    REGISTER: {
	      value: {
	        ADDRESS: 0x20,
	        // IO A
	        IODIRA: 0x00,
	        GPPUA: 0x0C,
	        GPIOA: 0x12,
	        OLATA: 0x14,
	        // IO B
	        IODIRB: 0x01,
	        GPPUB: 0x0D,
	        GPIOB: 0x13,
	        OLATB: 0x15,
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.iodir = [ 0xff, 0xff ];
	        state.olat = [ 0xff, 0xff ];
	        state.gpio = [ 0xff, 0xff ];
	        state.gppu = [ 0x00, 0x00 ];

	        this.address = opts.address || this.REGISTER.ADDRESS;

	        this.io.i2cConfig(opts);
	        this.io.i2cWrite(this.address, [ this.REGISTER.IODIRA, state.iodir[this.REGISTER.IODIRA] ]);
	        this.io.i2cWrite(this.address, [ this.REGISTER.IODIRB, state.iodir[this.REGISTER.IODIRB] ]);

	        Object.assign(this.MODES, this.io.MODES);

	        for (var i = 0; i < 16; i++) {
	          this.pins.push({
	            supportedModes: [
	              this.MODES.INPUT,
	              this.MODES.OUTPUT
	            ],
	            mode: 0,
	            value: 0,
	            report: 0,
	            analogChannel: 127
	          });

	          this.pinMode(i, this.MODES.OUTPUT);
	          this.digitalWrite(i, this.LOW);
	        }

	        this.name = "MCP23017";
	        this.isReady = true;

	        this.emit("connect");
	        this.emit("ready");
	      }
	    },
	    normalize: {
	      value: function(pin) {
	        return pin;
	      }
	    },
	    // 1.6.1 I/O DIRECTION REGISTER
	    pinMode: {
	      value: function(pin, mode) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port = 0;
	        var iodir = null;

	        if (pin < 8) {
	          port = this.REGISTER.IODIRA;
	        } else {
	          port = this.REGISTER.IODIRB;
	          pin -= 8;
	        }

	        iodir = state.iodir[port];

	        if (mode === this.io.MODES.INPUT) {
	          iodir |= 1 << pin;
	        } else {
	          iodir &= ~(1 << pin);
	        }

	        this.pins[pinIndex].mode = mode;
	        this.io.i2cWrite(this.address, [ port, iodir ]);

	        state.iodir[port] = iodir;
	      }
	    },
	    // 1.6.10 PORT REGISTER
	    digitalWrite: {
	      value: function(pin, value) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port = 0;
	        var gpio = 0;
	        // var olataddr = 0;
	        var gpioaddr = 0;

	        if (pin < 8) {
	          port = this.REGISTER.IODIRA;
	          // olataddr = this.REGISTER.OLATA;
	          gpioaddr = this.REGISTER.GPIOA;
	        } else {
	          port = this.REGISTER.IODIRB;
	          // olataddr = this.REGISTER.OLATB;
	          gpioaddr = this.REGISTER.GPIOB;
	          pin -= 8;
	        }

	        gpio = state.olat[port];

	        if (value === this.io.HIGH) {
	          gpio |= 1 << pin;
	        } else {
	          gpio &= ~(1 << pin);
	        }

	        this.pins[pinIndex].report = 0;
	        this.pins[pinIndex].value = value;
	        this.io.i2cWrite(this.address, [ gpioaddr, gpio ]);

	        state.olat[port] = gpio;
	        state.gpio[port] = gpio;
	      }
	    },
	    // 1.6.7 PULL-UP RESISTOR
	    // CONFIGURATION REGISTER
	    pullUp: {
	      value: function(pin, value) {
	        var state = priv.get(this);
	        var port = 0;
	        var gppu = 0;
	        var gppuaddr = 0;

	        if (pin < 8) {
	          port = this.REGISTER.IODIRA;
	          gppuaddr = this.REGISTER.GPPUA;
	        } else {
	          port = this.REGISTER.IODIRB;
	          gppuaddr = this.REGISTER.GPPUB;
	          pin -= 8;
	        }

	        gppu = state.gppu[port];

	        if (value === this.io.HIGH) {
	          gppu |= 1 << pin;
	        } else {
	          gppu &= ~(1 << pin);
	        }

	        this.io.i2cWrite(this.address, [ gppuaddr, gppu ]);

	        state.gppu[port] = gppu;
	      }
	    },
	    digitalRead: {
	      value: function(pin, callback) {
	        var pinIndex = pin;
	        var gpioaddr = 0;

	        if (pin < 8) {
	          gpioaddr = this.REGISTER.GPIOA;
	        } else {
	          gpioaddr = this.REGISTER.GPIOB;
	          pin -= 8;
	        }

	        this.pins[pinIndex].report = 1;

	        this.on("digital-read-" + pin, callback);

	        this.io.i2cRead(this.address, gpioaddr, 1, function(data) {
	          var byte = data[0];
	          var value = byte >> pin & 0x01;

	          this.pins[pinIndex].value = value;

	          this.emit("digital-read-" + pin, value);
	        }.bind(this));
	      }
	    },
	  },
	  MCP23008: {
	    REGISTER: {
	      value: {
	        ADDRESS: 0x20,
	        IODIR: 0x00,
	        GPPU: 0x06,
	        GPIO: 0x09,
	        OLAT: 0x0A,
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.iodir = [ 0xff ];
	        state.olat = [ 0xff ];
	        state.gpio = [ 0xff ];
	        state.gppu = [ 0x00 ];

	        this.address = opts.address || this.REGISTER.ADDRESS;

	        this.io.i2cConfig(opts);
	        this.io.i2cWrite(this.address, [ this.REGISTER.IODIR, state.iodir[this.REGISTER.IODIR] ]);

	        Object.assign(this.MODES, this.io.MODES);

	        for (var i = 0; i < 8; i++) {
	          this.pins.push({
	            supportedModes: [
	              this.MODES.INPUT,
	              this.MODES.OUTPUT
	            ],
	            mode: 0,
	            value: 0,
	            report: 0,
	            analogChannel: 127
	          });

	          this.pinMode(i, this.MODES.OUTPUT);
	          this.digitalWrite(i, this.LOW);
	        }

	        this.name = "MCP23008";
	        this.isReady = true;

	        this.emit("connect");
	        this.emit("ready");
	      }
	    },
	    normalize: {
	      value: function(pin) {
	        return pin;
	      }
	    },
	    // 1.6.1 I/O DIRECTION REGISTER
	    pinMode: {
	      value: function(pin, mode) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port = this.REGISTER.IODIR;
	        var iodir = state.iodir[port];

	        if (mode === this.io.MODES.INPUT) {
	          iodir |= 1 << pin;
	        } else {
	          iodir &= ~(1 << pin);
	        }

	        this.pins[pinIndex].mode = mode;
	        this.io.i2cWrite(this.address, [ port, iodir ]);

	        state.iodir[port] = iodir;
	      }
	    },
	    // 1.6.10 PORT REGISTER
	    digitalWrite: {
	      value: function(pin, value) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port = this.REGISTER.IODIR;
	        var gpioaddr = this.REGISTER.GPIO;
	        var gpio = state.olat[port];

	        if (value === this.io.HIGH) {
	          gpio |= 1 << pin;
	        } else {
	          gpio &= ~(1 << pin);
	        }

	        this.pins[pinIndex].report = 0;
	        this.pins[pinIndex].value = value;
	        this.io.i2cWrite(this.address, [ gpioaddr, gpio ]);

	        state.olat[port] = gpio;
	        state.gpio[port] = gpio;
	      }
	    },
	    // 1.6.7 PULL-UP RESISTOR
	    // CONFIGURATION REGISTER
	    pullUp: {
	      value: function(pin, value) {
	        var state = priv.get(this);
	        var port = this.REGISTER.IODIR;
	        var gppuaddr = this.REGISTER.GPPU;
	        var gppu = state.gppu[port];

	        if (value === this.io.HIGH) {
	          gppu |= 1 << pin;
	        } else {
	          gppu &= ~(1 << pin);
	        }

	        this.io.i2cWrite(this.address, [ gppuaddr, gppu ]);

	        state.gppu[port] = gppu;
	      }
	    },
	    digitalRead: {
	      value: function(pin, callback) {
	        var pinIndex = pin;
	        var gpioaddr = this.REGISTER.GPIO;

	        this.pins[pinIndex].report = 1;

	        this.on("digital-read-" + pin, callback);

	        this.io.i2cRead(this.address, gpioaddr, 1, function(data) {
	          var byte = data[0];
	          var value = byte >> pin & 0x01;

	          this.pins[pinIndex].value = value;

	          this.emit("digital-read-" + pin, value);
	        }.bind(this));
	      }
	    },
	  },
	  PCF8574: {
	    REGISTER: {
	      value: {
	        ADDRESS: 0x20,
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.port = 0x00;
	        state.ddr = 0x00;
	        state.pins = 0x00;

	        this.address = opts.address || this.REGISTER.ADDRESS;

	        this.io.i2cConfig(opts);

	        Object.assign(this.MODES, this.io.MODES);

	        for (var i = 0; i < 8; i++) {
	          this.pins.push({
	            supportedModes: [
	              this.MODES.INPUT,
	              this.MODES.OUTPUT
	            ],
	            mode: 1,
	            value: 0,
	            report: 0,
	            analogChannel: 127
	          });

	          this.pinMode(i, this.MODES.OUTPUT);
	          this.digitalWrite(i, this.LOW);
	        }

	        this.name = "PCF8574";
	        this.isReady = true;

	        this.emit("connect");
	        this.emit("ready");
	      }
	    },
	    normalize: {
	      value: function(pin) {
	        return pin;
	      }
	    },
	    pinMode: {
	      value: function(pin, mode) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port = state.port;
	        var ddr = state.ddr;
	        var pins = state.pins;

	        if (mode === this.MODES.INPUT) {
	          ddr &= ~(1 << pin);
	          port &= ~(1 << pin);
	        } else {
	          ddr |= (1 << pin);
	          port &= ~(1 << pin);
	        }

	        this.pins[pinIndex].mode = mode;

	        state.port = port;
	        state.ddr = ddr;

	        this.io.i2cWrite(this.address, (pins & ~ddr) | port);
	      }
	    },
	    digitalWrite: {
	      value: function(pin, value) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port = state.port;
	        var ddr = state.ddr;
	        var pins = state.pins;

	        if (value) {
	          port |= 1 << pin;
	        } else {
	          port &= ~(1 << pin);
	        }

	        this.pins[pinIndex].report = 0;
	        this.pins[pinIndex].value = value;

	        state.port = port;

	        this.io.i2cWrite(this.address, (pins & ~ddr) | port);
	      }
	    },
	    digitalRead: {
	      value: function(pin, callback) {
	        var state = priv.get(this);
	        var pinIndex = pin;

	        this.pins[pinIndex].report = 1;

	        this.on("digital-read-" + pin, callback);

	        this.io.i2cRead(this.address, 1, function(data) {
	          var byte = data[0];
	          var value = byte >> pin & 0x01;

	          state.pins = byte;

	          this.pins[pinIndex].value = value;

	          this.emit("digital-read-" + pin, value);
	        }.bind(this));
	      }
	    },
	  },
	  PCF8575: {
	    REGISTER: {
	      value: {
	        ADDRESS: 0x20,
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.port = [0x00, 0x01];
	        state.gpio = [0x00, 0x00];

	        this.address = opts.address || this.REGISTER.ADDRESS;

	        this.io.i2cConfig(opts);

	        Object.assign(this.MODES, this.io.MODES);

	        for (var i = 0; i < 16; i++) {
	          this.pins.push({
	            supportedModes: [
	              this.MODES.INPUT,
	              this.MODES.OUTPUT
	            ],
	            mode: 1,
	            value: 0,
	            report: 0,
	            analogChannel: 127
	          });

	          this.pinMode(i, this.MODES.OUTPUT);
	          this.digitalWrite(i, this.LOW);
	        }

	        // Set all pins low on initialization
	        this.io.i2cWrite(this.address, state.gpio);

	        this.name = "PCF8575";
	        this.isReady = true;

	        this.emit("connect");
	        this.emit("ready");
	      }
	    },
	    normalize: {
	      value: function(pin) {
	        return pin;
	      }
	    },
	    pinMode: {
	      value: function(pin, mode) {
	        var pinIndex = pin;
	        this.pins[pinIndex].mode = mode;
	      }
	    },
	    digitalWrite: {
	      value: function(pin, value) {
	        var state = priv.get(this);
	        var pinIndex = pin;
	        var port;

	        if (pin < 8) {
	          port = 0;
	        } else {
	          port = 1;
	          pin -= 8;
	        }

	        if (value === this.io.HIGH) {
	          state.gpio[port] |= 1 << pin;
	        } else {
	          state.gpio[port] &= ~(1 << pin);
	        }

	        this.pins[pinIndex].report = 0;
	        this.pins[pinIndex].value = value;

	        this.io.i2cWrite(this.address, state.gpio);
	      }
	    },
	    digitalRead: {
	      value: function(pin, callback) {
	        var pinIndex = pin;
	        var port;

	        if (pin < 8) {
	          port = 0;
	        } else {
	          port = 1;
	          pin -= 8;
	        }

	        this.pins[pinIndex].report = 1;

	        this.on("digital-read-" + pin, callback);

	        this.io.i2cRead(this.address, 2, function(data) {
	          var byte = data[port];
	          var value = byte >> pin & 0x01;

	          this.pins[pinIndex].value = value;

	          this.emit("digital-read-" + pin, value);
	        }.bind(this));
	      }
	    },
	  },
	  PCA9685: {
	    REGISTER: {
	      value: {
	        ADDRESS: 0x40,
	        MODE1: 0x00,
	        PRESCALE: 0xFE,
	        BASE: 0x06
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.frequency = opts.frequency || 50;

	        this.address = opts.address || this.REGISTER.ADDRESS;
	        this.range = opts.range || [0, 4095];

	        this.io.i2cConfig(opts);

	        // Reset
	        this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 0x00);
	        // Sleep
	        this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 0x10);
	        // Set prescalar
	        this.io.i2cWriteReg(this.address, this.REGISTER.PRESCALE, this.prescale);
	        // Wake up
	        this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 0x00);
	        // Wait 5 nanoseconds for restart
	        nanosleep(5);
	        // Auto-increment
	        this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 0xa1);

	        Object.assign(this.MODES, this.io.MODES);

	        for (var i = 0; i < 16; i++) {
	          this.pins.push({
	            supportedModes: [
	              this.MODES.OUTPUT,
	              this.MODES.PWM,
	              this.MODES.SERVO,
	            ],
	            mode: 0,
	            value: 0,
	            report: 0,
	            analogChannel: 127
	          });

	          this.pinMode(i, this.MODES.OUTPUT);
	          this.digitalWrite(i, this.LOW);
	        }

	        Object.defineProperties(this, {
	          prescale: {
	            get: function() {
	              // PCA9685 has an on-board 25MHz clock source
	              return (25000000 / (4096 * (state.frequency || 50))) | 0;
	            }
	          },
	          frequency: {
	            get: function() {
	              return state.frequency;
	            }
	          }
	        });

	        this.name = "PCA9685";
	        this.isReady = true;

	        this.emit("connect");
	        this.emit("ready");
	      }
	    },
	    normalize: {
	      value: function(pin) {
	        return pin;
	      }
	    },
	    pinMode: {
	      value: function(pin, mode) {
	        if (this.pins[pin] === undefined) {
	          throw new RangeError("Invalid PCA9685 pin: " + pin);
	        }
	        this.pins[pin].mode = mode;
	      }
	    },
	    digitalWrite: {
	      value: function(pin, value) {
	        this.pwmWrite(pin, value ? 255 : 0);
	      }
	    },
	    analogWrite: {
	      value: function(pin, value) {
	        this.pwmWrite(pin, value);
	      }
	    },
	    servoWrite: {
	      value: function(pin, degrees) {
	        this.pwmWrite(pin, __.map(degrees, 0, 180, 0, 255));
	      }
	    },
	    pwmWrite: {
	      value: function(pin, value) {
	        if (this.pins[pin] === undefined) {
	          throw new RangeError("Invalid PCA9685 pin: " + pin);
	        }

	        value = Board.constrain(value, 0, 255);

	        var off = this.range[1] * value / 255;

	        this.io.i2cWrite(this.address, [
	          this.REGISTER.BASE + 4 * pin,
	          0, 0,
	          off, off >> 8
	        ]);

	        this.pins[pin].value = value;
	      }
	    }
	  },
	  // http://www.nxp.com/documents/data_sheet/PCF8591.pdf
	  PCF8591: {
	    REGISTER: {
	      value: {
	        ADDRESS: 0x48,
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.control = 0x45;
	        state.reading = false;

	        this.address = opts.address || this.REGISTER.ADDRESS;

	        this.io.i2cConfig(opts);

	        Object.assign(this.MODES, this.io.MODES);

	        for (var i = 0; i < 4; i++) {
	          this.pins.push({
	            supportedModes: [
	              this.MODES.ANALOG
	            ],
	            mode: 1,
	            value: 0,
	            report: 0,
	            analogChannel: i
	          });
	        }

	        this.analogPins.push(0, 1, 2, 3);

	        this.io.i2cWrite(this.address, state.control);

	        this.name = "PCF8591";
	        this.isReady = true;

	        this.emit("connect");
	        this.emit("ready");
	      }
	    },
	    normalize: {
	      value: function(pin) {
	        if (typeof pin === "string" && pin[0] === "A") {
	          return +pin.slice(1);
	        }
	        return pin;
	      }
	    },
	    pinMode: {
	      value: function(pin, mode) {
	        this.pins[pin].mode = mode;
	      }
	    },
	    analogRead: {
	      value: function(pin, callback) {
	        var state = priv.get(this);
	        var pinIndex = pin;

	        this.pins[pinIndex].report = 1;

	        this.on("analog-read-" + pin, callback);

	        // Since this operation will read all 4 pins,
	        // it only needs to be initiated once.
	        if (!state.reading) {
	          state.reading = true;

	          this.io.i2cRead(this.address, 4, function(data) {
	            var value;
	            for (var i = 0; i < 4; i++) {
	              value = data[i] << 2;
	              this.pins[i].value = value;

	              if (this.pins[i].report) {
	                this.emit("analog-read-" + pin, value);
	              }
	            }
	          }.bind(this));
	        }
	      }
	    },
	  },
	};

	Controllers.PCF8574A = Object.assign({}, Controllers.PCF8574, {
	  REGISTER: {
	    value: {
	      ADDRESS: 0x38,
	    }
	  },
	});

	var methods = Object.keys(Board.prototype);

	Object.keys(Controllers).forEach(function(name) {
	  methods.forEach(function(key) {
	    if (Controllers[name][key] === undefined) {
	      Controllers[name][key] = {
	        writable: true,
	        configurable: true,
	        value: function() {
	          throw new Error("Expander:" + name + " does not support " + key);
	        }
	      };
	    }
	  });
	});

	function Expander(opts) {
	  if (!(this instanceof Expander)) {
	    return new Expander(opts);
	  }

	  Base.call(this);

	  var controller = null;
	  var state = {};
	  var controllerValue;

	  if (typeof opts === "string") {
	    controllerValue = opts;
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts), { normalizePin: false }
	  );

	  if (typeof opts.controller === "undefined" && controllerValue) {
	    opts.controller = controllerValue;
	  }

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    throw new Error("Expander expects a valid controller");
	  }

	  Board.Controller.call(this, controller, opts);

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts);
	  }

	  used.set(this.address, this);
	}

	util.inherits(Expander, Base);

	Expander.Active = {

	  has: function(filter) {
	    var byAddress = filter.address !== undefined;
	    var byController = filter.controller !== undefined;

	    if (byAddress && byController) {
	      // If the address is in use, then the controller doesn't matter.
	      if (this.byAddress(filter.address)) {
	        return true;
	      }

	      if (this.byController(filter.controller)) {
	        return true;
	      }
	    } else {
	      if (byAddress) {
	        return Boolean(this.byAddress(filter.address));
	      }

	      if (byController) {
	        return Boolean(this.byController(filter.controller));
	      }
	    }

	    return false;
	  },

	  byAddress: function(address) {
	    return used.get(address);
	  },

	  byController: function(name) {
	    var controller;

	    used.forEach(function(value) {
	      if (value.name === name.toUpperCase()) {
	        controller = value;
	      }
	    });
	    return controller;
	  }
	};

	if (IS_TEST_MODE) {
	  Expander.purge = function() {
	    priv.clear();
	    used.clear();
	  };
	}

	module.exports = Expander;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var Servo = __webpack_require__(144),
	  __ = __webpack_require__(115);

	/**
	 * Gripper
	 *
	 * Supports:
	 *   [Parallax Boe-Bot gripper](http://www.parallax.com/Portals/0/Downloads/docs/prod/acc/GripperManual-v3.0.pdf)
	 *
	 *   [DFRobot LG-NS](http://www.dfrobot.com/index.php?route=product/product&filter_name=gripper&product_id=628#.UCvGymNST_k)
	 *
	 *
	 * @param {[type]} servo [description]
	 */

	function Gripper(opts) {

	  if (!(this instanceof Gripper)) {
	    return new Gripper(opts);
	  }

	  // Default options mode, assume only when opts is a pin number
	  if (typeof opts === "number") {
	    opts = {
	      servo: {
	        pin: opts,
	        range: [0, 180]
	      },
	      scale: [0, 10]
	    };
	  }

	  // Default set() args to 0-10
	  this.scale = opts.scale || [0, 10];

	  // Setup servo
	  // Allows pre-constructed servo or creating new servo.
	  // Defaults for new Servo creation fall back to Servo defaults
	  this.servo = opts.servo instanceof Servo ?
	    opts.servo : new Servo(opts.servo);
	}

	[
	  /**
	   * open Open the gripper
	   *
	   * @return {Object} this
	   */
	  {
	    name: "open",
	    args: function() {
	      return this.servo.range[0];
	    }
	  },
	  /**
	   * close Close the gripper
	   *
	   * @return {Object} this
	   */
	  {
	    name: "close",
	    args: function() {
	      return this.servo.range[1];
	    }
	  },
	  /**
	   * set Set the gripper's open width
	   *
	   * @param  {Number} 0-10, 0 is closed, 10 is open
	   *
	   * @return {Object} this
	   */
	  {
	    name: "set",
	    args: function(position) {
	      // Map/Scale position value to a value within
	      // the servo's lo/hi range
	      return Math.floor(
	        __.map(
	          position,
	          this.scale[0], this.scale[1],
	          this.servo.range[1], this.servo.range[0]
	        )
	      );
	    }
	  }
	].forEach(function(api) {
	  Gripper.prototype[api.name] = function() {
	    return this.servo.to(
	      api.args.apply(this, [].slice.call(arguments))
	    );
	  };
	});

	module.exports = Gripper;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var Pins = Board.Pins;
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var Collection = __webpack_require__(114);
	var __ = __webpack_require__(115);
	var nanosleep = __webpack_require__(141).nano;
	var Animation = __webpack_require__(129);

	// Servo instance private data
	var priv = new Map();

	var Controllers = {
	  PCA9685: {
	    REGISTER: {
	      value: {
	        PCA9685_MODE1: 0x0,
	        PCA9685_PRESCALE: 0xFE,
	        LED0_ON_L: 0x6
	      }
	    },
	    servoWrite: {
	      value: function(pin, degrees) {

	        var on, off;

	        // If same degrees return immediately.
	        if (this.last && this.last.degrees === degrees) {
	          return this;
	        }

	        on = 0;
	        off = __.map(degrees, 0, 180, this.pwmRange[0]/4, this.pwmRange[1]/4 );

	        this.io.i2cWrite(this.address, [this.REGISTER.LED0_ON_L + 4 * pin, on, on >> 8, off, off >> 8]);

	      }
	    },
	    initialize: {
	      /*

	        TODO:

	        Refactor this initialization as an abstract controller


	       */

	      value: function(opts) {
	        this.address = opts.address || 0x40;
	        this.pwmRange = opts.pwmRange || [544, 2400];

	        if (!this.board.Drivers[this.address]) {
	          this.io.i2cConfig(opts);
	          this.board.Drivers[this.address] = {
	            initialized: false
	          };

	          // Reset
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0x00);
	          // Sleep
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0x10);
	          // Set prescalar
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_PRESCALE, 0x70);
	          // Wake up
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0x00);
	          // Wait 5 nanoseconds for restart
	          nanosleep(5);
	          // Auto-increment
	          this.io.i2cWriteReg(this.address, this.REGISTER.PCA9685_MODE1, 0xa1);

	          this.board.Drivers[this.address].initialized = true;
	        }
	      }
	    }
	  },
	  Standard: {
	    initialize: {
	      value: function(opts) {

	        // When in debug mode, if pin is not a PWM pin, emit an error
	        if (opts.debug && !this.board.pins.isServo(this.pin)) {
	          Board.Pins.Error({
	            pin: this.pin,
	            type: "PWM",
	            via: "Servo",
	          });
	        }

	        if (Array.isArray(opts.pwmRange)) {
	          this.io.servoConfig(this.pin, opts.pwmRange[0], opts.pwmRange[1]);
	        } else {
	          this.io.pinMode(this.pin, this.mode);
	        }
	      }
	    },
	    servoWrite: {
	      value: function(pin, degrees) {
	        // Servo is restricted to integers
	        degrees |= 0;

	        // If same degrees return immediately.
	        if (this.last && this.last.degrees === degrees) {
	          return this;
	        }

	        this.io.servoWrite(this.pin, degrees);
	      }
	    }
	  }
	};

	/**
	 * Servo
	 * @constructor
	 *
	 * @param {Object} opts Options: pin, type, id, range
	 */

	function Servo(opts) {
	  var history = [];
	  var pinValue;
	  var controller;

	  if (!(this instanceof Servo)) {
	    return new Servo(opts);
	  }

	  pinValue = typeof opts === "object" ? opts.pin : opts;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  this.range = opts.range || [0, 180];
	  this.deadband = opts.deadband || [90, 90];
	  this.fps = opts.fps || 100;
	  this.offset = opts.offset || 0;
	  this.mode = this.io.MODES.SERVO;
	  this.interval = null;
	  this.value = null;

	  // StandardFirmata on Arduino allows controlling
	  // servos from analog pins.
	  // If we're currently operating with an Arduino
	  // and the user has provided an analog pin name
	  // (eg. "A0", "A5" etc.), parse out the numeric
	  // value and capture the fully qualified analog
	  // pin number.
	  if (typeof opts.controller === "undefined" && Pins.isFirmata(this)) {
	    if (typeof pinValue === "string" && pinValue[0] === "A") {
	      pinValue = this.io.analogPins[+pinValue.slice(1)];
	    }

	    pinValue = +pinValue;

	    // If the board's default pin normalization
	    // came up with something different, use the
	    // the local value.
	    if (!Number.isNaN(pinValue) && this.pin !== pinValue) {
	      this.pin = pinValue;
	    }
	  }


	  // The type of servo determines certain alternate
	  // behaviours in the API
	  this.type = opts.type || "standard";

	  // Invert the value of all servoWrite operations
	  // eg. 80 => 100, 90 => 90, 0 => 180
	  if (opts.isInverted) {
	    console.warn("The 'isInverted' property has been renamed 'invert'");
	  }
	  this.invert = opts.isInverted || opts.invert || false;

	  // Specification config
	  this.specs = opts.specs || {
	    speed: Servo.Continuous.speeds["@5.0V"]
	  };

	  // Allow "setup"instructions to come from
	  // constructor options properties
	  this.startAt = 90;

	  // Collect all movement history for this servo
	  // history = [
	  //   {
	  //     timestamp: Date.now(),
	  //     degrees: degrees
	  //   }
	  // ];

	  priv.set(this, {
	    history: history
	  });


	  /**
	   * Used for adding special controllers (i.e. PCA9685)
	   **/
	  controller = typeof opts.controller === "string" ?
	    Controllers[opts.controller] : Controllers.Standard;

	  Object.defineProperties(this, Object.assign({}, controller, {
	    history: {
	      get: function() {
	        return history.slice(-5);
	      }
	    },
	    last: {
	      get: function() {
	        return history[history.length - 1];
	      }
	    },
	    position: {
	      get: function() {
	        return history[history.length - 1].degrees;
	      }
	    }
	  }));

	  this.initialize(opts);


	  // If "startAt" is defined and center is falsy
	  // set servo to min or max degrees
	  if (opts.startAt !== undefined) {
	    this.startAt = opts.startAt;

	    if (!opts.center) {
	      this.to(opts.startAt);
	    }
	  }

	  // If "center" true set servo to 90deg
	  if (opts.center) {
	    this.center();
	  }
	}

	util.inherits(Servo, Emitter);


	/**
	 * to
	 *
	 * Set the servo horn's position to given degree over time.
	 *
	 * @param  {Number} degrees   Degrees to turn servo to.
	 * @param  {Number} time      Time to spend in motion.
	 * @param  {Number} rate      The rate of the motion transiton
	 *
	 * - or -
	 *
	 * @param {Object} an Animation() segment config object
	 *
	 * @return {Servo} instance
	 */

	Servo.prototype.to = function(degrees, time, rate) {

	  var options = {};
	  var state = priv.get(this);

	  if (typeof degrees === "object") {

	    options = {
	      duration: 1000,
	      cuePoints: [0, 1.0],
	      keyFrames: [null, {degrees: typeof degrees.degrees === "number" ? degrees.degrees : this.startAt}],
	      oncomplete: function() {
	        this.stop();
	        process.nextTick(this.emit.bind(this, "move:complete"));
	      }.bind(this)
	    };

	    __.extend(options, degrees);

	    state.isRunning = true;

	    state.animation = state.animation || new Animation(this);
	    state.animation.enqueue(options);

	  } else {

	    var target = degrees;

	    // Enforce limited range of motion
	    degrees = Board.constrain(degrees, this.range[0], this.range[1]);

	    degrees += this.offset;
	    this.value = degrees;

	    if (this.invert) {
	      degrees = Board.map(
	        degrees,
	        0, 180,
	        180, 0
	      );
	    }

	    if (typeof time !== "undefined") {

	      options = {
	        duration: time,
	        keyFrames: [null, {degrees: degrees}],
	        fps: rate || this.fps
	      };

	      this.to(options);

	    } else {
	      this.servoWrite(this.pin, degrees);
	      state.history.push({
	        timestamp: Date.now(),
	        degrees: degrees,
	        target: target
	      });
	    }
	  }

	  // return this instance
	  return this;
	};


	/**
	 * Animation.normalize
	 *
	 * @param [number || object] keyFrames An array of step values or a keyFrame objects
	 */

	Servo.prototype[Animation.normalize] = function(keyFrames) {

	  var last = this.last ? this.last.target : this.startAt;

	  // If user passes null as the first element in keyFrames use current position
	  if (keyFrames[0] === null) {
	    keyFrames[0] = {
	      value: last
	    };
	  }

	  // There are a couple of properties that are device type sepcific
	  // that we need to convert to something generic
	  keyFrames.forEach(function(keyFrame) {
	    if (typeof keyFrame.degrees !== "undefined") {
	      keyFrame.value = keyFrame.degrees;
	    }
	    if (typeof keyFrame.copyDegrees !== "undefined") {
	      keyFrame.copyValue = keyFrame.copyDegrees;
	    }
	  });

	  return keyFrames;

	};

	/**
	 * Animation.render
	 *
	 * @position [number] value to set the servo to
	 */

	Servo.prototype[Animation.render] = function(position) {
	  return this.to(position[0]);
	};

	/**
	 * step
	 *
	 * Update the servo horn's position by specified degrees (over time)
	 *
	 * @param  {Number} degrees   Degrees to turn servo to.
	 * @param  {Number} time      Time to spend in motion.
	 *
	 * @return {Servo} instance
	 */

	Servo.prototype.step = function(degrees, time) {
	  return this.to(this.last.target + degrees, time);
	};

	/**
	 * move Alias for Servo.prototype.to
	 */
	Servo.prototype.move = function(degrees, time) {
	  console.warn("Servo.prototype.move has been renamed to Servo.prototype.to");

	  return this.to(degrees, time);
	};

	/**
	 * min Set Servo to minimum degrees, defaults to 0deg
	 * @param  {Number} time      Time to spend in motion.
	 * @param  {Number} rate      The rate of the motion transiton
	 * @return {Object} instance
	 */

	Servo.prototype.min = function(time, rate) {
	  return this.to(this.range[0], time, rate);
	};

	/**
	 * max Set Servo to maximum degrees, defaults to 180deg
	 * @param  {Number} time      Time to spend in motion.
	 * @param  {Number} rate      The rate of the motion transiton
	 * @return {[type]} [description]
	 */
	Servo.prototype.max = function(time, rate) {
	  return this.to(this.range[1], time, rate);
	};

	/**
	 * center Set Servo to centerpoint, defaults to 90deg
	 * @param  {Number} time      Time to spend in motion.
	 * @param  {Number} rate      The rate of the motion transiton
	 * @return {[type]} [description]
	 */
	Servo.prototype.center = function(time, rate) {
	  return this.to(Math.abs((this.range[0] + this.range[1]) / 2), time, rate);
	};

	/**
	 * sweep Sweep the servo between min and max or provided range
	 * @param  {Array} range constrain sweep to range
	 *
	 * @param {Object} options Set range or interval.
	 *
	 * @return {[type]} [description]
	 */
	Servo.prototype.sweep = function(opts) {

	  var options = {
	    keyFrames: [{degrees: this.range[0]}, {degrees: this.range[1]}],
	    metronomic: true,
	    loop: true,
	    easing: "inOutSine"
	  };

	  // If opts is an array, then assume a range was passed
	  if (Array.isArray(opts)) {
	    options.keyframes = opts;
	  } else {
	    // Otherwise, opts is an object.
	    __.extend(options, opts);
	  }

	  this.to(options);

	  return this;
	};

	/**
	 * stop Stop a moving servo
	 * @return {[type]} [description]
	 */
	Servo.prototype.stop = function() {

	  var state = priv.get(this);

	  if (state.animation) {
	    state.animation.stop();
	  }

	  if (this.type === "continuous") {
	    this.to(90);
	  } else {
	    clearInterval(this.interval);
	  }

	  return this;
	};

	//
	["clockWise", "cw", "counterClockwise", "ccw"].forEach(function(api) {
	  Servo.prototype[api] = function(rate) {
	    var range;
	    rate = rate === undefined ? 1 : rate;
	    if (this.type !== "continuous") {
	      this.board.error(
	        "Servo",
	        "Servo.prototype." + api + " is only available for continuous servos"
	      );
	    }
	    if (api === "cw" || api === "clockWise") {
	      range = [rate, 0, 1, this.deadband[1] + 1, this.range[1]];
	    } else {
	      range = [rate, 0, 1, this.deadband[0] - 1, this.range[0]];
	    }
	    return this.to(__.scale.apply(null, range) | 0);
	  };
	});


	/**
	 *
	 * Static API
	 *
	 *
	 */

	Servo.Continuous = function(pinOrOpts) {
	  var opts = {};

	  if (typeof pinOrOpts === "object") {
	    __.extend(opts, pinOrOpts);
	  } else {
	    opts.pin = pinOrOpts;
	  }

	  opts.type = "continuous";
	  return new Servo(opts);
	};

	Servo.Continuous.speeds = {
	  // seconds to travel 60 degrees
	  "@4.8V": 0.23,
	  "@5.0V": 0.17,
	  "@6.0V": 0.18
	};

	/**
	 * Servos()
	 * new Servos()
	 *
	 * Constructs an Array-like instance of all servos
	 */
	function Servos(numsOrObjects) {
	  if (!(this instanceof Servos)) {
	    return new Servos(numsOrObjects);
	  }

	  Object.defineProperty(this, "type", {
	    value: Servo
	  });

	  Collection.call(this, numsOrObjects);
	}

	Servos.prototype = Object.create(Collection.prototype, {
	  constructor: {
	    value: Servos
	  }
	});


	/*
	 * Servos, center()
	 *
	 * centers all servos to 90deg
	 *
	 * eg. array.center();

	 * Servos, min()
	 *
	 * set all servos to the minimum degrees
	 * defaults to 0
	 *
	 * eg. array.min();

	 * Servos, max()
	 *
	 * set all servos to the maximum degrees
	 * defaults to 180
	 *
	 * eg. array.max();

	 * Servos, stop()
	 *
	 * stop all servos
	 *
	 * eg. array.stop();
	 */

	Object.keys(Servo.prototype).forEach(function(method) {
	  // Create Servos wrappers for each method listed.
	  // This will allow us control over all Servo instances
	  // simultaneously.
	  Servos.prototype[method] = function() {
	    var length = this.length;

	    for (var i = 0; i < length; i++) {
	      this[i][method].apply(this[i], arguments);
	    }
	    return this;
	  };
	});

	/**
	 * Animation.normalize
	 *
	 * @param [number || object] keyFrames An array of step values or a keyFrame objects
	 */

	Servos.prototype[Animation.normalize] = function(keyFrameSet) {

	  keyFrameSet.forEach(function(keyFrames, index) {

	    if (keyFrames !== null) {
	      var servo = this[index];

	      // If servo is a servoArray then user servo[0] for default values
	      if (servo instanceof Servos) {
	        servo = servo[0];
	      }

	      var last = servo.last ? servo.last.target : servo.startAt;

	      // If the first keyFrameSet is null use the current position
	      if (keyFrames[0] === null) {
	        keyFrames[0] = {
	          value: last
	        };
	      }

	      if (Array.isArray(keyFrames)) {
	        if (keyFrames[0] === null) {
	          keyFrameSet[index][0] = {
	            value: last
	          };
	        }
	      }

	      keyFrames.forEach(function(keyFrame) {
	        if (keyFrame != null && typeof keyFrame.degrees !== "undefined") {
	          keyFrame.value = keyFrame.degrees;
	        }
	        if (keyFrame != null && typeof keyFrame.copyDegrees !== "undefined") {
	          keyFrame.copyValue = keyFrame.copyDegrees;
	        }
	      });

	    }

	  }, this);

	  return keyFrameSet;

	};

	/**
	 * Animation.render
	 *
	 * @position [number] array of values to set the servos to
	 */

	Servos.prototype[Animation.render] = function(position) {
	  this.each(function(servo, i) {
	    servo.to(position[i]);
	  });
	  return this;
	};


	// Alias
	// TODO: Deprecate and REMOVE
	Servo.prototype.write = Servo.prototype.move;

	if (IS_TEST_MODE) {
	  Servo.purge = function() {
	    priv.clear();
	  };
	}

	// Assign Servos Collection class as static "method" of Servo.
	Servo.Array = Servos;

	module.exports = Servo;



	// References
	//
	// http://www.societyofrobots.com/actuators_servos.shtml
	// http://www.parallax.com/Portals/0/Downloads/docs/prod/motors/900-00008-CRServo-v2.2.pdf
	// http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM
	// http://servocity.com/html/hs-7980th_servo.html
	// http://mbed.org/cookbook/Servo

	// Further API info:
	// http://www.tinkerforge.com/doc/Software/Bricks/Servo_Brick_Python.html#servo-brick-python-api
	// http://www.tinkerforge.com/doc/Software/Bricks/Servo_Brick_Java.html#servo-brick-java-api

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12);

	var priv = new Map(),
	  Devices;

	Devices = {
	  /**
	   * Sharp GP2Y0D805Z0F IR Sensor
	   * 020, 022, 024, 026
	   *
	   * http://osepp.com/products/sensors-arduino-compatible/osepp-ir-proximity-sensor-module/
	   *
	   *
	   * http://sharp-world.com/products/device/lineup/data/pdf/datasheet/gp2y0d805z_e.pdf
	   *
	   */

	  /* @deprecated */
	  "GP2Y0D805Z0F": {
	    type: "proximity",
	    address: 0x26,
	    bytes: 1,
	    delay: 250,

	    // read request data handler
	    data: function(read, data) {
	      var state = priv.get(this).state,
	        value = data[0],
	        timestamp = new Date(),
	        err = null;

	      if (value !== state && value === 1) {
	        this.emit("motionstart", err, timestamp);
	      }

	      if (state === 1 && value === 3) {
	        this.emit("motionend", err, timestamp);
	      }

	      priv.set(this, {
	        state: value
	      });
	    },

	    // These are added to the property descriptors defined
	    // within the constructor
	    descriptor: {
	      value: {
	        get: function() {
	          return priv.get(this).state;
	        }
	      }
	    },
	    setup: [
	      // CRA
	      [0x3, 0xFE]
	    ],
	    preread: [
	      [0x0]
	    ]
	  },

	  "QRE1113GR": {
	    // http://www.pololu.com/file/0J117/QRE1113GR.pdf
	    type: "reflect",
	    address: 0x4B,
	    bytes: 2,
	    delay: 100,

	    // read request data handler
	    data: function(data) {
	      var temp = {
	        left: data[0],
	        right: data[1]
	      };

	      // if ( temp.left < 200 ) {
	      //   this.emit( "left", err, timestamp );
	      // }

	      // if ( temp.right < 200 ) {
	      //   this.emit( "right", err, timestamp );
	      // }


	      priv.set(this, temp);
	    },

	    descriptor: {
	      left: {
	        get: function() {
	          return priv.get(this).left;
	        }
	      },
	      right: {
	        get: function() {
	          return priv.get(this).right;
	        }
	      }
	    },

	    setup: [
	      // Reset the ADC (analog-to-digital converter)
	      // NXP PCA969
	      [0x0, 0x0]
	    ],
	    preread: [
	      // left, right
	      [0x0, 0x1]
	    ]
	  }
	};



	function IR(opts) {

	  if (!(this instanceof IR)) {
	    return new IR(opts);
	  }

	  var address, bytes, data, device, delay, descriptor,
	    preread, setup;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  device = Devices[opts.device];

	  address = opts.address || device.address;
	  bytes = device.bytes;
	  data = device.data;
	  delay = device.delay;
	  setup = device.setup;
	  descriptor = device.descriptor;
	  preread = device.preread;

	  // Read event throttling
	  this.freq = opts.freq || 500;

	  // Make private data entry
	  priv.set(this, {
	    state: 0
	  });

	  // Set up I2C data connection
	  this.io.i2cConfig(opts);

	  // Enumerate and write each set of setup instructions
	  setup.forEach(function(byteArray) {
	    this.io.i2cWrite(address, byteArray);
	  }, this);

	  // Read Request Loop
	  setInterval(function() {
	    // Set pointer to X most signficant byte/register
	    this.io.i2cWrite(address, preread);

	    // Read from register
	    this.io.i2cReadOnce(address, bytes, data.bind(this));

	  }.bind(this), delay);

	  // Continuously throttled "read" event
	  setInterval(function() {
	    // @DEPRECATE
	    this.emit("read");
	    // The "read" event has been deprecated in
	    // favor of a "data" event.
	    this.emit("data");
	  }.bind(this), this.freq);

	  if (descriptor) {
	    Object.defineProperties(this, descriptor);
	  }
	}

	util.inherits(IR, events.EventEmitter);

	module.exports = IR;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var Board = __webpack_require__(103);
	var __ = __webpack_require__(115);
	var int16 = __.int16;

	var priv = new Map();

	var aliases = {
	  down: ["down", "press", "tap", "impact", "hit"],
	  up: ["up", "release"],
	  hold: ["hold"]
	};

	var trigger = function(key, value) {
	  var event = { which: value, timestamp: Date.now() };
	  aliases[key].forEach(function(type) {
	    this.emit(type, event);
	  }, this);
	};


	function flatKeys(opts) {
	  var keys = [];

	  if (opts.keys && Array.isArray(opts.keys)) {
	    keys = opts.keys.slice();

	    if (keys.every(Array.isArray)) {
	      keys = keys.reduce(function(accum, row) {
	        return accum.concat(row);
	      }, []);
	    }
	  }

	  return keys;
	}

	// TODO:
	//
	// Provide a mechanism for explicitly naming aliases for buttons
	//
	//
	var Controllers = {
	  MPR121QR2: {
	    REGISTER: {
	      value: __webpack_require__(147)
	    },
	    initialize: {
	      value: function(opts, dataHandler) {

	        var state = priv.get(this);
	        var address = opts.address || 0x5A;
	        var keys = flatKeys(opts);
	        var keyMap = this.REGISTER.MAPS[opts.controller].KEYS;
	        var targets = this.REGISTER.MAPS[opts.controller].TARGETS;
	        var mapping = Object.keys(keyMap).reduce(function(accum, index) {
	          accum[index] = keyMap[index];
	          return accum;
	        }, []);

	        var length = mapping.length;

	        this.io.i2cConfig(opts);

	        this.io.i2cWrite(address, this.REGISTER.MHD_RISING, 0x01);
	        this.io.i2cWrite(address, this.REGISTER.NHD_AMOUNT_RISING, 0x01);
	        this.io.i2cWrite(address, this.REGISTER.NCL_RISING, 0x00);
	        this.io.i2cWrite(address, this.REGISTER.FDL_RISING, 0x00);

	        this.io.i2cWrite(address, this.REGISTER.MHD_FALLING, 0x01);
	        this.io.i2cWrite(address, this.REGISTER.NHD_AMOUNT_FALLING, 0x01);
	        this.io.i2cWrite(address, this.REGISTER.NCL_FALLING, 0xFF);
	        this.io.i2cWrite(address, this.REGISTER.FDL_FALLING, 0x02);

	        for (var i = 0; i < 12; i++) {
	          this.io.i2cWrite(address, this.REGISTER.ELE0_TOUCH_THRESHOLD + (i << 1), 40);
	          this.io.i2cWrite(address, this.REGISTER.ELE0_RELEASE_THRESHOLD + (i << 1), 20);
	        }

	        this.io.i2cWrite(address, this.REGISTER.FILTER_CONFIG, 0x04);
	        this.io.i2cWrite(address, this.REGISTER.ELECTRODE_CONFIG, 0x0C);


	        if (!keys.length) {
	          keys = Array.from(Object.assign({}, keyMap, {length: length}));
	        }

	        state.length = length;
	        state.touches = touches(length);
	        state.keys = keys;
	        state.mapping = mapping;
	        state.targets = targets;

	        this.io.i2cRead(address, 0x00, 2, function(bytes) {
	          dataHandler(int16(bytes[1], bytes[0]));
	        });
	      }
	    },
	    toAlias: {
	      value: function(index) {
	        var state = priv.get(this);
	        return state.keys[index];
	      }
	    },
	    toIndex: {
	      value: function(raw) {
	        var state = priv.get(this);
	        // console.log("raw", raw, state.targets[raw]);
	        return state.targets[raw];
	      }
	    }
	  },

	  // https://learn.sparkfun.com/tutorials/vkey-voltage-keypad-hookup-guide
	  VKEY: {
	    initialize: {
	      value: function(opts, dataHandler) {

	        var state = priv.get(this);
	        var keys = flatKeys(opts);
	        var mapping = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ];
	        var length = 0;

	        if (!keys.length) {
	          keys = mapping;
	        }

	        length = mapping.length;

	        state.length = length;
	        state.scale = { bottom: 17, step: 40, top: 496 };
	        state.touches = touches(length);
	        state.mapping = mapping;
	        state.keys = keys;

	        this.io.pinMode(this.pin, this.io.MODES.ANALOG);
	        this.io.analogRead(this.pin, function(adc) {
	          dataHandler(adc);
	        }.bind(this));
	      },
	    },
	    toAlias: {
	      value: function(index) {
	        var state = priv.get(this);
	        return state.keys[index];
	      }
	    },
	    toIndex: {
	      value: function(raw) {
	        var state = priv.get(this);
	        var scale = state.scale;
	        var length = state.length;

	        if (raw < scale.bottom || raw > scale.top) {
	          return null;
	        }

	        return (length - ((raw - scale.bottom) / scale.step)) | 0;
	      }
	    }
	  },

	  // WaveShare AD
	  //  - http://www.amazon.com/WaveShare-Accessory-buttons-controlled-keyboard/dp/B00KM6UXVS
	  //  - http://www.wvshare.com/product/A_D-Keypad.htm
	  //
	  //  TODO: Create docs to show how to create a DIY keypad
	  //        that works with this class.
	  //
	  ANALOG: {
	    initialize: {
	      value: function(opts, dataHandler) {

	        var keys = flatKeys(opts);
	        var mapping = [];
	        var length = 0;

	        if (opts.length && !keys.length) {
	          keys = Array.from({ length: opts.length }, function(_, key) {
	            return key;
	          });
	        }

	        if (!keys.length) {
	          throw new Error(
	            "Missing `keys`. Analog Keypad requires either a numeric `length` or a `keys` array."
	          );
	        }

	        mapping = keys;
	        length = mapping.length;

	        var state = priv.get(this);
	        // keys + Idle state == length + 1
	        var total = length + 1;
	        var vrange = Math.round(1023 / total);
	        var ranges = Array.from({ length: total }, function(_, index) {
	          var start = vrange * index;
	          return Array.from({ length: vrange - 1 }, function(_, index) {
	            return start + index;
	          });
	        });

	        state.length = length;
	        state.ranges = ranges;
	        state.touches = touches(length);
	        state.mapping = mapping;
	        state.keys = keys;

	        this.io.pinMode(this.pin, this.io.MODES.ANALOG);
	        this.io.analogRead(this.pin, function(adc) {
	          dataHandler(adc);
	        });
	      }
	    },
	    toAlias: {
	      value: function(index) {
	        var state = priv.get(this);
	        return state.keys[index];
	      }
	    },
	    toIndex: {
	      value: function(raw) {
	        var state = priv.get(this);
	        var ranges = state.ranges;
	        var index = ranges.findIndex(function(range) {
	          return range.includes(raw);
	        });

	        if (index === state.length) {
	          index--;
	        }

	        if (index < 0) {
	          return null;
	        }

	        return index;
	      }
	    }
	  }
	};


	// Otherwise known as...
	Controllers["MPR121"] = Controllers.MPR121QR2;

	function touches(length) {
	  return Array.from({ length: length }, function() {
	    return 0;
	  });
	}

	function Keypad(opts) {

	  if (!(this instanceof Keypad)) {
	    return new Keypad(opts);
	  }

	  // Initialize a Device instance on a Board
	  Board.Device.call(
	    this, opts = Board.Options(opts)
	  );

	  var raw = null;
	  var controller = null;
	  var state = {
	    touches: null,
	    timeout: null,
	    length: null,
	    keys: null,
	    mapping: null,
	    holdtime: null,
	  };



	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers.ANALOG;
	  }

	  Board.Controller.call(this, controller, opts);

	  state.holdtime = opts.holdtime ? opts.holdtime : 500;

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      var target = this.toIndex(data);
	      var length = state.length;
	      var alias = null;

	      raw = data;

	      for (var i = 0; i < length; i++) {
	        alias = this.toAlias(i);

	        if (target === i) {
	          if (state.touches[i] === 0) {

	            state.timeout = Date.now() + state.holdtime;
	            trigger.call(this, "down", alias);

	          } else if (state.touches[i] === 1) {
	            if (state.timeout !== null && Date.now() > state.timeout) {
	              state.timeout = Date.now() + state.holdtime;
	              trigger.call(this, "hold", alias);
	            }
	          }

	          state.touches[i] = 1;
	        } else {
	          if (state.touches[i] === 1) {
	            state.timeout = null;
	            trigger.call(this, "up", alias);
	          }

	          state.touches[i] = 0;
	        }
	        alias = null;
	      }
	    }.bind(this));
	  }

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return raw;
	      }
	    },
	    target: {
	      get: function() {
	        return state.keys[this.toIndex(this.value)];
	      }
	    }
	  });
	}

	util.inherits(Keypad, Emitter);

	module.exports = Keypad;


/***/ },
/* 147 */
/***/ function(module, exports) {

	// MPR121* Register Defines
	module.exports = {
	  MAPS: {
	    MPR121QR2:   {
	      KEYS: {
	        0: 1,
	        1: 2,
	        2: 3,
	        3: 4,
	        4: 5,
	        5: 6,
	        6: 7,
	        7: 8,
	        8: 9,
	      },
	      TARGETS: {
	        256: 0,
	        32: 1,
	        4: 2,
	        128: 3,
	        16: 4,
	        2: 5,
	        64: 6,
	        8: 7,
	        1: 8,
	      }
	    },
	    // MPR121:   {
	    //   3: 1,
	    //   7: 2,
	    //   11: 3,
	    //   2: 4,
	    //   6: 5,
	    //   10: 6,
	    //   1: 7,
	    //   5: 8,
	    //   9: 9,
	    //   0: 10,
	    //   4: 11,
	    //   8: 12,
	    // },
	    MPR121:   {
	      KEYS: {
	        0: 1,
	        1: 2,
	        2: 3,
	        3: 4,
	        4: 5,
	        5: 6,
	        6: 7,
	        7: 8,
	        8: 9,
	        9: 10,
	        10: 11,
	        11: 12,
	      },
	      TARGETS: {
	        8: 0,
	        128: 1,
	        2048: 2,
	        4: 3,
	        64: 4,
	        1024 : 5,
	        2: 6,
	        32: 7,
	        512: 8,
	        1: 9,
	        16: 10,
	        256: 11,
	      }
	    },
	  },
	  MPR121_DEFAULT_ADDRESS: 0x5A,

	  // MPR121 Registers (from data sheet)
	  ELE0_ELE7_TOUCH_STATUS: 0x00,
	  ELE8_ELE11_ELEPROX_TOUCH_STATUS: 0x01,

	  ELE0_7_OOR_STATUS: 0x02,
	  ELE8_11_ELEPROX_OOR_STATUS: 0x03,

	  ELE0_FILTERED_DATA_LSB: 0x04,
	  ELE0_FILTERED_DATA_MSB: 0x05,
	  ELE1_FILTERED_DATA_LSB: 0x06,
	  ELE1_FILTERED_DATA_MSB: 0x07,
	  ELE2_FILTERED_DATA_LSB: 0x08,
	  ELE2_FILTERED_DATA_MSB: 0x09,
	  ELE3_FILTERED_DATA_LSB: 0x0A,
	  ELE3_FILTERED_DATA_MSB: 0x0B,
	  ELE4_FILTERED_DATA_LSB: 0x0C,
	  ELE4_FILTERED_DATA_MSB: 0x0D,
	  ELE5_FILTERED_DATA_LSB: 0x0E,
	  ELE5_FILTERED_DATA_MSB: 0x0F,
	  ELE6_FILTERED_DATA_LSB: 0x10,
	  ELE6_FILTERED_DATA_MSB: 0x11,
	  ELE7_FILTERED_DATA_LSB: 0x12,
	  ELE7_FILTERED_DATA_MSB: 0x13,
	  ELE8_FILTERED_DATA_LSB: 0x14,
	  ELE8_FILTERED_DATA_MSB: 0x15,
	  ELE9_FILTERED_DATA_LSB: 0x16,
	  ELE9_FILTERED_DATA_MSB: 0x17,
	  ELE10_FILTERED_DATA_LSB: 0x18,
	  ELE10_FILTERED_DATA_MSB: 0x19,
	  ELE11_FILTERED_DATA_LSB: 0x1A,
	  ELE11_FILTERED_DATA_MSB: 0x1B,
	  ELEPROX_FILTERED_DATA_LSB: 0x1C,
	  ELEPROX_FILTERED_DATA_MSB: 0x1D,

	  ELE0_BASELINE_VALUE: 0x1E,
	  ELE1_BASELINE_VALUE: 0x1F,
	  ELE2_BASELINE_VALUE: 0x20,
	  ELE3_BASELINE_VALUE: 0x21,
	  ELE4_BASELINE_VALUE: 0x22,
	  ELE5_BASELINE_VALUE: 0x23,
	  ELE6_BASELINE_VALUE: 0x24,
	  ELE7_BASELINE_VALUE: 0x25,
	  ELE8_BASELINE_VALUE: 0x26,
	  ELE9_BASELINE_VALUE: 0x27,
	  ELE10_BASELINE_VALUE: 0x28,
	  ELE11_BASELINE_VALUE: 0x29,
	  ELEPROX_BASELINE_VALUE: 0x2A,

	  MHD_RISING: 0x2B,
	  NHD_AMOUNT_RISING: 0x2C,
	  NCL_RISING: 0x2D,
	  FDL_RISING: 0x2E,
	  MHD_FALLING: 0x2F,
	  NHD_AMOUNT_FALLING: 0x30,
	  NCL_FALLING: 0x31,
	  FDL_FALLING: 0x32,
	  NHD_AMOUNT_TOUCHED: 0x33,
	  NCL_TOUCHED: 0x34,
	  FDL_TOUCHED: 0x35,
	  ELEPROX_MHD_RISING: 0x36,
	  ELEPROX_NHD_AMOUNT_RISING: 0x37,
	  ELEPROX_NCL_RISING: 0x38,
	  ELEPROX_FDL_RISING: 0x39,
	  ELEPROX_MHD_FALLING: 0x3A,
	  ELEPROX_NHD_AMOUNT_FALLING: 0x3B,
	  ELEPROX_FDL_FALLING: 0x3C,
	  ELEPROX_NHD_AMOUNT_TOUCHED: 0x3E,
	  ELEPROX_NCL_TOUCHED: 0x3F,
	  ELEPROX_FDL_TOUCHED: 0x40,

	  ELE0_TOUCH_THRESHOLD: 0x41,
	  ELE0_RELEASE_THRESHOLD: 0x42,
	  ELE1_TOUCH_THRESHOLD: 0x43,
	  ELE1_RELEASE_THRESHOLD: 0x44,
	  ELE2_TOUCH_THRESHOLD: 0x45,
	  ELE2_RELEASE_THRESHOLD: 0x46,
	  ELE3_TOUCH_THRESHOLD: 0x47,
	  ELE3_RELEASE_THRESHOLD: 0x48,
	  ELE4_TOUCH_THRESHOLD: 0x49,
	  ELE4_RELEASE_THRESHOLD: 0x4A,
	  ELE5_TOUCH_THRESHOLD: 0x4B,
	  ELE5_RELEASE_THRESHOLD: 0x4C,
	  ELE6_TOUCH_THRESHOLD: 0x4D,
	  ELE6_RELEASE_THRESHOLD: 0x4E,
	  ELE7_TOUCH_THRESHOLD: 0x4F,
	  ELE7_RELEASE_THRESHOLD: 0x50,
	  ELE8_TOUCH_THRESHOLD: 0x51,
	  ELE8_RELEASE_THRESHOLD: 0x52,
	  ELE9_TOUCH_THRESHOLD: 0x53,
	  ELE9_RELEASE_THRESHOLD: 0x54,
	  ELE10_TOUCH_THRESHOLD: 0x55,
	  ELE10_RELEASE_THRESHOLD: 0x56,
	  ELE11_TOUCH_THRESHOLD: 0x57,
	  ELE11_RELEASE_THRESHOLD: 0x58,
	  ELEPROX_TOUCH_THRESHOLD: 0x59,
	  ELEPROX_RELEASE_THRESHOLD: 0x5A,
	  DEBOUNCE_TOUCH_AND_RELEASE: 0x5B,
	  AFE_CONFIGURATION: 0x5C,

	  FILTER_CONFIG: 0x5D,
	  ELECTRODE_CONFIG: 0x5E,
	  ELE0_CURRENT: 0x5F,
	  ELE1_CURRENT: 0x60,
	  ELE2_CURRENT: 0x61,
	  ELE3_CURRENT: 0x62,
	  ELE4_CURRENT: 0x63,
	  ELE5_CURRENT: 0x64,
	  ELE6_CURRENT: 0x65,
	  ELE7_CURRENT: 0x66,
	  ELE8_CURRENT: 0x67,
	  ELE9_CURRENT: 0x68,
	  ELE10_CURRENT: 0x69,
	  ELE11_CURRENT: 0x6A,
	  ELEPROX_CURRENT: 0x6B,

	  ELE0_ELE1_CHARGE_TIME: 0x6C,
	  ELE2_ELE3_CHARGE_TIME: 0x6D,
	  ELE4_ELE5_CHARGE_TIME: 0x6E,
	  ELE6_ELE7_CHARGE_TIME: 0x6F,
	  ELE8_ELE9_CHARGE_TIME: 0x70,
	  ELE10_ELE11_CHARGE_TIME: 0x71,
	  ELEPROX_CHARGE_TIME: 0x72,

	  GPIO_CONTROL_0: 0x73,
	  GPIO_CONTROL_1: 0x74,
	  GPIO_DATA: 0x75,
	  GPIO_DIRECTION: 0x76,
	  GPIO_ENABLE: 0x77,
	  GPIO_SET: 0x78,
	  GPIO_CLEAR: 0x79,
	  GPIO_TOGGLE: 0x7A,
	  AUTO_CONFIG_CONTROL_0: 0x7B,
	  AUTO_CONFIG_CONTROL_1: 0x7C,
	  AUTO_CONFIG_USL: 0x7D,
	  AUTO_CONFIG_LSL: 0x7E,
	  AUTO_CONFIG_TARGET_LEVEL: 0x7F,

	  // Other Constants
	  // these are suggested values from app note 3944
	  TOUCH_THRESHOLD: 0x0F,
	  RELEASE_THRESHOLD: 0x0A,
	  NUM_CHANNELS: 12
	};


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Pin = __webpack_require__(149),
	  lcdCharacters = __webpack_require__(151),
	  converter = __webpack_require__(152)();

	var priv = new Map();

	/**
	 * This atrocitity is unfortunately necessary.
	 * If any other approach can be found, patches
	 * will gratefully be accepted.
	 */
	function sleep(ms) {
	  var start = Date.now();
	  while (Date.now() < start + ms) {}
	}


	// TODO:  Migrate this to the new codified Expander class.
	//
	// - add portMode to PCF8574 controller
	// - add portWrite to PCF8574 controller
	//
	//
	// TODO:  Investigate adding the above methods to
	//        all expander controllers.
	//
	function Expander(address, io) {
	  this.address = address;
	  this.mask = 0xFF;
	  this.shadow = 0x00;
	  this.io = io;
	}

	Expander.prototype.pinMode = function(pin, dir) {
	  if (dir === 0x01) {
	    this.mask &= ~(1 << pin);
	  } else {
	    this.mask |= 1 << pin;
	  }
	};

	Expander.prototype.portMode = function(dir) {
	  this.mask = dir === 0x00 ? 0xFF : 0x00;
	};

	Expander.prototype.write = function(value) {
	  this.shadow = value & ~(this.mask);
	  this.io.i2cWrite(this.address, this.shadow);
	};




	// const-caps throughout serve to indicate the
	// "const-ness" of the binding to the reader
	// and nothing more.

	var OPS = {
	  DEFAULT: {
	    SHIFT_LEFT: 0x04,

	    CLEAR: 0x01,
	    HOME: 0x02,
	    ENTRY: 0x04,
	    DISPLAY: 0x08,
	    DIMENSIONS: 0x20,
	    CURSORSHIFT: 0x10,

	    SETCGRAMADDR: 0x40,
	    SETDDRAMADDR: 0x80,

	    // Command And Control

	    DATA: 0x40,
	    COMMAND: 0x80,

	    // flags for display entry mode
	    ENTRYRIGHT: 0x00,
	    ENTRYLEFT: 0x02,
	    ENTRYSHIFTINCREMENT: 0x01,
	    ENTRYSHIFTDECREMENT: 0x00,

	    // flags for display on/off control
	    DISPLAYON: 0x04,
	    DISPLAYOFF: 0x00,
	    CURSORON: 0x02,
	    CURSOROFF: 0x00,
	    BLINKON: 0x01,
	    BLINKOFF: 0x00,

	    // flags for display/cursor shift
	    DISPLAYMOVE: 0x08,
	    CURSORMOVE: 0x00,
	    MOVERIGHT: 0x04,
	    MOVELEFT: 0x00,

	    // flags for function set
	    BITMODE: {
	      4: 0x00,
	      8: 0x10,
	    },

	    LINE: {
	      1: 0x00,
	      2: 0x08
	    },

	    DOTS: {
	      "5x10": 0x04,
	      "5x8": 0x00
	    },

	    // flags for backlight control
	    BACKLIGHT_ON: 0x08,
	    BACKLIGHT_OFF: 0x00,

	    MEMORYLIMIT: 0x08,

	    // Control
	    // Enable
	    EN: 0x04,
	    // Read/Write
	    RW: 0x02,
	    // Register Select
	    RS: 0x01,

	    // DATA
	    D4: 0x04,
	    D5: 0x05,
	    D6: 0x06,
	    D7: 0x07,
	  }
	};

	var Controllers = {
	  JHD1313M1: {
	    OP: {
	      value: OPS.DEFAULT,
	    },
	    CHARS: {
	      value: lcdCharacters.DEFAULT,
	    },
	    initialize: {
	      value: function(opts) {

	        this.io.i2cConfig(opts);

	        this.lines = opts.lines || 2;
	        this.rows = opts.rows || 2;
	        this.cols = opts.cols || 16;
	        this.dots = opts.dots || "5x8";

	        // LCD: 0x3E
	        // RGB: 0x62
	        this.address = {
	          lcd: opts.address || 0x3E,
	          rgb: 0x62
	        };

	        var display = this.OP.DISPLAY | this.OP.DISPLAYON | this.OP.CURSOROFF | this.OP.BLINKOFF;

	        var state = {
	          display: display,
	          characters: {},
	          index: this.OP.MEMORYLIMIT - 1,
	          backlight: {
	            polarity: 1,
	            pin: null,
	            value: null
	          }
	        };

	        priv.set(this, state);

	        // Operations within the following labelled block are init-only,
	        // but _do_ block the process negligible number of milliseconds.
	        blocking: {
	          var lines = this.OP.DIMENSIONS | this.OP.LINE[2];
	          // Copied from Grove Studio lib.
	          // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
	          // according to datasheet, we need at least 40ms after
	          // power rises above 2.7V before sending commands.
	          // Arduino can turn on way befer 4.5V so we'll wait 50



	          sleep(50);
	          this.command(lines);
	          sleep(5);
	          this.command(lines);
	          this.command(lines);
	          this.command(lines);
	          sleep(5);

	          this.command(
	            this.OP.ENTRY |
	            this.OP.ENTRYLEFT |
	            this.OP.ENTRYSHIFTDECREMENT
	          );

	          this.on();
	          this.clear();
	          this.home();
	        }

	        // Backlight initialization
	        this.io.i2cWrite(this.address.rgb, [ 0, 0 ]);
	        this.io.i2cWrite(this.address.rgb, [ 1, 0 ]);
	        this.io.i2cWrite(this.address.rgb, [ 0x08, 0xAA ]);

	        this.bgColor(opts.color || "white");
	      },
	    },
	    clear: {
	      value: function() {
	        return this.command(this.OP.CLEAR);
	      }
	    },
	    setCursor: {
	      value: function(col, row) {
	        return this.command(row === 0 ? col | 0x80 : col | 0xc0);
	      }
	    },
	    bgColor: {
	      value: function(r, g, b) {
	        var rgb = [r, g, b];
	        if (arguments.length === 1) {
	          if (Array.isArray(r)) {
	            rgb = r;
	          }
	          if (typeof r === "string") {
	            rgb = converter.keyword(r).rgb();
	          }
	        }

	        [0x04, 0x03, 0x02].forEach(function(cmd, i) {
	          this.io.i2cWrite(this.address.rgb, [ cmd, rgb[i] ]);
	        }, this);

	        return this;
	      }
	    },
	    command: {
	      value: function(mode, value) {
	        if (arguments.length === 1) {
	          value = mode;
	          mode = this.OP.COMMAND;
	        }

	        if (mode === this.OP.DATA) {
	          return this.send(value);
	        }

	        return this.writeBits(this.OP.COMMAND, value);
	      }
	    },
	    send: {
	      value: function(value) {
	        return this.writeBits(this.OP.DATA, value);
	      }
	    },
	    writeBits: {
	      value: function(mode, value) {
	        this.io.i2cWrite(this.address.lcd, [ mode, value ]);
	        return this;
	      }
	    },
	    hilo: {
	      value: function(callback) {
	        callback.call(this);
	      }
	    },
	  },


	  PCF8574: {

	    OP: {
	      value: Object.assign({}, OPS.DEFAULT, {
	        COMMAND: 0x00,
	        DATA: 0x01,
	        BACKLIGHT_ON: 0xFF,
	        BACKLIGHT_OFF: 0X00
	      }),
	    },
	    CHARS: {
	      value: lcdCharacters.DEFAULT,
	    },
	    initialize: {
	      value: function(opts) {

	        this.io.i2cConfig(opts);

	        this.bitMode = opts.bitMode || 4;
	        this.lines = opts.lines || 2;
	        this.rows = opts.rows || 2;
	        this.cols = opts.cols || 16;
	        this.dots = opts.dots || "5x8";

	        if (!opts.address) {
	          opts.address = ["PCF8574A", "PCF8574AT"].includes(opts.controller) ?
	            0x3F : 0x27;

	          /*
	            | A2 | A1 | A0 | PCF8574(T) | PCF8574A(T) |
	            |----|----|----|---------|----------|
	            | L  | L  | L  | 0x20    | 0x38     |
	            | L  | L  | H  | 0x21    | 0x39     |
	            | L  | H  | L  | 0x22    | 0x3A     |
	            | L  | H  | H  | 0x23    | 0x3B     |
	            | H  | L  | L  | 0x24    | 0x3C     |
	            | H  | L  | H  | 0x25    | 0x3D     |
	            | H  | H  | L  | 0x26    | 0x3E     |
	            | H  | H  | H  | 0x27    | 0x3F     |

	            TODO: move to API docs
	           */
	        }

	        this.address = {
	          lcd: opts.address
	        };

	        // Ported from https://bitbucket.org/fmalpartida/new-liquidcrystal
	        this.expander = new Expander(this.address.lcd, this.io);
	        this.expander.portMode(this.io.MODES.OUTPUT);
	        this.expander.write(0);

	        var backlight = opts.backlight || {
	          polarity: 0,
	          pin: 3
	        };

	        backlight.pin = typeof backlight.pin === "undefined" ? 3 : backlight.pin;
	        backlight.polarity = typeof backlight.polarity === "undefined" ? 0 : backlight.polarity;

	        var dimensions = this.OP.BITMODE[this.bitMode] |
	          this.OP.LINE[this.lines] |
	          this.OP.DOTS[this.dots];

	        var display = this.OP.DISPLAY |
	          this.OP.DISPLAYON |
	          this.OP.CURSOROFF |
	          this.OP.BLINKOFF;

	        var entry = this.OP.ENTRYLEFT |
	          this.OP.ENTRYSHIFTDECREMENT;


	        var state = {
	          display: display,
	          characters: {},
	          index: this.OP.MEMORYLIMIT - 1,
	          backlight: {
	            polarity: backlight.polarity,
	            pinMask: 1 << backlight.pin,
	            statusMask: 0x00
	          },
	          data: [
	            1 << this.OP.D4,
	            1 << this.OP.D5,
	            1 << this.OP.D6,
	            1 << this.OP.D7
	          ]
	        };

	        priv.set(this, state);

	        // Operations within the following labelled block are init-only,
	        // but _do_ block the process for negligible number of milliseconds.
	        blocking: {
	          //
	          // Toggle wrte/pulse to reset the LCD component.
	          //
	          this.expander.write(0x03 << this.OP.SHIFT_LEFT);
	          this.pulse(0x03 << this.OP.SHIFT_LEFT);
	          sleep(4);

	          this.expander.write(0x03 << this.OP.SHIFT_LEFT);
	          this.pulse(0x03 << this.OP.SHIFT_LEFT);
	          sleep(4);

	          this.expander.write(0x03 << this.OP.SHIFT_LEFT);
	          this.pulse(0x03 << this.OP.SHIFT_LEFT);

	          this.expander.write(0x02 << this.OP.SHIFT_LEFT);
	          this.pulse(0x02 << this.OP.SHIFT_LEFT);

	          // Initialize the reset component
	          this.command(this.OP.DIMENSIONS | dimensions);
	          this.on();
	          this.clear();

	          this.command(this.OP.ENTRY | entry);
	          this.backlight();
	        }
	      },
	    },
	    clear: {
	      value: function() {
	        this.command(this.OP.CLEAR);
	        sleep(2);
	        return this;

	      }
	    },
	    backlight: {
	      value: function(value) {
	        var state = priv.get(this);
	        var mask;

	        value = typeof value === "undefined" ? 255 : value;

	        if (state.backlight.pinMask !== 0x00) {
	          if ((state.backlight.polarity === 0 && value > 0) ||
	              (state.backlight.polarity === 1 && value === 0)) {

	            mask = 0xFF;
	          } else {
	            mask = 0x00;
	          }

	          state.backlight.statusMask = state.backlight.pinMask & mask;

	          this.expander.write(state.backlight.statusMask);
	        }

	        return this;
	      }
	    },

	    createChar: {
	      value: function(name, charMap) {
	        var state = priv.get(this);
	        var address;

	        if (typeof name === "number") {
	          address = name & 0x07;
	        } else {
	          address = state.index;
	          state.index--;
	          if (state.index === -1) {
	            state.index = this.OP.MEMORYLIMIT - 1;
	          }
	        }

	        this.command(this.OP.SETCGRAMADDR | (address << 3));

	        blocking: {
	          sleep(1);

	          for (var i = 0; i < 8; i++) {
	            this.command(this.OP.DATA, charMap[i]);
	            sleep(1);
	          }
	        }

	        state.characters[name] = address;

	        return address;
	      }
	    },
	    noBacklight: {
	      value: function() {
	        this.backlight(0);
	      }
	    },
	    hilo: {
	      value: function(callback) {
	        callback.call(this);
	      }
	    },
	    command: {
	      value: function(mode, value) {

	        if (arguments.length === 1) {
	          value = mode;
	          mode = this.OP.COMMAND;
	        }

	        this.send(mode, value);

	        return this;
	      }
	    },
	    send: {
	      writable: true,
	      value: function(mode, value) {

	        this.writeBits(mode, value >> 4);
	        this.writeBits(mode, value & 0x0F);

	        return this;
	      }
	    },
	    writeBits: {
	      writable: true,
	      value: function(mode, value) {
	        var state = priv.get(this);
	        var pinMapValue = 0;

	        for (var i = 0; i < 4; i++) {
	          if ((value & 0x01) === 1) {
	            pinMapValue |= state.data[i];
	          }
	          value = (value >> 1);
	        }

	        if (mode === this.OP.DATA) {
	          mode = this.OP.RS;
	        }

	        pinMapValue |= mode | state.backlight.statusMask;

	        this.pulse(pinMapValue);
	        return this;
	      }
	    },
	    pulse: {
	      writable: true,
	      value: function(data) {
	        this.expander.write(data | this.OP.EN);   // En HIGH
	        this.expander.write(data & ~this.OP.EN);  // En LOW
	      }
	    }
	  },


	  PARALLEL: {
	    OP: {
	      value: OPS.DEFAULT,
	    },
	    CHARS: {
	      value: lcdCharacters.DEFAULT,
	    },
	    initialize: {
	      value: function(opts) {

	        this.bitMode = opts.bitMode || 4;
	        this.lines = opts.lines || 2;
	        this.rows = opts.rows || 2;
	        this.cols = opts.cols || 16;
	        this.dots = opts.dots || "5x8";

	        if (Array.isArray(opts.pins)) {
	          this.pins = {
	            rs: opts.pins[0],
	            en: opts.pins[1],
	            // TODO: Move to device map profile
	            data: [
	              opts.pins[5],
	              opts.pins[4],
	              opts.pins[3],
	              opts.pins[2]
	            ]
	          };
	        } else {
	          this.pins = opts.pins;
	        }

	        var display = this.OP.DISPLAY | this.OP.DISPLAYON;
	        var state = {
	          display: display,
	          characters: {},
	          index: this.OP.MEMORYLIMIT - 1,
	          backlight: {
	            polarity: 1,
	            pin: null,
	            value: null
	          }
	        };

	        priv.set(this, state);

	        opts.pins.forEach(function(pin) {
	          this.io.pinMode(pin, 1);
	        }, this);

	        this.io.digitalWrite(this.pins.rs, this.io.LOW);
	        this.io.digitalWrite(this.pins.en, this.io.LOW);

	        if (opts.backlight) {
	          if (typeof opts.backlight === "number") {
	            var temp = opts.backlight;
	            opts.backlight = {
	              pin: temp
	            };
	          }

	          if (opts.backlight.pin) {
	            state.backlight.pin = new Pin({
	              pin: opts.backlight.pin,
	              board: this.board
	            });

	            state.backlight.pin.high();
	          }
	        }

	        // Operations within the following labelled block are init-only,
	        // but _do_ block the process negligible number of milliseconds.
	        blocking: {
	          // Send 0011 thrice to make sure LCD
	          // is initialized properly
	          this.command(0x03);
	          sleep(4);
	          this.command(0x03);
	          sleep(4);
	          this.command(0x03);

	          // Switch to 4-bit mode
	          if (this.bitMode === 4) {
	            // this.OP.DIMENSIONS |
	            this.command(0x02);
	          }

	          // Set number of lines and dots
	          // TODO: Move to device map profile
	          this.command(

	            this.OP.LINE[this.lines] |
	            this.OP.DOTS[this.dots]
	          );

	          // Clear display and turn it on
	          this.command(display);
	          this.clear();
	          this.home();
	        }
	      }
	    }
	  }
	};


	// Alias controllers
	Controllers.HD44780 = Controllers.JHD1313M1;


	Controllers.LCM1602 = Controllers.LCD1602 = Controllers.LCM1602IIC = Controllers.LCD2004 = Controllers.PCF8574A = Controllers.PCF8574AT = Controllers.PCF8574T = Controllers.PCF8574;

	Controllers.MJKDZ = Object.assign({}, Controllers.PCF8574, {
	  OP: {
	    value: Object.assign({}, OPS.DEFAULT, {
	      SHIFT_LEFT: 0x00,

	      COMMAND: 0x00,
	      DATA: 0x06,

	      // Control
	      // Enable
	      EN: 0x10,
	      // Read/Write
	      RW: 0x05,
	      // Register Select
	      RS: 0x06,

	      D4: 0x00,
	      D5: 0x01,
	      D6: 0x02,
	      D7: 0x03
	    })
	  },
	  writeBits: {
	    writable: true,
	    value: function(mode, value) {
	      var state = priv.get(this);
	      var pinMapValue = 0;

	      for (var i = 0; i < 4; i++) {
	        if ((value & 0x01) === 1) {
	          pinMapValue |= state.data[i];
	        }
	        value = (value >> 1);
	      }

	      if (mode === this.OP.DATA) {
	        mode = (1 << this.OP.RS);
	      }

	      pinMapValue |= mode | state.backlight.statusMask;

	      this.pulse(pinMapValue);
	      return this;
	    }
	  },
	});

	/**
	 * LCD
	 * @param {[type]} opts [description]
	 */

	function LCD(opts) {

	  if (!(this instanceof LCD)) {
	    return new LCD(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  var controller;

	  if (opts.controller) {
	    controller = typeof opts.controller === "string" ?
	      Controllers[opts.controller.toUpperCase()] :
	      opts.controller;
	  }

	  if (!controller) {
	    controller = Controllers.PARALLEL;
	  }

	  Board.Controller.call(this, controller, opts);

	  this.ctype = opts.controller;

	  if (this.initialize) {
	    this.initialize(opts);
	  }
	}

	LCD.prototype.command = function(mode, value) {
	  if (typeof value === "undefined") {
	    value = mode;
	    mode = 0x80;
	  }

	  if (this.bitMode === 4) {
	    this.send(value >> 4);
	  }

	  this.send(value);

	  return this;
	};

	LCD.prototype.send = function(value) {
	  var pin = 0;
	  var mask = {
	    4: 8,
	    8: 128
	  }[this.bitMode];

	  for (; mask > 0; mask = mask >> 1) {
	    this.io.digitalWrite(
	      this.pins.data[pin],
	      this.io[value & mask ? "HIGH" : "LOW"]
	    );
	    pin++;
	  }

	  ["LOW", "HIGH", "LOW"].forEach(function(val) {
	    this.io.digitalWrite(this.pins.en, this.io[val]);
	  }, this);

	  return this;
	};

	LCD.prototype.hilo = function(callback) {
	  // RS High for write mode
	  this.io.digitalWrite(this.pins.rs, this.io.HIGH);

	  callback.call(this);

	  // RS Low for command mode
	  this.io.digitalWrite(this.pins.rs, this.io.LOW);
	};



	var RE_SPECIALS = /:(\w+):/g;

	LCD.prototype.print = function(message, opts) {
	  var state, dontProcessSpecials, hasCharacters, processed;

	  message = message + "";
	  opts = opts || {};

	  state = priv.get(this);
	  dontProcessSpecials = opts.dontProcessSpecials || false;
	  hasCharacters = !dontProcessSpecials && RE_SPECIALS.test(message);

	  if (message.length === 1) {
	    this.hilo(function() {
	      this.command(this.OP.DATA, message.charCodeAt(0));
	    });
	  } else {

	    if (hasCharacters) {
	      processed = message.replace(RE_SPECIALS, function(match, name) {
	        var address = state.characters[name];

	        return typeof address === "number" ? String.fromCharCode(address) : match;
	      });

	      this.print(processed, {
	        dontProcessSpecials: true
	      });
	    } else {
	      this.hilo(function() {
	        Array.from(message).forEach(function(character) {
	          this.command(this.OP.DATA, character.charCodeAt(0));
	        }, this);
	        // var char;

	        // while ((char = chars[k++])) {
	        //   this.command(this.OP.DATA, char.charCodeAt(0));
	        // }
	      });
	    }
	  }

	  return this;
	};

	LCD.prototype.write = function(charCode) {
	  this.hilo.call(this, function() {
	    this.command(this.OP.DATA, charCode);
	  });

	  return this;
	};

	LCD.prototype.clear = function() {
	  this.command(this.OP.CLEAR);
	  sleep(2);
	  return this;
	};

	LCD.prototype.home = function() {
	  this.command(this.OP.HOME);
	  sleep(2);
	  return this;
	};

	LCD.prototype.setCursor = function(col, row) {
	  var rowOffsets = [0x00, 0x40, 0x14, 0x54];
	  this.command(this.OP.SETDDRAMADDR | (col + rowOffsets[row]));
	  return this;
	};

	LCD.prototype.backlight = function(highOrLow) {
	  var state = priv.get(this);

	  highOrLow = typeof highOrLow === "undefined" ? true : false;

	  if (state.backlight.pin instanceof Pin) {
	    if (highOrLow) {
	      state.backlight.pin.high();
	    } else {
	      state.backlight.pin.low();
	    }
	  }

	  if (highOrLow) {
	    state.display |= this.OP.DISPLAYON;
	  } else {
	    state.display &= ~this.OP.DISPLAYON;
	  }

	  this.command(state.display);

	  return this;
	};

	LCD.prototype.noBacklight = function() {
	  var state = priv.get(this);

	  if (state.backlight.pin instanceof Pin) {
	    state.backlight.pin.high();
	  }

	  // if (highOrLow) {
	  //   state.display |= this.OP.DISPLAYON;
	  // } else {
	  //   state.display &= ~this.OP.DISPLAYON;
	  // }

	  // this.command(state.display);

	  return this.backlight(false);
	};

	LCD.prototype.on = function() {
	  var state = priv.get(this);

	  state.display |= this.OP.DISPLAYON;
	  this.command(state.display);

	  return this;
	};

	LCD.prototype.off = function() {
	  var state = priv.get(this);

	  state.display &= ~this.OP.DISPLAYON;
	  this.command(state.display);

	  return this;
	};

	LCD.prototype.cursor = function(row, col) {
	  // When provided with col & row, cursor will behave like setCursor,
	  // except that it has row and col in the order that most people
	  // intuitively expect it to be in.
	  if (typeof col !== "undefined" && typeof row !== "undefined") {
	    return this.setCursor(col, row);
	  }
	  var state = priv.get(this);

	  state.display |= this.OP.CURSORON;
	  this.command(state.display);

	  return this;
	};

	LCD.prototype.noCursor = function() {
	  var state = priv.get(this);

	  state.display &= ~this.OP.CURSORON;
	  this.command(state.display);

	  return this;
	};

	LCD.prototype.blink = function() {
	  var state = priv.get(this);

	  state.display |= this.OP.BLINKON;
	  this.command(state.display);

	  return this;
	};

	LCD.prototype.noBlink = function() {
	  var state = priv.get(this);

	  state.display &= ~this.OP.BLINKON;
	  this.command(state.display);

	  return this;
	};

	LCD.prototype.autoscroll = function() {
	  var state = priv.get(this);

	  state.display |= this.OP.ENTRYSHIFTINCREMENT;
	  this.command(this.OP.ENTRY | state.display);

	  return this;
	};

	LCD.prototype.noAutoscroll = function() {
	  var state = priv.get(this);

	  state.display &= ~this.OP.ENTRYSHIFTINCREMENT;
	  this.command(this.OP.ENTRY | state.display);

	  return this;
	};

	LCD.prototype.createChar = function(name, charMap) {
	  // Ensure location is never above 7
	  var state = priv.get(this);
	  var address;

	  if (typeof name === "number") {
	    address = name & 0x07;
	  } else {
	    address = state.index;
	    state.index--;
	    if (state.index === -1) {
	      state.index = this.OP.MEMORYLIMIT - 1;
	    }
	  }

	  this.command(this.OP.SETCGRAMADDR | (address << 3));

	  this.hilo(function() {
	    for (var i = 0; i < 8; i++) {
	      this.command(this.OP.DATA, charMap[i]);
	    }
	  });

	  // Fill in address
	  state.characters[name] = address;

	  return address;
	};


	LCD.prototype.useChar = function(name) {
	  var state = priv.get(this);

	  if (!state.characters[name]) {
	    // Create the character in LCD memory and
	    // Add character to current LCD character map
	    state.characters[name] = this.createChar(name, this.CHARS[name]);
	  }

	  return this;
	};


	/**
	 *

	TODO:


	burst()

	scrollDisplayLeft()
	scrollDisplayRight()

	leftToRight()
	rightToLeft()


	*/

	LCD.POSITIVE = 0;
	LCD.NEGATIVE = 1;

	LCD.Characters = lcdCharacters;

	module.exports = LCD;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var Descriptor = __webpack_require__(150);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var Collection = __webpack_require__(114);

	var priv = new Map();
	var modes = {
	  INPUT: 0x00,
	  OUTPUT: 0x01,
	  ANALOG: 0x02,
	  PWM: 0x03,
	  SERVO: 0x04
	};

	/**
	 * Pin
	 * @constructor
	 *
	 * @description Direct Pin access objects
	 *
	 * @param {Object} opts Options: pin, freq, range
	 */

	function Pin(opts) {
	  if (!(this instanceof Pin)) {
	    return new Pin(opts);
	  }
	  if (opts === undefined || (typeof opts === "object" &&
	      opts.addr === undefined && opts.pin === undefined)
	      ) {
	    throw new Error("Pins must have a pin number");
	  }

	  var pinValue = typeof opts === "object" ? (opts.addr || opts.pin || 0) : opts;
	  var isAnalogInput = Pin.isAnalog(opts);
	  var isDTOA = false;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  opts.addr = opts.addr || opts.pin;

	  if (this.io.analogPins.includes(pinValue)) {
	    isAnalogInput = false;
	    isDTOA = true;
	  }

	  var isPin = typeof opts !== "object";
	  var addr = isDTOA ? pinValue : (isPin ? opts : opts.addr);
	  var type = opts.type || (isAnalogInput ? "analog" : "digital");

	  // Create a private side table
	  var state = {
	    mode: null,
	    last: null,
	    value: 0
	  };

	  priv.set(this, state);

	  // Create read-only "addr(address)" property
	  Object.defineProperties(this, {
	    type: new Descriptor(type),
	    addr: new Descriptor(addr, "!writable"),
	    value: {
	      get: function() {
	        return state.value;
	      }
	    },
	    mode: {
	      set: function(mode) {
	        var state = priv.get(this);
	        state.mode = mode;
	        this.io.pinMode(this.addr, mode);
	      },
	      get: function() {
	        return priv.get(this).mode;
	      }
	    }
	  });

	  this.mode = typeof opts.as !== "undefined" ? opts.as :
	    (typeof opts.mode !== "undefined" ? opts.mode : (isAnalogInput ? 0x02 : 0x01));

	  this.freq = typeof opts.freq !== "undefined" ? opts.freq : 20;

	  if (this.mode === 0 || this.mode === 2) {
	    read(this);
	  }

	  if (type === "digital") {
	    Object.defineProperties(this, {
	      isHigh: {
	        get: function() {
	          return !!state.value;
	        }
	      },
	      isLow: {
	        get: function() {
	          return !state.value;
	        }
	      },
	    });
	  }
	}


	function read(pin) {
	  var state = priv.get(pin);

	  pin.io[pin.type + "Read"](pin.addr, function(data) {
	    state.value = data;
	  });

	  setInterval(function() {
	    var isNot, emit;

	    isNot = state.value ? "low" : "high";
	    emit = state.value ? "high" : "low";

	    if (state.mode === modes.INPUT) {
	      if (state.last === null) {
	        state.last = isNot;
	      }
	      if (state.last === isNot) {
	        state.last = emit;
	        pin.emit(emit, state.value);
	        pin.emit("change", state.value);
	      }
	    }
	    pin.emit("data", state.value);
	  }, pin.freq);
	}

	util.inherits(Pin, Emitter);

	/**
	 * Pin.@@MODE
	 *
	 * Read-only constants
	 * Pin.INPUT   = 0x00
	 * Pin.OUTPUT  = 0x01
	 * Pin.ANALOG  = 0x02
	 * Pin.PWM     = 0x03
	 * Pin.SERVO   = 0x04
	 *
	 */
	Object.keys(modes).forEach(function(mode) {
	  Object.defineProperty(Pin, mode, {
	    value: modes[mode]
	  });
	});


	Pin.isAnalog = function(opts) {
	  if (typeof opts === "string" && Pin.isPrefixed(opts, ["I", "A"])) {
	    return true;
	  }

	  if (typeof opts === "object") {
	    return Pin.isAnalog(
	      typeof opts.addr !== "undefined" ? opts.addr : opts.pin
	    );
	  }
	};

	Pin.isPrefixed = function(value, prefixes) {
	  value = value[0];

	  return prefixes.reduce(function(resolution, prefix) {
	    if (!resolution) {
	      return prefix === value;
	    }
	    return resolution;
	  }, false);
	};

	Pin.write = function(pin, val) {
	  var state = priv.get(pin);

	  state.value = val;

	  // Set the correct mode (OUTPUT)
	  // This will only set if it needs to be set, otherwise a no-op
	  pin.mode = modes.OUTPUT;

	  // Create the correct type of write command
	  pin.io[pin.type + "Write"](pin.addr, val);

	  pin.emit("write", null, val);
	};

	Pin.read = function(pin, callback) {
	  // Set the correct mode (INPUT)
	  // This will only set if it needs to be set, otherwise a no-op

	  var isChanging = false;

	  if (pin.type === "digital" && pin.mode !== 0) {
	    isChanging = true;
	    pin.mode = modes.INPUT;
	  }

	  if (pin.type === "analog" && pin.mode !== 2) {
	    isChanging = true;
	    pin.mode = modes.ANALOG;
	  }

	  if (isChanging) {
	    read(pin);
	  }

	  pin.on("data", function() {
	    callback.call(pin, null, pin.value);
	  });
	};


	// Pin.prototype.isDigital = function() {
	//   return this.addr > 1;
	// };

	// Pin.prototype.isAnalog = function() {
	//   return this.board > 1;
	// };

	// Pin.prototype.isPWM = function() {
	// };

	// Pin.prototype.isServo = function() {
	// };

	// Pin.prototype.isI2C = function() {
	// };

	// Pin.prototype.isSerial = function() {
	// };

	// Pin.prototype.isInterrupt = function() {
	// };

	// Pin.prototype.isVersion = function() {
	// };


	Pin.prototype.query = function(callback) {
	  var index = this.addr;

	  if (this.type === "analog") {
	    index = this.io.analogPins[this.addr];
	  }

	  function handler() {
	    callback(this.io.pins[index]);
	  }

	  this.io.queryPinState(index, handler.bind(this));

	  return this;
	};

	/**
	 * high  Write high/1 to the pin
	 * @return {Pin}
	 */

	Pin.prototype.high = function() {
	  var value = this.type === "analog" ? 255 : 1;
	  Pin.write(this, value);
	  this.emit("high");
	  return this;
	};

	/**
	 * low  Write low/0 to the pin
	 * @return {Pin}
	 */

	Pin.prototype.low = function() {
	  Pin.write(this, 0);
	  this.emit("low");
	  return this;
	};

	/**
	 * read  Read from the pin, value is passed to callback continuation
	 * @return {Pin}
	 */

	/**
	 * write  Write to a pin
	 * @return {Pin}
	 */
	["read", "write"].forEach(function(operation) {
	  Pin.prototype[operation] = function(valOrCallback) {
	    Pin[operation](this, valOrCallback);
	    return this;
	  };
	});


	/**
	 * Pins()
	 * new Pins()
	 *
	 * Constructs an Array-like instance of all servos
	 */
	function Pins(numsOrObjects) {
	  if (!(this instanceof Pins)) {
	    return new Pins(numsOrObjects);
	  }

	  Object.defineProperty(this, "type", {
	    value: Pin
	  });

	  Collection.call(this, numsOrObjects);
	}

	Pins.prototype = Object.create(Collection.prototype, {
	  constructor: {
	    value: Pins
	  }
	});


	[
	  "high", "low", "write"
	].forEach(function(method) {
	  Pins.prototype[method] = function() {
	    var length = this.length;

	    for (var i = 0; i < length; i++) {
	      this[i][method].apply(this[i], arguments);
	    }
	    return this;
	  };
	});

	if (IS_TEST_MODE) {
	  Pin.purge = function() {
	    priv.clear();
	  };
	}

	// Assign Pins Collection class as static "method" of Pin.
	Pin.Array = Pins;

	module.exports = Pin;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	/*
	 * descriptor
	 * https://github.com/rick/descriptor
	 *
	 * Copyright (c) 2012 Rick Waldron
	 * Licensed under the MIT license.
	 */

	function assign( target, source ) {
	  Object.keys( source ).forEach(function( key ) {
	    this[ key ] = source[ key ];
	  }, target );

	  return target;
	}

	function Put( source ) {
	  return assign( this, source );
	}

	function isDescriptor( o ) {
	  return !!(
	    o && typeof o === "object" &&
	    ( "value" in o ||
	      (
	        ("get" in o && typeof o.get === "function") &&
	        !("writable" in o)
	      ) ||
	      (
	        ("set" in o && typeof o.set === "function") &&
	        !("writable" in o)
	      )
	    )
	  );
	}

	var options, defaults;

	options = [ "writable", "configurable", "enumerable" ];
	defaults = options.reduce(function( target, prop ) {
	  return (target[ prop ] = true, target);
	}, {});

	function Descriptor( map, opts ) {
	  var descriptor, fields;

	  if ( !(this instanceof Descriptor) ) {
	    return new Descriptor( map, opts || "" );
	  }

	  // Setup defaults on descriptor map:
	  //  [ "writable", "configurable", "enumerable" ] = true
	  descriptor = assign( {}, defaults );

	  // If descriptor map overrides are present, parse the string
	  // and set the fields accordingly.
	  if ( opts !== undefined ) {
	    opts.split(",").reduce(function( target, prop ) {
	      // Parse, eg. "!enumerable"
	      if ( prop[0] === "!" ) {
	        target[ prop.slice(1) ] = false;
	      }

	      return target;
	    }, descriptor);
	  }

	  fields = assign( descriptor, !isDescriptor(map) ? { value: map } : map );

	  // Last Descriptor validation tests

	  if ( !isDescriptor(fields) ) {
	    if ( fields.get || fields.set ) {
	      if ( fields.writable ) {
	        delete fields.writable;
	      }
	      // Intentially sub conditioned to allow for
	      // further additions
	    }
	    // If explicitly designing an accessor,
	    // get rid of the value field
	    if ( typeof map === "object" && (map.get || map.set) ) {
	      if ( fields.value ) {
	        delete fields.value;
	      }
	      // Intentially sub conditioned to allow for
	      // further additions
	    }
	  }

	  Put.call( this, fields );
	}


	Descriptor.isDescriptor = isDescriptor;


	module.exports = Descriptor;


/***/ },
/* 151 */
/***/ function(module, exports) {

	// http://www.quinapalus.com/hd44780udg.html
	// http://www.darreltaylor.com/files/CustChar.htm

	module.exports = {
	  DEFAULT: {
	    "0": [0xe, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0xe],
	    "1": [0x2, 0x6, 0xe, 0x6, 0x6, 0x6, 0x6],
	    "2": [0xe, 0x1b, 0x3, 0x6, 0xc, 0x18, 0x1f],
	    "3": [0xe, 0x1b, 0x3, 0xe, 0x3, 0x1b, 0xe],
	    "4": [0x3, 0x7, 0xf, 0x1b, 0x1f, 0x3, 0x3],
	    "5": [0x1f, 0x18, 0x1e, 0x3, 0x3, 0x1b, 0xe],
	    "6": [0xe, 0x1b, 0x18, 0x1e, 0x1b, 0x1b, 0xe],
	    "7": [0x1f, 0x3, 0x6, 0xc, 0xc, 0xc, 0xc],
	    "8": [0xe, 0x1b, 0x1b, 0xe, 0x1b, 0x1b, 0xe],
	    "9": [0xe, 0x1b, 0x1b, 0xf, 0x3, 0x1b, 0xe],
	    "10": [0x17, 0x15, 0x15, 0x15, 0x17, 0x0, 0x1f],
	    "11": [0xa, 0xa, 0xa, 0xa, 0xa, 0x0, 0x1f],
	    "12": [0x17, 0x11, 0x17, 0x14, 0x17, 0x0, 0x1f],
	    "13": [0x17, 0x11, 0x13, 0x11, 0x17, 0x0, 0x1f],
	    "14": [0x15, 0x15, 0x17, 0x11, 0x11, 0x0, 0x1f],
	    "15": [0x17, 0x14, 0x17, 0x11, 0x17, 0x0, 0x1f],
	    "16": [0x17, 0x14, 0x17, 0x15, 0x17, 0x0, 0x1f],
	    "17": [0x17, 0x11, 0x12, 0x12, 0x12, 0x0, 0x1f],
	    "18": [0x17, 0x15, 0x17, 0x15, 0x17, 0x0, 0x1f],
	    "19": [0x17, 0x15, 0x17, 0x11, 0x17, 0x0, 0x1f],
	    circle: [0x0, 0xe, 0x11, 0x11, 0x11, 0xe, 0x0],
	    cdot: [0x0, 0xe, 0x11, 0x15, 0x11, 0xe, 0x0],
	    donut: [0x0, 0xe, 0x1f, 0x1b, 0x1f, 0xe, 0x0],
	    ball: [0x0, 0xe, 0x1f, 0x1f, 0x1f, 0xe, 0x0],

	    square: [0x0, 0x1f, 0x11, 0x11, 0x11, 0x1f, 0x0],
	    sdot: [0x0, 0x1f, 0x11, 0x15, 0x11, 0x1f, 0x0],
	    fbox: [0x0, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0],
	    sbox: [0x0, 0x0, 0xe, 0xa, 0xe, 0x0, 0x0],
	    sfbox: [0x0, 0x0, 0xe, 0xe, 0xe, 0x0, 0x0],
	    bigpointerright: [0x8, 0xc, 0xa, 0x9, 0xa, 0xc, 0x8],
	    bigpointerleft: [0x2, 0x6, 0xa, 0x12, 0xa, 0x6, 0x2],
	    arrowright: [0x8, 0xc, 0xa, 0x9, 0xa, 0xc, 0x8],
	    arrowleft: [0x2, 0x6, 0xa, 0x12, 0xa, 0x6, 0x2],
	    ascprogress1: [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10],
	    ascprogress2: [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18],
	    ascprogress3: [0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c],
	    ascprogress4: [0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e],
	    fullprogress: [0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f],
	    descprogress1: [1, 1, 1, 1, 1, 1, 1, 1],
	    descprogress2: [3, 3, 3, 3, 3, 3, 3, 3],
	    descprogress3: [7, 7, 7, 7, 7, 7, 7, 7],
	    descprogress4: [15, 15, 15, 15, 15, 15, 15, 15],
	    ascchart1: [31, 0, 0, 0, 0, 0, 0, 0],
	    ascchart2: [31, 31, 0, 0, 0, 0, 0, 0],
	    ascchart3: [31, 31, 31, 0, 0, 0, 0, 0],
	    ascchart4: [31, 31, 31, 31, 0, 0, 0, 0],
	    ascchart5: [31, 31, 31, 31, 31, 0, 0, 0],
	    ascchart6: [31, 31, 31, 31, 31, 31, 0, 0],
	    ascchart7: [31, 31, 31, 31, 31, 31, 31, 0],
	    descchart1: [0, 0, 0, 0, 0, 0, 0, 31],
	    descchart2: [0, 0, 0, 0, 0, 0, 31, 31],
	    descchart3: [0, 0, 0, 0, 0, 31, 31, 31],
	    descchart4: [0, 0, 0, 0, 31, 31, 31, 31],
	    descchart5: [0, 0, 0, 31, 31, 31, 31, 31],
	    descchart6: [0, 0, 31, 31, 31, 31, 31, 31],
	    descchart7: [0, 31, 31, 31, 31, 31, 31, 31],
	    borderleft1: [1, 1, 1, 1, 1, 1, 1, 1],
	    borderleft2: [3, 2, 2, 2, 2, 2, 2, 3],
	    borderleft3: [7, 4, 4, 4, 4, 4, 4, 7],
	    borderleft4: [15, 8, 8, 8, 8, 8, 8, 15],
	    borderleft5: [31, 16, 16, 16, 16, 16, 16, 31],
	    bordertopbottom5: [31, 0, 0, 0, 0, 0, 0, 31],
	    borderright1: [16, 16, 16, 16, 16, 16, 16, 16],
	    borderright2: [24, 8, 8, 8, 8, 8, 8, 24],
	    borderright3: [28, 4, 4, 4, 4, 4, 4, 28],
	    borderright4: [30, 2, 2, 2, 2, 2, 2, 30],
	    borderright5: [31, 1, 1, 1, 1, 1, 1, 31],
	    box1: [3, 3, 3, 0, 0, 0, 0],
	    box2: [24, 24, 24, 0, 0, 0, 0],
	    box3: [27, 27, 27, 0, 0, 0, 0],
	    box4: [0, 0, 0, 0, 3, 3, 3],
	    box5: [3, 3, 3, 0, 3, 3, 3],
	    box6: [24, 24, 24, 0, 3, 3, 3],
	    box7: [27, 27, 27, 0, 3, 3, 3],
	    box8: [0, 0, 0, 0, 24, 24, 24],
	    box9: [3, 3, 3, 0, 24, 24, 24],
	    box10: [24, 24, 24, 0, 24, 24, 24],
	    box11: [27, 27, 27, 0, 24, 24, 24],
	    box12: [0, 0, 0, 0, 27, 27, 27],
	    box13: [3, 3, 3, 0, 27, 27, 27],
	    box14: [24, 24, 24, 0, 27, 27, 27],
	    box15: [27, 27, 27, 0, 27, 27, 27],
	    euro: [3, 4, 30, 8, 30, 8, 7],
	    cent: [0, 0, 14, 17, 16, 21, 14, 8],
	    speaker: [1, 3, 15, 15, 15, 3, 1],
	    sound: [8, 16, 0, 24, 0, 16, 8],
	    x: [0, 27, 14, 4, 14, 27, 0],
	    target: [0, 10, 17, 21, 17, 10, 0],
	    pointerright: [0, 8, 12, 14, 12, 8, 0],
	    pointerup: [0, 0, 4, 14, 31, 0, 0],
	    pointerleft: [0, 2, 6, 14, 6, 2, 0],
	    pointerdown: [0, 0, 31, 14, 4, 0, 0],
	    arrowne: [0, 15, 3, 5, 9, 16, 0],
	    arrownw: [0, 30, 24, 20, 18, 1, 0],
	    arrowsw: [0, 1, 18, 20, 24, 30, 0],
	    arrowse: [0, 16, 9, 5, 3, 15, 0],
	    dice1: [0, 0, 0, 4, 0, 0, 0],
	    dice2: [0, 16, 0, 0, 0, 1, 0],
	    dice3: [0, 16, 0, 4, 0, 1, 0],
	    dice4: [0, 17, 0, 0, 0, 17, 0],
	    dice5: [0, 17, 0, 4, 0, 17, 0],
	    dice6: [0, 17, 0, 17, 0, 17, 0],
	    bell: [4, 14, 14, 14, 31, 0, 4],
	    smile: [0, 10, 0, 17, 14, 0, 0],
	    note: [2, 3, 2, 14, 30, 12, 0],
	    clock: [0, 14, 21, 23, 17, 14, 0],
	    heart: [0, 10, 31, 31, 31, 14, 4, 0],
	    duck: [0, 12, 29, 15, 15, 6, 0],
	    check: [0, 1, 3, 22, 28, 8, 0],
	    retarrow: [1, 1, 5, 9, 31, 8, 4],
	    runninga: [6, 6, 5, 14, 20, 4, 10, 17],
	    runningb: [6, 6, 4, 14, 14, 4, 10, 10]
	  }
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var conversions = __webpack_require__(153);

	var convert = function() {
	   return new Converter();
	}

	for (var func in conversions) {
	  // export Raw versions
	  convert[func + "Raw"] =  (function(func) {
	    // accept array or plain args
	    return function(arg) {
	      if (typeof arg == "number")
	        arg = Array.prototype.slice.call(arguments);
	      return conversions[func](arg);
	    }
	  })(func);

	  var pair = /(\w+)2(\w+)/.exec(func),
	      from = pair[1],
	      to = pair[2];

	  // export rgb2hsl and ["rgb"]["hsl"]
	  convert[from] = convert[from] || {};

	  convert[from][to] = convert[func] = (function(func) { 
	    return function(arg) {
	      if (typeof arg == "number")
	        arg = Array.prototype.slice.call(arguments);
	      
	      var val = conversions[func](arg);
	      if (typeof val == "string" || val === undefined)
	        return val; // keyword

	      for (var i = 0; i < val.length; i++)
	        val[i] = Math.round(val[i]);
	      return val;
	    }
	  })(func);
	}


	/* Converter does lazy conversion and caching */
	var Converter = function() {
	   this.convs = {};
	};

	/* Either get the values for a space or
	  set the values for a space, depending on args */
	Converter.prototype.routeSpace = function(space, args) {
	   var values = args[0];
	   if (values === undefined) {
	      // color.rgb()
	      return this.getValues(space);
	   }
	   // color.rgb(10, 10, 10)
	   if (typeof values == "number") {
	      values = Array.prototype.slice.call(args);        
	   }

	   return this.setValues(space, values);
	};
	  
	/* Set the values for a space, invalidating cache */
	Converter.prototype.setValues = function(space, values) {
	   this.space = space;
	   this.convs = {};
	   this.convs[space] = values;
	   return this;
	};

	/* Get the values for a space. If there's already
	  a conversion for the space, fetch it, otherwise
	  compute it */
	Converter.prototype.getValues = function(space) {
	   var vals = this.convs[space];
	   if (!vals) {
	      var fspace = this.space,
	          from = this.convs[fspace];
	      vals = convert[fspace][space](from);

	      this.convs[space] = vals;
	   }
	  return vals;
	};

	["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
	   Converter.prototype[space] = function(vals) {
	      return this.routeSpace(space, arguments);
	   }
	});

	module.exports = convert;

/***/ },
/* 153 */
/***/ function(module, exports) {

	/* MIT license */

	module.exports = {
	  rgb2hsl: rgb2hsl,
	  rgb2hsv: rgb2hsv,
	  rgb2hwb: rgb2hwb,
	  rgb2cmyk: rgb2cmyk,
	  rgb2keyword: rgb2keyword,
	  rgb2xyz: rgb2xyz,
	  rgb2lab: rgb2lab,
	  rgb2lch: rgb2lch,

	  hsl2rgb: hsl2rgb,
	  hsl2hsv: hsl2hsv,
	  hsl2hwb: hsl2hwb,
	  hsl2cmyk: hsl2cmyk,
	  hsl2keyword: hsl2keyword,

	  hsv2rgb: hsv2rgb,
	  hsv2hsl: hsv2hsl,
	  hsv2hwb: hsv2hwb,
	  hsv2cmyk: hsv2cmyk,
	  hsv2keyword: hsv2keyword,

	  hwb2rgb: hwb2rgb,
	  hwb2hsl: hwb2hsl,
	  hwb2hsv: hwb2hsv,
	  hwb2cmyk: hwb2cmyk,
	  hwb2keyword: hwb2keyword,

	  cmyk2rgb: cmyk2rgb,
	  cmyk2hsl: cmyk2hsl,
	  cmyk2hsv: cmyk2hsv,
	  cmyk2hwb: cmyk2hwb,
	  cmyk2keyword: cmyk2keyword,

	  keyword2rgb: keyword2rgb,
	  keyword2hsl: keyword2hsl,
	  keyword2hsv: keyword2hsv,
	  keyword2hwb: keyword2hwb,
	  keyword2cmyk: keyword2cmyk,
	  keyword2lab: keyword2lab,
	  keyword2xyz: keyword2xyz,

	  xyz2rgb: xyz2rgb,
	  xyz2lab: xyz2lab,
	  xyz2lch: xyz2lch,

	  lab2xyz: lab2xyz,
	  lab2rgb: lab2rgb,
	  lab2lch: lab2lch,

	  lch2lab: lch2lab,
	  lch2xyz: lch2xyz,
	  lch2rgb: lch2rgb
	}


	function rgb2hsl(rgb) {
	  var r = rgb[0]/255,
	      g = rgb[1]/255,
	      b = rgb[2]/255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, l;

	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g)/ delta;

	  h = Math.min(h * 60, 360);

	  if (h < 0)
	    h += 360;

	  l = (min + max) / 2;

	  if (max == min)
	    s = 0;
	  else if (l <= 0.5)
	    s = delta / (max + min);
	  else
	    s = delta / (2 - max - min);

	  return [h, s * 100, l * 100];
	}

	function rgb2hsv(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, v;

	  if (max == 0)
	    s = 0;
	  else
	    s = (delta/max * 1000)/10;

	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g) / delta;

	  h = Math.min(h * 60, 360);

	  if (h < 0)
	    h += 360;

	  v = ((max / 255) * 1000) / 10;

	  return [h, s, v];
	}

	function rgb2hwb(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      h = rgb2hsl(rgb)[0],
	      w = 1/255 * Math.min(r, Math.min(g, b)),
	      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

	  return [h, w * 100, b * 100];
	}

	function rgb2cmyk(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255,
	      c, m, y, k;

	  k = Math.min(1 - r, 1 - g, 1 - b);
	  c = (1 - r - k) / (1 - k) || 0;
	  m = (1 - g - k) / (1 - k) || 0;
	  y = (1 - b - k) / (1 - k) || 0;
	  return [c * 100, m * 100, y * 100, k * 100];
	}

	function rgb2keyword(rgb) {
	  return reverseKeywords[JSON.stringify(rgb)];
	}

	function rgb2xyz(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255;

	  // assume sRGB
	  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	  return [x * 100, y *100, z * 100];
	}

	function rgb2lab(rgb) {
	  var xyz = rgb2xyz(rgb),
	        x = xyz[0],
	        y = xyz[1],
	        z = xyz[2],
	        l, a, b;

	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;

	  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);

	  return [l, a, b];
	}

	function rgb2lch(args) {
	  return lab2lch(rgb2lab(args));
	}

	function hsl2rgb(hsl) {
	  var h = hsl[0] / 360,
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      t1, t2, t3, rgb, val;

	  if (s == 0) {
	    val = l * 255;
	    return [val, val, val];
	  }

	  if (l < 0.5)
	    t2 = l * (1 + s);
	  else
	    t2 = l + s - l * s;
	  t1 = 2 * l - t2;

	  rgb = [0, 0, 0];
	  for (var i = 0; i < 3; i++) {
	    t3 = h + 1 / 3 * - (i - 1);
	    t3 < 0 && t3++;
	    t3 > 1 && t3--;

	    if (6 * t3 < 1)
	      val = t1 + (t2 - t1) * 6 * t3;
	    else if (2 * t3 < 1)
	      val = t2;
	    else if (3 * t3 < 2)
	      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	    else
	      val = t1;

	    rgb[i] = val * 255;
	  }

	  return rgb;
	}

	function hsl2hsv(hsl) {
	  var h = hsl[0],
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      sv, v;

	  if(l === 0) {
	      // no need to do calc on black
	      // also avoids divide by 0 error
	      return [0, 0, 0];
	  }

	  l *= 2;
	  s *= (l <= 1) ? l : 2 - l;
	  v = (l + s) / 2;
	  sv = (2 * s) / (l + s);
	  return [h, sv * 100, v * 100];
	}

	function hsl2hwb(args) {
	  return rgb2hwb(hsl2rgb(args));
	}

	function hsl2cmyk(args) {
	  return rgb2cmyk(hsl2rgb(args));
	}

	function hsl2keyword(args) {
	  return rgb2keyword(hsl2rgb(args));
	}


	function hsv2rgb(hsv) {
	  var h = hsv[0] / 60,
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      hi = Math.floor(h) % 6;

	  var f = h - Math.floor(h),
	      p = 255 * v * (1 - s),
	      q = 255 * v * (1 - (s * f)),
	      t = 255 * v * (1 - (s * (1 - f))),
	      v = 255 * v;

	  switch(hi) {
	    case 0:
	      return [v, t, p];
	    case 1:
	      return [q, v, p];
	    case 2:
	      return [p, v, t];
	    case 3:
	      return [p, q, v];
	    case 4:
	      return [t, p, v];
	    case 5:
	      return [v, p, q];
	  }
	}

	function hsv2hsl(hsv) {
	  var h = hsv[0],
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      sl, l;

	  l = (2 - s) * v;
	  sl = s * v;
	  sl /= (l <= 1) ? l : 2 - l;
	  sl = sl || 0;
	  l /= 2;
	  return [h, sl * 100, l * 100];
	}

	function hsv2hwb(args) {
	  return rgb2hwb(hsv2rgb(args))
	}

	function hsv2cmyk(args) {
	  return rgb2cmyk(hsv2rgb(args));
	}

	function hsv2keyword(args) {
	  return rgb2keyword(hsv2rgb(args));
	}

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	function hwb2rgb(hwb) {
	  var h = hwb[0] / 360,
	      wh = hwb[1] / 100,
	      bl = hwb[2] / 100,
	      ratio = wh + bl,
	      i, v, f, n;

	  // wh + bl cant be > 1
	  if (ratio > 1) {
	    wh /= ratio;
	    bl /= ratio;
	  }

	  i = Math.floor(6 * h);
	  v = 1 - bl;
	  f = 6 * h - i;
	  if ((i & 0x01) != 0) {
	    f = 1 - f;
	  }
	  n = wh + f * (v - wh);  // linear interpolation

	  switch (i) {
	    default:
	    case 6:
	    case 0: r = v; g = n; b = wh; break;
	    case 1: r = n; g = v; b = wh; break;
	    case 2: r = wh; g = v; b = n; break;
	    case 3: r = wh; g = n; b = v; break;
	    case 4: r = n; g = wh; b = v; break;
	    case 5: r = v; g = wh; b = n; break;
	  }

	  return [r * 255, g * 255, b * 255];
	}

	function hwb2hsl(args) {
	  return rgb2hsl(hwb2rgb(args));
	}

	function hwb2hsv(args) {
	  return rgb2hsv(hwb2rgb(args));
	}

	function hwb2cmyk(args) {
	  return rgb2cmyk(hwb2rgb(args));
	}

	function hwb2keyword(args) {
	  return rgb2keyword(hwb2rgb(args));
	}

	function cmyk2rgb(cmyk) {
	  var c = cmyk[0] / 100,
	      m = cmyk[1] / 100,
	      y = cmyk[2] / 100,
	      k = cmyk[3] / 100,
	      r, g, b;

	  r = 1 - Math.min(1, c * (1 - k) + k);
	  g = 1 - Math.min(1, m * (1 - k) + k);
	  b = 1 - Math.min(1, y * (1 - k) + k);
	  return [r * 255, g * 255, b * 255];
	}

	function cmyk2hsl(args) {
	  return rgb2hsl(cmyk2rgb(args));
	}

	function cmyk2hsv(args) {
	  return rgb2hsv(cmyk2rgb(args));
	}

	function cmyk2hwb(args) {
	  return rgb2hwb(cmyk2rgb(args));
	}

	function cmyk2keyword(args) {
	  return rgb2keyword(cmyk2rgb(args));
	}


	function xyz2rgb(xyz) {
	  var x = xyz[0] / 100,
	      y = xyz[1] / 100,
	      z = xyz[2] / 100,
	      r, g, b;

	  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	  // assume sRGB
	  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
	    : r = (r * 12.92);

	  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
	    : g = (g * 12.92);

	  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
	    : b = (b * 12.92);

	  r = Math.min(Math.max(0, r), 1);
	  g = Math.min(Math.max(0, g), 1);
	  b = Math.min(Math.max(0, b), 1);

	  return [r * 255, g * 255, b * 255];
	}

	function xyz2lab(xyz) {
	  var x = xyz[0],
	      y = xyz[1],
	      z = xyz[2],
	      l, a, b;

	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;

	  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);

	  return [l, a, b];
	}

	function xyz2lch(args) {
	  return lab2lch(xyz2lab(args));
	}

	function lab2xyz(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      x, y, z, y2;

	  if (l <= 8) {
	    y = (l * 100) / 903.3;
	    y2 = (7.787 * (y / 100)) + (16 / 116);
	  } else {
	    y = 100 * Math.pow((l + 16) / 116, 3);
	    y2 = Math.pow(y / 100, 1/3);
	  }

	  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

	  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

	  return [x, y, z];
	}

	function lab2lch(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      hr, h, c;

	  hr = Math.atan2(b, a);
	  h = hr * 360 / 2 / Math.PI;
	  if (h < 0) {
	    h += 360;
	  }
	  c = Math.sqrt(a * a + b * b);
	  return [l, c, h];
	}

	function lab2rgb(args) {
	  return xyz2rgb(lab2xyz(args));
	}

	function lch2lab(lch) {
	  var l = lch[0],
	      c = lch[1],
	      h = lch[2],
	      a, b, hr;

	  hr = h / 360 * 2 * Math.PI;
	  a = c * Math.cos(hr);
	  b = c * Math.sin(hr);
	  return [l, a, b];
	}

	function lch2xyz(args) {
	  return lab2xyz(lch2lab(args));
	}

	function lch2rgb(args) {
	  return lab2rgb(lch2lab(args));
	}

	function keyword2rgb(keyword) {
	  return cssKeywords[keyword];
	}

	function keyword2hsl(args) {
	  return rgb2hsl(keyword2rgb(args));
	}

	function keyword2hsv(args) {
	  return rgb2hsv(keyword2rgb(args));
	}

	function keyword2hwb(args) {
	  return rgb2hwb(keyword2rgb(args));
	}

	function keyword2cmyk(args) {
	  return rgb2cmyk(keyword2rgb(args));
	}

	function keyword2lab(args) {
	  return rgb2lab(keyword2rgb(args));
	}

	function keyword2xyz(args) {
	  return rgb2xyz(keyword2rgb(args));
	}

	var cssKeywords = {
	  aliceblue:  [240,248,255],
	  antiquewhite: [250,235,215],
	  aqua: [0,255,255],
	  aquamarine: [127,255,212],
	  azure:  [240,255,255],
	  beige:  [245,245,220],
	  bisque: [255,228,196],
	  black:  [0,0,0],
	  blanchedalmond: [255,235,205],
	  blue: [0,0,255],
	  blueviolet: [138,43,226],
	  brown:  [165,42,42],
	  burlywood:  [222,184,135],
	  cadetblue:  [95,158,160],
	  chartreuse: [127,255,0],
	  chocolate:  [210,105,30],
	  coral:  [255,127,80],
	  cornflowerblue: [100,149,237],
	  cornsilk: [255,248,220],
	  crimson:  [220,20,60],
	  cyan: [0,255,255],
	  darkblue: [0,0,139],
	  darkcyan: [0,139,139],
	  darkgoldenrod:  [184,134,11],
	  darkgray: [169,169,169],
	  darkgreen:  [0,100,0],
	  darkgrey: [169,169,169],
	  darkkhaki:  [189,183,107],
	  darkmagenta:  [139,0,139],
	  darkolivegreen: [85,107,47],
	  darkorange: [255,140,0],
	  darkorchid: [153,50,204],
	  darkred:  [139,0,0],
	  darksalmon: [233,150,122],
	  darkseagreen: [143,188,143],
	  darkslateblue:  [72,61,139],
	  darkslategray:  [47,79,79],
	  darkslategrey:  [47,79,79],
	  darkturquoise:  [0,206,209],
	  darkviolet: [148,0,211],
	  deeppink: [255,20,147],
	  deepskyblue:  [0,191,255],
	  dimgray:  [105,105,105],
	  dimgrey:  [105,105,105],
	  dodgerblue: [30,144,255],
	  firebrick:  [178,34,34],
	  floralwhite:  [255,250,240],
	  forestgreen:  [34,139,34],
	  fuchsia:  [255,0,255],
	  gainsboro:  [220,220,220],
	  ghostwhite: [248,248,255],
	  gold: [255,215,0],
	  goldenrod:  [218,165,32],
	  gray: [128,128,128],
	  green:  [0,128,0],
	  greenyellow:  [173,255,47],
	  grey: [128,128,128],
	  honeydew: [240,255,240],
	  hotpink:  [255,105,180],
	  indianred:  [205,92,92],
	  indigo: [75,0,130],
	  ivory:  [255,255,240],
	  khaki:  [240,230,140],
	  lavender: [230,230,250],
	  lavenderblush:  [255,240,245],
	  lawngreen:  [124,252,0],
	  lemonchiffon: [255,250,205],
	  lightblue:  [173,216,230],
	  lightcoral: [240,128,128],
	  lightcyan:  [224,255,255],
	  lightgoldenrodyellow: [250,250,210],
	  lightgray:  [211,211,211],
	  lightgreen: [144,238,144],
	  lightgrey:  [211,211,211],
	  lightpink:  [255,182,193],
	  lightsalmon:  [255,160,122],
	  lightseagreen:  [32,178,170],
	  lightskyblue: [135,206,250],
	  lightslategray: [119,136,153],
	  lightslategrey: [119,136,153],
	  lightsteelblue: [176,196,222],
	  lightyellow:  [255,255,224],
	  lime: [0,255,0],
	  limegreen:  [50,205,50],
	  linen:  [250,240,230],
	  magenta:  [255,0,255],
	  maroon: [128,0,0],
	  mediumaquamarine: [102,205,170],
	  mediumblue: [0,0,205],
	  mediumorchid: [186,85,211],
	  mediumpurple: [147,112,219],
	  mediumseagreen: [60,179,113],
	  mediumslateblue:  [123,104,238],
	  mediumspringgreen:  [0,250,154],
	  mediumturquoise:  [72,209,204],
	  mediumvioletred:  [199,21,133],
	  midnightblue: [25,25,112],
	  mintcream:  [245,255,250],
	  mistyrose:  [255,228,225],
	  moccasin: [255,228,181],
	  navajowhite:  [255,222,173],
	  navy: [0,0,128],
	  oldlace:  [253,245,230],
	  olive:  [128,128,0],
	  olivedrab:  [107,142,35],
	  orange: [255,165,0],
	  orangered:  [255,69,0],
	  orchid: [218,112,214],
	  palegoldenrod:  [238,232,170],
	  palegreen:  [152,251,152],
	  paleturquoise:  [175,238,238],
	  palevioletred:  [219,112,147],
	  papayawhip: [255,239,213],
	  peachpuff:  [255,218,185],
	  peru: [205,133,63],
	  pink: [255,192,203],
	  plum: [221,160,221],
	  powderblue: [176,224,230],
	  purple: [128,0,128],
	  rebeccapurple: [102, 51, 153],
	  red:  [255,0,0],
	  rosybrown:  [188,143,143],
	  royalblue:  [65,105,225],
	  saddlebrown:  [139,69,19],
	  salmon: [250,128,114],
	  sandybrown: [244,164,96],
	  seagreen: [46,139,87],
	  seashell: [255,245,238],
	  sienna: [160,82,45],
	  silver: [192,192,192],
	  skyblue:  [135,206,235],
	  slateblue:  [106,90,205],
	  slategray:  [112,128,144],
	  slategrey:  [112,128,144],
	  snow: [255,250,250],
	  springgreen:  [0,255,127],
	  steelblue:  [70,130,180],
	  tan:  [210,180,140],
	  teal: [0,128,128],
	  thistle:  [216,191,216],
	  tomato: [255,99,71],
	  turquoise:  [64,224,208],
	  violet: [238,130,238],
	  wheat:  [245,222,179],
	  white:  [255,255,255],
	  whitesmoke: [245,245,245],
	  yellow: [255,255,0],
	  yellowgreen:  [154,205,50]
	};

	var reverseKeywords = {};
	for (var key in cssKeywords) {
	  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
	}


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var Led = __webpack_require__(155);
	Led.Array = __webpack_require__(156);
	Led.RGB = __webpack_require__(157);
	Led.Matrix = __webpack_require__(158);
	Led.Digits = __webpack_require__(161);

	module.exports = Led;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var nanosleep = __webpack_require__(141).nano;
	var Animation = __webpack_require__(129);
	var __ = __webpack_require__(115);
	var Pins = Board.Pins;

	var priv = new Map();

	var Controllers = {
	  PCA9685: {
	    REGISTER: {
	      value: {
	        PCA9685_MODE1: 0x0,
	        PCA9685_PRESCALE: 0xFE,
	        LED0_ON_L: 0x6
	      }
	    },
	    initialize: {
	      value: function(opts) {

	        var state = priv.get(this);

	        this.address = opts.address || 0x40;
	        this.pwmRange = opts.pwmRange || [0, 4095];

	        if (!this.board.Drivers[this.address]) {
	          this.io.i2cConfig(opts);
	          this.board.Drivers[this.address] = {
	            initialized: false
	          };

	          // Reset
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0x0]);
	          // Sleep
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0x10]);
	          // Set prescalar
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_PRESCALE, 0x70]);
	          // Wake up
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0x0]);
	          // Wait 5 nanoseconds for restart
	          nanosleep(5);
	          // Auto-increment
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0xa1]);

	          this.board.Drivers[this.address].initialized = true;
	        }

	        this.pin = typeof opts.pin === "undefined" ? 0 : opts.pin;

	        state.mode = this.io.MODES.PWM;
	      }
	    },
	    write: {
	      value: function() {

	        var on, off;
	        var state = priv.get(this);
	        var value = state.isAnode ? 255 - Board.constrain(state.value, 0, 255) : state.value;

	        on = 0;
	        off = this.pwmRange[1] * value / 255;

	        this.io.i2cWrite(this.address, [this.REGISTER.LED0_ON_L + 4 * (this.pin), on, on >> 8, off, off >> 8]);
	      }
	    }
	  },
	  DEFAULT: {
	    initialize: {
	      value: function(opts, pinValue) {

	        var state = priv.get(this);
	        var isFirmata = true;
	        var defaultLed;

	        isFirmata = Pins.isFirmata(this);

	        if (isFirmata && typeof pinValue === "string" && pinValue[0] === "A") {
	          pinValue = this.io.analogPins[+pinValue.slice(1)];
	        }

	        defaultLed = this.io.defaultLed || 13;
	        pinValue = +pinValue;

	        if (isFirmata && this.io.analogPins.includes(pinValue)) {
	          this.pin = pinValue;
	          state.mode = this.io.MODES.OUTPUT;
	        } else {
	          this.pin = typeof opts.pin === "undefined" ? defaultLed : opts.pin;
	          state.mode = this.io.MODES[
	            (this.board.pins.isPwm(this.pin) ? "PWM" : "OUTPUT")
	          ];
	        }

	        this.io.pinMode(this.pin, state.mode);
	      }
	    },
	    write: {
	      value: function() {
	        var state = priv.get(this);
	        var value = state.value;

	        // If pin is not a PWM pin and brightness is not HIGH or LOW, emit an error
	        if (value !== this.io.LOW && value !== this.io.HIGH && this.mode !== this.io.MODES.PWM) {
	          Board.Pins.Error({
	            pin: this.pin,
	            type: "PWM",
	            via: "Led"
	          });
	        }

	        if (state.mode === this.io.MODES.OUTPUT) {
	          this.io.digitalWrite(this.pin, value);
	        }

	        if (state.mode === this.io.MODES.PWM) {
	          if (state.isAnode) {
	            value = 255 - Board.constrain(value, 0, 255);
	          }

	          this.io.analogWrite(this.pin, value);
	        }
	      }
	    }
	  }
	};

	/**
	 * Led
	 * @constructor
	 *
	 * five.Led(pin);
	 *
	 * five.Led({
	 *   pin: number
	 *  });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Led(opts) {
	  if (!(this instanceof Led)) {
	    return new Led(opts);
	  }

	  var state;
	  var controller;
	  var pinValue = typeof opts === "object" ? opts.pin : opts;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["DEFAULT"];
	  }

	  Object.defineProperties(this, controller);

	  state = {
	    isOn: false,
	    isRunning: false,
	    value: null,
	    direction: 1,
	    mode: null,
	    isAnode: opts.isAnode,
	    interval: null
	  };

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return state.value;
	      }
	    },
	    mode: {
	      get: function() {
	        return state.mode;
	      }
	    },
	    isOn: {
	      get: function() {
	        return !!state.value;
	      }
	    },
	    isRunning: {
	      get: function() {
	        return state.isRunning;
	      }
	    },
	    animation: {
	      get: function() {
	        return state.animation;
	      }
	    }
	  });

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, pinValue);
	  }
	}

	/**
	 * on Turn the led on
	 * @return {Led}
	 */
	Led.prototype.on = function() {
	  var state = priv.get(this);

	  if (state.mode === this.io.MODES.OUTPUT) {
	    state.value = this.io.HIGH;
	  }

	  if (state.mode === this.io.MODES.PWM) {
	    // Assume we need to simply turn this all the way on, when:

	    // ...state.value is null
	    if (state.value === null) {
	      state.value = 255;
	    }

	    // ...there is no active interval
	    if (!state.interval) {
	      state.value = 255;
	    }

	    // ...the last value was 0
	    if (state.value === 0) {
	      state.value = 255;
	    }
	  }

	  this.write();

	  return this;
	};

	/**
	 * off  Turn the led off
	 * @return {Led}
	 */
	Led.prototype.off = function() {
	  var state = priv.get(this);

	  state.value = 0;

	  this.write();

	  return this;
	};

	/**
	 * toggle Toggle the on/off state of an led
	 * @return {Led}
	 */
	Led.prototype.toggle = function() {
	  return this[this.isOn ? "off" : "on"]();
	};

	/**
	 * brightness
	 * @param  {Number} value analog brightness value 0-255
	 * @return {Led}
	 */
	Led.prototype.brightness = function(value) {
	  var state = priv.get(this);

	  state.value = value;

	  this.write();

	  return this;
	};

	/**
	 * Animation.normalize
	 *
	 * @param [number || object] keyFrames An array of step values or a keyFrame objects
	 */

	Led.prototype[Animation.normalize] = function(keyFrames) {

	  var state = priv.get(this);
	  var last = state.value || 0;

	  // If user passes null as the first element in keyFrames use current value
	  if (keyFrames[0] === null) {
	    keyFrames[0] = {
	      value: last
	    };
	  }

	  keyFrames.forEach(function(keyFrame, i) {

	    if (keyFrame !== null) {
	      // keyFrames that are just numbers represent values
	      if (typeof keyFrame === "number") {
	        keyFrames[i] = {
	          value: keyFrame,
	          easing: "linear"
	        };
	      }
	    }

	  });

	  return keyFrames;

	};

	/**
	 * Animation.render
	 *
	 * @position [number] value to set the led to
	 */

	Led.prototype[Animation.render] = function(position) {
	  var state = priv.get(this);
	  state.value = position[0];
	  return this.write();
	};

	/**
	 * pulse Fade the Led in and out in a loop with specified time
	 * @param  {number} rate Time in ms that a fade in/out will elapse
	 * @return {Led}
	 *
	 * - or -
	 *
	 * @param  {Object} val An Animation() segment config object
	 */

	Led.prototype.pulse = function(rate, callback) {
	  var state = priv.get(this);

	  var options = {
	    duration: typeof rate === "number" ? rate : 1000,
	    keyFrames: [0, 0xff],
	    metronomic: true,
	    loop: true,
	    easing: "inOutSine",
	    onloop: function() {
	      if (typeof callback === "function") {
	        callback();
	      }
	    }
	  };

	  if (typeof rate === "object") {
	    __.extend(options, rate);
	  }

	  if (typeof rate === "function") {
	    callback = rate;
	  }

	  state.isRunning = true;

	  state.animation = state.animation || new Animation(this);
	  state.animation.enqueue(options);
	  return this;
	};

	/**
	 * fade Fade an led in and out
	 * @param  {Number} val  Analog brightness value 0-255
	 * @param  {Number} time Time in ms that a fade in/out will elapse
	 * @return {Led}
	 *
	 * - or -
	 *
	 * @param  {Object} val An Animation() segment config object
	 */

	Led.prototype.fade = function(val, time, callback) {

	  var state = priv.get(this);

	  var options = {
	    duration: typeof time === "number" ? time : 1000,
	    keyFrames: [null, typeof val === "number" ? val : 0xff],
	    easing: "outSine",
	    oncomplete: function() {
	      state.isRunning = false;
	      if (typeof callback === "function") {
	        callback();
	      }
	    }
	  };

	  if (typeof val === "object") {
	    __.extend(options, val);
	  }

	  if (typeof val === "function") {
	    callback = val;
	  }

	  if (typeof time === "function") {
	    callback = time;
	  }

	  state.isRunning = true;

	  state.animation = state.animation || new Animation(this);
	  state.animation.enqueue(options);

	};

	Led.prototype.fadeIn = function(time, callback) {
	  return this.fade(255, time || 1000, callback);
	};

	Led.prototype.fadeOut = function(time, callback) {
	  return this.fade(0, time || 1000, callback);
	};

	/**
	 * strobe
	 * @param  {Number} rate Time in ms to strobe/blink
	 * @return {Led}
	 */
	Led.prototype.strobe = function(rate, callback) {
	  var state = priv.get(this);

	  // Avoid traffic jams
	  if (state.interval) {
	    clearInterval(state.interval);
	  }

	  if (typeof rate === "function") {
	    callback = rate;
	    rate = null;
	  }

	  state.isRunning = true;

	  state.interval = setInterval(function() {
	    this.toggle();
	    if (typeof callback === "function") {
	      callback();
	    }
	  }.bind(this), rate || 100);

	  return this;
	};

	Led.prototype.blink = Led.prototype.strobe;

	/**
	 * stop Stop the led from strobing, pulsing or fading
	 * @return {Led}
	 */
	Led.prototype.stop = function() {
	  var state = priv.get(this);

	  clearInterval(state.interval);

	  if (state.animation) {
	    state.animation.stop();
	  }

	  state.isRunning = false;

	  return this;
	};

	if (IS_TEST_MODE) {
	  Led.purge = function() {
	    priv.clear();
	  };
	}


	module.exports = Led;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var Led = __webpack_require__(155);
	var Collection = __webpack_require__(114);

	/**
	 * Leds()
	 * new Leds()
	 *
	 * Create an Array-like object instance of Leds
	 * @alias Led.Array
	 * @constructor
	 * @return {Leds}
	 */
	function Leds(numsOrObjects) {
	  if (!(this instanceof Leds)) {
	    return new Leds(numsOrObjects);
	  }

	  Object.defineProperty(this, "type", {
	    value: Led
	  });

	  Collection.call(this, numsOrObjects);
	}

	Leds.prototype = Object.create(Collection.prototype, {
	  constructor: {
	    value: Leds
	  }
	});

	[

	  "on", "off", "toggle", "brightness",
	  "fade", "fadeIn", "fadeOut",
	  "pulse", "strobe",
	  "stop"

	].forEach(function(method) {
	  // Create Leds wrappers for each method listed.
	  // This will allow us control over all Led instances
	  // simultaneously.
	  Leds.prototype[method] = function() {
	    var length = this.length;

	    for (var i = 0; i < length; i++) {
	      this[i][method].apply(this[i], arguments);
	    }
	    return this;
	  };
	});

	Leds.prototype.blink = Leds.prototype.strobe;

	module.exports = Leds;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var nanosleep = __webpack_require__(141).nano;
	var __ = __webpack_require__(115);

	var priv = new Map();

	var Controllers = {
	  DEFAULT: {
	    initialize: {
	      value: function(opts) {
	        RGB.colors.forEach(function(color, index) {
	          var pin = opts.pins[index];

	          if (!this.board.pins.isPwm(pin)) {
	            Board.Pins.Error({
	              pin: pin,
	              type: "PWM",
	              via: "Led.RGB"
	            });
	          }

	          this.io.pinMode(pin, this.io.MODES.PWM);
	          this.pins[index] = pin;
	        }, this);
	      }
	    },
	    write: {
	      writable: true,
	      value: function(colors) {
	        var state = priv.get(this);

	        RGB.colors.forEach(function(color, index) {
	          var pin = this.pins[index];
	          var value = colors[color];

	          if (state.isAnode) {
	            value = 255 - Board.constrain(value, 0, 255);
	          }

	          this.io.analogWrite(pin, value);
	        }, this);
	      }
	    }
	  },
	  PCA9685: {
	    REGISTER: {
	      value: {
	        PCA9685_MODE1: 0x0,
	        PCA9685_PRESCALE: 0xFE,
	        LED0_ON_L: 0x6
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        this.address = opts.address || 0x40;

	        if (!this.board.Drivers[this.address]) {
	          this.io.i2cConfig(opts);
	          this.board.Drivers[this.address] = {
	            initialized: false
	          };

	          // Reset
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0x0]);
	          // Sleep
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0x10]);
	          // Set prescalar
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_PRESCALE, 0x70]);
	          // Wake up
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0x0]);
	          // Wait 5 nanoseconds for restart
	          nanosleep(5);
	          // Auto-increment
	          this.io.i2cWrite(this.address, [this.REGISTER.PCA9685_MODE1, 0xa1]);

	          this.board.Drivers[this.address].initialized = true;
	        }

	        RGB.colors.forEach(function(color, index) {
	          var pin = opts.pins[index];
	          this.pins[index] = pin;
	        }, this);
	      }
	    },
	    write: {
	      writable: true,
	      value: function(colors) {
	        var state = priv.get(this);

	        RGB.colors.forEach(function(color, index) {
	          var pin = this.pins[index];
	          var value = colors[color];
	          var on, off;

	          if (state.isAnode) {
	            value = 255 - Board.constrain(value, 0, 255);
	          }

	          on = 0;
	          off = value * 4095 / 255;

	          // Special value for fully off
	          if (state.isAnode && value === 255) {
	            on = 4096;
	            off = 0;
	          }

	          this.io.i2cWrite(this.address, [this.REGISTER.LED0_ON_L + 4 * pin, on, on >> 8, off, off >> 8]);
	        }, this);
	      }
	    }
	  },
	  BLINKM: {
	    REGISTER: {
	      value: {
	        GO_TO_RGB_COLOR_NOW: 0x6e,
	        STOP_SCRIPT: 0x6f
	      }
	    },
	    initialize: {
	      value: function(opts) {
	        this.address = opts.address || 0x09;

	        if (!this.board.Drivers[this.address]) {
	          this.io.i2cConfig(opts);
	          this.board.Drivers[this.address] = {
	            initialized: false
	          };

	          // Stop the current script
	          this.io.i2cWrite(this.address, [this.REGISTER.STOP_SCRIPT]);

	          this.board.Drivers[this.address].initialized = true;
	        }
	      }
	    },
	    write: {
	      writable: true,
	      value: function(colors) {
	        this.io.i2cWrite(this.address,
	          [this.REGISTER.GO_TO_RGB_COLOR_NOW, colors.red, colors.green, colors.blue]);
	      }
	    }
	  }
	};

	Controllers.ESPLORA = {
	  initialize: {
	    value: function(opts) {
	      opts.pins = [5, 10, 9];
	      this.pins = [];
	      Controllers.DEFAULT.initialize.value.call(this, opts);
	    }
	  },
	  write: Controllers.DEFAULT.write
	};

	/**
	 * RGB
	 * @constructor
	 *
	 * @param {Object} opts [description]
	 * @alias Led.RGB
	 */
	var RGB = function(opts) {
	  if (!(this instanceof RGB)) {
	    return new RGB(opts);
	  }

	  var state;
	  var controller;

	  if (Array.isArray(opts)) {
	    // RGB([Byte, Byte, Byte]) shorthand
	    // Convert to opts.pins array definition
	    opts = {
	      pins: opts
	    };
	  // If opts.pins is an object, convert to array
	  } else if (typeof opts.pins === "object" && !Array.isArray(opts.pins)) {
	    opts.pins = [opts.pins.red, opts.pins.green, opts.pins.blue];
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["DEFAULT"];
	  }

	  Object.defineProperties(this, controller);

	  // The default color is #ffffff, but the light will be off
	  state = {
	    red: 255,
	    green: 255,
	    blue: 255,
	    intensity: 100,
	    isAnode: opts.isAnode || false,
	    interval: null
	  };

	  // red, green, and blue store the raw color set via .color()
	  // values takes state into account, such as on/off and intensity
	  state.values = {
	    red: state.red,
	    green: state.green,
	    blue: state.blue
	  };

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    isOn: {
	      get: function() {
	        return RGB.colors.some(function(color) {
	          return state[color] > 0;
	        });
	      }
	    },
	    isRunning: {
	      get: function() {
	        return !!state.interval;
	      }
	    },
	    isAnode: {
	      get: function () {
	        return state.isAnode;
	      }
	    },
	    values: {
	      get: function() {
	        return Object.assign({}, state.values);
	      }
	    },
	    update: {
	      value: function(colors) {
	        var state = priv.get(this);
	        var scale = state.intensity / 100;

	        colors = colors || this.color();
	        var scaledColors = RGB.colors.reduce(function(current, color) {
	          return (current[color] = Math.round(colors[color] * scale), current);
	        }, {});

	        this.write(scaledColors);

	        state.values = scaledColors;
	        Object.assign(state, colors);
	      }
	    }
	  });

	  this.initialize(opts);
	  this.off();
	};

	RGB.colors = ["red", "green", "blue"];

	/**
	* color
	*
	* @param  {String} color Hexadecimal color string
	* @param  {Array} color Array of color values
	* @param  {Object} color object {red, green, blue}
	*
	* @return {RGB}
	*/
	RGB.prototype.color = function(red, green, blue) {
	  var state = priv.get(this);
	  var update = {};
	  var input;
	  var colors;

	  if (arguments.length === 0) {
	    // Return a copy of the state values,
	    // not a reference to the state object itself.
	    colors = this.isOn ? state : state.prev;
	    return RGB.colors.reduce(function(current, color) {
	      return (current[color] = Math.round(colors[color]), current);
	    }, {});
	  }

	  if (arguments.length === 1) {
	    input = red;

	    if (input == null) {
	      throw new Error("Led.RGB.color: invalid color (" + input + ")");
	    }

	    if (Array.isArray(input)) {
	        // color([Byte, Byte, Byte])
	        update = {
	          red: input[0],
	          green: input[1],
	          blue: input[2]
	        };
	    } else if (typeof input === "object") {
	        // colors({
	        //   red: Byte,
	        //   green: Byte,
	        //   blue: Byte
	        // });
	        update = {
	          red: input.red,
	          green: input.green,
	          blue: input.blue
	        };
	    } else if (typeof input === "string") {
	      // color("#ffffff")
	      if (input.length === 7 && input[0] === "#") {
	        input = input.slice(1);
	      }

	      if (!input.match(/^[0-9A-Fa-f]{6}$/)) {
	        throw new Error("Led.RGB.color: invalid color (#" + input + ")");
	      }

	      // color("ffffff")
	      update = {
	        red: parseInt(input.slice(0, 2), 16),
	        green: parseInt(input.slice(2, 4), 16),
	        blue: parseInt(input.slice(4, 6), 16)
	      };
	    }
	  } else {
	    // color(Byte, Byte, Byte)
	    update = {
	      red: red,
	      green: green,
	      blue: blue
	    };
	  }

	  // Validate all color values before writing any values
	  RGB.colors.forEach(function(color) {
	    var value = update[color];

	    if (value == null) {
	      throw new Error("Led.RGB.color: invalid color ([" + [update.red, update.green, update.blue].join(",") + "])");
	    }

	    value = __.constrain(value, 0, 255);
	    update[color] = value;
	  }, this);

	  this.update(update);

	  return this;
	};

	RGB.prototype.on = function() {
	  var state = priv.get(this);
	  var colors;

	  // If it's not already on, we set them to the previous color
	  if (!this.isOn) {
	    colors = state.prev || { red: 255, green: 255, blue: 255 };
	    delete state.prev;

	    this.update(colors);
	  }

	  return this;
	};

	RGB.prototype.off = function() {
	  var state = priv.get(this);

	  // If it's already off, do nothing so the pervious state stays intact
	  if (this.isOn) {
	    state.prev = RGB.colors.reduce(function(current, color) {
	      return (current[color] = state[color], current);
	    }.bind(this), {});

	    this.update({ red: 0, green: 0, blue: 0 });
	  }

	  return this;
	};

	/**
	 * strobe
	 * @param  {Number} rate Time in ms to strobe/blink
	 * @return {Led}
	 */
	RGB.prototype.strobe = function(rate) {
	  var state = priv.get(this);

	  // Avoid traffic jams
	  if (state.interval) {
	    clearInterval(state.interval);
	  }

	  state.interval = setInterval(this.toggle.bind(this), rate || 100);

	  return this;
	};

	RGB.prototype.blink = RGB.prototype.strobe;

	RGB.prototype.toggle = function() {
	  return this[this.isOn ? "off" : "on"]();
	};

	RGB.prototype.stop = function() {
	  var state = priv.get(this);

	  clearInterval(state.interval);
	  delete state.interval;

	  return this;
	};

	RGB.prototype.intensity = function(intensity) {
	  var state = priv.get(this);

	  if (arguments.length === 0) {
	    return state.intensity;
	  }

	  state.intensity = __.constrain(intensity, 0, 100);

	  this.update();

	  return this;
	};

	module.exports = RGB;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var LedControl = __webpack_require__(159);

	// stub implementation; extract functionality from ledcontrol.js
	function Matrix(opts) {
	  opts.isMatrix = true;
	  return new LedControl(opts);
	}

	Object.assign(Matrix, LedControl, {
	  CHARS: LedControl.MATRIX_CHARS
	});

	module.exports = Matrix;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
	  About the original version of ledcontrol.js:

	  This was originally a port by Rebecca Murphey of the LedControl library
	  and also includes a port of the AdaFruit LEDBackpack library
	  (MIT License, Copyright (c) 2012 Adafruit Industries)

	  The license of the original LedControl library is as follows:

	  LedControl.cpp - A library for controling Leds with a MAX7219/MAX7221
	  Copyright (c) 2007 Eberhard Fahle

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation
	  files (the "Software"), to deal in the Software without
	  restriction, including without limitation the rights to use,
	  copy, modify, merge, publish, distribute, sublicense, and/or sell
	  copies of the Software, and to permit persons to whom the
	  Software is furnished to do so, subject to the following
	  conditions:

	  This permission notice shall be included in all copies or
	  substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	  OTHER DEALINGS IN THE SOFTWARE.

	 */
	var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var ledCharacters = __webpack_require__(160);

	// Led instance private data
	var priv = new Map(),
	  Controllers;

	function LedControl(opts) {

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  /*
	   device instance uses an interface from Controllers:
	   either MAX 7219 (default) or HT16K33
	   */
	  var controller;

	  if (typeof opts.controller === "string") {
	    controller = Controllers[opts.controller];
	  } else {
	    controller = opts.controller;
	  }

	  if (typeof controller === "undefined") {
	    controller = Controllers.DEFAULT;
	  }

	  // functions from Controller interface

	  this.clear = controller.clear;
	  this.led = controller.led;
	  this.row = controller.row;
	  this.scanLimit = controller.scanLimit;
	  this.send = controller.send;
	  this.sendDigit = controller.sendDigit;
	  this.initialize = controller.initialize;

	  // controller specific op codes
	  this.OP = controller.OP;

	  // digit indexes may be ordered left to right (1) or reversed (-1)
	  this.digitOrder = 1;

	  // Does the device have a built-in colon?
	  if (!this.isMatrix) {
	    this.colon = opts.colon || false;
	  }

	  // extra functions for HT16K33 devices only
	  if (controller.writeDisplay) {
	    this.writeDisplay = controller.writeDisplay;
	  }
	  if (controller.blink) {
	    this.blink = controller.blink;
	  }
	  /*
	    devices variable indicates number of connected LED devices
	    Here's an example of multiple devices:
	    http://tronixstuff.com/2013/10/11/tutorial-arduino-max7219-led-display-driver-ic/
	   */
	  var devices = opts.devices || (opts.addresses ? opts.addresses.length : 1);

	  // TODO: Store this in priv Map.
	  this.status = [];

	  for (var i = 0; i < 64; i++) {
	    this.status[i] = 0x00;
	  }
	  opts.dims = opts.dims || LedControl.MATRIX_DIMENSIONS["8x8"];
	  if (typeof opts.dims === "string") {
	    opts.dims = LedControl.MATRIX_DIMENSIONS[opts.dims];
	  }
	  if (Array.isArray(opts.dims)) {
	    opts.dims = {
	      rows: opts.dims[0],
	      columns: opts.dims[1],
	    };
	  }
	  var state = {
	    devices: devices,
	    digits: opts.digits || 8,
	    isMatrix: !!opts.isMatrix,
	    isBicolor: !!opts.isBicolor,
	    rows: opts.dims.rows,
	    columns: opts.dims.columns
	  };

	  if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {
	    throw new Error("Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16");
	  }

	  Object.defineProperties(this, {
	    devices: {
	      get: function() {
	        return state.devices;
	      }
	    },
	    digits: {
	      get: function() {
	        return state.digits;
	      }
	    },
	    isMatrix: {
	      get: function() {
	        return state.isMatrix;
	      }
	    },
	    isBicolor: {
	      get: function() {
	        return state.isBicolor;
	      }
	    },
	    rows: {
	      get: function() {
	        return state.rows;
	      }
	    },
	    columns: {
	      get: function() {
	        return state.columns;
	      }
	    }
	  });

	  priv.set(this, state);
	  controller.initialize.call(this, opts);
	}

	LedControl.prototype.each = function(callbackfn) {
	  for (var i = 0; i < this.devices; i++) {
	    callbackfn.call(this, i);
	  }
	};

	LedControl.prototype.on = function(addr) {
	  if (typeof addr === "undefined") {
	    this.each(function(device) {
	      this.on(device);
	    });
	  } else {
	    this.send(addr, this.OP.SHUTDOWN || LedControl.OP.SHUTDOWN, 1);
	  }
	  return this;
	};

	LedControl.prototype.off = function(addr) {
	  if (typeof addr === "undefined") {
	    this.each(function(device) {
	      this.off(device);
	    });
	  } else {
	    this.send(addr, this.OP.SHUTDOWN || LedControl.OP.SHUTDOWN, 0);
	  }
	  return this;
	};

	LedControl.prototype.setLed = function(addr, chr, val, dp) {
	  console.log("The `setLed` method is deprecated, use `led` instead");
	  return this.led(addr, chr, val, dp);
	};

	/**
	 * digit Display a digit and optional decimal point.
	 * @param  {Number} addr      Device address
	 * @param  {Number} position  0-7
	 * @param  {String} val       0-9[.]
	 * @return {LedControl}
	 */
	LedControl.prototype.digit = function(addr, position, chr) {
	  var args, offset, index, character, value;
	  var hasDecimal = false;

	  if (arguments.length < 3) {
	    args = Array.from(arguments);
	    this.each(function(device) {
	      this.digit.apply(this, (args.unshift(device), args));
	    });
	    return this;
	  }

	  if (this.isMatrix) {
	    // Not sure this is the best path, will check when segment
	    // devices are available.
	    this.draw.apply(this, arguments);
	    return this;
	  }

	  offset = addr * this.digits;

	  character = String(chr);
	  position = Number(position);

	  // If controller's indexes are ordered right to left, flip
	  // the index around.
	  index = position;
	  if (this.digitOrder === -1) {
	    index = this.digits - index - 1;
	  }

	  if (character.length === 2 && character[1] === ".") {
	    hasDecimal = true;
	    character = character[0];
	  }

	  value = LedControl.DIGIT_CHARS[character];

	  if (!value) {
	    value = Math.abs(Number(character));
	  }

	  if (hasDecimal) {
	    value = value | LedControl.DIGIT_CHARS["."];
	  }

	  this.status[offset + index] = value;
	  this.sendDigit(addr, index, value);
	  return this;
	};

	/**
	 * print Print series of characters to the display.
	 * @param  {String} message One or more characters to be displayed.
	 * @param  {Object} opts    (Optional) Options specifying:
	 *                          - device: {Number} Device address
	 * @return {LedControl}
	 */
	LedControl.prototype.print = function(message, opts) {
	  var rdigchars = /([0-9A-Za-z][.]|[0-9A-Za-z:]|[\s])/g;
	  var characters;

	  opts = opts || {
	    device: 0
	  };

	  if (this.isMatrix) {
	    // figure out what to do with Matrix displays
	    throw new Error("Led.Matrix does not yet support the print method");
	  }

	  if (typeof message !== "string") {
	    message = String(message);
	  }

	  characters = message.match(rdigchars);

	  // When a device has a built-in colon, ie. "00:00",
	  // then attempt to make it less awkward to print words across
	  // the display by splicing in a " " placeholder, but only
	  // when necessary.
	  if (this.colon) {
	    if (characters.length > 2 &&
	      (characters[2] !== ":" && characters[2] !== " ")) {
	      characters.splice(2, 0, " ");
	    }
	  }

	  (characters || []).forEach(function(character, position) {
	    this.digit(opts.device, position, character);
	  }, this);
	  return this;
	};

	/*
	 * brightness
	 * @param {Number} addr Address of Led device
	 * @param {Number} val Brightness value
	 */
	LedControl.prototype.brightness = function(addr, val) {
	  if (arguments.length === 1) {
	    val = addr;
	    this.each(function(device) {
	      this.brightness(device, val);
	    });
	  } else {
	    this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));
	  }
	  return this;
	};
	/**
	 * column Update an entire column with an 8 or 16 bit value
	 * @param  {Number} addr Device address
	 * @param  {Number} col  0 indexed col number 0-7
	 * @param  {Number} val  8-bit 0-0xFF (for 8x8 or 16x8 matrix) or 16-bit 0-0xFFFF (for 8x16) value
	 * @return {LedControl}
	 */
	LedControl.prototype.column = function(addr, col, value ) {
	  var state;
	  if (!this.isMatrix) {
	    console.log("The `column` method is only supported for Matrix devices");
	  }
	  if (arguments.length === 2) {
	    value = col;
	    col = addr;
	    this.each(function(device) {
	      this.column(device, col, value);
	    });
	  } else {
	    for (var row = 0; row < this.rows; row++) {
	      state = value >> ((this.rows - 1) - row);
	      state = state & 0x01;
	      this.led(addr, row, col, state);
	    }
	  }

	  return this;
	};

	/**
	 * draw Draw a character
	 * @param  {Number} addr  Device address
	 * @param  {Number} chr   Character to draw
	 *
	 * Used as pass-through to .digit
	 *
	 * @param  {Number} val   8-bit value 0-255
	 * @param  {Number} dp    ugly
	 * @return {LedControl}
	 */
	LedControl.prototype.draw = function(addr, chr) {
	  // in matrix mode, this takes two arguments:
	  // addr and the character to display
	  var character;

	  if (arguments.length === 1) {
	    chr = addr;
	    this.each(function(device) {
	      this.draw(device, chr);
	    });
	  } else {

	    if (this.isMatrix) {
	      if (Array.isArray(chr)) {
	        character = chr;
	      } else {
	        character = ledCharacters.MATRIX_CHARS[chr];
	      }

	      if (character !== undefined) {
	        if (character.length !== this.rows && character.length !== this.columns) {
	          throw new Error("character is invalid: " + character);
	        }
	        // pad character to match number of rows suppported by device
	        var charLength = character.length;

	        for (var i = 0; i < (this.rows - charLength); i++) {
	          character.push(0);
	        }

	        character.forEach(function(rowData, idx) {
	          this.row(addr, idx, rowData);
	        }, this);
	      }
	    } else {

	      // in seven-segment mode, this takes four arguments, which
	      // are just passed through to digit
	      this.digit.apply(this, arguments);
	    }
	  }

	  return this;
	};

	LedControl.prototype.shift = function(addr, direction, distance) {

	  if (arguments.length === 2) {
	    distance = direction;
	    direction = addr;
	    this.each(function() {
	      this.shift(addr, direction, distance);
	    });
	  } else {

	  }

	  return this;
	};

	LedControl.prototype.char = function(addr, chr, val, dp) {
	  console.log("The `char` method is deprecated, use `draw` instead");

	  return this.draw(addr, chr, val, dp);
	};

	LedControl.prototype.device = function(addr) {
	  var bound = {};

	  /* keys from prototype */
	  Object.keys(LedControl.prototype).forEach(function(key) {
	    bound[key] = this[key].bind(this, addr);
	  }, this);

	  /* functions from interface */
	  Object.getOwnPropertyNames(this).forEach(function(key) {
	    if (this[key] && typeof this[key] === "function") {
	      bound[key] = this[key].bind(this, addr);
	    }
	  }, this);
	  return bound;
	};

	var addresses = new Set([0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77]);

	Controllers = {
	  HT16K33: {
	    OP: {
	      SHUTDOWN: 0x20,
	      BRIGHTNESS: 0xE0,
	      BLINK: 0x80
	    },
	    initialize: function(opts) {
	      var state = priv.get(this);
	      var available = Array.from(addresses);

	      if (available.length === 0) {
	        throw new Error("There are no available HT16K33 controller addresses");
	      }

	      this.addresses = opts.addresses || (opts.address ? [opts.address] : null);

	      // use default range of addresses if addresses aren't specified
	      if (this.addresses === null) {
	        this.addresses = available.slice(0, state.devices);
	      }

	      this.addresses.forEach(function(address) {
	        if (!addresses.has(address)) {
	          throw new Error("Invalid HT16K33 controller address: " + address);
	        }
	        addresses.delete(address);
	      });

	      this.rotation = opts.rotation || 1;
	      // set a default rotation that works with AdaFruit 16x8 matrix if using 16 columns
	      if (this.columns === 16 && !opts.rotation) {
	        this.rotation = 0;
	      }
	      this.displaybuffers = [];
	      for (var i = 0; i < this.rows; i++) {
	        this.displaybuffers[i] = [];
	      }

	      if (!this.isMatrix) {
	        this.colon = true;
	      }

	      // Set up I2C data connection
	      this.io.i2cConfig(opts);
	      // TODO allow setup to be configured through opts
	      this.each(function(device) {
	        this.on(device);
	        this.blink(device, 1);
	        this.brightness(device, 100);
	        this.clear(device);
	      });
	    },
	    blink: function(addr, val) {
	      if (arguments.length === 1) {
	        val = addr;
	        this.each(function(device) {
	          this.brightness(device, val);
	        });
	      } else {
	        //var BLINK = 0x80;
	        //this.io.i2cWrite(this.addresses[addr], [BLINK | val]);
	        this.send(addr, this.OP.BLINK, val);
	      }
	      return this;
	    },

	    /*
	     * clear
	     * @param {Number} addr Address of Led device
	     */
	    clear: function(addr) {
	      var offset;
	      if (typeof addr === "undefined") {
	        this.each(function(device) {
	          this.clear(device);
	        });
	      } else {
	        offset = addr * this.columns;

	        for (var i = 0; i < this.rows; i++) {
	          this.status[offset + i] = 0;
	          this.displaybuffers[addr][i] = 0;
	        }
	        this.writeDisplay(addr);
	      }
	      return this;
	    },
	    /**
	     * led or setLed Set the status of a single Led.
	     *
	     * @param {Number} addr Address of Led
	     * @param {Number} row Row number of Led (0-7)
	     * @param {Number} column Column number of Led (0-7)
	     * @param {Boolean} state [ true: on, false: off ] [ 1, 0 ] or an LedControl color code
	     *
	     */
	    led: function(addr, row, col, state) {
	      if (arguments.length === 3) {
	        state = col;
	        col = row;
	        row = addr;
	        this.each(function(device) {
	          this.led(device, row, col, state);
	        });
	      } else {
	        var x = col;
	        var y = row;
	        var tmp, rows = this.rows, columns = this.columns;
	        if ((y < 0) || (y >= rows)) {
	          return;
	        }
	        if ((x < 0) || (x >= columns)) {
	          return;
	        }
	        switch (this.rotation) {
	          case 1:
	            columns = this.rows;
	            rows = this.columns;
	            tmp = x;
	            x = y;
	            y = tmp;
	            x = columns - x - 1;
	            break;
	          case 2:
	            x = columns - x - 1;
	            y = rows - y - 1;
	            break;
	          case 3:
	            columns = this.rows;
	            rows = this.columns;
	            tmp = x;
	            x = y;
	            y = tmp;
	            y = rows - y - 1;
	            break;
	        }
	        if (!this.isBicolor) {
	          // x needs to be wrapped around for single color 8x8 AdaFruit matrix
	          if (columns === 8 && rows === 8) {
	            x += columns - 1;
	            x %= columns;
	          }
	          if (state) {
	            this.displaybuffers[addr][y] |= 1 << x;
	          } else {
	            this.displaybuffers[addr][y] &= ~(1 << x);
	          }
	        } else {
	          // 8x8 bi-color matrixes only
	          if (state === LedControl.COLORS.GREEN) {
	            // Turn on green LED.
	            this.displaybuffers[addr][y] |= 1 << x;
	            // Turn off red LED.
	            this.displaybuffers[addr][y] &= ~(1 << (x + 8));
	          } else if (state === LedControl.COLORS.YELLOW) {
	            // Turn on green and red LED.
	            this.displaybuffers[addr][y] |= (1 << (x + 8)) | (1 << x);
	          } else if (state) {
	            // Turn on red LED.
	            this.displaybuffers[addr][y] |= 1 << (x + 8);
	            // Turn off green LED.
	            this.displaybuffers[addr][y] &= ~(1 << x);
	          } else {
	            // Turn off green and red LED.
	            this.displaybuffers[addr][y] &= ~(1 << x) & ~(1 << (x + 8));
	          }
	        }
	        this.writeDisplay(addr);
	      }
	      return this;
	    },
	    writeDisplay: function(addr) {
	      var bytes = [0x00];
	      // always writes 8 rows (for 8x16, the values have already been rotated)
	      for (var i = 0; i < 8; i++) {
	        bytes.push(this.displaybuffers[addr][i] & 0xFF);
	        bytes.push(this.displaybuffers[addr][i] >> 8);
	      }
	      this.io.i2cWrite(this.addresses[addr], bytes);
	    },

	    /**
	     * row Update an entire row with an 8 bit value
	     * @param  {Number} addr Device address
	     * @param  {Number} row  0 indexed row number 0-7
	     * @param  {Number} val  8-bit value 0-255
	     * @return {LedControl}
	     */
	    row: function(addr, row, val /* 0 - 0xFFFF or string */ ) {
	      if (!this.isMatrix) {
	        console.log("The `row` method is only supported for Matrix devices");
	      }
	      if (typeof val === "number") {
	        val = ("0000000000000000" + parseInt(val, 10).toString(2)).substr(0-(this.columns), this.columns);
	      }
	      if (arguments.length === 2) {
	        val = row;
	        row = addr;
	        this.each(function(device) {
	          this.row(device, row, val);
	        });
	      } else {

	        // call the led function because the handling of rotation
	        // and wrapping for monochrome matrixes is done there
	        for (var i = 0; i < this.columns; i++) {
	          this.led(addr, row, i, parseInt(val[i], 10));
	        }
	      }

	      return this;
	    },

	    scanLimit: function() {
	      console.log("The scanLimit function is not implemented for HT16K33 devices");
	      return this;
	    },

	    /*
	     * doSend
	     * @param {Number} addr Address of Led device
	     * @param {Number} opcode Operation code
	     * @param {Number} data Data
	     */
	    send: function(addr, opcode, data) {
	      if (arguments.length !== 3) {
	        throw new Error("`send` expects three arguments: device, opcode, data");
	      }
	      this.io.i2cWrite(this.addresses[addr], [opcode | data]);
	      return this;
	    },

	    /**
	     * sendDigit
	     * @param  {Number} addr     Device address.
	     * @param  {Number} index    0-7
	     * @param  {Number} code     8-bit value 0-255
	     * @return {LedControl}
	     */
	    sendDigit: function(addr, index, code) {
	      // Given:
	      //
	      //   0 === 0b00000000
	      // 255 === 0b11111111
	      //
	      // ...0 & 255 can be skipped.
	      //
	      if (code > 0 && code < 255) {
	        // Convert from hex to binary, padded to 8 bits.
	        code = ("00000000" + code.toString(2)).slice(-8).split("");
	        // Reverse bits for each display segment except the decimal,
	        // to match the HT16K33 controller's segment ordering.
	        code = code.shift() + code.reverse().join("");
	        code = parseInt(code, 2);
	      }

	      // Convert to decimal and write to the display.
	      this.displaybuffers[addr][index] = code;
	      this.writeDisplay(addr);
	      return this;
	    },
	  },

	  DEFAULT: {
	    OP: {},
	    initialize: function(opts) {

	      this.pins = {
	        data: opts.pins.data,
	        clock: opts.pins.clock,
	        cs: opts.pins.cs || opts.pins.latch
	      };
	      ["data", "clock", "cs"].forEach(function(pin) {
	        this.io.pinMode(this.pins[pin], this.io.MODES.OUTPUT);
	      }, this);
	      // NOTE: Currently unused, these will form
	      // the basis for the `setup` constructor option
	      // var setup = Object.assign({}, LedControl.DEFAULTS, opts.setup || {});
	      // var keys = Object.keys(setup);

	      // digit indexes ordered right to left.
	      this.digitOrder = -1;
	      this.digitOrder = -1;

	      for (var device = 0; device < this.devices; device++) {
	        /*
	          TODO: Add support for custom initialization

	          An example of initialization, added to the constructor options:

	            setup: {
	              // OPCODE: VALUE
	              DECODING: 0,
	              BRIGHTNESS: 3,
	              SCANLIMIT: 7,
	              SHUTDOWN: 1,
	              DISPLAYTEST: 1
	            },


	          In context:

	            var lc = new five.LedControl({
	              pins: {
	                data: 2,
	                clock: 3,
	                cs: 4
	              },
	              setup: {
	                DECODING: 0,
	                BRIGHTNESS: 3,
	                SCANLIMIT: 7,
	                SHUTDOWN: 1,
	                DISPLAYTEST: 1
	              },
	              isMatrix: true
	            });


	          The custom initializers are invoked as:

	            keys.forEach(function(key) {
	              this.send(device, LedControl.OP[key], setup[key]);
	            }, this);


	          I might be missing something obvious, but this isn't working.
	          Using the same options shown below, the above should behave exactly the
	          same way that the code below does, but that's not the case. The result is
	          all leds in the matrix are lit and none can be cleared.
	          */
	        if (this.isMatrix) {
	          this.send(device, LedControl.OP.DECODING, 0);
	        }

	        this.send(device, LedControl.OP.BRIGHTNESS, 3);
	        this.send(device, LedControl.OP.SCANLIMIT, 7);
	        this.send(device, LedControl.OP.SHUTDOWN, 1);
	        this.send(device, LedControl.OP.DISPLAYTEST, 0);

	        this.clear(device);
	        this.on(device);
	      }
	      return this;

	    },
	    clear: function(addr) {
	      var offset;

	      if (typeof addr === "undefined") {
	        this.each(function(device) {
	          this.clear(device);
	        });
	      } else {
	        offset = addr * 8;

	        for (var i = 0; i < 8; i++) {
	          this.status[offset + i] = 0;
	          this.send(addr, i + 1, 0);
	        }
	      }
	      return this;
	    },

	    /**
	     * sendDigit
	     * @param  {Number} addr     Device address.
	     * @param  {Number} index    0-7
	     * @param  {Number} code     8-bit value 0-255
	     * @return {LedControl}
	     */
	    sendDigit: function(addr, index, code) {
	      this.send(addr, index + 1, code);
	      return this;
	    },

	    /**
	     * led or setLed Set the status of a single Led.
	     *
	     * @param {Number} addr Address of Led
	     * @param {Number} row Row number of Led (0-7)
	     * @param {Number} column Column number of Led (0-7)
	     * @param {Boolean} state [ true: on, false: off ] [ 1, 0 ]
	     *
	     */
	    led: function(addr, row, col, state) {
	      var offset, val;

	      if (arguments.length === 3) {
	        state = col;
	        col = row;
	        row = addr;
	        this.each(function(device) {
	          this.led(device, row, col, state);
	        });
	      } else {
	        offset = addr * this.columns;
	        val = 0x80 >> col;

	        if (state) {
	          this.status[offset + row] = this.status[offset + row] | val;
	        } else {
	          val = ~val;
	          this.status[offset + row] = this.status[offset + row] & val;
	        }
	        this.send(addr, row + 1, this.status[offset + row]);
	      }

	      return this;
	    },

	    /**
	     * row Update an entire row with an 8 bit value
	     * @param  {Number} addr Device address
	     * @param  {Number} row  0 indexed row number 0-7
	     * @param  {Number} val  8-bit value 0-255
	     * @return {LedControl}
	     */
	    row: function(addr, row, val /* 0 - 255 or string */ ) {
	      if (!this.isMatrix) {
	        console.log("The `row` method is only supported for Matrix devices");
	      }
	      var offset;
	      if (typeof val === "string") {
	        val = parseInt(val, 2);
	      }
	      if (arguments.length === 2) {
	        val = row;
	        row = addr;
	        this.each(function(device) {
	          this.row(device, row, val);
	        });
	      } else {
	        offset = addr * this.columns;
	        this.status[offset + row] = val;
	        this.send(addr, row + 1, this.status[offset + row]);
	      }

	      return this;
	    },
	    /*
	     * scanLimit (function from interface)
	     * @param {Number} addr Address of Led device
	     * @param {Number} limit
	     */
	    scanLimit: function(addr, limit) {
	      if (arguments.length === 1) {
	        limit = addr;
	        this.each(function(device) {
	          this.scanLimit(device, limit);
	        });
	      } else {
	        this.send(addr, LedControl.OP.SCANLIMIT, limit);
	      }
	      return this;
	    },
	    send: function(addr, opcode, data) {
	      if (arguments.length !== 3) {
	        throw new Error("`send` expects three arguments: device, opcode, data");
	      }
	      var offset = addr * 2;
	      var maxBytes = this.devices * 2;
	      var spiData = [];

	      if (addr < this.devices) {
	        for (var i = 0; i < maxBytes; i++) {
	          spiData[i] = 0;
	        }

	        spiData[offset + 1] = opcode;
	        spiData[offset] = data;

	        this.board.digitalWrite(this.pins.cs, this.io.LOW);

	        for (var j = maxBytes; j > 0; j--) {
	          this.board.shiftOut(this.pins.data, this.pins.clock, spiData[j - 1]);
	        }

	        this.board.digitalWrite(this.pins.cs, this.io.HIGH);
	      }

	      return this;
	    }
	  }
	};

	// NOTE: Currently unused, these will form
	// the basis for the `setup` constructor option
	LedControl.DEFAULTS = {
	  DECODING: 0x00,
	  BRIGHTNESS: 0x03,
	  SCANLIMIT: 0x07,
	  SHUTDOWN: 0x01,
	  DISPLAYTEST: 0x00
	};

	Object.freeze(LedControl.DEFAULTS);

	LedControl.OP = {};

	LedControl.OP.NOOP = 0x00;

	LedControl.OP.DIGIT0 = 0x01;
	LedControl.OP.DIGIT1 = 0x02;
	LedControl.OP.DIGIT2 = 0x03;
	LedControl.OP.DIGIT3 = 0x04;
	LedControl.OP.DIGIT4 = 0x05;
	LedControl.OP.DIGIT5 = 0x06;
	LedControl.OP.DIGIT6 = 0x07;
	LedControl.OP.DIGIT7 = 0x08;

	LedControl.OP.DECODEMODE = 0x09;
	LedControl.OP.INTENSITY = 0x0a;
	LedControl.OP.SCANLIMIT = 0x0b;
	LedControl.OP.SHUTDOWN = 0x0c;
	LedControl.OP.DISPLAYTEST = 0x0f;

	// Aliases
	LedControl.OP.BRIGHTNESS = LedControl.OP.INTENSITY;
	LedControl.OP.DECODING = LedControl.OP.DECODEMODE;
	LedControl.OP.DISPLAY = LedControl.OP.DISPLAYTEST;
	LedControl.OP.POWERDOWN = LedControl.OP.SHUTDOWN;

	Object.freeze(LedControl.OP);

	LedControl.COLORS = {
	  "RED": 1,
	  "YELLOW": 2,
	  "GREEN": 3
	};

	LedControl.DIRECTIONS = {
	  UP: 1,
	  RIGHT: 2,
	  DOWN: 3,
	  LEFT: 4,
	  1: "UP",
	  2: "RIGHT",
	  3: "DOWN",
	  4: "LEFT",
	};

	Object.freeze(LedControl.DIRECTIONS);

	// Double Digit Numbers
	//
	// Each digit:
	//
	// - is drawn as far to the left as possible.
	// - uses 3 bits
	//
	var digits = [
	  [0xe0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xe0, 0x00],
	  [0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00],
	  [0xe0, 0x20, 0x20, 0xe0, 0x80, 0x80, 0xe0, 0x00],
	  [0xe0, 0x20, 0x20, 0x60, 0x20, 0x20, 0xe0, 0x00],
	  [0x20, 0x60, 0xa0, 0xe0, 0x20, 0x20, 0x20, 0x00],
	  [0xe0, 0x80, 0x80, 0xe0, 0x20, 0x20, 0xe0, 0x00],
	  [0xe0, 0x80, 0x80, 0xe0, 0xa0, 0xa0, 0xe0, 0x00],
	  [0xe0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00],
	  [0xe0, 0xa0, 0xa0, 0x40, 0xa0, 0xa0, 0xe0, 0x00],
	  [0xe0, 0xa0, 0xa0, 0xe0, 0x20, 0x20, 0xe0, 0x00],
	];

	var charName = "";

	for (var i = 0; i < 10; i++) {
	  for (var k = 0; k < 10; k++) {
	    charName = i + "" + k;
	    ledCharacters.MATRIX_CHARS[charName] = [];

	    for (var j = 0; j < 8; j++) {
	      // Left digit takes 3 bits, plus 1 to between digits = 4 bits to the right.
	      ledCharacters.MATRIX_CHARS[charName][j] = digits[i][j] | (digits[k][j] >>> 4);
	    }
	  }
	}

	LedControl.MATRIX_DIMENSIONS = {
	  "16x8": { rows: 16, columns: 8 },
	  "8x16": { rows: 8, columns: 16 },
	  "8x8": { rows: 8, columns: 8 }
	};

	LedControl.MATRIX_CHARS = ledCharacters.MATRIX_CHARS;
	LedControl.DIGIT_CHARS = ledCharacters.DIGIT_CHARS;

	if (IS_TEST_MODE) {
	  LedControl.reset = function() {
	    addresses = new Set([0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77]);
	    priv.clear();
	  };
	}
	module.exports = LedControl;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 160 */
/***/ function(module, exports) {

	// https://dl.dropboxusercontent.com/u/3531958/digits.html

	module.exports = {
	  MATRIX_CHARS: {
	    //symbols & punctuation
	    " ": [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
	    "!": [0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x04, 0x00],
	    "\"": [0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00],
	    "#": [0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A, 0x00],
	    "$": [0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04, 0x00],
	    "%": [0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03, 0x00],
	    "&": [0x0C, 0x12, 0x14, 0x08, 0x15, 0x12, 0x0D, 0x00],
	    "'": [0x0C, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00],
	    "(": [0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02, 0x00],
	    ")": [0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00],
	    "*": [0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00, 0x00],
	    "+": [0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00, 0x00],
	    ",": [0x00, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x08, 0x00],
	    "-": [0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00],
	    ".": [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00],
	    "/": [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00],
	    "[": [0x0E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00],
	    "\\": [0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00],
	    "]": [0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x00],
	    "^": [0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00],
	    "_": [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00],
	    "`": [0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00],
	    ":": [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00, 0x00],
	    ";": [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08, 0x00],
	    "<": [0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00],
	    "=": [0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00, 0x00],
	    ">": [0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x00],
	    "?": [0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04, 0x00],
	    "@": [0x0E, 0x11, 0x01, 0x0D, 0x15, 0x15, 0x0E, 0x00],
	    "{": [0x02, 0x04, 0x04, 0x08, 0x04, 0x04, 0x02, 0x00],
	    "|": [0x04, 0x04, 0x04, 0x00, 0x04, 0x04, 0x04, 0x00],
	    "}": [0x08, 0x04, 0x04, 0x02, 0x04, 0x04, 0x08, 0x00],
	    "~": [0x08, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00],

	    //standard numbers
	    "0": [0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E, 0x00],
	    "1": [0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00],
	    "2": [0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F, 0x00],
	    "3": [0x1F, 0x02, 0x04, 0x02, 0x01, 0x11, 0x0E, 0x00],
	    "4": [0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02, 0x00],
	    "5": [0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E, 0x00],
	    "6": [0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E, 0x00],
	    "7": [0x1F, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x00],
	    "8": [0x1E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E, 0x00],
	    "9": [0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C, 0x00],
	   
	    //capital letters
	    "A": [0x08, 0x14, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x22],
	    "B": [0x3C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x3C, 0x00],
	    "C": [0x3C, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3C, 0x00],
	    "D": [0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00],
	    "E": [0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x7C],
	    "F": [0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40],
	    "G": [0x3C, 0x40, 0x40, 0x40, 0x40, 0x44, 0x44, 0x3C],
	    "H": [0x44, 0x44, 0x44, 0x7C, 0x44, 0x44, 0x44, 0x44],
	    "I": [0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C],
	    "J": [0x3C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x48, 0x30],
	    "K": [0x00, 0x24, 0x28, 0x30, 0x20, 0x30, 0x28, 0x24],
	    "L": [0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7C],
	    "M": [0x81, 0xC3, 0xA5, 0x99, 0x81, 0x81, 0x81, 0x81],
	    "N": [0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00],
	    "O": [0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C],
	    "P": [0x3C, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20],
	    "Q": [0x1C, 0x22, 0x22, 0x22, 0x22, 0x26, 0x22, 0x1D],
	    "R": [0x3C, 0x22, 0x22, 0x22, 0x3C, 0x24, 0x22, 0x21],
	    "S": [0x00, 0x1E, 0x20, 0x20, 0x3E, 0x02, 0x02, 0x3C],
	    "T": [0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08],
	    "U": [0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x22, 0x1C],
	    "V": [0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18],
	    "W": [0x00, 0x49, 0x49, 0x49, 0x49, 0x2A, 0x1C, 0x00],
	    "X": [0x00, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41],
	    "Y": [0x41, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08],
	    "Z": [0x00, 0x7F, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7F],
	    
	    //question: do these need to stay or what?
	    // "A": [0x0E, 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x00],
	    // "B": [0x1E, 0x09, 0x09, 0x0E, 0x09, 0x09, 0x1E, 0x00],
	    // "C": [0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E, 0x00],
	    // "D": [0x1E, 0x09, 0x09, 0x09, 0x09, 0x09, 0x1E, 0x00],
	    // "E": [0x1F, 0x10, 0x10, 0x1F, 0x10, 0x10, 0x1F, 0x00],
	    // "F": [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10, 0x00],
	    // "G": [0x0E, 0x11, 0x10, 0x13, 0x11, 0x11, 0x0F, 0x00],
	    // "H": [0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11, 0x00],
	    // "I": [0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00],
	    // "J": [0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C, 0x00],
	    // "K": [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00],
	    // "L": [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x00],
	    // "M": [0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11, 0x00],
	    // "N": [0x11, 0x19, 0x19, 0x15, 0x13, 0x13, 0x11, 0x00],
	    // "O": [0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E, 0x00],
	    // "P": [0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10, 0x00],
	    // "Q": [0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x1D, 0x00],
	    // "R": [0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11, 0x00],
	    // "S": [0x0E, 0x11, 0x10, 0x0E, 0x01, 0x11, 0x0E, 0x00],
	    // "T": [0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00],
	    // "U": [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E, 0x00],
	    // "V": [0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04, 0x00],
	    // "W": [0x11, 0x11, 0x11, 0x15, 0x15, 0x1B, 0x11, 0x00],
	    // "X": [0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11, 0x00],
	    // "Y": [0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04, 0x00],
	    // "Z": [0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F, 0x00],
	    
	    //lowercase letters
	    "a": [0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F, 0x00],
	    "b": [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x1E, 0x00],
	    "c": [0x00, 0x00, 0x0E, 0x11, 0x10, 0x11, 0x0E, 0x00],
	    "d": [0x01, 0x01, 0x0D, 0x13, 0x11, 0x11, 0x0F, 0x00],
	    "e": [0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E, 0x00],
	    "f": [0x02, 0x05, 0x04, 0x0E, 0x04, 0x04, 0x04, 0x00],
	    "g": [0x00, 0x0D, 0x13, 0x13, 0x0D, 0x01, 0x0E, 0x00],
	    "h": [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11, 0x00],
	    "i": [0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E, 0x00],
	    "j": [0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C, 0x00],
	    "k": [0x08, 0x08, 0x09, 0x0A, 0x0C, 0x0A, 0x09, 0x00],
	    "l": [0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00],
	    "m": [0x00, 0x00, 0x1A, 0x15, 0x15, 0x15, 0x15, 0x00],
	    "n": [0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11, 0x00],
	    "o": [0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E, 0x00],
	    "p": [0x00, 0x16, 0x19, 0x19, 0x16, 0x10, 0x10, 0x00],
	    "q": [0x00, 0x0D, 0x13, 0x13, 0x0D, 0x01, 0x01, 0x00],
	    "r": [0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10, 0x00],
	    "s": [0x00, 0x00, 0x0F, 0x10, 0x1E, 0x01, 0x1F, 0x00],
	    "t": [0x08, 0x08, 0x1C, 0x08, 0x08, 0x09, 0x06, 0x00],
	    "u": [0x00, 0x00, 0x12, 0x12, 0x12, 0x12, 0x0D, 0x00],
	    "v": [0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04, 0x00],
	    "w": [0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A, 0x00],
	    "x": [0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x00],
	    "y": [0x00, 0x00, 0x11, 0x11, 0x13, 0x0D, 0x01, 0x0E],
	    "z": [0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F, 0x00],

	    //misc.
	    euro: [0x0e, 0x10, 0x7c, 0x20, 0x7c, 0x20, 0x10, 0x0e],
	    cent: [0x00, 0x3c, 0x42, 0x40, 0x40, 0x52, 0x3c, 0x20],

	    //emojis + objects
	    angryface: [0x00, 0x66, 0x66, 0x00, 0x18, 0x24, 0x42, 0x81],
	    circle: [0x3c, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3c],
	    cdot: [0x3c, 0x42, 0x81, 0x99, 0x99, 0x81, 0x42, 0x3c],
	    donut: [0x3c, 0x7e, 0xff, 0xe7, 0xe7, 0xff, 0x7e, 0x3c],
	    equality: [0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00],
	    ball: [0x3c, 0x7e, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x3c],
	    thinsquare: [0xff, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xff],
	    thicksquare: [0xff, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xff],
	    centeredsquare1: [0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00],
	    centeredsquare2: [0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00],
	    arrowright: [0x00, 0x04, 0x06, 0xff, 0xff, 0x06, 0x04, 0x00],
	    arrowleft: [0x00, 0x20, 0x60, 0xff, 0xff, 0x60, 0x20, 0x00],
	    note: [0x04, 0x06, 0x07, 0x04, 0x3c, 0x7c, 0x7c, 0x38],
	    clock: [0x3c, 0x52, 0x91, 0x91, 0x8f, 0x81, 0x42, 0x3c],
	    heartoutline: [0x66, 0x99, 0x81, 0x81, 0x42, 0x24, 0x18, 0x00],
	    heartfull: [0x66, 0xff, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00],
	    thincheck: [0x00, 0x00, 0x01, 0x02, 0x04, 0x88, 0x50, 0x20],
	    thickcheck: [0x00, 0x01, 0x03, 0x06, 0x8c, 0xd8, 0x70, 0x20],
	    speaker: [0x03, 0x07, 0x3f, 0x3f, 0x3f, 0x3f, 0x07, 0x03],
	    sound: [0x00, 0x40, 0x80, 0x00, 0xc0, 0x00, 0x80, 0x40],
	    xbig: [0xc3, 0xe7, 0x7e, 0x3c, 0x3c, 0x7e, 0xe7, 0xc3],
	    target: [0x3c, 0x7e, 0xc3, 0xdb, 0xdb, 0xc3, 0x7e, 0x3c],
	    bell: [0x18, 0x3c, 0x3c, 0x3c, 0x3c, 0x7e, 0x00, 0x18],
	    smile: [0x00, 0x66, 0x66, 0x00, 0x00, 0x81, 0x42, 0x3c],
	    frown: [0x00, 0x66, 0x66, 0x00, 0x00, 0x3c, 0x42, 0x81],
	    winkright: [0x00, 0x60, 0x66, 0x00, 0x00, 0x81, 0x42, 0x3c],
	    winkleft: [0x00, 0x06, 0x66, 0x00, 0x00, 0x81, 0x42, 0x3c],
	    blink: [0x00, 0x00, 0x66, 0x00, 0x00, 0x81, 0x42, 0x3c],
	    laughing: [0x00, 0x66, 0x66, 0x00, 0xff, 0x81, 0x42, 0x3c],
	    tongueout: [0x00, 0x66, 0x66, 0x00, 0x00, 0x7e, 0x0a, 0x04],
	    expressionless: [0x00, 0x66, 0x66, 0x00, 0x00, 0xff, 0x00, 0x00],

	    //patterns
	    ascprogress1: [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80],
	    ascprogress2: [0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0],
	    ascprogress3: [0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0],
	    ascprogress4: [0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0],
	    ascprogress5: [0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8],
	    ascprogress6: [0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc],
	    ascprogress7: [0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe],
	    fullprogress: [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],
	    descprogress1: [0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f],
	    descprogress2: [0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f],
	    descprogress3: [0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f],
	    descprogress4: [0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f],
	    descprogress5: [0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07],
	    descprogress6: [0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03],
	    descprogress7: [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01],
	    ascchart1: [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
	    ascchart2: [0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
	    ascchart3: [0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00],
	    ascchart4: [0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00],
	    ascchart5: [0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00],
	    ascchart6: [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00],
	    ascchart7: [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00],
	    ascchart8: [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],
	    descchart1: [0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],
	    descchart2: [0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],
	    descchart3: [0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff],
	    descchart4: [0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff],
	    descchart5: [0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff],
	    descchart6: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff],
	    descchart7: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff],
	    descchart8: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
	    borderleft1: [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01],
	    borderleft2: [0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03],
	    borderleft3: [0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x07],
	    borderleft4: [0x0f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f],
	    borderleft5: [0x1f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f],
	    borderleft6: [0x3f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3f],
	    borderleft7: [0x7f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7f],
	    borderleft8: [0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff],
	    bordertopbottom5: [0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff],
	    borderright1: [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80],
	    borderright2: [0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0],
	    borderright3: [0xe0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xe0],
	    borderright4: [0xf0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xf0],
	    borderright5: [0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0xf8],
	    borderright6: [0xfc, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xfc],
	    borderright7: [0xfe, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe],
	    borderright8: [0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff],
	    box1: [0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00],
	    box2: [0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00],
	    box3: [0xe7, 0xe7, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00],
	    box4: [0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07],
	    box5: [0x07, 0x07, 0x07, 0x00, 0x00, 0x07, 0x07, 0x07],
	    box6: [0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x07, 0x07, 0x07],
	    box7: [0xe7, 0xe7, 0xe7, 0x00, 0x00, 0x07, 0x07, 0x07],
	    box8: [0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0xe0],
	    box9: [0x07, 0x07, 0x07, 0x00, 0x00, 0xe0, 0xe0, 0xe0],
	    box10: [0xe0, 0xe0, 0xe0, 0x00, 0x00, 0xe0, 0xe0, 0xe0],
	    box11: [0xe7, 0xe7, 0xe7, 0x00, 0x00, 0xe0, 0xe0, 0xe0],
	    box12: [0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0xe7, 0xe7],
	    box13: [0x07, 0x07, 0x07, 0x00, 0x00, 0xe7, 0xe7, 0xe7],
	    box14: [0xe0, 0xe0, 0xe0, 0x00, 0x00, 0xe7, 0xe7, 0xe7],
	    box15: [0xe7, 0xe7, 0xe7, 0x00, 0x00, 0xe7, 0xe7, 0xe7],
	    checkerboard1: [0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55],
	    checkerboard2: [0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa],
	    checkerboard3: [0x5d, 0xea, 0x57, 0xba, 0x55, 0xee, 0x55, 0xbb],
	    checkerboard4: [0xcc, 0x33, 0x33, 0xcc, 0xcc, 0x33, 0x33, 0xcc],
	    checkerboard5: [0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0x33, 0x33],
	    checkerboard6: [0x33, 0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0x33],
	    checkerboard7: [0x33, 0x33, 0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc],
	    pointerright: [0x20, 0x30, 0x38, 0x3c, 0x3c, 0x38, 0x30, 0x20],
	    pointerup: [0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0x00, 0x00],
	    pointerleft: [0x04, 0x0c, 0x1c, 0x3c, 0x3c, 0x1c, 0x0c, 0x04],
	    pointerdown: [0x00, 0x00, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00],
	    arrowne: [0x00, 0x3e, 0x06, 0x0a, 0x12, 0x22, 0x40, 0x80],
	    arrownw: [0x00, 0x7c, 0x60, 0x50, 0x48, 0x44, 0x02, 0x01],
	    arrowsw: [0x01, 0x02, 0x44, 0x48, 0x50, 0x60, 0x7c, 0x00],
	    arrowse: [0x80, 0x40, 0x22, 0x12, 0x0a, 0x06, 0x3e, 0x00],
	    dice1: [0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00],
	    dice2: [0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03],
	    dice3: [0xc0, 0xc0, 0x00, 0x18, 0x18, 0x00, 0x03, 0x03],
	    dice4: [0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3],
	    dice5: [0xc3, 0xc3, 0x00, 0x18, 0x18, 0x00, 0xc3, 0xc3],
	    dice6: [0xc3, 0xc3, 0x00, 0xc3, 0xc3, 0x00, 0xc3, 0xc3],
	    outlinedplus1: [0x3c, 0x24, 0xe7, 0x81, 0x81, 0xe7, 0x24, 0x3c],
	    outlinedplus2: [0xff, 0xe7, 0xe7, 0x81, 0x81, 0xe7, 0xe7, 0xff],
	    twoboxes1: [0xf0, 0x90, 0x90, 0xf0, 0x0f, 0x09, 0x09, 0x0f],
	    twoboxes2: [0xf0, 0x90, 0x90, 0xfe, 0x12, 0x12, 0x1e, 0x00],
	    twoboxes3: [0xf0, 0x90, 0xbc, 0xf4, 0x24, 0x3c, 0x00, 0x00],
	    twoboxes4: [0xf0, 0xf8, 0xd8, 0xf8, 0x78, 0x00, 0x00, 0x00],
	    twoboxes5: [0x0f, 0x09, 0x09, 0x0f, 0xf0, 0x90, 0x90, 0xf0],
	    fourboxes: [0xff, 0x99, 0x99, 0xff, 0xff, 0x99, 0x99, 0xff],
	    chain1: [0xf0, 0xf8, 0xd8, 0xf8, 0x78, 0x00, 0x00, 0x00],
	    chain2: [0xf0, 0x90, 0xbc, 0xf4, 0x2f, 0x3d, 0x09, 0x0f],
	  },

	  SPECIAL_CHARS: {
	    //thicker numbers
	    "0": [0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c],
	    "1": [0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18],
	    "2": [0x3c, 0x66, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e],
	    "3": [0x3c, 0x66, 0x06, 0x1c, 0x06, 0x06, 0x66, 0x3c],
	    "4": [0x0e, 0x1e, 0x36, 0x66, 0x66, 0x7e, 0x06, 0x06],
	    "5": [0x7e, 0x60, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c],
	    "6": [0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x3c],
	    "7": [0x7e, 0x7e, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x18],
	    "8": [0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x3c],
	    "9": [0x3c, 0x66, 0x66, 0x3e, 0x06, 0x06, 0x66, 0x3c],

	    //Jory's double digits
	    "10": [0x5e, 0x52, 0x52, 0x52, 0x52, 0x5e, 0x00, 0xff],
	    "11": [0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0xff],
	    "12": [0x5e, 0x42, 0x44, 0x48, 0x50, 0x5e, 0x00, 0xff],
	    "13": [0x5e, 0x42, 0x4e, 0x42, 0x42, 0x5e, 0x00, 0xff],
	    "14": [0x52, 0x52, 0x5e, 0x42, 0x42, 0x42, 0x00, 0xff],
	    "15": [0x5e, 0x50, 0x5e, 0x42, 0x42, 0x5e, 0x00, 0xff],
	    "16": [0x5e, 0x50, 0x5e, 0x52, 0x52, 0x5e, 0x00, 0xff],
	    "17": [0x5e, 0x42, 0x44, 0x48, 0x48, 0x48, 0x00, 0xff],
	    "18": [0x5e, 0x52, 0x5e, 0x52, 0x52, 0x5e, 0x00, 0xff],
	    "19": [0x5e, 0x52, 0x5e, 0x42, 0x42, 0x5e, 0x00, 0xff],
	  },

	  DIGIT_CHARS: {
	    "0": 0x7E,
	    "1": 0x30,
	    "2": 0x6D,
	    "3": 0x79,
	    "4": 0x33,
	    "5": 0x5B,
	    "6": 0x5F,
	    "7": 0x70,
	    "8": 0x7F,
	    "9": 0x7B,
	    " ": 0x00,
	    ".": 0x80,
	    ":": 0xFF,
	    "!": 0xB0,
	    "A": 0x77,
	    "a": 0x7D,
	    "B": 0x7F,
	    "b": 0x1F,
	    "C": 0x4E,
	    "c": 0x0D,
	    "D": 0x7E,
	    "d": 0x3D,
	    "E": 0x4F,
	    "e": 0x6f,
	    "F": 0x47,
	    "f": 0x47,
	    "G": 0x5E,
	    "g": 0x7B,
	    "H": 0x37,
	    "h": 0x17,
	    "I": 0x30,
	    "i": 0x10,
	    "J": 0x3C,
	    "j": 0x38,
	    "K": 0x37,
	    "k": 0x17,
	    "L": 0x0E,
	    "l": 0x06,
	    "M": 0x55,
	    "m": 0x55,
	    "N": 0x15,
	    "n": 0x15,
	    "O": 0x7E,
	    "o": 0x1D,
	    "P": 0x67,
	    "p": 0x67,
	    "Q": 0x73,
	    "q": 0x73,
	    "R": 0x77,
	    "r": 0x05,
	    "S": 0x5B,
	    "s": 0x5B,
	    "T": 0x46,
	    "t": 0x0F,
	    "U": 0x3E,
	    "u": 0x1C,
	    "V": 0x27,
	    "v": 0x23,
	    "W": 0x3F,
	    "w": 0x2B,
	    "X": 0x25,
	    "x": 0x25,
	    "Y": 0x3B,
	    "y": 0x33,
	    "Z": 0x6D,
	    "z": 0x6D,
	  }
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var LedControl = __webpack_require__(159);

	// stub implementation; extract functionality from ledcontrol.js
	function Digits(opts) {
	  opts.isMatrix = false;
	  return new LedControl(opts);
	}

	Object.assign(Digits, LedControl, {
	  CHARS: LedControl.DIGIT_CHARS
	});

	module.exports = Digits;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var EVS = __webpack_require__(134);
	var within = __webpack_require__(139);
	var __ = __webpack_require__(115);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var priv = new Map();
	var int16 = __.int16;

	function analogHandler(opts, dataHandler) {
	  this.io.pinMode(this.pin, this.io.MODES.ANALOG);
	  this.io.analogRead(this.pin, function(data) {
	    dataHandler.call(this, data);
	  }.bind(this));
	}

	var Controllers = {
	  DEFAULT: {
	    initialize: {
	      value: analogHandler
	    },
	    toIntensityLevel: {
	      value: function(raw) {
	        return __.scale(raw, 0, 1023, 0, 100);
	      }
	    }
	  },
	  EVS_EV3: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        if (opts.mode) {
	          opts.mode = opts.mode.toUpperCase();
	        }

	        state.mode = opts.mode === "REFLECTED" ? EVS.Type_EV3_LIGHT_REFLECTED : EVS.Type_EV3_LIGHT;

	        state.shield = EVS.shieldPort(opts.pin);
	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, EVS.Type_EV3);
	        state.ev3.write(state.shield, 0x81 + state.shield.offset, state.mode);
	        state.ev3.read(state.shield, EVS.Light, EVS.Light_Bytes, function(data) {
	          var value = data[0] | (data[1] << 8);
	          dataHandler(value);
	        });
	      }
	    },
	    toIntensityLevel: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	  EVS_NXT: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        if (opts.mode) {
	          opts.mode = opts.mode.toUpperCase();
	        }

	        state.mode = opts.mode === "REFLECTED" ? EVS.Type_NXT_LIGHT_REFLECTED : EVS.Type_NXT_LIGHT;

	        state.shield = EVS.shieldPort(opts.pin);
	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, state.mode);
	        state.ev3.read(state.shield, state.shield.analog, EVS.Analog_Bytes, function(data) {
	          var value = data[0] | (data[1] << 8);
	          dataHandler(value);
	        });
	      }
	    },
	    toIntensityLevel: {
	      value: function(raw) {
	        return __.scale(raw, 0, 1023, 100, 0);
	      }
	    }
	  },
	  TSL2561: {
	    ADDRESSES: {
	      value: [ 0x29, 0x39, 0x49 ]
	    },
	    REGISTER: {
	      value: {

	        CONTROL: 0x00,
	        TIMING: 0x01,
	        READ: 0x8C,
	      }
	    },
	    initialize: {
	      value: function(opts, dataHandler) {
	        var address = opts.address || 0x39;
	        // var read = (address & 0x0F) | 0x80;
	        var gain = opts.gain || 0;
	        var time = opts.time || 0;

	        var iMs = [ 13.7, 101, 402 ][ time ];

	        // Default value of timing register
	        // http://www.adafruit.com/datasheets/TSL2561.pdf
	        // Page 15
	        var timing = 0x02;

	        // gain [ 0 => 1X, 1 => 16X]
	        if (gain) {
	          timing |= 0x10;
	        } else {
	          timing &= ~0x10;
	        }

	        // time [ 0 => 13.7, 1 => 101, 2 => 402 ] ms
	        timing &= ~0x03;
	        timing |= (time & 0x03);

	        this.io.i2cConfig();

	        // Write the "power on" byte to the control register
	        this.io.i2cWriteReg(address, this.REGISTER.CONTROL, 0x03);

	        // Configure the timing and gain
	        this.io.i2cWriteReg(address, this.REGISTER.TIMING, timing);

	        this.io.i2cRead(address, this.REGISTER.READ, 4, function(data) {
	          var ch0 = int16(data[1], data[0]);
	          var ch1 = int16(data[3], data[2]);
	          var value = 0;
	          var ratio = 0;

	          // http://www.adafruit.com/datasheets/TSL2561.pdf
	          // Page 23
	          if (ch0 === 0xFFFF || ch1 === 0xFFFF) {
	            value = 0;
	          } else {

	            ratio = ch1 / ch0;

	            ch0 *= 402 / iMs;
	            ch1 *= 402 / iMs;

	            if (!gain) {
	              ch0 *= 16;
	              ch1 *= 16;
	            }

	            if (ratio < 0.5) {
	              value = 0.0304 * ch0 - 0.062 * ch0 * Math.pow(ratio, 1.4);
	            } else if (ratio < 0.61) {
	              value = 0.0224 * ch0 - 0.031 * ch1;
	            } else if (ratio < 0.80) {
	              value = 0.0128 * ch0 - 0.0153 * ch1;
	            } else if (ratio < 1.30) {
	              value = 0.00146 * ch0 - 0.00112 * ch1;
	            } else {
	              value = 0;
	            }
	          }

	          dataHandler(value);
	        });
	      }
	    },
	    toIntensityLevel: {
	      value: function(raw) {
	        return __.scale(raw, 0.1, 40000, 0, 100);
	      }
	    }
	  },
	};

	Controllers.ALSPT19 = Controllers["ALS-PT19"] = Controllers.DEFAULT;


	/**
	 * Light
	 * @constructor
	 *
	 */

	function Light(opts) {

	  if (!(this instanceof Light)) {
	    return new Light(opts);
	  }

	  var controller = null;
	  var state = {};
	  var raw = 0;
	  var last = 0;
	  var freq = opts.freq || 25;

	  Board.Device.call(
	    this, opts = Board.Options(opts)
	  );

	  if (typeof opts.controller === "string") {
	    controller = Controllers[opts.controller];
	  } else {
	    controller = opts.controller || Controllers.DEFAULT;
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toIntensityLevel) {
	    this.toIntensityLevel = opts.toIntensityLevel || function(x) {
	      return x;
	    };
	  }

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return raw;
	      }
	    },
	    level: {
	      get: function() {
	        return this.toIntensityLevel(raw);
	      }
	    },
	    // TODO:
	    //
	    // lux?
	    //
	  });

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === undefined) {
	      return;
	    }

	    var data = {
	      level: this.level
	    };

	    this.emit("data", data);

	    if (raw !== last) {
	      last = raw;
	      this.emit("change", data);
	    }
	  }.bind(this), freq);
	}

	util.inherits(Light, Emitter);

	__.mixin(Light.prototype, within);

	module.exports = Light;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var __ = __webpack_require__(115);
	var priv = new Map();
	var axes = ["x", "y"];

	function Multiplexer(options) {
	  this.pins = options.pins;
	  this.io = options.io;

	  // Setup these "analog" pins as digital output.
	  this.io.pinMode(this.pins[0], this.io.MODES.OUTPUT);
	  this.io.pinMode(this.pins[1], this.io.MODES.OUTPUT);
	  this.io.pinMode(this.pins[2], this.io.MODES.OUTPUT);
	  this.io.pinMode(this.pins[3], this.io.MODES.OUTPUT);
	}

	Multiplexer.prototype.select = function(channel) {
	  this.io.digitalWrite(this.pins[0], channel & 1 ? this.io.HIGH : this.io.LOW);
	  this.io.digitalWrite(this.pins[1], channel & 2 ? this.io.HIGH : this.io.LOW);
	  this.io.digitalWrite(this.pins[2], channel & 4 ? this.io.HIGH : this.io.LOW);
	  this.io.digitalWrite(this.pins[3], channel & 8 ? this.io.HIGH : this.io.LOW);
	};

	var Controllers = {
	  ANALOG: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var axisValues = {
	          x: null,
	          y: null
	        };

	        opts.pins.forEach(function(pin, index) {
	          this.io.pinMode(pin, this.io.MODES.ANALOG);
	          this.io.analogRead(pin, function(value) {
	            axisValues[axes[index]] = value;

	            if (axisValues.x !== null && axisValues.y !== null) {
	              dataHandler({
	                x: axisValues.x,
	                y: axisValues.y
	              });

	              axisValues.x = null;
	              axisValues.y = null;
	            }
	          }.bind(this));
	        }, this);
	      }
	    },
	    toAxis: {
	      value: function(raw, axis) {
	        var state = priv.get(this);
	        return __.constrain(__.fscale(raw - state[axis].zeroV, -511, 511, -1, 1), -1, 1);
	      }
	    }
	  },
	  ESPLORA: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        // References:
	        //
	        // https://github.com/arduino/Arduino/blob/master/libraries/Esplora/src/Esplora.h
	        // https://github.com/arduino/Arduino/blob/master/libraries/Esplora/src/Esplora.cpp
	        //
	        var multiplexer = new Multiplexer({
	          // Since Multiplexer uses digitalWrite,
	          // we have to send the analog pin numbers
	          // in their "digital" pin order form.
	          pins: [ 18, 19, 20, 21 ],
	          io: this.io
	        });
	        var channels = [ 11, 12 ];
	        var index = 1;
	        var axisValues = {
	          x: null,
	          y: null
	        };

	        this.io.pinMode(4, this.io.MODES.ANALOG);

	        var handler = function(value) {
	          axisValues[axes[index]] = value;

	          if (axisValues.x !== null && axisValues.y !== null) {
	            dataHandler({
	              x: axisValues.x,
	              y: axisValues.y
	            });

	            axisValues.x = null;
	            axisValues.y = null;
	          }

	          // Remove this handler to all the multiplexer
	          // to setup the next pin for the next read.
	          this.io.removeListener("analog-read-4", handler);

	          setTimeout(read, 10);
	        }.bind(this);

	        var read = function() {
	          multiplexer.select(channels[index ^= 1]);
	          this.io.analogRead(4, handler);
	        }.bind(this);

	        read();
	      }
	    },
	    toAxis: {
	      value: function(raw, axis) {
	        var state = priv.get(this);
	        return __.constrain(__.fscale(raw - state[axis].zeroV, -511, 511, -1, 1), -1, 1);
	      }
	    }
	  }
	};

	/**
	 * Joystick
	 * @constructor
	 *
	 * five.Joystick([ x, y[, z] ]);
	 *
	 * five.Joystick({
	 *   pins: [ x, y[, z] ]
	 *   freq: ms
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */
	function Joystick(opts) {
	  if (!(this instanceof Joystick)) {
	    return new Joystick(opts);
	  }

	  var controller = null;

	  var state = {
	    x: {
	      invert: false,
	      value: 0,
	      previous: 0,
	      zeroV: 0,
	      calibrated: false
	    },
	    y: {
	      invert: false,
	      value: 0,
	      previous: 0,
	      zeroV: 0,
	      calibrated: false
	    }
	  };

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (opts.controller && typeof opts.controller === "string") {
	    controller = Controllers[opts.controller.toUpperCase()];
	  } else {
	    controller = opts.controller;
	  }

	  if (controller == null) {
	    controller = Controllers["ANALOG"];
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toAxis) {
	    this.toAxis = opts.toAxis || function(raw) { return raw; };
	  }

	  state.x.zeroV = opts.zeroV === undefined ? 0 : (opts.zeroV.x || 0);
	  state.y.zeroV = opts.zeroV === undefined ? 0 : (opts.zeroV.y || 0);

	  state.x.invert = opts.invertX || opts.invert || false;
	  state.y.invert = opts.invertY || opts.invert || false;

	  priv.set(this, state);

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      var isChange = false;
	      var computed = {
	        x: null,
	        y: null
	      };

	      Object.keys(data).forEach(function(axis) {
	        var value = data[axis];
	        var sensor = state[axis];

	        // Set the internal ADC reading value...
	        sensor.value = value;

	        if (!state[axis].calibrated) {
	          state[axis].calibrated = true;
	          state[axis].zeroV = value;
	          isChange = true;
	        }

	        // ... Get the computed axis value.
	        computed[axis] = this[axis];

	        var absAxis = Math.abs(computed[axis]);
	        var absPAxis = Math.abs(sensor.previous);

	        if ((absAxis < absPAxis) ||
	            (absAxis > absPAxis)) {
	          isChange = true;
	        }

	        sensor.previous = computed[axis];
	      }, this);

	      this.emit("data", {
	        x: computed.x,
	        y: computed.y
	      });

	      if (isChange) {
	        this.emit("change", {
	          x: computed.x,
	          y: computed.y
	        });
	      }
	    }.bind(this));
	  }

	  Object.defineProperties(this, {
	    x: {
	      get: function() {
	        return this.toAxis(state.x.value, "x") * (state.x.invert ? -1 : 1);
	      }
	    },
	    y: {
	      get: function() {
	        return this.toAxis(state.y.value, "y") * (state.y.invert ? -1 : 1);
	      }
	    }
	  });
	}

	util.inherits(Joystick, Emitter);

	module.exports = Joystick;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12),
	  priv = new Map();


	function analogInitializer(opts, dataHandler) {
	  var state = priv.get(this);

	  this.io.pinMode(opts.pin, this.io.MODES.ANALOG);

	  setTimeout(function() {
	    state.isCalibrated = true;
	    this.emit("calibrated");
	  }.bind(this), 10);

	  this.io.analogRead(opts.pin, dataHandler);
	}
	var Controllers = {
	  PIR: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);
	        var calibrationDelay = typeof opts.calibrationDelay !== "undefined" ?
	              opts.calibrationDelay : 2000;

	        this.io.pinMode(opts.pin, this.io.MODES.INPUT);

	        setTimeout(function() {
	          state.isCalibrated = true;
	          this.emit("calibrated");
	        }.bind(this), calibrationDelay);

	        this.io.digitalRead(opts.pin, dataHandler);
	      }
	    },
	    toBoolean: {
	      value: function(raw) {
	        return !!raw;
	      }
	    }
	  },
	  GP2Y0D805Z0F: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var address = opts.address || 0x26;
	        var state = priv.get(this);

	        // This is meaningless for GP2Y0D805Z0F.
	        // The event is implemented for consistency
	        // with the digital passive infrared sensor
	        setTimeout(function() {
	          state.isCalibrated = true;
	          this.emit("calibrated");
	        }.bind(this), 10);

	        // Set up I2C data connection
	        this.io.i2cConfig(opts);

	        this.io.i2cWriteReg(address, 0x03, 0xFE);
	        this.io.i2cWrite(address, [0x00]);
	        this.io.i2cRead(address, 1, function(data) {
	          dataHandler(data[0] & 0x02);
	        });
	      }
	    },
	    toBoolean: {
	      value: function(raw) {
	        return raw === 0;
	      }
	    }
	  },
	  GP2Y0D810Z0F: {
	    initialize: {
	      value: analogInitializer
	    },
	    toBoolean: {
	      value: function(raw) {
	        return raw >> 9 === 0;
	      }
	    }
	  },
	  GP2Y0A60SZLF: {
	    initialize: {
	      value: analogInitializer
	    },
	    toBoolean: {
	      value: function(raw) {
	        return raw >> 9 === 1;
	      }
	    }
	  }
	};

	Controllers.GP2Y0D815Z0F = Controllers.GP2Y0D810Z0F;

	Controllers["HC-SR501"] = Controllers.PIR;
	Controllers["HCSR501"] = Controllers.PIR;
	Controllers["0D805"] = Controllers.GP2Y0D805Z0F;
	Controllers["805"] = Controllers.GP2Y0D805Z0F;
	Controllers["0D810"] = Controllers.GP2Y0D810Z0F;
	Controllers["810"] = Controllers.GP2Y0D810Z0F;
	Controllers["0D815"] = Controllers.GP2Y0D815Z0F;
	Controllers["815"] = Controllers.GP2Y0D815Z0F;
	Controllers["0A60SZLF"] = Controllers.GP2Y0A60SZLF;
	Controllers["60SZLF"] = Controllers.GP2Y0A60SZLF;

	/**
	 * Motion
	 * @constructor
	 *
	 * five.Motion(7);
	 *
	 * five.Motion({
	 *  controller: "PIR",
	 *  pin: 7,
	 *  freq: 100,
	 *  calibrationDelay: 1000
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Motion(opts) {

	  if (!(this instanceof Motion)) {
	    return new Motion(opts);
	  }

	  var freq = opts.freq || 25;
	  var last = false;
	  var controller;
	  var state;

	  Board.Device.call(
	    this, opts = Board.Options(opts)
	  );

	  if (typeof opts.controller === "string") {
	    controller = Controllers[opts.controller];
	  } else {
	    controller = opts.controller || Controllers["PIR"];
	  }

	  Board.Controller.call(this, controller, opts);

	  state = {
	    value: false,
	    isCalibrated: false
	  };

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    /**
	     * [read-only] Current sensor state
	     * @property detectedMotion
	     * @type Boolean
	     */
	    detectedMotion: {
	      get: function() {
	        return this.toBoolean(state.value);
	      }
	    },
	    /**
	     * [read-only] Sensor calibration status
	     * @property isCalibrated
	     * @type Boolean
	     */
	    isCalibrated: {
	      get: function() {
	        return state.isCalibrated;
	      }
	    },
	  });

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      state.value = data;
	    });
	  }

	  setInterval(function() {
	    var isChange = false;
	    var eventData = {
	      timestamp: Date.now(),
	      detectedMotion: this.detectedMotion,
	      isCalibrated: state.isCalibrated
	    };

	    if (state.isCalibrated && this.detectedMotion && !last) {
	      this.emit("motionstart", eventData);
	    }

	    if (state.isCalibrated && !this.detectedMotion && last) {
	      this.emit("motionend", eventData);
	    }

	    if (last !== this.detectedMotion) {
	      isChange = true;
	    }

	    this.emit("data", eventData);

	    if (isChange) {
	      this.emit("change", eventData);
	    }

	    last = this.detectedMotion;
	  }.bind(this), freq);
	}

	util.inherits(Motion, events.EventEmitter);

	module.exports = Motion;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
	var Board = __webpack_require__(103);
	var EVS = __webpack_require__(134);
	var __ = __webpack_require__(115);
	var events = __webpack_require__(8);
	var util = __webpack_require__(12);
	var Collection = __webpack_require__(114);
	var Sensor = __webpack_require__(138);
	var ShiftRegister = __webpack_require__(166);
	var nanosleep = __webpack_require__(141).nano;

	var priv = new Map();
	var registers = new Map();

	function registerKey(registerOpts) {
	  return Object.keys(registerOpts).sort().reduce(function(accum, key) {
	    accum = accum + "." + registerOpts[key];
	    return accum;
	  }, "");
	}

	function latch(state, bit, on) {
	  return on ? state |= (1 << bit) : state &= ~(1 << bit);
	}

	function updateShiftRegister(motor, dir) {
	  var rKey = registerKey(motor.opts.register),
	      register = registers.get(motor.board)[rKey],
	      latchState = register.value,
	      bits = priv.get(motor).bits,
	      forward = dir !== "reverse";

	  // There are two ShiftRegister bits which we need to change based on the
	  // direction of the motor.  These will be the pins that control the HBridge
	  // on the board.  They will get flipped high/low based on the current flow
	  // in the HBridge.
	  latchState = latch(latchState, bits.a, forward);
	  latchState = latch(latchState, bits.b, !forward);

	  if (register.value !== latchState) {
	    register.send(latchState);
	  }
	}

	var Controllers = {
	  ShiftRegister: {
	    initialize: {
	      value: function (opts) {
	        var rKey = registerKey(opts.register);

	        if (!opts.bits || opts.bits.a === undefined || opts.bits.b === undefined) {
	          throw new Error("ShiftRegister Motors MUST contain HBRIDGE bits {a, b}");
	        }

	        priv.get(this).bits = opts.bits;

	        if (!registers.has(this.board)) {
	          registers.set(this.board, {});
	        }

	        if (!registers.get(this.board)[rKey]) {
	          registers.get(this.board)[rKey] = new ShiftRegister({
	            board: this.board,
	            pins: opts.register
	          });
	        }

	        this.io.pinMode(this.pins.pwm, this.io.MODES.PWM);
	      }
	    },
	    dir: {
	      value: function(speed, dir) {
	        this.stop();

	        updateShiftRegister(this, dir.name);

	        this.direction = dir;

	        process.nextTick(this.emit.bind(this, dir.name));

	        return this;
	      }
	    }
	  },
	  PCA9685: {
	    REGISTER: {
	      value: {
	        PCA9685_MODE1: 0x0,
	        PCA9685_PRESCALE: 0xFE,
	        LED0_ON_L: 0x6
	      }
	    },
	    address: {
	      get: function() {
	        return this.opts.address;
	      }
	    },
	    setPWM: {
	      value: function(pin, off, on) {
	        if (typeof on === "undefined") {
	          on = 0;
	        }
	        on *= 16;
	        off *= 16;
	        this.io.i2cWrite(this.opts.address, [this.REGISTER.LED0_ON_L + 4 * (pin), on, on >> 8, off, off >> 8]);
	      }
	    },
	    setPin: {
	      value: function(pin, value, duty, phaseShift) {
	        var on = 0;

	        if (value !== 0) {
	          value = 255;
	        }

	        if (typeof duty !== "undefined") {
	          value = duty;
	        }

	        if (typeof phaseShift !== "undefined") {
	          on = phaseShift;
	          value = value + on;
	        }

	        this.setPWM(pin, value, on);

	      }
	    },
	    initialize: {
	      value: function() {

	        if (!this.board.Drivers[this.opts.address]) {
	          this.io.i2cConfig(this.opts);
	          this.board.Drivers[this.opts.address] = {
	            initialized: false
	          };

	          // Reset
	          this.io.i2cWrite(this.opts.address, [this.REGISTER.PCA9685_MODE1, 0x0]);
	          // Sleep
	          this.io.i2cWrite(this.opts.address, [this.REGISTER.PCA9685_MODE1, 0x10]);
	          // Set prescalar
	          this.io.i2cWrite(this.opts.address, [this.REGISTER.PCA9685_PRESCALE, 0x3]);
	          // Wake up
	          this.io.i2cWrite(this.opts.address, [this.REGISTER.PCA9685_MODE1, 0x0]);
	          // Wait 5 nanoseconds for restart
	          nanosleep(5);
	          // Auto-increment
	          this.io.i2cWrite(this.opts.address, [this.REGISTER.PCA9685_MODE1, 0xa1]);

	          // Reset all PWM values
	          for (var i = 0; i < 16; i++) {
	            this.setPWM(i, 0, 0);
	          }

	          this.board.Drivers[this.opts.address].initialized = true;
	        }
	      }
	    }
	  },
	  EVS_EV3: {
	    initialize: {
	      value: function(opts) {
	        var state = priv.get(this);

	        state.shield = EVS.shieldPort(opts.pin);
	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));

	        this.opts.pins = {
	          pwm: opts.pin,
	          dir: opts.pin,
	        };
	      }
	    },
	    setPWM: {
	      value: function(pin, value) {
	        var state = priv.get(this);

	        var register = state.shield.motor === EVS.M1 ? EVS.SPEED_M1 : EVS.SPEED_M2;
	        var speed = __.scale(value, 0, 255, 0, 100) | 0;

	        if (value === 0) {
	          state.ev3.write(state.shield, EVS.COMMAND, EVS.Motor_Reset);
	        } else {
	          if (!this.direction.value) {
	            speed = -speed;
	          }

	          var data = [
	            // 0-100
	            speed,
	            // Duration (0 is forever)
	            0,
	            // Command B
	            0,
	            // Command A
	            EVS.CONTROL_SPEED | EVS.CONTROL_GO
	          ];

	          state.ev3.write(state.shield, register, data);
	        }
	      }
	    },
	    setPin: {
	      value: function(pin, value) {
	        this.setPWM(this.pin, value);
	      }
	    },
	  },
	};

	// Aliases
	//
	// NXT motors have the exact same control commands as EV3 motors
	Controllers.EVS_NXT = Controllers.EVS_EV3;

	var Devices = {
	  NONDIRECTIONAL: {
	    pins: {
	      get: function() {
	        return {
	          pwm: this.opts.pin
	        };
	      }
	    },
	    dir: {
	      value: function(speed) {
	        speed = speed || this.speed();
	        return this;
	      }
	    },
	    resume: {
	      value: function() {
	        var speed = this.speed();
	        this.speed({
	          speed: speed
	        });
	        return this;
	      }
	    }
	  },
	  DIRECTIONAL: {
	    pins: {
	      get: function() {
	        if (Array.isArray(this.opts.pins)) {
	          return {
	            pwm: this.opts.pins[0],
	            dir: this.opts.pins[1]
	          };
	        } else {
	          return this.opts.pins;
	        }
	      }
	    },
	    dir: {
	      configurable: true,
	      value: function(speed, dir) {

	        speed = speed || this.speed();

	        this.stop();

	        this.setPin(this.pins.dir, dir.value);
	        this.direction = dir;

	        process.nextTick(this.emit.bind(this, dir.name));

	        return this;
	      }
	    }
	  },
	  CDIR: {
	    pins: {
	      get: function() {
	        if (Array.isArray(this.opts.pins)) {
	          return {
	            pwm: this.opts.pins[0],
	            dir: this.opts.pins[1],
	            cdir: this.opts.pins[2]
	          };
	        } else {
	          return this.opts.pins;
	        }
	      }
	    },
	    dir: {
	      value: function(speed, dir) {

	        if (typeof speed === "undefined") {
	          speed = this.speed();
	        }

	        this.stop();
	        this.direction = dir;

	        this.setPin(this.pins.cdir, 1 ^ dir.value);
	        this.setPin(this.pins.dir, dir.value);

	        process.nextTick(this.emit.bind(this, dir.name));

	        return this;
	      }
	    },
	    brake: {
	      value: function(duration) {

	        this.speed({
	          speed: 0,
	          saveSpeed: false
	        });
	        this.setPin(this.pins.dir, 1, 127);
	        this.setPin(this.pins.cdir, 1, 128, 127);
	        this.speed({
	          speed: 255,
	          saveSpeed: false,
	          braking: true
	        });
	        process.nextTick(this.emit.bind(this, "brake"));

	        if (duration) {
	          var motor = this;
	          this.board.wait(duration, function() {
	            motor.stop();
	          });
	        }

	        return this;
	      }
	    }
	  }
	};

	/**
	 * Motor
	 * @constructor
	 *
	 * @param {Object} opts Options: pin|pins{pwm, dir[, cdir]}, device, controller, current
	 * @param {Number} pin A single pin for basic
	 * @param {Array} pins A two or three digit array of pins [pwm, dir]|[pwm, dir, cdir]
	 *
	 *
	 * Initializing "Hobby Motors"
	 *
	 *    new five.Motor(9);
	 *
	 * ...is the same as...
	 *
	 *    new five.Motor({
	 *      pin: 9
	 *    });
	 *
	 *
	 * Initializing 2 pin, Bi-Directional DC Motors:
	 *
	 *    new five.Motor([ 3, 12 ]);
	 *
	 * ...is the same as...
	 *
	 *    new five.Motor({
	 *      pins: [ 3, 12 ]
	 *    });
	 *
	 * ...is the same as...
	 *
	 *    new five.Motor({
	 *      pins: {
	 *        pwm: 3,
	 *        dir: 12
	 *      }
	 *    });
	 *
	 *
	 * Initializing 3 pin, I2C PCA9685 Motor Controllers:
	 * i.e. The Adafruit Motor Shield V2
	 *
	 *    new five.Motor({
	 *      pins: [ 8, 9, 10 ],
	 *      controller: "PCA9685",
	 *      address: 0x60
	 *    });
	 *
	 *
	 * Initializing 3 pin, Bi-Directional DC Motors:
	 *
	 *    new five.Motor([ 3, 12, 11 ]);
	 *
	 * ...is the same as...
	 *
	 *    new five.Motor({
	 *      pins: [ 3, 12, 11 ]
	 *    });
	 *
	 * ...is the same as...
	 *
	 *    new five.Motor({
	 *      pins: {
	 *        pwm: 3,
	 *        dir: 12,
	 *        cdir: 11
	 *      }
	 *    });
	 *
	 *
	 * Initializing Bi-Directional DC Motors with brake:
	 *
	 *    new five.Motor({
	 *      pins: {
	 *        pwm: 3,
	 *        dir: 12,
	 *        brake: 11
	 *      }
	 *    });
	 *
	 *
	 * Initializing Bi-Directional DC Motors with current sensing pins:
	 * See Sensor.js for details on options
	 *
	 *    new five.Motor({
	 *      pins: [3, 12],
	 *      current: {
	 *        pin: "A0",
	 *        freq: 250,
	 *        range: [0, 2000]
	 *      }
	 *    });
	 *
	 *
	 * Initializing Bi-Directional DC Motors with inverted speed for reverse:
	 * Most likely used for non-commercial H-Bridge controllers
	 *
	 *    new five.Motor({
	 *      pins: [3, 12],
	 *      invertPWM: true
	 *    });
	 *
	 */

	function Motor(opts) {

	  var device, controller, state;

	  if (!(this instanceof Motor)) {
	    return new Motor(opts);
	  }

	  Board.Component.call(
	    this, this.opts = Board.Options(opts)
	  );

	  controller = opts.controller || null;

	  // Derive device based on pins passed
	  if (typeof this.opts.device === "undefined") {

	    this.opts.device = (typeof this.opts.pins === "undefined" && typeof this.opts.register !== "object") ?
	      "NONDIRECTIONAL" : "DIRECTIONAL";

	    if (this.opts.pins && (this.opts.pins.cdir || this.opts.pins.length > 2)) {
	      this.opts.device = "CDIR";
	    }

	    if (typeof controller === "string" && controller.startsWith("EVS")) {
	      this.opts.device = "DIRECTIONAL";
	    }
	  }

	  // Allow users to pass in custom device types
	  device = typeof this.opts.device === "string" ?
	    Devices[this.opts.device] : this.opts.device;

	  this.threshold = typeof this.opts.threshold !== "undefined" ?
	    this.opts.threshold : 30;

	  this.invertPWM = typeof this.opts.invertPWM !== "undefined" ?
	    this.opts.invertPWM : false;

	  Object.defineProperties(this, device);

	  if (this.opts.register) {
	    this.opts.controller = "ShiftRegister";
	  }

	  /**
	   * Note: Controller decorates the device. Used for adding
	   * special controllers (i.e. PCA9685)
	   **/
	  if (this.opts.controller) {
	    controller = typeof this.opts.controller === "string" ?
	      Controllers[this.opts.controller] : this.opts.controller;

	    Board.Controller.call(this, controller, opts);
	  }

	  // current just wraps a Sensor
	  if (this.opts.current) {
	    this.opts.current.board = this.board;
	    this.current = new Sensor(this.opts.current);
	  }

	  // Create a "state" entry for privately
	  // storing the state of the motor
	  state = {
	    isOn: false,
	    currentSpeed: typeof this.opts.speed !== "undefined" ?
	      this.opts.speed : 128,
	    braking: false
	  };

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    // Calculated, read-only motor on/off state
	    // true|false
	    isOn: {
	      get: function() {
	        return state.isOn;
	      }
	    },
	    currentSpeed: {
	      get: function() {
	        return state.currentSpeed;
	      }
	    },
	    braking: {
	      get: function() {
	        return state.braking;
	      }
	    }
	  });

	  // We need to store and initialize the state of the dir pin(s)
	  this.direction = {
	    value: 1
	  };

	  if (this.initialize) {
	    this.initialize(opts);
	  }

	  this.dir(0, this.direction);
	}

	util.inherits(Motor, events.EventEmitter);

	Motor.prototype.initialize = function() {
	  this.io.pinMode(this.pins.pwm, this.io.MODES.PWM);

	  ["dir", "cdir", "brake"].forEach(function(pin) {
	    if (this.pins[pin]) {
	      this.io.pinMode(this.pins[pin], this.io.MODES.OUTPUT);
	    }
	  }, this);

	};

	Motor.prototype.setPin = function(pin, value) {
	  this.io.digitalWrite(pin, value);
	};

	Motor.prototype.setPWM = function(pin, value) {
	  this.io.analogWrite(pin, value);
	};

	Motor.prototype.speed = function(opts) {
	  var state = priv.get(this);

	  if (typeof opts === "undefined") {
	    return this.currentSpeed;
	  } else {

	    if (typeof opts === "number") {
	      opts = {
	        speed: opts
	      };
	    }

	    opts.speed = Board.constrain(opts.speed, 0, 255);

	    opts.saveSpeed = typeof opts.saveSpeed !== "undefined" ?
	      opts.saveSpeed : true;

	    if (opts.speed < this.threshold) {
	      opts.speed = 0;
	    }

	    state.isOn = opts.speed === 0 ? false : true;

	    if (opts.saveSpeed) {
	      state.currentSpeed = opts.speed;
	    }

	    if (opts.braking) {
	      state.braking = true;
	    }

	    if (this.invertPWM && this.direction.value === 1) {
	      opts.speed ^= 0xff;
	    }

	    this.setPWM(this.pins.pwm, opts.speed);

	    return this;
	  }

	};

	// start a motor - essentially just switch it on like a normal motor
	Motor.prototype.start = function(speed) {
	  // Send a signal to turn on the motor and run at given speed in whatever
	  // direction is currently set.
	  if (this.pins.brake && this.braking) {
	    this.setPin(this.pins.brake, 0);
	  }

	  // get current speed if nothing provided.
	  speed = typeof speed !== "undefined" ?
	    speed : this.speed();

	  this.speed({
	    speed: speed,
	    braking: false
	  });

	  // "start" event is fired when the motor is started
	  if (speed > 0) {
	    process.nextTick(this.emit.bind(this, "start"));
	  }

	  return this;
	};

	Motor.prototype.stop = function() {
	  this.speed({
	    speed: 0,
	    saveSpeed: false
	  });
	  process.nextTick(this.emit.bind(this, "stop"));

	  return this;
	};

	Motor.prototype.brake = function(duration) {
	  if (typeof this.pins.brake === "undefined") {
	    if (this.board.io.name !== "Mock") {
	      console.log("Non-braking motor type");
	    }
	    this.stop();
	  } else {
	    this.setPin(this.pins.brake, 1);
	    this.setPin(this.pins.dir, 1);
	    this.speed({
	      speed: 255,
	      saveSpeed: false,
	      braking: true
	    });
	    process.nextTick(this.emit.bind(this, "brake"));

	    if (duration) {
	      var motor = this;
	      this.board.wait(duration, function() {
	        motor.resume();
	      });
	    }
	  }

	  return this;
	};

	Motor.prototype.release = function() {
	  this.resume();
	  process.nextTick(this.emit.bind(this, "release"));

	  return this;
	};

	Motor.prototype.resume = function() {
	  var speed = this.speed();
	  this.dir(speed, this.direction);
	  this.start(speed);

	  return this;
	};

	[
	  /**
	   * forward Turn the Motor in its forward direction
	   * fwd Turn the Motor in its forward direction
	   *
	   * @param  {Number} 0-255, 0 is stopped, 255 is fastest
	   * @return {Object} this
	   */
	  {
	    name: "forward",
	    abbr: "fwd",
	    value: 1
	  },
	  /**
	   * reverse Turn the Motor in its reverse direction
	   * rev Turn the Motor in its reverse direction
	   *
	   * @param  {Number} 0-255, 0 is stopped, 255 is fastest
	   * @return {Object} this
	   */
	  {
	    name: "reverse",
	    abbr: "rev",
	    value: 0
	  }
	].forEach(function(dir) {
	  var method = function(speed) {
	    this.dir(speed, dir);
	    this.start(speed);
	    return this;
	  };

	  Motor.prototype[dir.name] = Motor.prototype[dir.abbr] = method;
	});

	Motor.SHIELD_CONFIGS = {
	  ADAFRUIT_V1: {
	    M1: {
	      pins: { pwm: 11 },
	      register: { data: 8, clock: 4, latch: 12 },
	      bits: { a: 2, b: 3 }
	    },
	    M2: {
	      pins: { pwm: 3 },
	      register: { data: 8, clock: 4, latch: 12 },
	      bits: { a: 1, b: 4 }
	    },
	    M3: {
	      pins: { pwm: 6 },
	      register: { data: 8, clock: 4, latch: 12 },
	      bits: { a: 5, b: 7 }
	    },
	    M4: {
	      pins: { pwm: 5 },
	      register: { data: 8, clock: 4, latch: 12 },
	      bits: { a: 0, b: 6 }
	    }
	  },
	  ADAFRUIT_V2: {
	    M1: {
	      pins: { pwm: 8, dir: 9, cdir: 10 },
	      address: 0x60,
	      controller: "PCA9685"
	    },
	    M2: {
	      pins: { pwm: 13, dir: 12, cdir: 11 },
	      address: 0x60,
	      controller: "PCA9685"
	    },
	    M3: {
	      pins: { pwm: 2, dir: 3, cdir: 4 },
	      address: 0x60,
	      controller: "PCA9685"
	    },
	    M4: {
	      pins: { pwm: 7, dir: 6, cdir: 5 },
	      address: 0x60,
	      controller: "PCA9685"
	    }
	  },
	  SEEED_STUDIO: {
	    A: {
	      pins: { pwm:9, dir:8, cdir: 11 }
	    },
	    B: {
	      pins: { pwm:10, dir:12, cdir: 13 }
	    }
	  },
	  FREETRONICS_HBRIDGE: {
	    A: {
	      pins: { pwm: 6, dir: 4, cdir: 7 }
	    },
	    B: {
	      pins: { pwm: 5, dir: 3, cdir: 2 }
	    }
	  },
	  ARDUINO_MOTOR_SHIELD_R3_1: {
	    A: {
	      pins: { pwm: 3, dir: 12 }
	    },
	    B: {
	      pins: { pwm: 11, dir: 13 }
	    }
	  },
	  ARDUINO_MOTOR_SHIELD_R3_2: {
	    A: {
	      pins: { pwm: 3, dir: 12, brake: 9 }
	    },
	    B: {
	      pins: { pwm: 11, dir: 13, brake: 8 }
	    }
	  },
	  ARDUINO_MOTOR_SHIELD_R3_3: {
	    A: {
	      pins: { pwm: 3, dir: 12, brake: 9, current: "A0" }
	    },
	    B: {
	      pins: { pwm: 11, dir: 13, brake: 8, current: "A1" }
	    }
	  },
	  DF_ROBOT: {
	    A: {
	      pins: { pwm: 6, dir: 7 }
	    },
	    B: {
	      pins: { pwm: 5, dir: 4 }
	    }
	  },
	  NKC_ELECTRONICS_KIT: {
	    A: {
	      pins: { pwm: 9, dir: 12 }
	    },
	    B: {
	      pins: { pwm: 10, dir: 13 }
	    }
	  },
	  RUGGED_CIRCUITS: {
	    A: {
	      pins: { pwm: 3, dir: 12 }
	    },
	    B: {
	      pins: { pwm: 11, dir: 13 }
	    }
	  },
	  SPARKFUN_ARDUMOTO: {
	    A: {
	      pins: { pwm: 3, dir: 12 }
	    },
	    B: {
	      pins: { pwm: 11, dir: 13 }
	    }
	  },
	  POLOLU_DRV8835_SHIELD: {
	    M1: {
	      pins: { pwm: 9, dir: 7 }
	    },
	    M2: {
	      pins: { pwm: 10, dir: 8 }
	    }
	  },
	  MICRO_MAGICIAN_V2: {
	    A : {
	      pins: { pwm: 6, dir: 8 },
	      invertPWM: true
	    },
	    B: {
	      pins: { pwm: 5, dir: 7 },
	      invertPWM: true
	    }
	  },
	  SPARKFUN_LUDUS: {
	    A: {
	      pins: { pwm: 3, dir: 4, cdir: 5 }
	    },
	    B: {
	      pins: { pwm: 6, dir: 7, cdir: 8 }
	    }
	  },
	};


	/**
	 * Motors()
	 * new Motors()
	 *
	 * Constructs an Array-like instance of all servos
	 */
	function Motors(numsOrObjects) {
	  if (!(this instanceof Motors)) {
	    return new Motors(numsOrObjects);
	  }

	  Object.defineProperty(this, "type", {
	    value: Motor
	  });

	  Collection.call(this, numsOrObjects);
	}

	Motors.prototype = Object.create(Collection.prototype, {
	  constructor: {
	    value: Motors
	  }
	});


	/*
	 * Motors, forward(speed)/fwd(speed)
	 *
	 * eg. array.forward(speed);

	 * Motors, reverse(speed)/rev(speed)
	 *
	 * eg. array.reverse(speed);

	 * Motors, start(speed)
	 *
	 * eg. array.start(speed);

	 * Motors, stop()
	 *
	 * eg. array.stop();

	 * Motors, brake()
	 *
	 * eg. array.brake();

	 * Motors, release()
	 *
	 * eg. array.release();
	 */

	Object.keys(Motor.prototype).forEach(function(method) {
	  // Create Motors wrappers for each method listed.
	  // This will allow us control over all Motor instances
	  // simultaneously.
	  Motors.prototype[method] = function() {
	    var length = this.length;

	    for (var i = 0; i < length; i++) {
	      this[i][method].apply(this[i], arguments);
	    }
	    return this;
	  };
	});


	if (IS_TEST_MODE) {
	  Motor.purge = function() {
	    priv.clear();
	    registers.clear();
	  };
	}

	// Assign Motors Collection class as static "method" of Motor.
	Motor.Array = Motors;

	module.exports = Motor;

	// References
	// http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);

	var priv = new Map();

	function ShiftRegister(opts) {
	  if (!(this instanceof ShiftRegister)) {
	    return new ShiftRegister(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  this.pins = {
	    data: opts.pins.data,
	    clock: opts.pins.clock,
	    latch: opts.pins.latch
	  };

	  this.size = opts.size || 1;

	  priv.set(this, {
	    value: this.size > 1 ? new Array(this.size).fill(0) : 0
	  });

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return priv.get(this).value;
	      }
	    }
	  });
	}

	/**
	 * Send one or more values to the shift register.
	 * @param {...number} value Value to send
	 * @returns {ShiftRegister}
	 */
	ShiftRegister.prototype.send = function(value) {
	  var args = Array.prototype.slice.apply(arguments);
	  this.board.digitalWrite(this.pins.latch, this.io.LOW);
	  args.forEach(function(val) {
	    this.board.shiftOut(this.pins.data, this.pins.clock, true, val);
	  }, this);
	  this.board.digitalWrite(this.pins.latch, this.io.HIGH);

	  priv.get(this).value = args.length > 1 ? args : value;

	  return this;
	};

	/**
	 * Clear the shift register by replacing each value with a 0.
	 * @type {ShiftRegister}
	 */
	ShiftRegister.prototype.clear = function () {
	  var value = priv.get(this).value;
	  if (Array.isArray(value)) {
	    return this.send.apply(this, new Array(value.length).fill(0));
	  }
	  return this.send(0);
	};

	module.exports = ShiftRegister;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var Servo = __webpack_require__(144),
	  __ = __webpack_require__(115),
	  DIR_TRANSLATION,
	  temporal;


	function scale(speed, low, high) {
	  return Math.floor(__.scale(speed, 0, 5, low, high));
	}

	DIR_TRANSLATION = {
	  reverse: {
	    right: "left",
	    left: "right",
	    fwd: "rev",
	    rev: "fwd"
	  },
	  translations: [{
	    f: "forward",
	    r: "reverse",
	    fwd: "forward",
	    rev: "reverse"
	  }, {
	    r: "right",
	    l: "left"
	  }]
	};

	function Movement(move) {
	  __.extend(this, move, {
	    timestamp: Date.now()
	  });
	}

	Movement.prototype.toString = function() {
	  return "<" + [this.timestamp, "L" + this.left, "R" + this.right].join(" ") + ">";
	};

	/**
	 * Nodebot
	 * @param {Object} opts Optional properties object
	 */

	function Nodebot(opts) {

	  opts.board = opts.board || null;

	  // Boe Nodebot continuous are calibrated to stop at 90
	  this.center = opts.center || 90;

	  if (typeof opts.right === "number") {
	    opts.right = new Servo({
	      board: opts.board,
	      pin: opts.right,
	      type: "continuous"
	    });
	  }

	  if (typeof opts.left === "number") {
	    opts.left = new Servo({
	      board: opts.board,
	      pin: opts.left,
	      type: "continuous"
	    });
	  }

	  // Initialize the right and left cooperative servos
	  this.servos = {
	    right: opts.right,
	    left: opts.left
	  };

	  // Set the initial servo cooperative direction
	  this.direction = {
	    right: this.center,
	    left: this.center
	  };

	  // Store the cooperative speed
	  this.speed = opts.speed === undefined ? 0 : opts.speed;

	  // Used to record a recallable history of movement.
	  this.history = [];

	  // Initial motion state
	  this.motion = "forward";

	  // Track directional state
	  this.isTurning = false;

	  // Garbage hack to avoid including
	  if (!temporal) {
	    temporal = __webpack_require__(131);
	  }


	  // Wait 10ms, send fwd pulse on, then off to
	  // "wake up" the servos
	  temporal.wait(10, function() {
	    this.fwd(1).fwd(0);
	  }.bind(this));
	}


	Nodebot.DIR_TRANSLATION = DIR_TRANSLATION;

	/**
	 * move Move the bot in an arbitrary direction
	 * @param  {Number} right Speed/Direction of right servo
	 * @param  {Number} left  Speed/Direction of left servo
	 * @return {Object} this
	 */
	Nodebot.prototype.move = function(right, left) {

	  // Quietly ignore duplicate instructions
	  if (this.direction.right === right &&
	    this.direction.left === left) {
	    return this;
	  }

	  // Cooperative servo motion.
	  // Servos are mounted opposite of each other,
	  // the values for left and right will be in
	  // opposing directions.
	  this.servos.right.to(right);
	  this.servos.left.to(left);

	  // Push a record object into the history
	  this.history.push({
	    timestamp: Date.now(),
	    right: right,
	    left: left
	  });

	  // Update the stored direction state
	  this.direction.right = right;
	  this.direction.left = left;

	  return this;
	};


	[
	  /**
	   * forward Move the bot forward
	   * fwd Move the bot forward
	   *
	   * @param  {Number} 0-5, 0 is stopped, 5 is fastest
	   * @return {Object} this
	   */
	  {
	    name: "forward",
	    abbr: "fwd",
	    toArguments: function(center, val) {
	      return [center - (val - center), val];
	    }
	  },

	  /**
	   * reverse Move the bot in reverse
	   * rev Move the bot in reverse
	   *
	   * @param  {Number}0-5, 0 is stopped, 5 is fastest
	   * @return {Object} this
	   */
	  {
	    name: "reverse",
	    abbr: "rev",
	    toArguments: function(center, val) {
	      return [val, center - (val - center)];
	    }
	  }

	].forEach(function(dir) {

	  var method = function(speed) {
	    // Set default direction method
	    speed = speed === undefined ? this.speed : speed;

	    this.speed = speed;
	    this.motion = dir.name;

	    return this.move.apply(this,
	      dir.toArguments(this.center, scale(speed, this.center, 110))
	    );
	  };

	  Nodebot.prototype[dir.name] = Nodebot.prototype[dir.abbr] = method;
	});

	/**
	 * stop Stops the bot, regardless of current direction
	 * @return {Object} this
	 */
	Nodebot.prototype.stop = function() {
	  this.speed = this.center;
	  this.motion = "stop";

	  return this.move(this.center, this.center);
	};


	[
	  /**
	   * right Turn the bot right
	   * @return {Object} this
	   */
	  "right",

	  /**
	   * left Turn the bot left
	   * @return {Object} this
	   */
	  "left"

	].forEach(function(dir) {
	  Nodebot.prototype[dir] = function(time) {

	    if (dir === "right") {
	      this.move(110, 110);
	    } else {
	      this.move(70, 70);
	    }

	    if (time) {
	      temporal.wait(time, this[this.motion].bind(this));
	    }

	    return this;
	  };
	});


	/**
	 * pivot Pivot the bot with combo directions:
	 * rev Move the bot in reverse
	 *
	 * @param  {String} which Combination directions:
	 *                        "forward-right", "forward-left",
	 *                        "reverse-right", "reverse-left"
	 *                        (aliased as: "f-l", "f-r", "r-r", "r-l")
	 *
	 * @return {Object} this
	 */
	Nodebot.prototype.pivot = function(instruct, time) {
	  var directions, scaled, expansion;

	  scaled = scale(this.speed, this.center, 110);

	  // Directions are declared where |this| is in scope
	  directions = {
	    "forward-right": function() {
	      this.move(this.center, scaled);
	    },
	    "forward-left": function() {
	      this.move(this.center - (scaled - this.center), this.center);
	    },
	    "reverse-right": function() {
	      this.move(scaled, this.center);
	    },
	    "reverse-left": function() {
	      this.move(this.center, this.center - (scaled - this.center));
	    }
	  };

	  //
	  expansion = this.pivot.translate(instruct);
	  instruct = directions[instruct] || directions[expansion];

	  // Commence pivot...
	  instruct.call(this, this.speed);

	  // ...Until... time or 1000ms and then
	  temporal.wait(time || 1000, function() {
	    this[this.motion](this.speed);
	  }.bind(this));

	  return this;
	};


	Nodebot.prototype.pivot.translate = function(instruct) {
	  var instructions;

	  if (instruct.length === 2) {
	    instructions = [instruct[0], instruct[1]];
	  }

	  if (/\-/.test(instruct)) {
	    instructions = instruct.split("-");
	  }

	  return instructions.map(function(val, i) {
	    return DIR_TRANSLATION.translations[i][val];
	  }).join("-");
	};

	module.exports = Nodebot;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Timer = __webpack_require__(169);

	function Piezo(opts) {

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  // Hardware instance properties
	  this.mode = this.io.MODES.OUTPUT;
	  this.pin = opts.pin || 3;

	  this.io.pinMode(this.pin, this.mode);

	  // Piezo instance properties
	  this.isPlaying = false;
	}

	// These notes are rounded up at .5 otherwise down.
	Piezo.Notes = {
	  "c0": 16,
	  "c#0": 17,
	  "d0": 18,
	  "d#0": 19,
	  "e0": 21,
	  "f0": 22,
	  "f#0": 23,
	  "g0": 25,
	  "g#0": 26,
	  "a0": 28,
	  "a#0": 29,
	  "b0": 31,
	  "c1": 33,
	  "c#1": 35,
	  "d1": 37,
	  "d#1": 39,
	  "e1": 41,
	  "f1": 44,
	  "f#1": 47,
	  "g1": 49,
	  "g#1": 52,
	  "a1": 55,
	  "a#1": 58,
	  "b1": 62,
	  "c2": 65,
	  "c#2": 69,
	  "d2": 73,
	  "d#2": 78,
	  "e2": 82,
	  "f2": 87,
	  "f#2": 93,
	  "g2": 98,
	  "g#2": 104,
	  "a2": 110,
	  "a#2": 117,
	  "b2": 124,
	  "c3": 131,
	  "c#3": 139,
	  "d3": 147,
	  "d#3": 156,
	  "e3": 165,
	  "f3": 175,
	  "f#3": 185,
	  "g3": 196,
	  "g#3": 208,
	  "a3": 220,
	  "a#3": 233,
	  "b3": 247,
	  "c4": 262,
	  "c#4": 277,
	  "d4": 294,
	  "d#4": 311,
	  "e4": 330,
	  "f4": 349,
	  "f#4": 370,
	  "g4": 392,
	  "g#4": 415,
	  "a4": 440,
	  "a#4": 466,
	  "b4": 494,
	  "c5": 523,
	  "c#5": 554,
	  "d5": 587,
	  "d#5": 622,
	  "e5": 659,
	  "f5": 698,
	  "f#5": 740,
	  "g5": 784,
	  "g#5": 831,
	  "a5": 880,
	  "a#5": 932,
	  "b5": 988,
	  "c6": 1047,
	  "c#6": 1109,
	  "d6": 1175,
	  "d#6": 1245,
	  "e6": 1319,
	  "f6": 1397,
	  "f#6": 1480,
	  "g6": 1568,
	  "g#6": 1661,
	  "a6": 1760,
	  "a#6": 1865,
	  "b6": 1976,
	  "c7": 2093,
	  "c#7": 2217,
	  "d7": 2349,
	  "d#7": 2489,
	  "e7": 2637,
	  "f7": 2794,
	  "f#7": 2960,
	  "g7": 3136,
	  "g#7": 3322,
	  "a7": 3520,
	  "a#7": 3729,
	  "b7": 3951,
	  "c8": 4186,
	  "c#8": 4435,
	  "d8": 4699,
	  "d#8": 4978,
	  "e8": 5274,
	  "f8": 5588,
	  "f#8": 5920,
	  "g8": 6272,
	  "g#8": 6645,
	  "a8": 7040,
	  "a#8": 7459,
	  "b8": 7902
	};

	function clearTimer() {
	  if (!this.timer) {
	    return;
	  }

	  this.timer.clearInterval();
	  delete this.timer;
	}

	/**
	 * Get the tone from the current note. note
	 * could be an int, string, array or null.
	 * If int or null, leave alone. Otherwise,
	 * derive what the tone should be.
	 * @return int | null
	 */
	function parseTone(note) {
	  var tone = note;
	  if (Array.isArray(note)) {
	    tone = note[0];
	  }
	  if (typeof tone === "string") {
	    tone = tone.toLowerCase();

	    var needsOctave = isNaN(tone.substr(tone.length -1));
	    if (needsOctave) {
	      tone = tone + Piezo.prototype.defaultOctave().toString();
	    }

	    tone = (Piezo.Notes[tone]) ? Piezo.Notes[tone] : null;
	  }
	  if (isNaN(tone)) {
	    tone = null;
	  }
	  return tone;
	}

	/**
	 * Obtain the beat/duration count from the current
	 * note. This is either an int or undefined. Default
	 * to 1.
	 * @return int (default 1)
	 */
	function parseBeat(note) {
	  var beat = 1;
	  if (Array.isArray(note) && note[1] !== undefined) {
	    // If extant, beat will be second element of note
	    beat = note[1];
	  }
	  return beat;
	}

	/**
	 * Validate the octave provided to ensure the value is
	 * supported and won't crash the board.
	 * @return bool
	 */
	function isValidOctave(octave) {
	  // octave should be a number.
	   if (octave && !isNaN(octave) &&
	     (octave >= 0 && octave <= 8)) {
	       return true;
	   }

	   return false;
	}

	Piezo.prototype.defaultOctave = function(octave) {
	  if (typeof this.defaultOctave.value === "undefined") {
	    this.defaultOctave.value = 4;
	  }

	  if (isValidOctave(octave)) {
	    this.defaultOctave.value = octave;
	  }

	  return this.defaultOctave.value;
	};

	Piezo.prototype.note = function(note, duration) {
	  var tone = parseTone(note);

	  return this.tone(tone, duration);
	};

	Piezo.prototype.tone = function(tone, duration) {
	  if (isNaN(tone) || isNaN(duration)) {
	    // Very Bad Things happen if one tries to play a NaN tone
	    throw new Error(
	      "Piezo.tone: invalid tone or duration"
	    );
	  }

	  clearTimer.call(this);

	  var timer = this.timer = new Timer();
	  var value = 1;

	  timer.setInterval(function() {
	    value = value === 1 ? 0 : 1;
	    this.io.digitalWrite(this.pin, value);

	    if ((timer.difTime / 1000000) > duration) {
	      clearTimer.call(this);
	    }
	  }.bind(this), null, tone + "u", function() {});

	  return this;
	};

	Piezo.prototype.frequency = function(frequency, duration) {
	  var period = 1 / frequency;
	  var duty = period / 2;
	  var tone = Math.round(duty * 1000000);

	  return this.tone(tone, duration);
	};

	function stringToSong(stringSong, beats) {
	  beats = beats || 1;
	  var notes = stringSong.match(/\S+/g);
	  var song = [];
	  var note, lastNote;
	  while (notes.length) {
	    note = notes.shift();
	    if (/^[0-9]+$/.test(note)) {
	      note = parseInt(note, 10);
	    }
	    lastNote = song[song.length - 1];
	    if (lastNote && lastNote[0] === note) {
	      lastNote[1] += beats;
	    } else {
	      song.push([note, beats]);
	    }
	  }
	  return song;
	}

	Piezo.prototype.play = function(tune, callback) {
	  if (typeof tune !== "object") {
	    tune = {
	      song: tune
	    };
	  }
	  if (typeof tune.song === "string") {
	    tune.song = stringToSong(tune.song, tune.beats);
	  }
	  var duration,
	    tempo = tune.tempo || 250,
	    beatDuration = Math.round(60000 / tempo), // Length for a single beat in ms
	    song = tune.song || [],
	    i = 0;
	  if (song && !Array.isArray(song)) {
	    song = [song];
	  }
	  var next = function() {
	    var note, beat;

	    note = parseTone(song[i]);
	    beat = parseBeat(song[i]);

	    duration = beat * beatDuration;

	    if (i++ === song.length) {
	      // Song is over
	      this.isPlaying = false;
	      if (typeof callback === "function") {
	        callback(tune);
	      }
	      return;
	    }

	    if (note === null) {
	      this.noTone();
	    } else {
	      this.frequency(note, duration);
	    }

	    setTimeout(next, duration);
	  }.bind(this);

	  // We are playing a song
	  this.isPlaying = true;

	  next();

	  return this;
	};

	Piezo.prototype.noTone = function() {
	  this.io.digitalWrite(this.pin, 0);
	  clearTimer.call(this);

	  return this;
	};

	Piezo.prototype.off = Piezo.prototype.noTone;

	module.exports = Piezo;


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate, clearImmediate) {function NanoTimer(log){

	    var version = process.version;
		var major = version.split('.')[0];
		major = major.split('v')[1];
	    var minor = version.split('.')[1];
	    if ((major == 0) && (minor < 10)){
	        console.log('Error: Please update to the latest version of node! This library requires 0.10.x or later');
	        process.exit(0);
	    }
		
		//Time reference variables
	    this.intervalT1 = null;
		this.timeOutT1 = null;
	    this.intervalCount = 1; 
		
		//Deferred reference indicator variables.  Indicate whether the timer used/will use the deferred call. ie - delay/interval > 25ms
	    this.deferredInterval = false;
	    this.deferredTimeout = false;
		
		//Deferred reference variables.  Used to clear the native js timeOut calls
		this.deferredTimeoutRef = null;
		this.deferredIntervalRef = null;
		
		//Callback reference variables.  Used to be able to still successfully call callbacks when timeouts or intervals are cleared.
		this.timeoutCallbackRef = null;
		this.intervalCallbackRef = null;
		
		//Immediate reference variables. Used to clear functions scheduled with setImmediate from running in the event timeout/interval is cleared.
		this.timeoutImmediateRef = null;
		this.intervalImmediateRef = null;
		
		this.intervalErrorChecked = false;
		
		this.intervalType = "";
	    
	    if(log){
	        this.logging = true;
	    }
	}

	NanoTimer.prototype.time = function(task, args, format, callback){
	  //Asynchronous task
	    if(callback){
	        var t1 = process.hrtime();
	        
	        
	        if(args){
	        
	            args.push(function(){
	                var time = process.hrtime(t1);
	                if(format == 's'){
	                    callback(time[0] + time[1]/1000000000);
	                } else if (format == 'm'){
	                    callback(time[0]/1000 + time[1]/1000000);
	                } else if (format == 'u'){
	                    callback(time[0]/1000000 + time[1]/1000);
	                } else if (format == 'n'){
	                    callback(time[0]/1000000000 + time[1]);
	                } else {
	                    callback(time); 
	                }
	            });
	           
	            task.apply(null, args);
	        } else {
	            task(function(){
	                var time = process.hrtime(t1);
	                if(format == 's'){
	                    callback(time[0] + time[1]/1000000000);
	                } else if (format == 'm'){
	                    callback(time[0]/1000 + time[1]/1000000);
	                } else if (format == 'u'){
	                    callback(time[0]/1000000 + time[1]/1000);
	                } else if (format == 'n'){
	                    callback(time[0]/1000000000 + time[1]);
	                } else {
	                    callback(time); 
	                }
	            });
	        }
	        
	    //Synchronous task
	    } else {
	        var t1 = process.hrtime();
	        
	        if(args){
	            task.apply(null, args);
	        } else{
	            task();
	        }
	        
	        var t2 = process.hrtime(t1);
	        
	        if(format == 's'){
	            return t2[0] + t2[1]/1000000000;
	        } else if (format == 'm'){
	            return t2[0]/1000 + t2[1]/1000000;
	        } else if (format == 'u'){
	            return t2[0]/1000000 + t2[1]/1000;
	        } else if (format == 'n'){
	            return t2[0]/1000000000 + t2[1];
	        } else {
	            return process.hrtime(t1);
	        } 
	    } 
	};

	NanoTimer.prototype.setInterval = function(task, args, interval, callback){

		if(!this.intervalErrorChecked){
			//Task error handling
			if(!task){
				console.log("A task function must be specified to setInterval");
				process.exit(1);
			} else {
				if(typeof(task) != "function"){
					console.log("Task argument to setInterval must be a function reference");
					process.exit(1);
				}
			}
			
			//Interval error handling
			if(!interval){
				console.log("An interval argument must be specified");
				process.exit(1);
			} else {
				if(typeof(interval) != "string"){
					console.log("Interval argument to setInterval must be a string specified as an integer followed by 's' for seconds, 'm' for milli, 'u' for micro, and 'n' for nanoseconds. Ex. 2u");
					process.exit(1);
				}
			}
			
			//This ref is used if deferred timeout is cleared, so the callback can still be accessed
			if(callback){
				if(typeof(callback) != "function"){
					console.log("Callback argument to setInterval must be a function reference");
					process.exit(1);
				} else {
					this.intervalCallbackRef = callback;
				}
			}
			
			this.intervalType = interval[interval.length-1];
			
			if(this.intervalType == 's'){
				this.intervalTime = interval.slice(0, interval.length-1) * 1000000000;
			} else if(this.intervalType == 'm'){
				this.intervalTime = interval.slice(0, interval.length-1) * 1000000;
			} else if(this.intervalType == 'u'){
				this.intervalTime = interval.slice(0, interval.length-1) * 1000;
			} else if(this.intervalType == 'n'){
				this.intervalTime = interval.slice(0, interval.length-1);
			} else {
				console.log('Error with argument: ' + interval + ': Incorrect interval format. Format is an integer followed by "s" for seconds, "m" for milli, "u" for micro, and "n" for nanoseconds. Ex. 2u');
				process.exit(1);
			}
			
			this.intervalErrorChecked = true;
		}

	    //Avoid dereferencing inside of function objects later
		//Must be performed on every execution 
	    var thisTimer = this;
	    
	    if(this.intervalTime > 0){
	        
	        //Check and set constant t1 value.
	        if(this.intervalT1 == null){
	            this.intervalT1 = process.hrtime();
	        }
	        
	        //Check for overflow.  Every 8,000,000 seconds (92.6 days), this will overflow
	        //and the reference time T1 will be re-acquired.  This is the only case in which error will 
	        //propagate.
	        if(this.intervalTime*this.intervalCount > 8000000000000000){
	            this.intervalT1 = process.hrtime();
	            this.intervalCount = 1;
	        }
			
	        
	        //Get comparison time
	        this.difArray = process.hrtime(this.intervalT1);
	        this.difTime = (this.difArray[0] * 1000000000) + this.difArray[1];
	        
			//If updated time < expected time, continue
	        //Otherwise, run task and update counter
			if(this.difTime < (this.intervalTime*this.intervalCount)){
				
				//Can potentially defer to less accurate setTimeout if intervaltime > 25ms
				if(this.intervalTime > 25000000){
					if(this.deferredInterval == false){
						this.deferredInterval = true;
						msDelay = (this.intervalTime - 25000000) / 1000000.0;
						this.deferredIntervalRef = setTimeout(function(){thisTimer.setInterval(task, args, interval, callback);}, msDelay);
					} else {
						this.deferredIntervalRef = null;
						this.intervalImmediateRef = setImmediate(function(){thisTimer.setInterval(task, args, interval, callback);});
					}
				} else {
					this.intervalImmediateRef = setImmediate(function(){thisTimer.setInterval(task, args, interval, callback);});
				}
			} else {
				
				this.intervalImmediateRef = null;
				
				if(this.logging){
					console.log('nanotimer log: ' + 'cycle time at - ' + this.difTime);
				}
				
				
				
				if(args){
					task.apply(null, args);
				} else {
					task();
				}
				
				//Check if the intervalT1 is still not NULL. If it is, that means the task cleared the interval so it should not run again.
				if(this.intervalT1){
					this.intervalCount++;
					this.deferredInterval = false;
					this.intervalImmediateRef = setImmediate(function(){thisTimer.setInterval(task, args, interval, callback);});
				}
			}
	        
	    //If interval = 0, run as fast as possible.
	    } else {
	        
	      //Check and set constant t1 value.
	        if(this.intervalT1 == null){
	            this.intervalT1 = process.hrtime();
	            this.intervalContinue = true;
	        }
	        
	        if(this.intervalContinue == true) {
	            if(args){
	                task.apply(null, args);
	            } else {
	                task();
	            }
	            setImmediate(function(){thisTimer.setInterval(task, args, interval, callback);});
	        } else {
	            this.intervalT1 = null;
	            this.intervalCount = 1;
	            callback();
	        }  
	    }
	};

	NanoTimer.prototype.setTimeout = function(task, args, delay, callback){

		//Task error handling
		if(!task){
			console.log("A task function must be specified to setTimeout");
			process.exit(1);
		} else {
			if(typeof(task) != "function"){
				console.log("Task argument to setTimeout must be a function reference");
				process.exit(1);
			}
		}
		
		//Delay error handling
		if(!delay){
			console.log("A delay argument must be specified");
			process.exit(1);
		} else {
			if(typeof(delay) != "string"){
				console.log("Delay argument to setTimeout must be a string specified as an integer followed by 's' for seconds, 'm' for milli, 'u' for micro, and 'n' for nanoseconds. Ex. 2u");
				process.exit(1);
			}
		}
		
		//This ref is used if deferred timeout is cleared, so the callback can still be accessed
		if(callback){
			if(typeof(callback) != "function"){
				console.log("Callback argument to setTimeout must be a function reference");
				process.exit(1);
			} else {
				this.timeoutCallbackRef = callback;
			}
		}
	    
	    //Avoid dereferencing
	    var thisTimer = this;
	    
		var delayType = delay[delay.length-1];

		if(delayType == 's'){
			var delayTime = delay.slice(0, delay.length-1) * 1000000000;
		} else if(delayType == 'm'){
			var delayTime = delay.slice(0, delay.length-1) * 1000000;
		} else if(delayType == 'u'){
			var delayTime = delay.slice(0, delay.length-1) * 1000;
		} else if(delayType == 'n'){
			var delayTime = delay.slice(0, delay.length-1);
		} else {
			console.log('Error with argument: ' + delay + ': Incorrect delay format. Format is an integer followed by "s" for seconds, "m" for milli, "u" for micro, and "n" for nanoseconds. Ex. 2u');
			process.exit(1);
		}
	    
	    //Set marker
		if(this.timeOutT1 == null){
			this.timeOutT1 = process.hrtime();
		}
		
		
		var difArray = process.hrtime(this.timeOutT1);
		var difTime = (difArray[0] * 1000000000) + difArray[1];
	    
	    
		if(difTime < delayTime){
			//Can potentially defer to less accurate setTimeout if delayTime > 25ms
			if(delayTime > 25000000){
				if(this.deferredTimeout == false){
					this.deferredTimeout = true;
					msDelay = (delayTime - 25000000) / 1000000.0;
					this.deferredTimeoutRef = setTimeout(function(){thisTimer.setTimeout(task, args, delay, callback);}, msDelay);
				} else {
					this.deferredTimeoutRef = null;
					this.timeoutImmediateRef = setImmediate(function(){thisTimer.setTimeout(task, args, delay, callback);});
				}
			} else {
				this.timeoutImmediateRef = setImmediate(function(){thisTimer.setTimeout(task, args, delay, callback);});
			}
		} else {
			this.timeoutImmediateRef = null;
			this.timeOutT1 = null;
			this.deferredTimeout = false;
			
			if(this.logging == true){
				console.log('nanotimer log: ' + 'actual wait - ' + difTime);
			}
			
			if(args){
				task.apply(null, args);
			} else{
				task();
			}
			
			if(callback){
				var data = {'waitTime':difTime};
				callback(data);
			}

		}
	};

	NanoTimer.prototype.clearInterval = function(){
		if(this.deferredIntervalRef){
			clearTimeout(this.deferredIntervalRef);
			
			this.deferredInterval = false;
		}
		
		if(this.intervalImmediateRef){
			clearImmediate(this.intervalImmediateRef);
		}
		
		this.intervalT1 = null;
		this.intervalCount = 1;
		this.intervalErrorChecked = false;
		
		if(this.intervalCallbackRef){
			this.intervalCallbackRef();
		}
	};

	NanoTimer.prototype.clearTimeout = function(){
		
		if(this.deferredTimeoutRef){
			clearTimeout(this.deferredTimeoutRef);
			
			var difArray = process.hrtime(this.timeOutT1);
			var difTime = (difArray[0] * 1000000000) + difArray[1];
			
			this.deferredTimeout = false;
		}
		
		if(this.timeoutImmediateRef){
			clearImmediate(this.timeoutImmediateRef);
		}
		
		this.timeOutT1 = null;
		
		if(this.timeoutCallbackRef){
			var data = {'waitTime':difTime};
			this.timeoutCallbackRef(data);
		}
	};

	module.exports = NanoTimer;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(170).setImmediate, __webpack_require__(170).clearImmediate))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(1).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(170).setImmediate, __webpack_require__(170).clearImmediate))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  Emitter = __webpack_require__(8).EventEmitter,
	  util = __webpack_require__(12),
	  within = __webpack_require__(139),
	  __ = __webpack_require__(115);

	var priv = new Map();

	/**
	 * Ping
	 * @param {Object} opts Options: pin
	 */

	function Ping(opts) {

	  if (!(this instanceof Ping)) {
	    return new Ping(opts);
	  }

	  var last = null;

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  this.pin = opts && opts.pin || 7;
	  this.freq = opts.freq || 20;
	  // this.pulse = opts.pulse || 250;

	  var state = {
	    value: null
	  };

	  // Private settings object
	  var settings = {
	    pin: this.pin,
	    value: this.io.HIGH,
	    pulseOut: 5
	  };

	  this.io.setMaxListeners(100);

	  // Interval for polling pulse duration as reported in microseconds
	  setInterval(function() {
	    this.io.pingRead(settings, function(microseconds) {
	      state.value = microseconds;
	    });
	  }.bind(this), 225);

	  // Interval for throttled event
	  setInterval(function() {
	    var err = null;

	    if (state.value === null) {
	      return;
	    }

	    // median = samples.sort()[samples.length / 2 | 0];

	    // if (!median) {
	    //   median = last;
	    // }

	    // @DEPRECATE
	    this.emit("read", err, state.value);

	    // The "read" event has been deprecated in
	    // favor of a "data" event.
	    this.emit("data", err, state.value);

	    // If the state.value for this interval is not the same as the
	    // state.value in the last interval, fire a "change" event.
	    if (state.value !== last) {
	      this.emit("change", err, state.value);
	    }

	    // Store state.value for comparison in next interval
	    last = state.value;

	    // Reset samples;
	    // samples.length = 0;
	  }.bind(this), this.freq);

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return state.value;
	      }
	    },
	    // Based on the round trip travel time in microseconds,
	    // Calculate the distance in inches and centimeters
	    inches: {
	      get: function() {
	        return +(state.value / 74 / 2).toFixed(2);
	      }
	    },
	    in: {
	      get: function() {
	        return this.inches;
	      }
	    },
	    cm: {
	      get: function() {
	        return +(state.value / 29 / 2).toFixed(3);
	      }
	    }
	  });

	  priv.set(this, state);
	}

	util.inherits(Ping, Emitter);
	__.mixin(Ping.prototype, within);

	module.exports = Ping;


	//http://itp.nyu.edu/physcomp/Labs/Servo
	//http://arduinobasics.blogspot.com/2011/05/arduino-uno-flex-sensor-and-leds.html
	//http://protolab.pbworks.com/w/page/19403657/TutorialPings


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12);

	/**
	 * Pir, IR.Motion
	 * @deprecated
	 * @param {Object} opts Options: pin, type, id, range
	 */

	function Pir(opts) {

	  if (!(this instanceof Pir)) {
	    return new Pir(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  // Set the pin to INPUT mode
	  this.mode = this.io.MODES.INPUT;
	  this.io.pinMode(this.pin, this.mode);

	  // PIR instance properties
	  this.value = null;
	  this.isCalibrated = false;
	  this.freq = opts.freq || 25;

	  // Analog Read event loop
	  // TODO: make this "throttle-able"
	  this.io.digitalRead(this.pin, function(data) {
	    var timestamp = Date.now(),
	      err = null;

	    // If this is not a calibration event
	    if (this.value != null && this.value !== +data) {

	      // Update current value of PIR instance
	      this.value = +data;

	      // "motionstart" event fired when motion occurs
	      // within the observable range of the PIR sensor
	      if (data) {
	        this.emit("motionstart", err, timestamp);
	      }

	      // "motionend" event fired when motion has ceased
	      // within the observable range of the PIR sensor
	      if (!data) {
	        this.emit("motionend", err, timestamp);
	      }
	    }

	    // "calibrated" event fired when PIR sensor is
	    // ready to detect movement/motion in observable range
	    if (!this.isCalibrated) {
	      this.isCalibrated = true;
	      this.value = +data;
	      this.emit("calibrated", err, timestamp);
	    }
	  }.bind(this));

	  setInterval(function() {
	    this.emit("data", null, Date.now());
	  }.bind(this), this.freq);
	}

	util.inherits(Pir, events.EventEmitter);

	module.exports = Pir;

	// More information:
	// http://www.ladyada.net/learn/sensors/pir.html


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var EVS = __webpack_require__(134);
	var within = __webpack_require__(139);
	var __ = __webpack_require__(115);
	var Emitter = __webpack_require__(8).EventEmitter;
	var util = __webpack_require__(12);
	var priv = new Map();

	function analogHandler(opts, dataHandler) {
	  this.io.pinMode(this.pin, this.io.MODES.ANALOG);
	  this.io.analogRead(this.pin, function(data) {
	    dataHandler.call(this, data);
	  }.bind(this));
	}

	var Controllers = {
	  GP2Y0A21YK: {
	    // https://www.sparkfun.com/products/242
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        return +(12343.85 * Math.pow(raw, -1.15)).toFixed(2);
	      }
	    }
	  },
	  GP2D120XJ00F: {
	    // https://www.sparkfun.com/products/8959
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        return +((2914 / (raw + 5)) - 1).toFixed(2);
	      }
	    }
	  },
	  GP2Y0A02YK0F: {
	    // https://www.sparkfun.com/products/8958
	    // 15cm - 150cm
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        return +(10650.08 * Math.pow(raw, -0.935) - 10).toFixed(2);
	      }
	    }
	  },
	  GP2Y0A41SK0F: {
	    // https://www.sparkfun.com/products/12728
	    // 4cm - 30cm
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        return +(2076 / (raw - 11)).toFixed(2);
	      }
	    }
	  },
	  GP2Y0A710K0F: {
	    // https://www.adafruit.com/products/1568
	    // 100cm - 500cm
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        // http://www.basicx.com/Products/robotbook/ir%20curve%20fit.pdf
	        return 3.8631e8 * Math.pow(raw, -2.463343);
	      }
	    }
	  },
	  SRF10: {
	    initialize: {
	      value: function(opts, dataHandler) {

	        var address = 0x70;
	        var msUntilNextRead = 65;

	        // Set up I2C data connection
	        this.io.i2cConfig(opts);

	        // Startup parameter
	        this.io.i2cWrite(address, [0x01, 16]);
	        this.io.i2cWrite(address, [0x02, 255]);

	        function read() {
	          this.io.i2cWrite(address, [0x02]);
	          this.io.i2cReadOnce(address, 2, function(data) {
	            dataHandler((data[0] << 8) | data[1]);
	          }.bind(this));

	          prime.call(this);
	        }

	        function prime() {
	          // 0x51 result in cm (centimeters)
	          this.io.i2cWrite(address, [0x00, 0x51]);

	          setTimeout(read.bind(this), msUntilNextRead);
	        }

	        prime.call(this);
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	  // LV-MaxSonar-EZ
	  // LV-MaxSonar-EZ0
	  // LV-MaxSonar-EZ1
	  MB1000: {
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        // From http://www.maxbotix.com/articles/032.htm
	        // ADC -> inches -> cm
	        return (raw / 2) * 2.54;
	      }
	    }
	  },
	  // HRLV-MaxSonar-EZ0
	  MB1003: {
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        // http://www.maxbotix.com/articles/032.htm
	        return raw / 2;
	      }
	    }
	  },
	  // XL-MaxSonar-EZ3
	  MB1230: {
	    initialize: {
	      value: analogHandler
	    },
	    toCm: {
	      value: function(raw) {
	        // From http://www.maxbotix.com/articles/016.htm
	        // Using a Standard Range XL-MaxSonar with an ADC (Analog Digital Converter)
	        // When using a standard XL-MaxSonar with an ADC, verify that the sensor
	        // and micro-controller are referencing the same power supply and ground.
	        // This also assumes that the ADC being used is perfectly accurate.
	        // When reading the sensor's output with the scaling in centimeters with a
	        // 10-bit ADC, the range can be read directly off the ADC.
	        // If the ADC output reads 700 the range in centimeters is 700 centimeters.
	        //
	        // ADC -> cm
	        return raw;
	      }
	    }
	  },
	  HCSR04: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        // Private settings object
	        var settings = {
	          pin: opts.pin,
	          value: this.io.HIGH,
	          pulseOut: 5
	        };

	        var read = function() {
	          this.io.pingRead(settings, function(microseconds) {
	            dataHandler(microseconds);
	            setTimeout(function() {
	              read();
	            }, 65);
	          });
	        }.bind(this);

	        read();
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return +(raw / 29.1 / 2).toFixed(3);
	      }
	    }
	  },
	  LIDARLITE: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var ADDRESS = 0x62;
	        var ENABLE = 0x00;
	        var MEASUREMODE = 0x04;
	        var READREGISTER = 0x8f;
	        var BYTES_TO_READ = 0x02;

	        this.io.i2cConfig(opts);

	        var read = function() {
	          this.io.i2cWrite(ADDRESS, ENABLE, MEASUREMODE);
	          setTimeout(function() {
	            this.io.i2cReadOnce(ADDRESS, READREGISTER, BYTES_TO_READ, function(bytes) {
	              // http://www.robotshop.com/media/files/pdf/operating-manual-llm20c132i500s011.pdf
	              // Step 5 of Quick Start Guide
	              dataHandler((bytes[0] << 8) + bytes[1]);
	              read();
	            });
	          }.bind(this), 20);
	        }.bind(this);

	        read();
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	  EVS_EV3_IR: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        state.shield = EVS.shieldPort(opts.pin);

	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, EVS.Type_EV3);
	        state.ev3.read(state.shield, EVS.Proximity, EVS.Proximity_Bytes, function(data) {
	          var value = data[0] | (data[1] << 8);

	          dataHandler(value);
	        });
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return raw;
	      }
	    }
	  },
	  EVS_EV3_US: {
	    initialize: {
	      value: function(opts, dataHandler) {
	        var state = priv.get(this);

	        state.shield = EVS.shieldPort(opts.pin);

	        state.ev3 = new EVS(Object.assign(opts, { io: this.io }));
	        state.ev3.setup(state.shield, EVS.Type_EV3);
	        state.ev3.read(state.shield, EVS.Proximity, EVS.Proximity_Bytes, function(data) {
	          var value = data[0] | (data[1] << 8);
	          dataHandler(value);
	        });
	      }
	    },
	    toCm: {
	      value: function(raw) {
	        return raw / 10;
	      }
	    }
	  },
	};

	// Sensor aliases
	// IR
	Controllers["2Y0A21"] = Controllers.GP2Y0A21YK;
	Controllers["2D120X"] = Controllers.GP2D120XJ00F;
	Controllers["2Y0A02"] = Controllers.GP2Y0A02YK0F;
	Controllers["0A41"] = Controllers.GP2Y0A41SK0F;
	Controllers["0A21"] = Controllers.GP2Y0A21YK;
	Controllers["0A02"] = Controllers.GP2Y0A02YK0F;
	Controllers["41SK0F"] = Controllers.GP2Y0A41SK0F;
	Controllers["21YK"] = Controllers.GP2Y0A21YK;
	Controllers["2YK0F"] = Controllers.GP2Y0A02YK0F;

	// Sonar
	Controllers.MB1010 = Controllers.MB1000;

	Controllers["LV-MaxSonar-EZ"] = Controllers.MB1000;
	Controllers["LV-MaxSonar-EZ0"] = Controllers.MB1000;
	Controllers["LV-MaxSonar-EZ1"] = Controllers.MB1010;
	Controllers["HRLV-MaxSonar-EZ0"] = Controllers.MB1003;
	Controllers["XL-MaxSonar-EZ3"] = Controllers.MB1230;

	// Ping
	Controllers["HC-SR04"] = Controllers.HCSR04;
	Controllers["SR04"] = Controllers.HCSR04;
	Controllers["SRF05"] = Controllers.HCSR04;
	Controllers["SRF06"] = Controllers.HCSR04;
	Controllers["PARALLAXPING"] = Controllers.HCSR04;
	Controllers["SEEEDPING"] = Controllers.HCSR04;
	Controllers["GROVEPING"] = Controllers.HCSR04;
	Controllers["PING_PULSE_IN"] = Controllers.HCSR04;

	// LIDAR Lite
	Controllers["LIDAR-Lite"] = Controllers.LIDARLITE;


	/**
	 * Proximity
	 * @constructor
	 *
	 * five.Proximity("A0");
	 *
	 * five.Proximity({
	 *  controller: "GP2Y0A41SK0F",
	 *  pin: "A0",
	 *  freq: 100
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Proximity(opts) {

	  if (!(this instanceof Proximity)) {
	    return new Proximity(opts);
	  }

	  var controller = null;
	  var state = {};
	  var raw = 0;
	  var freq = opts.freq || 25;
	  var last = 0;

	  Board.Device.call(
	    this, opts = Board.Options(opts)
	  );

	  if (typeof opts.controller === "string") {
	    controller = Controllers[opts.controller];
	  } else {
	    controller = opts.controller || Controllers["GP2Y0A21YK"];
	  }

	  Board.Controller.call(this, controller, opts);

	  if (!this.toCm) {
	    this.toCm = opts.toCm || function(x) {
	      return x;
	    };
	  }

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    /**
	     * [read-only] Calculated centimeter value
	     * @property centimeters
	     * @type Number
	     */
	    centimeters: {
	      get: function() {
	        return this.toCm(raw);
	      }
	    },
	    cm: {
	      get: function() {
	        return this.centimeters;
	      }
	    },
	    /**
	     * [read-only] Calculated inch value
	     * @property inches
	     * @type Number
	     */
	    inches: {
	      get: function() {
	        return +(this.centimeters * 0.39).toFixed(2);
	      }
	    },
	    in: {
	      get: function() {
	        return this.inches;
	      }
	    },
	  });

	  if (typeof this.initialize === "function") {
	    this.initialize(opts, function(data) {
	      raw = data;
	    });
	  }

	  setInterval(function() {
	    if (raw === undefined) {
	      return;
	    }

	    var data = {
	      cm: this.cm,
	      centimeters: this.centimeters,
	      in: this.in,
	      inches: this.inches
	    };

	    this.emit("data", data);

	    if (raw !== last) {
	      last = raw;
	      this.emit("change", data);
	    }
	  }.bind(this), freq);
	}

	Proximity.Controllers = [
	  "2Y0A21", "GP2Y0A21YK",
	  "2D120X", "GP2D120XJ00F",
	  "2Y0A02", "GP2Y0A02YK0F",
	  "OA41SK", "GP2Y0A41SK0F",
	  "0A21", "GP2Y0A21YK",
	  "0A02", "GP2Y0A02YK0F",
	];

	util.inherits(Proximity, Emitter);

	__.mixin(Proximity.prototype, within);

	module.exports = Proximity;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);

	var priv = new Map();

	function Relay(opts) {

	  var state;

	  if (!(this instanceof Relay)) {
	    return new Relay(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  opts.type = opts.type || "NO";

	  state = {
	    isInverted: opts.type === "NC",
	    isOn: false,
	    value: null,
	  };

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    value: {
	      get: function() {
	        return Number(this.isOn);
	      }
	    },
	    type: {
	      get: function() {
	        return state.isInverted ? "NC" : "NO";
	      }
	    },
	    isOn: {
	      get: function() {
	        return state.isOn;
	      }
	    }
	  });
	}

	/**
	 * on Turn the relay on
	 * @return {Relay}
	 */
	Relay.prototype.on = function() {
	  var state = priv.get(this);

	  this.io.digitalWrite(
	    this.pin, state.isInverted ? this.io.LOW : this.io.HIGH
	  );
	  state.isOn = true;

	  return this;
	};

	Relay.prototype.close = Relay.prototype.on;

	/**
	 * off Turn the relay off
	 * @return {Relay}
	 */
	Relay.prototype.off = function() {
	  var state = priv.get(this);

	  this.io.digitalWrite(
	    this.pin, state.isInverted ? this.io.HIGH : this.io.LOW
	  );
	  state.isOn = false;

	  return this;
	};

	Relay.prototype.open = Relay.prototype.off;

	/**
	 * toggle Toggle the on/off state of the relay
	 * @return {Relay}
	 */
	Relay.prototype.toggle = function() {
	  var state = priv.get(this);

	  if (state.isOn) {
	    this.off();
	  } else {
	    this.on();
	  }

	  return this;
	};

	module.exports = Relay;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12),
	  within = __webpack_require__(139),
	  __ = __webpack_require__(115);

	var priv = new Map();
	var Devices;

	/**
	 * Sonar
	 * @constructor
	 *
	 * @param {Object} opts Options: pin (analog)
	 */

	function Sonar(opts) {

	  if (!(this instanceof Sonar)) {
	    return new Sonar(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  var device, state;

	  // Sonar instance properties
	  this.freq = opts.freq || 100;
	  this.value = null;

	  state = {
	    last: 0,
	    median: 0,
	    samples: []
	  };

	  priv.set(this, state);

	  if (typeof opts.device === "string") {
	    device = Devices[opts.device];
	  } else {
	    device = opts.device;
	  }

	  if (typeof device === "undefined") {
	    device = Devices.DEFAULT;
	  }

	  device.initialize.call(this, opts);

	  if (!device.descriptor.inches) {
	    device.descriptor.inches = {
	      get: function() {
	        return +(this.cm * 0.39).toFixed(2);
	      }
	    };
	  }

	  device.descriptor.in = device.descriptor.inches;

	  Object.defineProperties(this, device.descriptor);

	  // Throttle
	  setInterval(function() {
	    var err = null;

	    // Nothing read since previous interval
	    if (state.samples.length === 0) {
	      return;
	    }

	    state.median = state.samples.sort()[Math.floor(state.samples.length / 2)];
	    this.value = state.median;

	    // @DEPRECATE
	    this.emit("read", err, state.median);
	    // The "read" event has been deprecated in
	    // favor of a "data" event.
	    this.emit("data", err, state.median);


	    // If the state.median value for this interval is not the same as the
	    // state.median value in the last interval, fire a "change" event.
	    //
	    if (state.last && state.median &&
	      (state.median.toFixed(1) !== state.last.toFixed(1))) {
	      this.emit("change", err, state.median);
	    }

	    // Store this media value for comparison
	    // in next interval
	    state.last = state.median;

	    // Reset state.samples;
	    state.samples.length = 0;
	  }.bind(this), this.freq);
	}

	util.inherits(Sonar, events.EventEmitter);
	__.mixin(Sonar.prototype, within);

	Devices = {
	  SRF10: {
	    initialize: function(opts) {

	      var samples = priv.get(this).samples;
	      var address = 0x70;
	      var delay = 65;

	      // Set up I2C data connection
	      this.io.i2cConfig(opts);

	      // Startup parameter
	      this.io.i2cWrite(address, [0x01, 16]);
	      this.io.i2cWrite(address, [0x02, 255]);

	      this.io.setMaxListeners(100);

	      function read() {
	        this.io.i2cWrite(address, [0x02]);
	        this.io.i2cReadOnce(address, 2, function(data) {
	          samples.push((data[0] << 8) | data[1]);
	        }.bind(this));

	        prime.call(this);
	      }

	      function prime() {
	        // 0x52 result in us (microseconds)
	        this.io.i2cWrite(address, [0x00, 0x52]);

	        setTimeout(read.bind(this), delay);
	      }

	      prime.call(this);
	    },
	    descriptor: {
	      cm: {
	        get: function() {
	          var median = priv.get(this).median;
	          return +((((median / 2) * 343.2) / 10) / 1000).toFixed(1);
	        }
	      }
	    }
	  },

	  DEFAULT: {
	    initialize: function() {
	      var samples = priv.get(this).samples;

	      // Set the pin to ANALOG mode
	      this.mode = this.io.MODES.ANALOG;
	      this.io.pinMode(this.pin, this.mode);

	      this.io.analogRead(this.pin, function(data) {
	        samples.push(data);
	      }.bind(this));
	    },
	    descriptor: {
	      cm: {
	        get: function() {
	          var median = priv.get(this).median;
	          return +((median / 2) * 2.54).toFixed(1);
	        }
	      }
	    }
	  }
	};

	Devices.SRF02 = Devices.SRF08 = Devices.SRF10;

	module.exports = Sonar;

	// Reference
	//
	// http://www.maxbotix.com/tutorials.htm#Code_example_for_the_BasicX_BX24p
	// http://www.electrojoystick.com/tutorial/?page_id=285

	// Tutorials
	//
	// http://www.sensorpedia.com/blog/how-to-interface-an-ultrasonic-rangefinder-with-sensorpedia-via-twitter-guide-2/


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var priv = new Map();
	var steppers = new Map();

	var MAXSTEPPERS = 6; // correlates with MAXSTEPPERS in firmware


	function Step(stepper) {
	  this.rpm = 180;
	  this.direction = -1;
	  this.speed = 0;
	  this.accel = 0;
	  this.decel = 0;

	  this.stepper = stepper;
	}

	Step.PROPERTIES = ["rpm", "direction", "speed", "accel", "decel"];
	Step.DEFAULTS = [180, -1, 0, 0, 0];


	function MotorPins(pins) {
	  var k = 0;
	  pins = pins.slice();
	  while (pins.length) {
	    this["motor" + (++k)] = pins.shift();
	  }
	}

	function isSupported(io) {
	  return io.pins.some(function(pin) {
	    return pin.supportedModes.includes(io.MODES.STEPPER);
	  });
	}

	/**
	 * Stepper
	 *
	 * Class for handling steppers using AdvancedFirmata support for asynchronous stepper control
	 *
	 *
	 * five.Stepper({
	 *  type: constant,     // io.STEPPER.TYPE.*
	 *  stepsPerRev: number,  // steps to make on revolution of stepper
	 *  pins: {
	 *    step: number,   // pin attached to step pin on driver (used for type DRIVER)
	 *    dir: number,    // pin attached to direction pin on driver (used for type DRIVER)
	 *    motor1: number, // (used for type TWO_WIRE and FOUR_WIRE)
	 *    motor2: number, // (used for type TWO_WIRE and FOUR_WIRE)
	 *    motor3: number, // (used for type FOUR_WIRE)
	 *    motor4: number, // (used for type FOUR_WIRE)
	 *  }
	 * });
	 *
	 *
	 * five.Stepper({
	 *  type: five.Stepper.TYPE.DRIVER
	 *  stepsPerRev: number,
	 *  pins: {
	 *    step: number,
	 *    dir: number
	 *  }
	 * });
	 *
	 * five.Stepper({
	 *  type: five.Stepper.TYPE.DRIVER
	 *  stepsPerRev: number,
	 *  pins: [ step, dir ]
	 * });
	 *
	 * five.Stepper({
	 *  type: five.Stepper.TYPE.TWO_WIRE
	 *  stepsPerRev: number,
	 *  pins: {
	 *    motor1: number,
	 *    motor2: number
	 *  }
	 * });
	 *
	 * five.Stepper({
	 *  type: five.Stepper.TYPE.TWO_WIRE
	 *  stepsPerRev: number,
	 *  pins: [ motor1, motor2 ]
	 * });
	 *
	 * five.Stepper({
	 *  type: five.Stepper.TYPE.FOUR_WIRE
	 *  stepsPerRev: number,
	 *  pins: {
	 *    motor1: number,
	 *    motor2: number,
	 *    motor3: number,
	 *    motor4: number
	 *  }
	 * });
	 *
	 * five.Stepper({
	 *  type: five.Stepper.TYPE.FOUR_WIRE
	 *  stepsPerRev: number,
	 *  pins: [ motor1, motor2, motor3, motor4 ]
	 * });
	 *
	 *
	 * @param {Object} opts
	 *
	 */

	function Stepper(opts) {
	  var state, params = [];

	  if (!(this instanceof Stepper)) {
	    return new Stepper(opts);
	  }

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  if (!isSupported(this.io)) {
	    throw new Error(
	      "Stepper is not supported"
	    );
	  }

	  if (!opts.pins) {
	    throw new Error(
	      "Stepper requires a `pins` object or array"
	    );
	  }

	  if (!opts.stepsPerRev) {
	    throw new Error(
	      "Stepper requires a `stepsPerRev` number value"
	    );
	  }

	  steppers.set(this.board, steppers.get(this.board) || []);
	  this.id = steppers.get(this.board).length;

	  if (this.id >= MAXSTEPPERS) {
	    throw new Error(
	      "Stepper cannot exceed max steppers (" + MAXSTEPPERS + ")"
	    );
	  }

	  // Convert an array of pins to the appropriate named pin
	  if (Array.isArray(this.pins)) {
	    if (this.pins.length === 2) {
	      // Using an array of 2 pins requres a TYPE
	      // to disambiguate DRIVER and TWO_WIRE
	      if (!opts.type) {
	        throw new Error(
	          "Stepper requires a `type` number value (DRIVER, TWO_WIRE)"
	        );
	      }
	    }

	    if (opts.type === Stepper.TYPE.DRIVER) {
	      this.pins = {
	        step: this.pins[0],
	        dir: this.pins[1]
	      };
	    } else {
	      this.pins = new MotorPins(this.pins);
	    }
	  }

	  // Attempt to guess the type if none is provided
	  if (!opts.type) {
	    if (this.pins.dir) {
	      opts.type = Stepper.TYPE.DRIVER;
	    } else {
	      if (this.pins.motor3) {
	        opts.type = Stepper.TYPE.FOUR_WIRE;
	      } else {
	        opts.type = Stepper.TYPE.TWO_WIRE;
	      }
	    }
	  }


	  // Initial Stepper config params (same for all 3 types)
	  params.push(this.id, opts.type, opts.stepsPerRev);


	  if (opts.type === Stepper.TYPE.DRIVER) {
	    if (!this.pins.dir || !this.pins.step) {
	      throw new Error(
	        "Stepper.TYPE.DRIVER expects: `pins.dir`, `pins.step`"
	      );
	    }

	    params.push(
	      this.pins.dir, this.pins.step
	    );
	  }

	  if (opts.type === Stepper.TYPE.TWO_WIRE) {
	    if (!this.pins.motor1 || !this.pins.motor2) {
	      throw new Error(
	        "Stepper.TYPE.TWO_WIRE expects: `pins.motor1`, `pins.motor2`"
	      );
	    }

	    params.push(
	      this.pins.motor1, this.pins.motor2
	    );
	  }

	  if (opts.type === Stepper.TYPE.FOUR_WIRE) {
	    if (!this.pins.motor1 || !this.pins.motor2 || !this.pins.motor3 || !this.pins.motor4) {
	      throw new Error(
	        "Stepper.TYPE.FOUR_WIRE expects: `pins.motor1`, `pins.motor2`, `pins.motor3`, `pins.motor4`"
	      );
	    }

	    params.push(
	      this.pins.motor1, this.pins.motor2, this.pins.motor3, this.pins.motor4
	    );
	  }

	  // Iterate the params and set each pin's mode to MODES.STEPPER
	  // Params:
	  // [deviceNum, type, stepsPerRev, dirOrMotor1Pin, stepOrMotor2Pin, motor3Pin, motor4Pin]
	  // The first 3 are required, the remaining 2-4 will be pins
	  params.slice(3).forEach(function(pin) {
	    this.io.pinMode(pin, this.io.MODES.STEPPER);
	  }, this);

	  this.io.stepperConfig.apply(this.io, params);

	  steppers.get(this.board).push(this);

	  state = Step.PROPERTIES.reduce(function(state, key, i) {
	    return (state[key] = typeof opts[key] !== "undefined" ? opts[key] : Step.DEFAULTS[i], state);
	  }, {
	    isRunning: false,
	    type: opts.type,
	    pins: this.pins
	  });

	  priv.set(this, state);

	  Object.defineProperties(this, {
	    type: {
	      get: function() {
	        return state.type;
	      }
	    },

	    pins: {
	      get: function() {
	        return state.pins;
	      }
	    }
	  });
	}

	Object.defineProperties(Stepper, {
	  TYPE: {
	    value: Object.freeze({
	      DRIVER: 1,
	      TWO_WIRE: 2,
	      FOUR_WIRE: 4
	    })
	  },
	  RUNSTATE: {
	    value: Object.freeze({
	      STOP: 0,
	      ACCEL: 1,
	      DECEL: 2,
	      RUN: 3
	    })
	  },
	  DIRECTION: {
	    value: Object.freeze({
	      CCW: 0,
	      CW: 1
	    })
	  }
	});

	/**
	 * rpm
	 *
	 * Gets the rpm value or sets the rpm in revs per minute
	 * making an internal conversion to speed in `0.01 * rad/s`
	 *
	 * @param {Number} rpm Revs per minute
	 *
	 * NOTE: *rpm* is optional, if missing
	 * the method will behave like a getter
	 *
	 * @return {Stepper} this Chainable method when used as a setter
	 */
	Stepper.prototype.rpm = function(rpm) {
	  var state = priv.get(this);

	  if (typeof rpm === "undefined") {
	    return state.rpm;
	  }
	  state.rpm = rpm;
	  state.speed = Math.round(rpm * (2 * Math.PI) * 100 / 60);
	  return this;
	};

	/**
	 * speed
	 *
	 * Gets the speed value or sets the speed in `0.01 * rad/s`
	 * making an internal conversion to rpm
	 *
	 * @param {Number} speed Speed given in 0.01 * rad/s
	 *
	 * NOTE: *speed* is optional, if missing
	 * the method will behave like a getter
	 *
	 * @return {Stepper} this Chainable method when used as a setter
	 */
	Stepper.prototype.speed = function(speed) {
	  var state = priv.get(this);

	  if (typeof speed === "undefined") {
	    return state.speed;
	  }
	  state.speed = speed;
	  state.rpm = Math.round(speed / (2 * Math.PI) / 100 * 60);
	  return this;
	};

	["direction", "accel", "decel"].forEach(function(prop) {
	  Stepper.prototype[prop] = function(value) {
	    var state = priv.get(this);

	    if (typeof value === "undefined") {
	      return state[prop];
	    }
	    state[prop] = value;
	    return this;
	  };
	});

	Stepper.prototype.ccw = function() {
	  return this.direction(0);
	};

	Stepper.prototype.cw = function() {
	  return this.direction(1);
	};

	/**
	 * step
	 *
	 * Move stepper motor a number of steps and call the callback on completion
	 *
	 * @param {Number} stepsOrOpts Steps to move using current settings for speed, accel, etc.
	 * @param {Object} stepsOrOpts Options object containing any of the following:
	 *    stepsOrOpts = {
	 *      steps:
	 *      rpm:
	 *      speed:
	 *      direction:
	 *      accel:
	 *      decel:
	 *    }
	 *
	 * NOTE: *steps* is required.
	 *
	 * @param {Function} callback function(err, complete)
	 */
	Stepper.prototype.step = function(stepsOrOpts, callback) {
	  var steps, step, state, params, isValidStep;

	  steps = typeof stepsOrOpts === "object" ?
	    (stepsOrOpts.steps || 0) : Math.floor(stepsOrOpts);

	  step = new Step(this);

	  state = priv.get(this);

	  params = [];

	  isValidStep = true;

	  function failback(error) {
	    isValidStep = false;
	    if (callback) { callback(error); }
	  }

	  params.push(steps);

	  if (typeof stepsOrOpts === "object") {
	    // If an object of property values has been provided,
	    // call the correlating method with the value argument.
	    Step.PROPERTIES.forEach(function(key) {
	      if (typeof stepsOrOpts[key] !== "undefined") {
	        this[key](stepsOrOpts[key]);
	      }
	    }, this);
	  }

	  if (!state.speed) {
	    this.rpm(state.rpm);
	    step.speed = this.speed();
	  }


	  // Ensure that the property params are set in the
	  // correct order, but without rpm
	  Step.PROPERTIES.slice(1).forEach(function(key) {
	    params.push(step[key] = this[key]());
	  }, this);


	  if (steps === 0) {
	    failback(
	      new Error(
	        "Must set a number of steps when calling `step()`"
	      )
	    );
	  }

	  if (step.direction < 0) {
	    failback(
	      new Error(
	        "Must set a direction before calling `step()`"
	      )
	    );
	  }

	  if (isValidStep) {
	    state.isRunning = true;

	    params.push(function(complete) {
	      state.isRunning = false;
	      callback(null, complete);
	    });

	    step.move.apply(step, params);
	  }

	  return this;
	};

	Step.prototype.move = function(steps, dir, speed, accel, decel, callback) {
	  // Restore the param order... (steps, dir => dir, steps)
	  this.stepper.io.stepperStep.apply(
	    this.stepper.io, [this.stepper.id, dir, steps, speed, accel, decel, callback]
	  );
	};

	module.exports = Stepper;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103);
	var __ = __webpack_require__(115);
	var events = __webpack_require__(8);
	var util = __webpack_require__(12);

	// Switch instance private data
	var priv = new Map();
	var aliases = {
	  close: ["close", "closed", "on"],
	  open: ["open", "off"]
	};


	/**
	 * Switch
	 * @constructor
	 *
	 * five.Switch();
	 *
	 * five.Switch({
	 *   pin: 10
	 * });
	 *
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Switch(opts) {

	  if (!(this instanceof Switch)) {
	    return new Switch(opts);
	  }

	  // Create a 5 ms debounce boundary on event triggers
	  // this avoids button events firing on
	  // press noise and false positives
	  var trigger = __.debounce(function(key) {
	    aliases[key].forEach(function(type) {
	      this.emit(type, null);
	    }, this);
	  }, 7);

	  var state = {
	    isClosed: false
	  };

	  Board.Component.call(
	    this, opts = Board.Options(opts)
	  );

	  // Set the pin to INPUT mode
	  this.mode = this.io.MODES.INPUT;
	  this.io.pinMode(this.pin, this.mode);

	  // Create a "state" entry for privately
	  // storing the state of the Switch
	  priv.set(this, state);

	  // Digital Read event loop
	  this.io.digitalRead(this.pin, function(data) {
	    // data = 0, this.isClosed = true
	    // indicates that the Switch has been opened
	    // after previously being closed
	    if (!data && this.isClosed) {
	      state.isClosed = false;
	      trigger.call(this, "open");
	    }

	    // data = 1, this.isClosed = false
	    // indicates that the Switch has been close
	    // after previously being open
	    if (data && !this.isClosed) {

	      // Update private data
	      state.isClosed = true;

	      // Call debounced event trigger.
	      trigger.call(this, "close" /* key */ );
	    }
	  }.bind(this));

	  Object.defineProperties(this, {
	    isClosed: {
	      get: function() {
	        return state.isClosed;
	      }
	    },
	    isOpen: {
	      get: function() {
	        return !state.isClosed;
	      }
	    }
	  });
	}

	util.inherits(Switch, events.EventEmitter);


	/**
	 * Fired when the Switch is close
	 *
	 * @event
	 * @name close
	 * @memberOf Switch
	 */


	/**
	 * Fired when the Switch is opened
	 *
	 * @event
	 * @name open
	 * @memberOf Switch
	 */


	module.exports = Switch;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12);

	var DEBUG = true;

	var Devices, Change, Update;

	// Event type alias map
	var aliases = {
	  down: ["down", "press", "tap", "impact", "hit"],
	  up: ["up", "release"],
	  hold: ["hold"]
	};

	// all private instances
	var priv = new Map();

	// hold time out for buttons.
	var holdTimeout = new Map();

	// keeps data between cycles and fires change event
	// if data changes
	var last = new Map();




	/**
	 * Wii
	 * @constructor
	 *
	 * five.Wii({
	 *   device: "RVL-004",
	 *   holdtime: ms before firing a hold event on a button,
	 *   freq: ms to throttle the read data loop
	 *   threshold: difference of change to qualify for a change event
	 *  });
	 *
	 * Available events:
	 *    "read" - firehose.
	 *    "down", "press", "tap", "impact", "hit" - button press
	 *    "up", "release" - button release
	 *    "hold" - button hold
	 *
	 * @param {Object} opts [description]
	 *
	 */

	function Wii(opts) {

	  if (!(this instanceof Wii)) {
	    return new Wii(opts);
	  }

	  var address, bytes, data, device,
	    delay, setup, preread;

	  Board.Component.call(this, opts);

	  // Derive device definition from Devices
	  device = Devices[opts.device];

	  address = device.address;
	  bytes = device.bytes;
	  delay = device.delay;
	  data = device.data;
	  setup = device.setup;
	  preread = device.preread;

	  // Wii controller instance properties
	  this.freq = opts.freq || 500;

	  // Button instance properties
	  this.holdtime = opts.holdtime || 500;
	  this.threshold = opts.threshold || 10;

	  // Initialize components
	  device.initialize.call(this);

	  // Set initial "last data" byte array
	  last.set(this, [0, 0, 0, 0, 0, 0, 0]);

	  // Set up I2C data connection
	  this.io.i2cConfig(opts);

	  // Iterate and write each set of setup instructions
	  setup.forEach(function(bytes) {
	    this.io.i2cWrite(address, bytes);
	  }, this);

	  // Unthrottled i2c read request loop
	  setInterval(function() {

	    // Send this command to get all sensor data and store into
	    // the 6-byte register within Wii controller.
	    // This must be execute before reading data from the Wii.

	    // Iterate and write each set of setup instructions
	    preread.forEach(function(bytes) {
	      this.io.i2cWrite(address, bytes);
	    }, this);


	    // Request six bytes of data from the controller
	    this.io.i2cReadOnce(address, bytes, data.bind(this));

	    // Use the high-frequency data read loop as the change event
	    // emitting loop. This drastically improves change event
	    // frequency and sensitivity
	    //
	    // Emit change events if any delta is greater than
	    // the threshold

	    // RVL-005 does not have a read method at this time.
	    if (typeof device.read !== "undefined") {
	      device.read.call(this);
	    }
	  }.bind(this), delay || this.freq);

	  // Throttled "read" event loop
	  setInterval(function() {
	    var event = Board.Event({
	      target: this
	    });

	    // @DEPRECATE
	    this.emit("read", null, event);
	    // The "read" event has been deprecated in
	    // favor of a "data" event.
	    this.emit("data", null, event);

	  }.bind(this), this.freq);
	}

	Wii.Components = {};

	// A nunchuck button (c or z.)
	Wii.Components.Button = function(which, controller) {

	  if (!(this instanceof Wii.Components.Button)) {
	    return new Wii.Components.Button(which, controller);
	  }

	  // c or z.
	  this.which = which;

	  // reference to parent controller
	  this.controller = controller;

	  // Set initial values for state tracking
	  priv.set(this, {
	    isDown: false
	  });

	  Object.defineProperties(this, {
	    // is the button up (not pressed)?
	    isUp: {
	      get: function() {
	        return !priv.get(this).isDown;
	      }
	    },

	    // is the button pressed?
	    isDown: {
	      get: function() {
	        return priv.get(this).isDown;
	      }
	    }
	  });
	};

	Wii.Components.Joystick = function(controller) {

	  if (!(this instanceof Wii.Components.Joystick)) {
	    return new Wii.Components.Joystick(controller);
	  }

	  this.controller = controller;

	  var state, accessors;

	  // Initialize empty state object
	  state = {};

	  // Initialize empty accessors object
	  accessors = {};

	  // Enumerate Joystick properties
	  ["x", "y", "dx", "dy"].forEach(function(key) {

	    state[key] = 0;

	    // Define accessors for each property in Joystick list
	    accessors[key] = {
	      get: function() {
	        return priv.get(this)[key];
	      }
	    };
	  }, this);

	  // Store private state cache
	  priv.set(this, state);

	  // Register newly defined accessors
	  Object.defineProperties(this, accessors);
	};

	Wii.Components.Accelerometer = function(controller) {

	  if (!(this instanceof Wii.Components.Accelerometer)) {
	    return new Wii.Components.Accelerometer(controller);
	  }

	  this.controller = controller;

	  var state, accessors;

	  // Initialize empty state object
	  state = {};

	  // Initialize empty accessors object
	  accessors = {};

	  // Enumerate Joystick properties
	  ["x", "y", "z", "dx", "dy", "dz"].forEach(function(key) {

	    state[key] = 0;

	    // Define accessors for each property in Joystick list
	    accessors[key] = {
	      get: function() {
	        return priv.get(this)[key];
	      }
	    };
	  }, this);

	  // Store private state cache
	  priv.set(this, state);

	  // Register newly defined accessors
	  Object.defineProperties(this, accessors);
	};

	util.inherits(Wii, events.EventEmitter);
	util.inherits(Wii.Components.Button, events.EventEmitter);
	util.inherits(Wii.Components.Joystick, events.EventEmitter);
	util.inherits(Wii.Components.Accelerometer, events.EventEmitter);


	// Regular Wiimote driver bytes will be encoded 0x17

	function decodeByte(x) {
	  return (x ^ 0x17) + 0x17;
	}

	// Change handlers for disparate controller event types
	//
	// Note: Change.* methods are |this| sensitive,
	// therefore, call sites must use:
	//
	//    Change.button.call( instance, data );
	//
	//    Change.component.call( instance, data );
	//
	//
	Change = {

	  // Fire a "down", "up" or "hold" (and aliases) event
	  // for a button context
	  button: function(key) {
	    // |this| is button context set by calling as:
	    // Change.button.call( button instance, event key );
	    //

	    // Enumerate all button event aliases,
	    // fire matching types
	    aliases[key].forEach(function(type) {
	      var event = new Board.Event({
	        // |this| value is a button instance
	        target: this,
	        type: type
	      });

	      // fire button event on the button itself
	      this.emit(type, null, event);

	      // fire button event on the controller
	      this.controller.emit(type, null, event);
	    }, this);
	  },

	  // Fire a "change" event on a component context
	  component: function(coordinate) {
	    // |this| is component context set by calling as:
	    // Change.component.call( component instance, coordinate, val );
	    //

	    ["axischange", "change"].forEach(function(type) {
	      var event;

	      if (this._events && this._events[type]) {
	        event = new Board.Event({
	          // |this| value is a button instance
	          target: this,
	          type: type,
	          axis: coordinate,
	          // Check dx/dy/dz change to determine direction
	          direction: this["d" + coordinate] < 0 ? -1 : 1
	        });

	        // Fire change event on actual component
	        this.emit(type, null, event);

	        // Fire change on controller
	        this.controller.emit(type, null, event);
	      }
	    }, this);
	  }
	};

	// Update handlers for disparate controller event types
	//
	// Note: Update.* methods are |this| sensitive,
	// therefore, call sites must use:
	//
	//    Update.button.call( button instance, boolean down );
	//
	//    Update.component.call( component instance, coordinate, val );
	//
	//

	Update = {
	  // Set "down" state for button context.
	  button: function(isDown) {
	    // |this| is button context set by calling as:
	    // Update.button.call( button instance, boolean down );
	    //

	    var state, isFireable;

	    // Derive state from private cache
	    state = priv.get(this);

	    // if this is a state change, mark this
	    // change as fireable.
	    isFireable = false;

	    if (isDown !== state.isDown) {
	      isFireable = true;
	    }

	    state.isDown = isDown;

	    priv.set(this, state);

	    if (isFireable) {
	      // start hold timeout for broadcasting hold.
	      holdTimeout.set(this, setTimeout(function() {
	        if (state.isDown) {
	          Change.button.call(this, "hold");
	        }
	      }.bind(this), this.controller.holdtime));

	      Change.button.call(this, isDown ? "down" : "up");
	    }
	  },

	  // Set "coordinate value" state for component context.
	  component: function(coordinate, val) {
	    // |this| is component context set by calling as:
	    // Update.component.call( component instance, coordinate, val );
	    //

	    var state = priv.get(this);
	    state["d" + coordinate] = val - state[coordinate];
	    state[coordinate] = val;
	    priv.set(this, state);
	  }
	};


	Devices = {

	  // Nunchuk
	  "RVL-004": {
	    address: 0x52,
	    bytes: 6,
	    delay: 100,
	    setup: [
	      [0x40, 0x00]
	    ],
	    preread: [
	      [0x00]
	    ],
	    // device.read.call(this);
	    read: function() {
	      var axes = ["x", "y", "z"];

	      [
	        this.joystick,
	        this.accelerometer
	      ].forEach(function(component) {
	        axes.forEach(function(axis) {
	          var delta = "d" + axis;
	          if (typeof component[delta] !== "undefined") {
	            if (Math.abs(component[delta]) > this.threshold) {
	              Change.component.call(component, axis);
	            }
	          }
	        }, this);
	      }, this);
	    },
	    // Call as:
	    // device.initialize.call(this);
	    initialize: function() {
	      this.joystick = new Wii.Components.Joystick(this);
	      this.accelerometer = new Wii.Components.Accelerometer(this);
	      this.c = new Wii.Components.Button("c", this);
	      this.z = new Wii.Components.Button("z", this);
	    },
	    data: function(data) {
	      // TODO: Shift state management to weakmap, this
	      //       should only update an entry in the map
	      //

	      if (data[0] !== 254 && data[1] !== 254 && data[2] !== 254) {

	        // Byte 0x00 :  X-axis data of the joystick
	        Update.component.call(
	          this.joystick,
	          "x", decodeByte(data[0]) << 2
	        );

	        // Byte 0x01 :  Y-axis data of the joystick
	        Update.component.call(
	          this.joystick,
	          "y", decodeByte(data[1]) << 2
	        );

	        // Byte 0x02 :  X-axis data of the accellerometer sensor
	        Update.component.call(
	          this.accelerometer,
	          "x", decodeByte(data[2]) << 2
	        );

	        // Byte 0x03 :  Y-axis data of the accellerometer sensor
	        Update.component.call(
	          this.accelerometer,
	          "y", decodeByte(data[3]) << 2
	        );

	        // Byte 0x04 :  Z-axis data of the accellerometer sensor
	        Update.component.call(
	          this.accelerometer,
	          "z", decodeByte(data[4]) << 2
	        );

	        // Update Z button
	        // Grab the first byte of the sixth bit
	        Update.button.call(
	          this.z, (decodeByte(data[5]) & 0x01) === 0 ? true : false
	        );

	        // Update C button
	        // Grab the second byte of the sixth bit
	        Update.button.call(
	          this.c, (decodeByte(data[5]) & 0x02) === 0 ? true : false
	        );

	        // Update last data array cache
	        last.set(this, data);
	      }
	    }
	  },

	  // Classic Controller
	  "RVL-005": {
	    address: 0x52,
	    bytes: 6,
	    delay: 100,
	    setup: [
	      [0x40, 0x00]
	    ],
	    preread: [
	      [0x00]
	    ],

	    // read: function( this ) {
	    //   var axes = [ "x", "y", "z" ];

	    //   [ this.joystick.left, this.joystick.right ].forEach(function( component ) {
	    //     axes.forEach( function( axis ) {
	    //       var delta = "d" + axis;
	    //       if ( typeof component[ delta ] !== "undefined" ) {
	    //         if ( Math.abs( component[ delta ] ) > this.threshold ) {
	    //           Change.component.call( component, axis );
	    //         }
	    //       }
	    //     }, this );
	    //   }, this );
	    // },
	    initialize: function() {

	      this.joystick = {
	        left: new Wii.Components.Joystick(this),
	        right: new Wii.Components.Joystick(this)
	      };

	      // obj.direction_pad = new Wii.DirectionPad( obj );
	      [
	        "y", "x", "up", "down", "left", "right",
	        "a", "b", "l", "r", "zl", "zr", "start", "home", "select"
	      ].forEach(function(id) {

	        this[id] = new Wii.Components.Button(id, this);

	      }, this);
	    },
	    data: function(data) {
	      // TODO: Shift state management to weakmap, this
	      //       should only update an entry in the map
	      //
	      // console.log("data read");
	      if (data[0] !== 254 && data[1] !== 254 && data[2] !== 254) {
	        // Update.button.call(
	        //   this.l,
	        //   ( decodeByte( data[4] ) & 0x05 ) === 0 ? true : false
	        // );
	        // console.log("L:"+( decodeByte( data[4] ) & (1 << 5) ) === 0 ? true : false);

	        // LEFT/RIGHT
	        Update.button.call(
	          this.l, (decodeByte(data[4]) & 0x20) === 0 ? true : false
	        );

	        Update.button.call(
	          this.r, (decodeByte(data[4]) & 0x02) === 0 ? true : false
	        );

	        // Direction
	        Update.button.call(
	          this.up, (decodeByte(data[5]) & 0x01) === 0 ? true : false
	        );

	        Update.button.call(
	          this.left, (decodeByte(data[5]) & 0x02) === 0 ? true : false
	        );

	        Update.button.call(
	          this.down, (decodeByte(data[4]) & 0x40) === 0 ? true : false
	        );

	        Update.button.call(
	          this.right, (decodeByte(data[4]) & 0x80) === 0 ? true : false
	        );

	        // Z*
	        Update.button.call(
	          this.zr, (decodeByte(data[5]) & 0x04) === 0 ? true : false
	        );

	        Update.button.call(
	          this.zl, (decodeByte(data[5]) & 0x80) === 0 ? true : false
	        );

	        // X/Y
	        Update.button.call(
	          this.x, (decodeByte(data[5]) & 0x08) === 0 ? true : false
	        );

	        Update.button.call(
	          this.y, (decodeByte(data[5]) & 0x20) === 0 ? true : false
	        );

	        // A/B
	        Update.button.call(
	          this.a, (decodeByte(data[5]) & 0x10) === 0 ? true : false
	        );

	        Update.button.call(
	          this.b, (decodeByte(data[5]) & 0x40) === 0 ? true : false
	        );

	        // MENU
	        Update.button.call(
	          this.select, (decodeByte(data[4]) & 0x10) === 0 ? true : false
	        );

	        Update.button.call(
	          this.start, (decodeByte(data[4]) & 0x04) === 0 ? true : false
	        );

	        Update.button.call(
	          this.home, (decodeByte(data[4]) & 0x08) === 0 ? true : false
	        );


	        /// debugger to parse out keycodes.
	        if (DEBUG) {

	          // var leftX = ( decodeByte( data[1] ) & 0x0f );
	          // var leftX = ( decodeByte( data[1] ) & 0x0f );
	          // console.log("--------------------");
	          // console.log(data.join(","));
	          // console.log("--------------------");
	          // for (var b = 3; b < 6; b++) {
	          //   for (var c = 0; c <= 255; c++) {
	          //     var t = ( decodeByte( data[b] ) & c ) === 0 ? true : false;
	          //     if (t)
	          //       console.log(b+">"+c+":");
	          //   }
	          // }
	          // console.log("--------------------");
	          // ( pressedRowBit( decodeByte( data[0] ), 5 ));
	        }

	        Update.component.call(
	          this.joystick.left,
	          "x", decodeByte(data[0]) & 0x3f
	        );
	        // console.log("X"+decodeByte( data[0] ) << 2);

	        // Byte 0x01 :  Y-axis data of the joystick
	        Update.component.call(
	          this.joystick.left,
	          "y", decodeByte(data[0]) & 0x3f
	        );

	        Update.component.call(
	          this.joystick.right,
	          "x", ((data[0] & 0xc0) >> 3) + ((data[1] & 0xc0) >> 5) + ((data[2] & 0x80) >> 7)
	        );

	        Update.component.call(
	          this.joystick.right,
	          "y", data[2] & 0x1f
	        );

	        // Update last data array cache
	        last.set(this, data);
	      }
	    }
	  }
	};


	Wii.Nunchuk = function(opts) {
	  return new Wii({
	    freq: opts && "freq" in opts ? opts.freq : 100,
	    device: "RVL-004"
	  });
	};

	Wii.Classic = function(opts) {
	  return new Wii({
	    freq: opts && "freq" in opts ? opts.freq : 100,
	    device: "RVL-005"
	  });
	};

	module.exports = Wii;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var Board = __webpack_require__(103),
	  events = __webpack_require__(8),
	  util = __webpack_require__(12),
	  __ = __webpack_require__(115),
	  Led = __webpack_require__(154),
	  Sensor = __webpack_require__(138);

	var CALIBRATED_MIN_VALUE = 0;
	var CALIBRATED_MAX_VALUE = 1000;
	var LINE_ON_THRESHOLD = 200;
	var LINE_NOISE_THRESHOLD = 50;

	var priv = new Map();

	// Private methods
	function initialize() {
	  var self = this, state = priv.get(this);

	  if (typeof this.opts.emitter === "undefined") {
	    throw new Error("Emitter pin is required");
	  }

	  if (!this.pins || this.pins.length === 0) {
	    throw new Error("Pins must be defined");
	  }

	  state.emitter = new Led({
	    board: this.board,
	    pin: this.opts.emitter
	  });

	  state.sensorStates = this.pins.map(function(pin) {
	    var sensorState = {
	      sensor: new Sensor({
	        board: this.board,
	        freq: this.freq,
	        pin: pin
	      }),
	      rawValue: 0,
	      dataReceived: false
	    };


	    sensorState.sensor.on("data", function() {
	      onData.call(self, sensorState, this.value);
	    });

	    return sensorState;
	  }, this);
	}

	function onData(sensorState, value) {
	  var allRead, state = priv.get(this);

	  sensorState.dataReceived = true;
	  sensorState.rawValue = value;

	  allRead = __.every(state.sensorStates, "dataReceived");

	  if (allRead) {
	    this.emit("data", null, this.raw);

	    if (state.autoCalibrate) {
	      setCalibration(state.calibration, this.raw);
	    }

	    if (this.isCalibrated) {
	      this.emit("calibratedData", null, this.values);
	      this.emit("line", null, this.line);
	    }

	    state.sensorStates.forEach(function(sensorState) {
	      sensorState.dataReceived = false;
	    });
	  }
	}

	function setCalibration(calibration, values) {
	  values.forEach(function(value, i) {
	    if (calibration.min[i] === undefined || value < calibration.min[i]) {
	      calibration.min[i] = value;
	    }

	    if (calibration.max[i] === undefined || value > calibration.max[i]) {
	      calibration.max[i] = value;
	    }
	  });
	}

	function calibrationIsValid(calibration, sensors) {
	  return calibration &&
	         (calibration.max && calibration.max.length === sensors.length) &&
	         (calibration.min && calibration.min.length === sensors.length);
	}


	function calibratedValues() {
	  return this.raw.map(function(value, i) {
	    var max = this.calibration.max[i],
	        min = this.calibration.min[i];

	    var scaled = __.scale(value, min, max, CALIBRATED_MIN_VALUE, CALIBRATED_MAX_VALUE);
	    return __.constrain(scaled, CALIBRATED_MIN_VALUE, CALIBRATED_MAX_VALUE);
	  }, this);
	}

	function maxLineValue() {
	  return (this.sensors.length - 1) * CALIBRATED_MAX_VALUE;
	}

	// Returns a value between 0 and (n-1)*1000
	// Given 5 sensors, the value will be between 0 and 4000
	function getLine(whiteLine) {
	  var onLine = false;
	  var avg = 0, sum = 0;
	  var state = priv.get(this);

	  whiteLine = !!whiteLine;

	  this.values.forEach(function(value, i) {
	    value = whiteLine ? (CALIBRATED_MAX_VALUE - value) : value;

	    if (value > LINE_ON_THRESHOLD) {
	      onLine = true;
	    }

	    if (value > LINE_NOISE_THRESHOLD) {
	      avg += value * i * CALIBRATED_MAX_VALUE;
	      sum += value;
	    }
	  });

	  if (!onLine) {
	    var maxPoint = maxLineValue.call(this) + 1;
	    var centerPoint = maxPoint/2;

	    return state.lastLine < centerPoint ? 0 : maxPoint;
	  }

	  return state.lastLine = Math.floor(avg/sum);
	}

	// Constructor
	function ReflectanceArray(opts) {

	  if (!(this instanceof ReflectanceArray)) {
	    return new ReflectanceArray(opts);
	  }

	  this.opts = Board.Options(opts);

	  Board.Component.call(
	    this, this.opts, {
	      requestPin: false
	    }
	  );

	  // Read event throttling
	  this.freq = opts.freq || 25;

	  // Make private data entry
	  var state = {
	    lastLine: 0,
	    isOn: false,
	    calibration: {
	      min: [],
	      max: []
	    },
	    autoCalibrate: opts.autoCalibrate || false
	  };

	  priv.set(this, state);

	  initialize.call(this);

	  Object.defineProperties(this, {
	    isOn: {
	      get: function() {
	        return state.emitter.isOn;
	      }
	    },
	    isCalibrated: {
	      get: function() {
	        return calibrationIsValid(this.calibration, this.sensors);
	      }
	    },
	    isOnLine: {
	      get: function() {
	        var line = this.line;
	        return line > CALIBRATED_MIN_VALUE && line < maxLineValue.call(this);
	      }
	    },
	    sensors: {
	      get: function() {
	        return __.pluck(state.sensorStates, "sensor");
	      }
	    },
	    calibration: {
	      get: function() {
	        return state.calibration;
	      }
	    },
	    raw: {
	      get: function() {
	        return __.pluck(state.sensorStates, "rawValue");
	      }
	    },
	    values: {
	      get: function() {
	        return this.isCalibrated ? calibratedValues.call(this) : this.raw;
	      }
	    },
	    line: {
	      get: function() {
	        return this.isCalibrated ? getLine.call(this) : 0;
	      }
	    }
	  });
	}

	util.inherits(ReflectanceArray, events.EventEmitter);

	// Public methods
	ReflectanceArray.prototype.enable = function() {
	  var state = priv.get(this);

	  state.emitter.on();

	  return this;
	};

	ReflectanceArray.prototype.disable = function() {
	  var state = priv.get(this);

	  state.emitter.off();

	  return this;
	};

	// Calibrate will store the min/max values for this sensor array
	// It should be called many times in order to get a lot of readings
	// on light and dark areas.  See calibrateUntil for a convenience
	// for looping until a condition is met.
	ReflectanceArray.prototype.calibrate = function() {
	  var state = priv.get(this);

	  this.once("data", function(err, values) {
	    setCalibration(state.calibration, values);

	    this.emit("calibrated");
	  });

	  return this;
	};

	// This will continue to calibrate until the predicate is true.
	// Allows the user to calibrate n-times, or wait for user input,
	// or base it on calibration heuristics.  However the user wants.
	ReflectanceArray.prototype.calibrateUntil = function(predicate) {
	  var loop = function() {
	    this.calibrate();
	    this.once("calibrated", function() {
	      if (!predicate()) {
	        loop();
	      }
	    });
	  }.bind(this);

	  loop();

	  return this;
	};

	// Let the user tell us what the calibration data is
	// This allows the user to save calibration data and
	// reload it without needing to calibrate every time.
	ReflectanceArray.prototype.loadCalibration = function(calibration) {
	  var state = priv.get(this);

	  if (!calibrationIsValid(calibration, this.sensors)) {
	    throw new Error("Calibration data not properly set: {min: [], max: []}");
	  }

	  state.calibration = calibration;

	  return this;
	};

	module.exports = ReflectanceArray;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Leap is the global namespace of the Leap API.
	 * @namespace Leap
	 */
	module.exports = {
	  Controller: __webpack_require__(181),
	  Frame: __webpack_require__(182),
	  Gesture: __webpack_require__(188),
	  Hand: __webpack_require__(183),
	  Pointable: __webpack_require__(184),
	  Finger: __webpack_require__(190),
	  InteractionBox: __webpack_require__(189),
	  CircularBuffer: __webpack_require__(192),
	  UI: __webpack_require__(199),
	  JSONProtocol: __webpack_require__(196).JSONProtocol,
	  glMatrix: __webpack_require__(185),
	  mat3: __webpack_require__(185).mat3,
	  vec3: __webpack_require__(185).vec3,
	  loopController: undefined,
	  version: __webpack_require__(202),

	  /**
	   * Expose utility libraries for convenience
	   * Use carefully - they may be subject to upgrade or removal in different versions of LeapJS.
	   *
	   */
	  _: __webpack_require__(187),
	  EventEmitter: __webpack_require__(8).EventEmitter,

	  /**
	   * The Leap.loop() function passes a frame of Leap data to your
	   * callback function and then calls window.requestAnimationFrame() after
	   * executing your callback function.
	   *
	   * Leap.loop() sets up the Leap controller and WebSocket connection for you.
	   * You do not need to create your own controller when using this method.
	   *
	   * Your callback function is called on an interval determined by the client
	   * browser. Typically, this is on an interval of 60 frames/second. The most
	   * recent frame of Leap data is passed to your callback function. If the Leap
	   * is producing frames at a slower rate than the browser frame rate, the same
	   * frame of Leap data can be passed to your function in successive animation
	   * updates.
	   *
	   * As an alternative, you can create your own Controller object and use a
	   * {@link Controller#onFrame onFrame} callback to process the data at
	   * the frame rate of the Leap device. See {@link Controller} for an
	   * example.
	   *
	   * @method Leap.loop
	   * @param {function} callback A function called when the browser is ready to
	   * draw to the screen. The most recent {@link Frame} object is passed to
	   * your callback function.
	   *
	   * ```javascript
	   *    Leap.loop( function( frame ) {
	   *        // ... your code here
	   *    })
	   * ```
	   */
	  loop: function(opts, callback) {
	    if (opts && callback === undefined &&  ( ({}).toString.call(opts) === '[object Function]' ) ) {
	      callback = opts;
	      opts = {};
	    }

	    if (this.loopController) {
	      if (opts){
	        this.loopController.setupFrameEvents(opts);
	      }
	    }else{
	      this.loopController = new this.Controller(opts);
	    }

	    this.loopController.loop(callback);
	    return this.loopController;
	  },

	  /*
	   * Convenience method for Leap.Controller.plugin
	   */
	  plugin: function(name, options){
	    this.Controller.plugin(name, options)
	  }
	}


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Frame = __webpack_require__(182)
	  , Hand = __webpack_require__(183)
	  , Pointable = __webpack_require__(184)
	  , Finger = __webpack_require__(190)
	  , CircularBuffer = __webpack_require__(192)
	  , Pipeline = __webpack_require__(193)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , gestureListener = __webpack_require__(188).gestureListener
	  , Dialog = __webpack_require__(191)
	  , _ = __webpack_require__(187);

	/**
	 * Constructs a Controller object.
	 *
	 * When creating a Controller object, you may optionally pass in options
	 * to set the host , set the port, enable gestures, or select the frame event type.
	 *
	 * ```javascript
	 * var controller = new Leap.Controller({
	 *   host: '127.0.0.1',
	 *   port: 6437,
	 *   enableGestures: true,
	 *   frameEventName: 'animationFrame'
	 * });
	 * ```
	 *
	 * @class Controller
	 * @memberof Leap
	 * @classdesc
	 * The Controller class is your main interface to the Leap Motion Controller.
	 *
	 * Create an instance of this Controller class to access frames of tracking data
	 * and configuration information. Frame data can be polled at any time using the
	 * [Controller.frame]{@link Leap.Controller#frame}() function. Call frame() or frame(0) to get the most recent
	 * frame. Set the history parameter to a positive integer to access previous frames.
	 * A controller stores up to 60 frames in its frame history.
	 *
	 * Polling is an appropriate strategy for applications which already have an
	 * intrinsic update loop, such as a game.
	 *
	 * loopWhileDisconnected defaults to true, and maintains a 60FPS frame rate even when Leap Motion is not streaming
	 * data at that rate (such as no hands in frame).  This is important for VR/WebGL apps which rely on rendering for
	 * regular visual updates, including from other input devices.  Flipping this to false should be considered an
	 * optimization for very specific use-cases.
	 *
	 *
	 */


	var Controller = module.exports = function(opts) {
	  var inNode = (typeof(process) !== 'undefined' && process.versions && process.versions.node),
	    controller = this;

	  opts = _.defaults(opts || {}, {
	    inNode: inNode
	  });

	  this.inNode = opts.inNode;

	  opts = _.defaults(opts || {}, {
	    frameEventName: this.useAnimationLoop() ? 'animationFrame' : 'deviceFrame',
	    suppressAnimationLoop: !this.useAnimationLoop(),
	    loopWhileDisconnected: true,
	    useAllPlugins: false,
	    checkVersion: true
	  });

	  this.animationFrameRequested = false;
	  this.onAnimationFrame = function(timestamp) {
	    if (controller.lastConnectionFrame.valid){
	      controller.emit('animationFrame', controller.lastConnectionFrame);
	    }
	    controller.emit('frameEnd', timestamp);
	    if (
	      controller.loopWhileDisconnected &&
	      ( ( controller.connection.focusedState !== false )  // loop while undefined, pre-ready.
	        || controller.connection.opts.background) ){
	      window.requestAnimationFrame(controller.onAnimationFrame);
	    }else{
	      controller.animationFrameRequested = false;
	    }
	  };
	  this.suppressAnimationLoop = opts.suppressAnimationLoop;
	  this.loopWhileDisconnected = opts.loopWhileDisconnected;
	  this.frameEventName = opts.frameEventName;
	  this.useAllPlugins = opts.useAllPlugins;
	  this.history = new CircularBuffer(200);
	  this.lastFrame = Frame.Invalid;
	  this.lastValidFrame = Frame.Invalid;
	  this.lastConnectionFrame = Frame.Invalid;
	  this.accumulatedGestures = [];
	  this.checkVersion = opts.checkVersion;
	  if (opts.connectionType === undefined) {
	    this.connectionType = (this.inBrowser() ? __webpack_require__(194) : __webpack_require__(197));
	  } else {
	    this.connectionType = opts.connectionType;
	  }
	  this.connection = new this.connectionType(opts);
	  this.streamingCount = 0;
	  this.devices = {};
	  this.plugins = {};
	  this._pluginPipelineSteps = {};
	  this._pluginExtendedMethods = {};
	  if (opts.useAllPlugins) this.useRegisteredPlugins();
	  this.setupFrameEvents(opts);
	  this.setupConnectionEvents();
	  
	  this.startAnimationLoop(); // immediately when started
	}

	Controller.prototype.gesture = function(type, cb) {
	  var creator = gestureListener(this, type);
	  if (cb !== undefined) {
	    creator.stop(cb);
	  }
	  return creator;
	}

	/*
	 * @returns the controller
	 */
	Controller.prototype.setBackground = function(state) {
	  this.connection.setBackground(state);
	  return this;
	}

	Controller.prototype.setOptimizeHMD = function(state) {
	  this.connection.setOptimizeHMD(state);
	  return this;
	}

	Controller.prototype.inBrowser = function() {
	  return !this.inNode;
	}

	Controller.prototype.useAnimationLoop = function() {
	  return this.inBrowser() && !this.inBackgroundPage();
	}

	Controller.prototype.inBackgroundPage = function(){
	  // http://developer.chrome.com/extensions/extension#method-getBackgroundPage
	  return (typeof(chrome) !== "undefined") &&
	    chrome.extension &&
	    chrome.extension.getBackgroundPage &&
	    (chrome.extension.getBackgroundPage() === window)
	}

	/*
	 * @returns the controller
	 */
	Controller.prototype.connect = function() {
	  this.connection.connect();
	  return this;
	}

	Controller.prototype.streaming = function() {
	  return this.streamingCount > 0;
	}

	Controller.prototype.connected = function() {
	  return !!this.connection.connected;
	}

	Controller.prototype.startAnimationLoop = function(){
	  if (!this.suppressAnimationLoop && !this.animationFrameRequested) {
	    this.animationFrameRequested = true;
	    window.requestAnimationFrame(this.onAnimationFrame);
	  }
	}

	/*
	 * @returns the controller
	 */
	Controller.prototype.disconnect = function() {
	  this.connection.disconnect();
	  return this;
	}

	/**
	 * Returns a frame of tracking data from the Leap.
	 *
	 * Use the optional history parameter to specify which frame to retrieve.
	 * Call frame() or frame(0) to access the most recent frame; call frame(1) to
	 * access the previous frame, and so on. If you use a history value greater
	 * than the number of stored frames, then the controller returns an invalid frame.
	 *
	 * @method frame
	 * @memberof Leap.Controller.prototype
	 * @param {number} history The age of the frame to return, counting backwards from
	 * the most recent frame (0) into the past and up to the maximum age (59).
	 * @returns {Leap.Frame} The specified frame; or, if no history
	 * parameter is specified, the newest frame. If a frame is not available at
	 * the specified history position, an invalid Frame is returned.
	 **/
	Controller.prototype.frame = function(num) {
	  return this.history.get(num) || Frame.Invalid;
	}

	Controller.prototype.loop = function(callback) {
	  if (callback) {
	    if (typeof callback === 'function'){
	      this.on(this.frameEventName, callback);
	    }else{
	      // callback is actually of the form: {eventName: callback}
	      this.setupFrameEvents(callback);
	    }
	  }

	  return this.connect();
	}

	Controller.prototype.addStep = function(step) {
	  if (!this.pipeline) this.pipeline = new Pipeline(this);
	  this.pipeline.addStep(step);
	}

	// this is run on every deviceFrame
	Controller.prototype.processFrame = function(frame) {
	  if (frame.gestures) {
	    this.accumulatedGestures = this.accumulatedGestures.concat(frame.gestures);
	  }
	  // lastConnectionFrame is used by the animation loop
	  this.lastConnectionFrame = frame;
	  this.startAnimationLoop(); // Only has effect if loopWhileDisconnected: false
	  this.emit('deviceFrame', frame);
	}

	// on a this.deviceEventName (usually 'animationFrame' in browsers), this emits a 'frame'
	Controller.prototype.processFinishedFrame = function(frame) {
	  this.lastFrame = frame;
	  if (frame.valid) {
	    this.lastValidFrame = frame;
	  }
	  frame.controller = this;
	  frame.historyIdx = this.history.push(frame);
	  if (frame.gestures) {
	    frame.gestures = this.accumulatedGestures;
	    this.accumulatedGestures = [];
	    for (var gestureIdx = 0; gestureIdx != frame.gestures.length; gestureIdx++) {
	      this.emit("gesture", frame.gestures[gestureIdx], frame);
	    }
	  }
	  if (this.pipeline) {
	    frame = this.pipeline.run(frame);
	    if (!frame) frame = Frame.Invalid;
	  }
	  this.emit('frame', frame);
	  this.emitHandEvents(frame);
	}

	/**
	 * The controller will emit 'hand' events for every hand on each frame.  The hand in question will be passed
	 * to the event callback.
	 *
	 * @param frame
	 */
	Controller.prototype.emitHandEvents = function(frame){
	  for (var i = 0; i < frame.hands.length; i++){
	    this.emit('hand', frame.hands[i]);
	  }
	}

	Controller.prototype.setupFrameEvents = function(opts){
	  if (opts.frame){
	    this.on('frame', opts.frame);
	  }
	  if (opts.hand){
	    this.on('hand', opts.hand);
	  }
	}

	/**
	  Controller events.  The old 'deviceConnected' and 'deviceDisconnected' have been depricated -
	  use 'deviceStreaming' and 'deviceStopped' instead, except in the case of an unexpected disconnect.

	  There are 4 pairs of device events recently added/changed:
	  -deviceAttached/deviceRemoved - called when a device's physical connection to the computer changes
	  -deviceStreaming/deviceStopped - called when a device is paused or resumed.
	  -streamingStarted/streamingStopped - called when there is/is no longer at least 1 streaming device.
										  Always comes after deviceStreaming.
	  
	  The first of all of the above event pairs is triggered as appropriate upon connection.  All of
	  these events receives an argument with the most recent info about the device that triggered it.
	  These events will always be fired in the order they are listed here, with reverse ordering for the
	  matching shutdown call. (ie, deviceStreaming always comes after deviceAttached, and deviceStopped 
	  will come before deviceRemoved).
	  
	  -deviceConnected/deviceDisconnected - These are considered deprecated and will be removed in
	  the next revision.  In contrast to the other events and in keeping with it's original behavior,
	  it will only be fired when a device begins streaming AFTER a connection has been established.
	  It is not paired, and receives no device info.  Nearly identical functionality to
	  streamingStarted/Stopped if you need to port.
	*/
	Controller.prototype.setupConnectionEvents = function() {
	  var controller = this;
	  this.connection.on('frame', function(frame) {
	    controller.processFrame(frame);
	  });
	  // either deviceFrame or animationFrame:
	  this.on(this.frameEventName, function(frame) {
	    controller.processFinishedFrame(frame);
	  });


	  // here we backfill the 0.5.0 deviceEvents as best possible
	  // backfill begin streaming events
	  var backfillStreamingStartedEventsHandler = function(){
	    if (controller.connection.opts.requestProtocolVersion < 5 && controller.streamingCount == 0){
	      controller.streamingCount = 1;
	      var info = {
	        attached: true,
	        streaming: true,
	        type: 'unknown',
	        id: "Lx00000000000"
	      };
	      controller.devices[info.id] = info;

	      controller.emit('deviceAttached', info);
	      controller.emit('deviceStreaming', info);
	      controller.emit('streamingStarted', info);
	      controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler)
	    }
	  }

	  var backfillStreamingStoppedEvents = function(){
	    if (controller.streamingCount > 0) {
	      for (var deviceId in controller.devices){
	        controller.emit('deviceStopped', controller.devices[deviceId]);
	        controller.emit('deviceRemoved', controller.devices[deviceId]);
	      }
	      // only emit streamingStopped once, with the last device
	      controller.emit('streamingStopped', controller.devices[deviceId]);

	      controller.streamingCount = 0;

	      for (var deviceId in controller.devices){
	        delete controller.devices[deviceId];
	      }
	    }
	  }
	  // Delegate connection events
	  this.connection.on('focus', function() {

	    if ( controller.loopWhileDisconnected ){

	      controller.startAnimationLoop();

	    }

	    controller.emit('focus');

	  });
	  this.connection.on('blur', function() { controller.emit('blur') });
	  this.connection.on('protocol', function(protocol) {

	    protocol.on('beforeFrameCreated', function(frameData){
	      controller.emit('beforeFrameCreated', frameData)
	    });

	    protocol.on('afterFrameCreated', function(frame, frameData){
	      controller.emit('afterFrameCreated', frame, frameData)
	    });

	    controller.emit('protocol', protocol); 
	  });

	  this.connection.on('ready', function() {

	    if (controller.checkVersion && !controller.inNode){
	      // show dialog only to web users
	      controller.checkOutOfDate();
	    }

	    controller.emit('ready');
	  });

	  this.connection.on('connect', function() {
	    controller.emit('connect');
	    controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler)
	    controller.connection.on('frame', backfillStreamingStartedEventsHandler);
	  });

	  this.connection.on('disconnect', function() {
	    controller.emit('disconnect');
	    backfillStreamingStoppedEvents();
	  });

	  // this does not fire when the controller is manually disconnected
	  // or for Leap Service v1.2.0+
	  this.connection.on('deviceConnect', function(evt) {
	    if (evt.state){
	      controller.emit('deviceConnected');
	      controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler)
	      controller.connection.on('frame', backfillStreamingStartedEventsHandler);
	    }else{
	      controller.emit('deviceDisconnected');
	      backfillStreamingStoppedEvents();
	    }
	  });

	  // Does not fire for Leap Service pre v1.2.0
	  this.connection.on('deviceEvent', function(evt) {
	    var info = evt.state,
	        oldInfo = controller.devices[info.id];

	    //Grab a list of changed properties in the device info
	    var changed = {};
	    for(var property in info) {
	      //If a property i doesn't exist the cache, or has changed...
	      if( !oldInfo || !oldInfo.hasOwnProperty(property) || oldInfo[property] != info[property] ) {
	        changed[property] = true;
	      }
	    }

	    //Update the device list
	    controller.devices[info.id] = info;

	    //Fire events based on change list
	    if(changed.attached) {
	      controller.emit(info.attached ? 'deviceAttached' : 'deviceRemoved', info);
	    }

	    if(!changed.streaming) return;

	    if(info.streaming) {
	      controller.streamingCount++;
	      controller.emit('deviceStreaming', info);
	      if( controller.streamingCount == 1 ) {
	        controller.emit('streamingStarted', info);
	      }
	      //if attached & streaming both change to true at the same time, that device was streaming
	      //already when we connected.
	      if(!changed.attached) {
	        controller.emit('deviceConnected');
	      }
	    }
	    //Since when devices are attached all fields have changed, don't send events for streaming being false.
	    else if(!(changed.attached && info.attached)) {
	      controller.streamingCount--;
	      controller.emit('deviceStopped', info);
	      if(controller.streamingCount == 0){
	        controller.emit('streamingStopped', info);
	      }
	      controller.emit('deviceDisconnected');
	    }

	  });


	  this.on('newListener', function(event, listener) {
	    if( event == 'deviceConnected' || event == 'deviceDisconnected' ) {
	      console.warn(event + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
	    }
	  });

	};




	// Checks if the protocol version is the latest, if if not, shows the dialog.
	Controller.prototype.checkOutOfDate = function(){
	  console.assert(this.connection && this.connection.protocol);

	  var serviceVersion = this.connection.protocol.serviceVersion;
	  var protocolVersion = this.connection.protocol.version;
	  var defaultProtocolVersion = this.connectionType.defaultProtocolVersion;

	  if (defaultProtocolVersion > protocolVersion){

	    console.warn("Your Protocol Version is v" + protocolVersion +
	        ", this app was designed for v" + defaultProtocolVersion);

	    Dialog.warnOutOfDate({
	      sV: serviceVersion,
	      pV: protocolVersion
	    });
	    return true
	  }else{
	    return false
	  }

	};



	Controller._pluginFactories = {};

	/*
	 * Registers a plugin, making is accessible to controller.use later on.
	 *
	 * @member plugin
	 * @memberof Leap.Controller.prototype
	 * @param {String} name The name of the plugin (usually camelCase).
	 * @param {function} factory A factory method which will return an instance of a plugin.
	 * The factory receives an optional hash of options, passed in via controller.use.
	 *
	 * Valid keys for the object include frame, hand, finger, tool, and pointable.  The value
	 * of each key can be either a function or an object.  If given a function, that function
	 * will be called once for every instance of the object, with that instance injected as an
	 * argument.  This allows decoration of objects with additional data:
	 *
	 * ```javascript
	 * Leap.Controller.plugin('testPlugin', function(options){
	 *   return {
	 *     frame: function(frame){
	 *       frame.foo = 'bar';
	 *     }
	 *   }
	 * });
	 * ```
	 *
	 * When hand is used, the callback is called for every hand in `frame.hands`.  Note that
	 * hand objects are recreated with every new frame, so that data saved on the hand will not
	 * persist.
	 *
	 * ```javascript
	 * Leap.Controller.plugin('testPlugin', function(){
	 *   return {
	 *     hand: function(hand){
	 *       console.log('testPlugin running on hand ' + hand.id);
	 *     }
	 *   }
	 * });
	 * ```
	 *
	 * A factory can return an object to add custom functionality to Frames, Hands, or Pointables.
	 * The methods are added directly to the object's prototype.  Finger and Tool cannot be used here, Pointable
	 * must be used instead.
	 * This is encouraged for calculations which may not be necessary on every frame.
	 * Memoization is also encouraged, for cases where the method may be called many times per frame by the application.
	 *
	 * ```javascript
	 * // This plugin allows hand.usefulData() to be called later.
	 * Leap.Controller.plugin('testPlugin', function(){
	 *   return {
	 *     hand: {
	 *       usefulData: function(){
	 *         console.log('usefulData on hand', this.id);
	 *         // memoize the results on to the hand, preventing repeat work:
	 *         this.x || this.x = someExpensiveCalculation();
	 *         return this.x;
	 *       }
	 *     }
	 *   }
	 * });
	 *
	 * Note that the factory pattern allows encapsulation for every plugin instance.
	 *
	 * ```javascript
	 * Leap.Controller.plugin('testPlugin', function(options){
	 *   options || options = {}
	 *   options.center || options.center = [0,0,0]
	 *
	 *   privatePrintingMethod = function(){
	 *     console.log('privatePrintingMethod - options', options);
	 *   }
	 *
	 *   return {
	 *     pointable: {
	 *       publicPrintingMethod: function(){
	 *         privatePrintingMethod();
	 *       }
	 *     }
	 *   }
	 * });
	 *
	 */
	Controller.plugin = function(pluginName, factory) {
	  if (this._pluginFactories[pluginName]) {
	    console.warn("Plugin \"" + pluginName + "\" already registered");
	  }
	  return this._pluginFactories[pluginName] = factory;
	};

	/*
	 * Returns a list of registered plugins.
	 * @returns {Array} Plugin Factories.
	 */
	Controller.plugins = function() {
	  return _.keys(this._pluginFactories);
	};



	var setPluginCallbacks = function(pluginName, type, callback){
	  
	  if ( ['beforeFrameCreated', 'afterFrameCreated'].indexOf(type) != -1 ){
	    
	      // todo - not able to "unuse" a plugin currently
	      this.on(type, callback);
	      
	    }else {
	      
	      if (!this.pipeline) this.pipeline = new Pipeline(this);
	    
	      if (!this._pluginPipelineSteps[pluginName]) this._pluginPipelineSteps[pluginName] = [];

	      this._pluginPipelineSteps[pluginName].push(
	        
	        this.pipeline.addWrappedStep(type, callback)
	        
	      );
	      
	    }
	  
	};

	var setPluginMethods = function(pluginName, type, hash){
	  var klass;
	  
	  if (!this._pluginExtendedMethods[pluginName]) this._pluginExtendedMethods[pluginName] = [];

	  switch (type) {
	    case 'frame':
	      klass = Frame;
	      break;
	    case 'hand':
	      klass = Hand;
	      break;
	    case 'pointable':
	      klass = Pointable;
	      _.extend(Finger.prototype, hash);
	      _.extend(Finger.Invalid,   hash);
	      break;
	    case 'finger':
	      klass = Finger;
	      break;
	    default:
	      throw pluginName + ' specifies invalid object type "' + type + '" for prototypical extension'
	  }

	  _.extend(klass.prototype, hash);
	  _.extend(klass.Invalid, hash);
	  this._pluginExtendedMethods[pluginName].push([klass, hash])
	  
	}



	/*
	 * Begin using a registered plugin.  The plugin's functionality will be added to all frames
	 * returned by the controller (and/or added to the objects within the frame).
	 *  - The order of plugin execution inside the loop will match the order in which use is called by the application.
	 *  - The plugin be run for both deviceFrames and animationFrames.
	 *
	 *  If called a second time, the options will be merged with those of the already instantiated plugin.
	 *
	 * @method use
	 * @memberOf Leap.Controller.prototype
	 * @param pluginName
	 * @param {Hash} Options to be passed to the plugin's factory.
	 * @returns the controller
	 */
	Controller.prototype.use = function(pluginName, options) {
	  var functionOrHash, pluginFactory, key, pluginInstance;

	  pluginFactory = (typeof pluginName == 'function') ? pluginName : Controller._pluginFactories[pluginName];

	  if (!pluginFactory) {
	    throw 'Leap Plugin ' + pluginName + ' not found.';
	  }

	  options || (options = {});

	  if (this.plugins[pluginName]){
	    _.extend(this.plugins[pluginName], options);
	    return this;
	  }

	  this.plugins[pluginName] = options;

	  pluginInstance = pluginFactory.call(this, options);

	  for (key in pluginInstance) {

	    functionOrHash = pluginInstance[key];

	    if (typeof functionOrHash === 'function') {
	      
	      setPluginCallbacks.call(this, pluginName, key, functionOrHash);
	      
	    } else {
	      
	      setPluginMethods.call(this, pluginName, key, functionOrHash);
	      
	    }

	  }

	  return this;
	};




	/*
	 * Stop using a used plugin.  This will remove any of the plugin's pipeline methods (those called on every frame)
	 * and remove any methods which extend frame-object prototypes.
	 *
	 * @method stopUsing
	 * @memberOf Leap.Controller.prototype
	 * @param pluginName
	 * @returns the controller
	 */
	Controller.prototype.stopUsing = function (pluginName) {
	  var steps = this._pluginPipelineSteps[pluginName],
	      extMethodHashes = this._pluginExtendedMethods[pluginName],
	      i = 0, klass, extMethodHash;

	  if (!this.plugins[pluginName]) return;

	  if (steps) {
	    for (i = 0; i < steps.length; i++) {
	      this.pipeline.removeStep(steps[i]);
	    }
	  }

	  if (extMethodHashes){
	    for (i = 0; i < extMethodHashes.length; i++){
	      klass = extMethodHashes[i][0];
	      extMethodHash = extMethodHashes[i][1];
	      for (var methodName in extMethodHash) {
	        delete klass.prototype[methodName];
	        delete klass.Invalid[methodName];
	      }
	    }
	  }

	  delete this.plugins[pluginName];

	  return this;
	}

	Controller.prototype.useRegisteredPlugins = function(){
	  for (var plugin in Controller._pluginFactories){
	    this.use(plugin);
	  }
	}


	_.extend(Controller.prototype, EventEmitter.prototype);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var Hand = __webpack_require__(183)
	  , Pointable = __webpack_require__(184)
	  , createGesture = __webpack_require__(188).createGesture
	  , glMatrix = __webpack_require__(185)
	  , mat3 = glMatrix.mat3
	  , vec3 = glMatrix.vec3
	  , InteractionBox = __webpack_require__(189)
	  , Finger = __webpack_require__(190)
	  , _ = __webpack_require__(187);

	/**
	 * Constructs a Frame object.
	 *
	 * Frame instances created with this constructor are invalid.
	 * Get valid Frame objects by calling the
	 * [Controller.frame]{@link Leap.Controller#frame}() function.
	 *<C-D-Space>
	 * @class Frame
	 * @memberof Leap
	 * @classdesc
	 * The Frame class represents a set of hand and finger tracking data detected
	 * in a single frame.
	 *
	 * The Leap detects hands, fingers and tools within the tracking area, reporting
	 * their positions, orientations and motions in frames at the Leap frame rate.
	 *
	 * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.
	 */
	var Frame = module.exports = function(data) {
	  /**
	   * Reports whether this Frame instance is valid.
	   *
	   * A valid Frame is one generated by the Controller object that contains
	   * tracking data for all detected entities. An invalid Frame contains no
	   * actual tracking data, but you can call its functions without risk of a
	   * undefined object exception. The invalid Frame mechanism makes it more
	   * convenient to track individual data across the frame history. For example,
	   * you can invoke:
	   *
	   * ```javascript
	   * var finger = controller.frame(n).finger(fingerID);
	   * ```
	   *
	   * for an arbitrary Frame history value, "n", without first checking whether
	   * frame(n) returned a null object. (You should still check that the
	   * returned Finger instance is valid.)
	   *
	   * @member valid
	   * @memberof Leap.Frame.prototype
	   * @type {Boolean}
	   */
	  this.valid = true;
	  /**
	   * A unique ID for this Frame. Consecutive frames processed by the Leap
	   * have consecutive increasing values.
	   * @member id
	   * @memberof Leap.Frame.prototype
	   * @type {String}
	   */
	  this.id = data.id;
	  /**
	   * The frame capture time in microseconds elapsed since the Leap started.
	   * @member timestamp
	   * @memberof Leap.Frame.prototype
	   * @type {number}
	   */
	  this.timestamp = data.timestamp;
	  /**
	   * The list of Hand objects detected in this frame, given in arbitrary order.
	   * The list can be empty if no hands are detected.
	   *
	   * @member hands[]
	   * @memberof Leap.Frame.prototype
	   * @type {Leap.Hand}
	   */
	  this.hands = [];
	  this.handsMap = {};
	  /**
	   * The list of Pointable objects (fingers and tools) detected in this frame,
	   * given in arbitrary order. The list can be empty if no fingers or tools are
	   * detected.
	   *
	   * @member pointables[]
	   * @memberof Leap.Frame.prototype
	   * @type {Leap.Pointable}
	   */
	  this.pointables = [];
	  /**
	   * The list of Tool objects detected in this frame, given in arbitrary order.
	   * The list can be empty if no tools are detected.
	   *
	   * @member tools[]
	   * @memberof Leap.Frame.prototype
	   * @type {Leap.Pointable}
	   */
	  this.tools = [];
	  /**
	   * The list of Finger objects detected in this frame, given in arbitrary order.
	   * The list can be empty if no fingers are detected.
	   * @member fingers[]
	   * @memberof Leap.Frame.prototype
	   * @type {Leap.Pointable}
	   */
	  this.fingers = [];

	  /**
	   * The InteractionBox associated with the current frame.
	   *
	   * @member interactionBox
	   * @memberof Leap.Frame.prototype
	   * @type {Leap.InteractionBox}
	   */
	  if (data.interactionBox) {
	    this.interactionBox = new InteractionBox(data.interactionBox);
	  }
	  this.gestures = [];
	  this.pointablesMap = {};
	  this._translation = data.t;
	  this._rotation = _.flatten(data.r);
	  this._scaleFactor = data.s;
	  this.data = data;
	  this.type = 'frame'; // used by event emitting
	  this.currentFrameRate = data.currentFrameRate;

	  if (data.gestures) {
	   /**
	    * The list of Gesture objects detected in this frame, given in arbitrary order.
	    * The list can be empty if no gestures are detected.
	    *
	    * Circle and swipe gestures are updated every frame. Tap gestures
	    * only appear in the list for a single frame.
	    * @member gestures[]
	    * @memberof Leap.Frame.prototype
	    * @type {Leap.Gesture}
	    */
	    for (var gestureIdx = 0, gestureCount = data.gestures.length; gestureIdx != gestureCount; gestureIdx++) {
	      this.gestures.push(createGesture(data.gestures[gestureIdx]));
	    }
	  }
	  this.postprocessData(data);
	};

	Frame.prototype.postprocessData = function(data){
	  if (!data) {
	    data = this.data;
	  }

	  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {
	    var hand = new Hand(data.hands[handIdx]);
	    hand.frame = this;
	    this.hands.push(hand);
	    this.handsMap[hand.id] = hand;
	  }

	  data.pointables = _.sortBy(data.pointables, function(pointable) { return pointable.id });

	  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
	    var pointableData = data.pointables[pointableIdx];
	    var pointable = pointableData.dipPosition ? new Finger(pointableData) : new Pointable(pointableData);
	    pointable.frame = this;
	    this.addPointable(pointable);
	  }
	};

	/**
	 * Adds data from a pointable element into the pointablesMap; 
	 * also adds the pointable to the frame.handsMap hand to which it belongs,
	 * and to the hand's tools or hand's fingers map.
	 * 
	 * @param pointable {Object} a Pointable
	 */
	Frame.prototype.addPointable = function (pointable) {
	  this.pointables.push(pointable);
	  this.pointablesMap[pointable.id] = pointable;
	  (pointable.tool ? this.tools : this.fingers).push(pointable);
	  if (pointable.handId !== undefined && this.handsMap.hasOwnProperty(pointable.handId)) {
	    var hand = this.handsMap[pointable.handId];
	    hand.pointables.push(pointable);
	    (pointable.tool ? hand.tools : hand.fingers).push(pointable);
	    switch (pointable.type){
	      case 0:
	        hand.thumb = pointable;
	        break;
	      case 1:
	        hand.indexFinger = pointable;
	        break;
	      case 2:
	        hand.middleFinger = pointable;
	        break;
	      case 3:
	        hand.ringFinger = pointable;
	        break;
	      case 4:
	        hand.pinky = pointable;
	        break;
	    }
	  }
	};

	/**
	 * The tool with the specified ID in this frame.
	 *
	 * Use the Frame tool() function to retrieve a tool from
	 * this frame using an ID value obtained from a previous frame.
	 * This function always returns a Pointable object, but if no tool
	 * with the specified ID is present, an invalid Pointable object is returned.
	 *
	 * Note that ID values persist across frames, but only until tracking of a
	 * particular object is lost. If tracking of a tool is lost and subsequently
	 * regained, the new Pointable object representing that tool may have a
	 * different ID than that representing the tool in an earlier frame.
	 *
	 * @method tool
	 * @memberof Leap.Frame.prototype
	 * @param {String} id The ID value of a Tool object from a previous frame.
	 * @returns {Leap.Pointable} The tool with the
	 * matching ID if one exists in this frame; otherwise, an invalid Pointable object
	 * is returned.
	 */
	Frame.prototype.tool = function(id) {
	  var pointable = this.pointable(id);
	  return pointable.tool ? pointable : Pointable.Invalid;
	};

	/**
	 * The Pointable object with the specified ID in this frame.
	 *
	 * Use the Frame pointable() function to retrieve the Pointable object from
	 * this frame using an ID value obtained from a previous frame.
	 * This function always returns a Pointable object, but if no finger or tool
	 * with the specified ID is present, an invalid Pointable object is returned.
	 *
	 * Note that ID values persist across frames, but only until tracking of a
	 * particular object is lost. If tracking of a finger or tool is lost and subsequently
	 * regained, the new Pointable object representing that finger or tool may have
	 * a different ID than that representing the finger or tool in an earlier frame.
	 *
	 * @method pointable
	 * @memberof Leap.Frame.prototype
	 * @param {String} id The ID value of a Pointable object from a previous frame.
	 * @returns {Leap.Pointable} The Pointable object with
	 * the matching ID if one exists in this frame;
	 * otherwise, an invalid Pointable object is returned.
	 */
	Frame.prototype.pointable = function(id) {
	  return this.pointablesMap[id] || Pointable.Invalid;
	};

	/**
	 * The finger with the specified ID in this frame.
	 *
	 * Use the Frame finger() function to retrieve the finger from
	 * this frame using an ID value obtained from a previous frame.
	 * This function always returns a Finger object, but if no finger
	 * with the specified ID is present, an invalid Pointable object is returned.
	 *
	 * Note that ID values persist across frames, but only until tracking of a
	 * particular object is lost. If tracking of a finger is lost and subsequently
	 * regained, the new Pointable object representing that physical finger may have
	 * a different ID than that representing the finger in an earlier frame.
	 *
	 * @method finger
	 * @memberof Leap.Frame.prototype
	 * @param {String} id The ID value of a finger from a previous frame.
	 * @returns {Leap.Pointable} The finger with the
	 * matching ID if one exists in this frame; otherwise, an invalid Pointable
	 * object is returned.
	 */
	Frame.prototype.finger = function(id) {
	  var pointable = this.pointable(id);
	  return !pointable.tool ? pointable : Pointable.Invalid;
	};

	/**
	 * The Hand object with the specified ID in this frame.
	 *
	 * Use the Frame hand() function to retrieve the Hand object from
	 * this frame using an ID value obtained from a previous frame.
	 * This function always returns a Hand object, but if no hand
	 * with the specified ID is present, an invalid Hand object is returned.
	 *
	 * Note that ID values persist across frames, but only until tracking of a
	 * particular object is lost. If tracking of a hand is lost and subsequently
	 * regained, the new Hand object representing that physical hand may have
	 * a different ID than that representing the physical hand in an earlier frame.
	 *
	 * @method hand
	 * @memberof Leap.Frame.prototype
	 * @param {String} id The ID value of a Hand object from a previous frame.
	 * @returns {Leap.Hand} The Hand object with the matching
	 * ID if one exists in this frame; otherwise, an invalid Hand object is returned.
	 */
	Frame.prototype.hand = function(id) {
	  return this.handsMap[id] || Hand.Invalid;
	};

	/**
	 * The angle of rotation around the rotation axis derived from the overall
	 * rotational motion between the current frame and the specified frame.
	 *
	 * The returned angle is expressed in radians measured clockwise around
	 * the rotation axis (using the right-hand rule) between the start and end frames.
	 * The value is always between 0 and pi radians (0 and 180 degrees).
	 *
	 * The Leap derives frame rotation from the relative change in position and
	 * orientation of all objects detected in the field of view.
	 *
	 * If either this frame or sinceFrame is an invalid Frame object, then the
	 * angle of rotation is zero.
	 *
	 * @method rotationAngle
	 * @memberof Leap.Frame.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
	 * @param {number[]} [axis] The axis to measure rotation around.
	 * @returns {number} A positive value containing the heuristically determined
	 * rotational change between the current frame and that specified in the sinceFrame parameter.
	 */
	Frame.prototype.rotationAngle = function(sinceFrame, axis) {
	  if (!this.valid || !sinceFrame.valid) return 0.0;

	  var rot = this.rotationMatrix(sinceFrame);
	  var cs = (rot[0] + rot[4] + rot[8] - 1.0)*0.5;
	  var angle = Math.acos(cs);
	  angle = isNaN(angle) ? 0.0 : angle;

	  if (axis !== undefined) {
	    var rotAxis = this.rotationAxis(sinceFrame);
	    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));
	  }

	  return angle;
	};

	/**
	 * The axis of rotation derived from the overall rotational motion between
	 * the current frame and the specified frame.
	 *
	 * The returned direction vector is normalized.
	 *
	 * The Leap derives frame rotation from the relative change in position and
	 * orientation of all objects detected in the field of view.
	 *
	 * If either this frame or sinceFrame is an invalid Frame object, or if no
	 * rotation is detected between the two frames, a zero vector is returned.
	 *
	 * @method rotationAxis
	 * @memberof Leap.Frame.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
	 * @returns {number[]} A normalized direction vector representing the axis of the heuristically determined
	 * rotational change between the current frame and that specified in the sinceFrame parameter.
	 */
	Frame.prototype.rotationAxis = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return vec3.create();
	  return vec3.normalize(vec3.create(), [
	    this._rotation[7] - sinceFrame._rotation[5],
	    this._rotation[2] - sinceFrame._rotation[6],
	    this._rotation[3] - sinceFrame._rotation[1]
	  ]);
	}

	/**
	 * The transform matrix expressing the rotation derived from the overall
	 * rotational motion between the current frame and the specified frame.
	 *
	 * The Leap derives frame rotation from the relative change in position and
	 * orientation of all objects detected in the field of view.
	 *
	 * If either this frame or sinceFrame is an invalid Frame object, then
	 * this method returns an identity matrix.
	 *
	 * @method rotationMatrix
	 * @memberof Leap.Frame.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
	 * @returns {number[]} A transformation matrix containing the heuristically determined
	 * rotational change between the current frame and that specified in the sinceFrame parameter.
	 */
	Frame.prototype.rotationMatrix = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return mat3.create();
	  var transpose = mat3.transpose(mat3.create(), this._rotation)
	  return mat3.multiply(mat3.create(), sinceFrame._rotation, transpose);
	}

	/**
	 * The scale factor derived from the overall motion between the current frame and the specified frame.
	 *
	 * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
	 * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
	 *
	 * The Leap derives scaling from the relative inward or outward motion of all
	 * objects detected in the field of view (independent of translation and rotation).
	 *
	 * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.
	 *
	 * @method scaleFactor
	 * @memberof Leap.Frame.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
	 * @returns {number} A positive value representing the heuristically determined
	 * scaling change ratio between the current frame and that specified in the sinceFrame parameter.
	 */
	Frame.prototype.scaleFactor = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return 1.0;
	  return Math.exp(this._scaleFactor - sinceFrame._scaleFactor);
	}

	/**
	 * The change of position derived from the overall linear motion between the
	 * current frame and the specified frame.
	 *
	 * The returned translation vector provides the magnitude and direction of the
	 * movement in millimeters.
	 *
	 * The Leap derives frame translation from the linear motion of all objects
	 * detected in the field of view.
	 *
	 * If either this frame or sinceFrame is an invalid Frame object, then this
	 * method returns a zero vector.
	 *
	 * @method translation
	 * @memberof Leap.Frame.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
	 * @returns {number[]} A vector representing the heuristically determined change in
	 * position of all objects between the current frame and that specified in the sinceFrame parameter.
	 */
	Frame.prototype.translation = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return vec3.create();
	  return vec3.subtract(vec3.create(), this._translation, sinceFrame._translation);
	}

	/**
	 * A string containing a brief, human readable description of the Frame object.
	 *
	 * @method toString
	 * @memberof Leap.Frame.prototype
	 * @returns {String} A brief description of this frame.
	 */
	Frame.prototype.toString = function() {
	  var str = "Frame [ id:"+this.id+" | timestamp:"+this.timestamp+" | Hand count:("+this.hands.length+") | Pointable count:("+this.pointables.length+")";
	  if (this.gestures) str += " | Gesture count:("+this.gestures.length+")";
	  str += " ]";
	  return str;
	}

	/**
	 * Returns a JSON-formatted string containing the hands, pointables and gestures
	 * in this frame.
	 *
	 * @method dump
	 * @memberof Leap.Frame.prototype
	 * @returns {String} A JSON-formatted string.
	 */
	Frame.prototype.dump = function() {
	  var out = '';
	  out += "Frame Info:<br/>";
	  out += this.toString();
	  out += "<br/><br/>Hands:<br/>"
	  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {
	    out += "  "+ this.hands[handIdx].toString() + "<br/>";
	  }
	  out += "<br/><br/>Pointables:<br/>";
	  for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
	      out += "  "+ this.pointables[pointableIdx].toString() + "<br/>";
	  }
	  if (this.gestures) {
	    out += "<br/><br/>Gestures:<br/>";
	    for (var gestureIdx = 0, gestureCount = this.gestures.length; gestureIdx != gestureCount; gestureIdx++) {
	        out += "  "+ this.gestures[gestureIdx].toString() + "<br/>";
	    }
	  }
	  out += "<br/><br/>Raw JSON:<br/>";
	  out += JSON.stringify(this.data);
	  return out;
	}

	/**
	 * An invalid Frame object.
	 *
	 * You can use this invalid Frame in comparisons testing
	 * whether a given Frame instance is valid or invalid. (You can also check the
	 * [Frame.valid]{@link Leap.Frame#valid} property.)
	 *
	 * @static
	 * @type {Leap.Frame}
	 * @name Invalid
	 * @memberof Leap.Frame
	 */
	Frame.Invalid = {
	  valid: false,
	  hands: [],
	  fingers: [],
	  tools: [],
	  gestures: [],
	  pointables: [],
	  pointable: function() { return Pointable.Invalid },
	  finger: function() { return Pointable.Invalid },
	  hand: function() { return Hand.Invalid },
	  toString: function() { return "invalid frame" },
	  dump: function() { return this.toString() },
	  rotationAngle: function() { return 0.0; },
	  rotationMatrix: function() { return mat3.create(); },
	  rotationAxis: function() { return vec3.create(); },
	  scaleFactor: function() { return 1.0; },
	  translation: function() { return vec3.create(); }
	};


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var Pointable = __webpack_require__(184)
	  , Bone = __webpack_require__(186)
	  , glMatrix = __webpack_require__(185)
	  , mat3 = glMatrix.mat3
	  , vec3 = glMatrix.vec3
	  , _ = __webpack_require__(187);

	/**
	 * Constructs a Hand object.
	 *
	 * An uninitialized hand is considered invalid.
	 * Get valid Hand objects from a Frame object.
	 * @class Hand
	 * @memberof Leap
	 * @classdesc
	 * The Hand class reports the physical characteristics of a detected hand.
	 *
	 * Hand tracking data includes a palm position and velocity; vectors for
	 * the palm normal and direction to the fingers; properties of a sphere fit
	 * to the hand; and lists of the attached fingers and tools.
	 *
	 * Note that Hand objects can be invalid, which means that they do not contain
	 * valid tracking data and do not correspond to a physical entity. Invalid Hand
	 * objects can be the result of asking for a Hand object using an ID from an
	 * earlier frame when no Hand objects with that ID exist in the current frame.
	 * A Hand object created from the Hand constructor is also invalid.
	 * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.
	 */
	var Hand = module.exports = function(data) {
	  /**
	   * A unique ID assigned to this Hand object, whose value remains the same
	   * across consecutive frames while the tracked hand remains visible. If
	   * tracking is lost (for example, when a hand is occluded by another hand
	   * or when it is withdrawn from or reaches the edge of the Leap field of view),
	   * the Leap may assign a new ID when it detects the hand in a future frame.
	   *
	   * Use the ID value with the {@link Frame.hand}() function to find this
	   * Hand object in future frames.
	   *
	   * @member id
	   * @memberof Leap.Hand.prototype
	   * @type {String}
	   */
	  this.id = data.id;
	  /**
	   * The center position of the palm in millimeters from the Leap origin.
	   * @member palmPosition
	   * @memberof Leap.Hand.prototype
	   * @type {number[]}
	   */
	  this.palmPosition = data.palmPosition;
	  /**
	   * The direction from the palm position toward the fingers.
	   *
	   * The direction is expressed as a unit vector pointing in the same
	   * direction as the directed line from the palm position to the fingers.
	   *
	   * @member direction
	   * @memberof Leap.Hand.prototype
	   * @type {number[]}
	   */
	  this.direction = data.direction;
	  /**
	   * The rate of change of the palm position in millimeters/second.
	   *
	   * @member palmVeclocity
	   * @memberof Leap.Hand.prototype
	   * @type {number[]}
	   */
	  this.palmVelocity = data.palmVelocity;
	  /**
	   * The normal vector to the palm. If your hand is flat, this vector will
	   * point downward, or "out" of the front surface of your palm.
	   *
	   * ![Palm Vectors](images/Leap_Palm_Vectors.png)
	   *
	   * The direction is expressed as a unit vector pointing in the same
	   * direction as the palm normal (that is, a vector orthogonal to the palm).
	   * @member palmNormal
	   * @memberof Leap.Hand.prototype
	   * @type {number[]}
	   */
	  this.palmNormal = data.palmNormal;
	  /**
	   * The center of a sphere fit to the curvature of this hand.
	   *
	   * This sphere is placed roughly as if the hand were holding a ball.
	   *
	   * ![Hand Ball](images/Leap_Hand_Ball.png)
	   * @member sphereCenter
	   * @memberof Leap.Hand.prototype
	   * @type {number[]}
	   */
	  this.sphereCenter = data.sphereCenter;
	  /**
	   * The radius of a sphere fit to the curvature of this hand, in millimeters.
	   *
	   * This sphere is placed roughly as if the hand were holding a ball. Thus the
	   * size of the sphere decreases as the fingers are curled into a fist.
	   *
	   * @member sphereRadius
	   * @memberof Leap.Hand.prototype
	   * @type {number}
	   */
	  this.sphereRadius = data.sphereRadius;
	  /**
	   * Reports whether this is a valid Hand object.
	   *
	   * @member valid
	   * @memberof Leap.Hand.prototype
	   * @type {boolean}
	   */
	  this.valid = true;
	  /**
	   * The list of Pointable objects (fingers and tools) detected in this frame
	   * that are associated with this hand, given in arbitrary order. The list
	   * can be empty if no fingers or tools associated with this hand are detected.
	   *
	   * Use the {@link Pointable} tool property to determine
	   * whether or not an item in the list represents a tool or finger.
	   * You can also get only the tools using the Hand.tools[] list or
	   * only the fingers using the Hand.fingers[] list.
	   *
	   * @member pointables[]
	   * @memberof Leap.Hand.prototype
	   * @type {Leap.Pointable[]}
	   */
	  this.pointables = [];
	  /**
	   * The list of fingers detected in this frame that are attached to
	   * this hand, given in arbitrary order.
	   *
	   * The list can be empty if no fingers attached to this hand are detected.
	   *
	   * @member fingers[]
	   * @memberof Leap.Hand.prototype
	   * @type {Leap.Pointable[]}
	   */
	  this.fingers = [];
	  
	  if (data.armBasis){
	    this.arm = new Bone(this, {
	      type: 4,
	      width: data.armWidth,
	      prevJoint: data.elbow,
	      nextJoint: data.wrist,
	      basis: data.armBasis
	    });
	  }else{
	    this.arm = null;
	  }
	  
	  /**
	   * The list of tools detected in this frame that are held by this
	   * hand, given in arbitrary order.
	   *
	   * The list can be empty if no tools held by this hand are detected.
	   *
	   * @member tools[]
	   * @memberof Leap.Hand.prototype
	   * @type {Leap.Pointable[]}
	   */
	  this.tools = [];
	  this._translation = data.t;
	  this._rotation = _.flatten(data.r);
	  this._scaleFactor = data.s;

	  /**
	   * Time the hand has been visible in seconds.
	   *
	   * @member timeVisible
	   * @memberof Leap.Hand.prototype
	   * @type {number}
	   */
	   this.timeVisible = data.timeVisible;

	  /**
	   * The palm position with stabalization
	   * @member stabilizedPalmPosition
	   * @memberof Leap.Hand.prototype
	   * @type {number[]}
	   */
	   this.stabilizedPalmPosition = data.stabilizedPalmPosition;

	   /**
	   * Reports whether this is a left or a right hand.
	   *
	   * @member type
	   * @type {String}
	   * @memberof Leap.Hand.prototype
	   */
	   this.type = data.type;
	   this.grabStrength = data.grabStrength;
	   this.pinchStrength = data.pinchStrength;
	   this.confidence = data.confidence;
	}

	/**
	 * The finger with the specified ID attached to this hand.
	 *
	 * Use this function to retrieve a Pointable object representing a finger
	 * attached to this hand using an ID value obtained from a previous frame.
	 * This function always returns a Pointable object, but if no finger
	 * with the specified ID is present, an invalid Pointable object is returned.
	 *
	 * Note that the ID values assigned to fingers persist across frames, but only
	 * until tracking of a particular finger is lost. If tracking of a finger is
	 * lost and subsequently regained, the new Finger object representing that
	 * finger may have a different ID than that representing the finger in an
	 * earlier frame.
	 *
	 * @method finger
	 * @memberof Leap.Hand.prototype
	 * @param {String} id The ID value of a finger from a previous frame.
	 * @returns {Leap.Pointable} The Finger object with
	 * the matching ID if one exists for this hand in this frame; otherwise, an
	 * invalid Finger object is returned.
	 */
	Hand.prototype.finger = function(id) {
	  var finger = this.frame.finger(id);
	  return (finger && (finger.handId == this.id)) ? finger : Pointable.Invalid;
	}

	/**
	 * The angle of rotation around the rotation axis derived from the change in
	 * orientation of this hand, and any associated fingers and tools, between the
	 * current frame and the specified frame.
	 *
	 * The returned angle is expressed in radians measured clockwise around the
	 * rotation axis (using the right-hand rule) between the start and end frames.
	 * The value is always between 0 and pi radians (0 and 180 degrees).
	 *
	 * If a corresponding Hand object is not found in sinceFrame, or if either
	 * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.
	 *
	 * @method rotationAngle
	 * @memberof Leap.Hand.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
	 * @param {numnber[]} [axis] The axis to measure rotation around.
	 * @returns {number} A positive value representing the heuristically determined
	 * rotational change of the hand between the current frame and that specified in
	 * the sinceFrame parameter.
	 */
	Hand.prototype.rotationAngle = function(sinceFrame, axis) {
	  if (!this.valid || !sinceFrame.valid) return 0.0;
	  var sinceHand = sinceFrame.hand(this.id);
	  if(!sinceHand.valid) return 0.0;
	  var rot = this.rotationMatrix(sinceFrame);
	  var cs = (rot[0] + rot[4] + rot[8] - 1.0)*0.5
	  var angle = Math.acos(cs);
	  angle = isNaN(angle) ? 0.0 : angle;
	  if (axis !== undefined) {
	    var rotAxis = this.rotationAxis(sinceFrame);
	    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));
	  }
	  return angle;
	}

	/**
	 * The axis of rotation derived from the change in orientation of this hand, and
	 * any associated fingers and tools, between the current frame and the specified frame.
	 *
	 * The returned direction vector is normalized.
	 *
	 * If a corresponding Hand object is not found in sinceFrame, or if either
	 * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.
	 *
	 * @method rotationAxis
	 * @memberof Leap.Hand.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
	 * @returns {number[]} A normalized direction Vector representing the axis of the heuristically determined
	 * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
	 */
	Hand.prototype.rotationAxis = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return vec3.create();
	  var sinceHand = sinceFrame.hand(this.id);
	  if (!sinceHand.valid) return vec3.create();
	  return vec3.normalize(vec3.create(), [
	    this._rotation[7] - sinceHand._rotation[5],
	    this._rotation[2] - sinceHand._rotation[6],
	    this._rotation[3] - sinceHand._rotation[1]
	  ]);
	}

	/**
	 * The transform matrix expressing the rotation derived from the change in
	 * orientation of this hand, and any associated fingers and tools, between
	 * the current frame and the specified frame.
	 *
	 * If a corresponding Hand object is not found in sinceFrame, or if either
	 * this frame or sinceFrame are invalid Frame objects, then this method returns
	 * an identity matrix.
	 *
	 * @method rotationMatrix
	 * @memberof Leap.Hand.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
	 * @returns {number[]} A transformation Matrix containing the heuristically determined
	 * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
	 */
	Hand.prototype.rotationMatrix = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return mat3.create();
	  var sinceHand = sinceFrame.hand(this.id);
	  if(!sinceHand.valid) return mat3.create();
	  var transpose = mat3.transpose(mat3.create(), this._rotation);
	  var m = mat3.multiply(mat3.create(), sinceHand._rotation, transpose);
	  return m;
	}

	/**
	 * The scale factor derived from the hand's motion between the current frame and the specified frame.
	 *
	 * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
	 * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
	 *
	 * The Leap derives scaling from the relative inward or outward motion of a hand
	 * and its associated fingers and tools (independent of translation and rotation).
	 *
	 * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame
	 * are invalid Frame objects, then this method returns 1.0.
	 *
	 * @method scaleFactor
	 * @memberof Leap.Hand.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
	 * @returns {number} A positive value representing the heuristically determined
	 * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.
	 */
	Hand.prototype.scaleFactor = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return 1.0;
	  var sinceHand = sinceFrame.hand(this.id);
	  if(!sinceHand.valid) return 1.0;

	  return Math.exp(this._scaleFactor - sinceHand._scaleFactor);
	}

	/**
	 * The change of position of this hand between the current frame and the specified frame
	 *
	 * The returned translation vector provides the magnitude and direction of the
	 * movement in millimeters.
	 *
	 * If a corresponding Hand object is not found in sinceFrame, or if either this frame or
	 * sinceFrame are invalid Frame objects, then this method returns a zero vector.
	 *
	 * @method translation
	 * @memberof Leap.Hand.prototype
	 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
	 * @returns {number[]} A Vector representing the heuristically determined change in hand
	 * position between the current frame and that specified in the sinceFrame parameter.
	 */
	Hand.prototype.translation = function(sinceFrame) {
	  if (!this.valid || !sinceFrame.valid) return vec3.create();
	  var sinceHand = sinceFrame.hand(this.id);
	  if(!sinceHand.valid) return vec3.create();
	  return [
	    this._translation[0] - sinceHand._translation[0],
	    this._translation[1] - sinceHand._translation[1],
	    this._translation[2] - sinceHand._translation[2]
	  ];
	}

	/**
	 * A string containing a brief, human readable description of the Hand object.
	 * @method toString
	 * @memberof Leap.Hand.prototype
	 * @returns {String} A description of the Hand as a string.
	 */
	Hand.prototype.toString = function() {
	  return "Hand (" + this.type + ") [ id: "+ this.id + " | palm velocity:"+this.palmVelocity+" | sphere center:"+this.sphereCenter+" ] ";
	}

	/**
	 * The pitch angle in radians.
	 *
	 * Pitch is the angle between the negative z-axis and the projection of
	 * the vector onto the y-z plane. In other words, pitch represents rotation
	 * around the x-axis.
	 * If the vector points upward, the returned angle is between 0 and pi radians
	 * (180 degrees); if it points downward, the angle is between 0 and -pi radians.
	 *
	 * @method pitch
	 * @memberof Leap.Hand.prototype
	 * @returns {number} The angle of this vector above or below the horizon (x-z plane).
	 *
	 */
	Hand.prototype.pitch = function() {
	  return Math.atan2(this.direction[1], -this.direction[2]);
	}

	/**
	 *  The yaw angle in radians.
	 *
	 * Yaw is the angle between the negative z-axis and the projection of
	 * the vector onto the x-z plane. In other words, yaw represents rotation
	 * around the y-axis. If the vector points to the right of the negative z-axis,
	 * then the returned angle is between 0 and pi radians (180 degrees);
	 * if it points to the left, the angle is between 0 and -pi radians.
	 *
	 * @method yaw
	 * @memberof Leap.Hand.prototype
	 * @returns {number} The angle of this vector to the right or left of the y-axis.
	 *
	 */
	Hand.prototype.yaw = function() {
	  return Math.atan2(this.direction[0], -this.direction[2]);
	}

	/**
	 *  The roll angle in radians.
	 *
	 * Roll is the angle between the y-axis and the projection of
	 * the vector onto the x-y plane. In other words, roll represents rotation
	 * around the z-axis. If the vector points to the left of the y-axis,
	 * then the returned angle is between 0 and pi radians (180 degrees);
	 * if it points to the right, the angle is between 0 and -pi radians.
	 *
	 * @method roll
	 * @memberof Leap.Hand.prototype
	 * @returns {number} The angle of this vector to the right or left of the y-axis.
	 *
	 */
	Hand.prototype.roll = function() {
	  return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
	}

	/**
	 * An invalid Hand object.
	 *
	 * You can use an invalid Hand object in comparisons testing
	 * whether a given Hand instance is valid or invalid. (You can also use the
	 * Hand valid property.)
	 *
	 * @static
	 * @type {Leap.Hand}
	 * @name Invalid
	 * @memberof Leap.Hand
	 */
	Hand.Invalid = {
	  valid: false,
	  fingers: [],
	  tools: [],
	  pointables: [],
	  left: false,
	  pointable: function() { return Pointable.Invalid },
	  finger: function() { return Pointable.Invalid },
	  toString: function() { return "invalid frame" },
	  dump: function() { return this.toString(); },
	  rotationAngle: function() { return 0.0; },
	  rotationMatrix: function() { return mat3.create(); },
	  rotationAxis: function() { return vec3.create(); },
	  scaleFactor: function() { return 1.0; },
	  translation: function() { return vec3.create(); }
	};


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var glMatrix = __webpack_require__(185)
	  , vec3 = glMatrix.vec3;

	/**
	 * Constructs a Pointable object.
	 *
	 * An uninitialized pointable is considered invalid.
	 * Get valid Pointable objects from a Frame or a Hand object.
	 *
	 * @class Pointable
	 * @memberof Leap
	 * @classdesc
	 * The Pointable class reports the physical characteristics of a detected
	 * finger or tool.
	 *
	 * Both fingers and tools are classified as Pointable objects. Use the
	 * Pointable.tool property to determine whether a Pointable object represents a
	 * tool or finger. The Leap classifies a detected entity as a tool when it is
	 * thinner, straighter, and longer than a typical finger.
	 *
	 * Note that Pointable objects can be invalid, which means that they do not
	 * contain valid tracking data and do not correspond to a physical entity.
	 * Invalid Pointable objects can be the result of asking for a Pointable object
	 * using an ID from an earlier frame when no Pointable objects with that ID
	 * exist in the current frame. A Pointable object created from the Pointable
	 * constructor is also invalid. Test for validity with the Pointable.valid
	 * property.
	 */
	var Pointable = module.exports = function(data) {
	  /**
	   * Indicates whether this is a valid Pointable object.
	   *
	   * @member valid
	   * @type {Boolean}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.valid = true;
	  /**
	   * A unique ID assigned to this Pointable object, whose value remains the
	   * same across consecutive frames while the tracked finger or tool remains
	   * visible. If tracking is lost (for example, when a finger is occluded by
	   * another finger or when it is withdrawn from the Leap field of view), the
	   * Leap may assign a new ID when it detects the entity in a future frame.
	   *
	   * Use the ID value with the pointable() functions defined for the
	   * {@link Frame} and {@link Frame.Hand} classes to find this
	   * Pointable object in future frames.
	   *
	   * @member id
	   * @type {String}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.id = data.id;
	  this.handId = data.handId;
	  /**
	   * The estimated length of the finger or tool in millimeters.
	   *
	   * The reported length is the visible length of the finger or tool from the
	   * hand to tip. If the length isn't known, then a value of 0 is returned.
	   *
	   * @member length
	   * @type {number}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.length = data.length;
	  /**
	   * Whether or not the Pointable is believed to be a tool.
	   * Tools are generally longer, thinner, and straighter than fingers.
	   *
	   * If tool is false, then this Pointable must be a finger.
	   *
	   * @member tool
	   * @type {Boolean}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.tool = data.tool;
	  /**
	   * The estimated width of the tool in millimeters.
	   *
	   * The reported width is the average width of the visible portion of the
	   * tool from the hand to the tip. If the width isn't known,
	   * then a value of 0 is returned.
	   *
	   * Pointable objects representing fingers do not have a width property.
	   *
	   * @member width
	   * @type {number}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.width = data.width;
	  /**
	   * The direction in which this finger or tool is pointing.
	   *
	   * The direction is expressed as a unit vector pointing in the same
	   * direction as the tip.
	   *
	   * ![Finger](images/Leap_Finger_Model.png)
	   * @member direction
	   * @type {number[]}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.direction = data.direction;
	  /**
	   * The tip position in millimeters from the Leap origin.
	   * Stabilized
	   *
	   * @member stabilizedTipPosition
	   * @type {number[]}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.stabilizedTipPosition = data.stabilizedTipPosition;
	  /**
	   * The tip position in millimeters from the Leap origin.
	   *
	   * @member tipPosition
	   * @type {number[]}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.tipPosition = data.tipPosition;
	  /**
	   * The rate of change of the tip position in millimeters/second.
	   *
	   * @member tipVelocity
	   * @type {number[]}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.tipVelocity = data.tipVelocity;
	  /**
	   * The current touch zone of this Pointable object.
	   *
	   * The Leap Motion software computes the touch zone based on a floating touch
	   * plane that adapts to the user's finger movement and hand posture. The Leap
	   * Motion software interprets purposeful movements toward this plane as potential touch
	   * points. When a Pointable moves close to the adaptive touch plane, it enters the
	   * "hovering" zone. When a Pointable reaches or passes through the plane, it enters
	   * the "touching" zone.
	   *
	   * The possible states include:
	   *
	   * * "none" -- The Pointable is outside the hovering zone.
	   * * "hovering" -- The Pointable is close to, but not touching the touch plane.
	   * * "touching" -- The Pointable has penetrated the touch plane.
	   *
	   * The touchDistance value provides a normalized indication of the distance to
	   * the touch plane when the Pointable is in the hovering or touching zones.
	   *
	   * @member touchZone
	   * @type {String}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.touchZone = data.touchZone;
	  /**
	   * A value proportional to the distance between this Pointable object and the
	   * adaptive touch plane.
	   *
	   * ![Touch Distance](images/Leap_Touch_Plane.png)
	   *
	   * The touch distance is a value in the range [-1, 1]. The value 1.0 indicates the
	   * Pointable is at the far edge of the hovering zone. The value 0 indicates the
	   * Pointable is just entering the touching zone. A value of -1.0 indicates the
	   * Pointable is firmly within the touching zone. Values in between are
	   * proportional to the distance from the plane. Thus, the touchDistance of 0.5
	   * indicates that the Pointable is halfway into the hovering zone.
	   *
	   * You can use the touchDistance value to modulate visual feedback given to the
	   * user as their fingers close in on a touch target, such as a button.
	   *
	   * @member touchDistance
	   * @type {number}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.touchDistance = data.touchDistance;

	  /**
	   * How long the pointable has been visible in seconds.
	   *
	   * @member timeVisible
	   * @type {number}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.timeVisible = data.timeVisible;
	}

	/**
	 * A string containing a brief, human readable description of the Pointable
	 * object.
	 *
	 * @method toString
	 * @memberof Leap.Pointable.prototype
	 * @returns {String} A description of the Pointable object as a string.
	 */
	Pointable.prototype.toString = function() {
	  return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + ' ]';
	}

	/**
	 * Returns the hand which the pointable is attached to.
	 */
	Pointable.prototype.hand = function(){
	  return this.frame.hand(this.handId);
	}

	/**
	 * An invalid Pointable object.
	 *
	 * You can use this Pointable instance in comparisons testing
	 * whether a given Pointable instance is valid or invalid. (You can also use the
	 * Pointable.valid property.)

	 * @static
	 * @type {Leap.Pointable}
	 * @name Invalid
	 * @memberof Leap.Pointable
	 */
	Pointable.Invalid = { valid: false };


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview gl-matrix - High performance matrix and vector operations
	 * @author Brandon Jones
	 * @author Colin MacKenzie IV
	 * @version 2.2.1
	 */

	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


	(function(_global) {
	  "use strict";

	  var shim = {};
	  if (false) {
	    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
	      shim.exports = {};
	      define(function() {
	        return shim.exports;
	      });
	    } else {
	      // gl-matrix lives in a browser, define its namespaces in global
	      shim.exports = typeof(window) !== 'undefined' ? window : _global;
	    }
	  }
	  else {
	    // gl-matrix lives in commonjs, define its namespaces in exports
	    shim.exports = exports;
	  }

	  (function(exports) {
	    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


	if(!GLMAT_EPSILON) {
	    var GLMAT_EPSILON = 0.000001;
	}

	if(!GLMAT_ARRAY_TYPE) {
	    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	}

	if(!GLMAT_RANDOM) {
	    var GLMAT_RANDOM = Math.random;
	}

	/**
	 * @class Common utilities
	 * @name glMatrix
	 */
	var glMatrix = {};

	/**
	 * Sets the type of array used when creating new vectors and matricies
	 *
	 * @param {Type} type Array type, such as Float32Array or Array
	 */
	glMatrix.setMatrixArrayType = function(type) {
	    GLMAT_ARRAY_TYPE = type;
	}

	if(typeof(exports) !== 'undefined') {
	    exports.glMatrix = glMatrix;
	}

	var degree = Math.PI / 180;

	/**
	* Convert Degree To Radian
	*
	* @param {Number} Angle in Degrees
	*/
	glMatrix.toRadian = function(a){
	     return a * degree;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 2 Dimensional Vector
	 * @name vec2
	 */

	var vec2 = {};

	/**
	 * Creates a new, empty vec2
	 *
	 * @returns {vec2} a new 2D vector
	 */
	vec2.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(2);
	    out[0] = 0;
	    out[1] = 0;
	    return out;
	};

	/**
	 * Creates a new vec2 initialized with values from an existing vector
	 *
	 * @param {vec2} a vector to clone
	 * @returns {vec2} a new 2D vector
	 */
	vec2.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(2);
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};

	/**
	 * Creates a new vec2 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} a new 2D vector
	 */
	vec2.fromValues = function(x, y) {
	    var out = new GLMAT_ARRAY_TYPE(2);
	    out[0] = x;
	    out[1] = y;
	    return out;
	};

	/**
	 * Copy the values from one vec2 to another
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the source vector
	 * @returns {vec2} out
	 */
	vec2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};

	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	vec2.set = function(out, x, y) {
	    out[0] = x;
	    out[1] = y;
	    return out;
	};

	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    return out;
	};

	/**
	 * Alias for {@link vec2.subtract}
	 * @function
	 */
	vec2.sub = vec2.subtract;

	/**
	 * Multiplies two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    return out;
	};

	/**
	 * Alias for {@link vec2.multiply}
	 * @function
	 */
	vec2.mul = vec2.multiply;

	/**
	 * Divides two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    return out;
	};

	/**
	 * Alias for {@link vec2.divide}
	 * @function
	 */
	vec2.div = vec2.divide;

	/**
	 * Returns the minimum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    return out;
	};

	/**
	 * Scales a vec2 by a scalar number
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec2} out
	 */
	vec2.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    return out;
	};

	/**
	 * Adds two vec2's after scaling the second operand by a scalar value
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec2} out
	 */
	vec2.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec2.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return Math.sqrt(x*x + y*y);
	};

	/**
	 * Alias for {@link vec2.distance}
	 * @function
	 */
	vec2.dist = vec2.distance;

	/**
	 * Calculates the squared euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec2.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return x*x + y*y;
	};

	/**
	 * Alias for {@link vec2.squaredDistance}
	 * @function
	 */
	vec2.sqrDist = vec2.squaredDistance;

	/**
	 * Calculates the length of a vec2
	 *
	 * @param {vec2} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec2.length = function (a) {
	    var x = a[0],
	        y = a[1];
	    return Math.sqrt(x*x + y*y);
	};

	/**
	 * Alias for {@link vec2.length}
	 * @function
	 */
	vec2.len = vec2.length;

	/**
	 * Calculates the squared length of a vec2
	 *
	 * @param {vec2} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec2.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1];
	    return x*x + y*y;
	};

	/**
	 * Alias for {@link vec2.squaredLength}
	 * @function
	 */
	vec2.sqrLen = vec2.squaredLength;

	/**
	 * Negates the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to negate
	 * @returns {vec2} out
	 */
	vec2.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    return out;
	};

	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	vec2.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1];
	    var len = x*x + y*y;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec2.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	};

	/**
	 * Computes the cross product of two vec2's
	 * Note that the cross product must by definition produce a 3D vector
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec3} out
	 */
	vec2.cross = function(out, a, b) {
	    var z = a[0] * b[1] - a[1] * b[0];
	    out[0] = out[1] = 0;
	    out[2] = z;
	    return out;
	};

	/**
	 * Performs a linear interpolation between two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec2} out
	 */
	vec2.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec2} out
	 */
	vec2.random = function (out, scale) {
	    scale = scale || 1.0;
	    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
	    out[0] = Math.cos(r) * scale;
	    out[1] = Math.sin(r) * scale;
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat2 = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[2] * y;
	    out[1] = m[1] * x + m[3] * y;
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat2d
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2d} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat2d = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[2] * y + m[4];
	    out[1] = m[1] * x + m[3] * y + m[5];
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat3
	 * 3rd vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat3} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat3 = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[3] * y + m[6];
	    out[1] = m[1] * x + m[4] * y + m[7];
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat4
	 * 3rd vector component is implicitly '0'
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat4 = function(out, a, m) {
	    var x = a[0], 
	        y = a[1];
	    out[0] = m[0] * x + m[4] * y + m[12];
	    out[1] = m[1] * x + m[5] * y + m[13];
	    return out;
	};

	/**
	 * Perform some operation over an array of vec2s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec2.forEach = (function() {
	    var vec = vec2.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 2;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec2} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec2.str = function (a) {
	    return 'vec2(' + a[0] + ', ' + a[1] + ')';
	};

	if(typeof(exports) !== 'undefined') {
	    exports.vec2 = vec2;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 3 Dimensional Vector
	 * @name vec3
	 */

	var vec3 = {};

	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {vec3} a new 3D vector
	 */
	vec3.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(3);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    return out;
	};

	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {vec3} a vector to clone
	 * @returns {vec3} a new 3D vector
	 */
	vec3.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(3);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};

	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */
	vec3.fromValues = function(x, y, z) {
	    var out = new GLMAT_ARRAY_TYPE(3);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};

	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the source vector
	 * @returns {vec3} out
	 */
	vec3.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};

	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} out
	 */
	vec3.set = function(out, x, y, z) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};

	/**
	 * Adds two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.subtract}
	 * @function
	 */
	vec3.sub = vec3.subtract;

	/**
	 * Multiplies two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.multiply}
	 * @function
	 */
	vec3.mul = vec3.multiply;

	/**
	 * Divides two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.divide}
	 * @function
	 */
	vec3.div = vec3.divide;

	/**
	 * Returns the minimum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    return out;
	};

	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec3} out
	 */
	vec3.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    return out;
	};

	/**
	 * Adds two vec3's after scaling the second operand by a scalar value
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec3} out
	 */
	vec3.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec3.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Alias for {@link vec3.distance}
	 * @function
	 */
	vec3.dist = vec3.distance;

	/**
	 * Calculates the squared euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec3.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return x*x + y*y + z*z;
	};

	/**
	 * Alias for {@link vec3.squaredDistance}
	 * @function
	 */
	vec3.sqrDist = vec3.squaredDistance;

	/**
	 * Calculates the length of a vec3
	 *
	 * @param {vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec3.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Alias for {@link vec3.length}
	 * @function
	 */
	vec3.len = vec3.length;

	/**
	 * Calculates the squared length of a vec3
	 *
	 * @param {vec3} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec3.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return x*x + y*y + z*z;
	};

	/**
	 * Alias for {@link vec3.squaredLength}
	 * @function
	 */
	vec3.sqrLen = vec3.squaredLength;

	/**
	 * Negates the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to negate
	 * @returns {vec3} out
	 */
	vec3.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    return out;
	};

	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to normalize
	 * @returns {vec3} out
	 */
	vec3.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    var len = x*x + y*y + z*z;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	        out[2] = a[2] * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec3.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	};

	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.cross = function(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2],
	        bx = b[0], by = b[1], bz = b[2];

	    out[0] = ay * bz - az * by;
	    out[1] = az * bx - ax * bz;
	    out[2] = ax * by - ay * bx;
	    return out;
	};

	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec3} out
	 */
	vec3.random = function (out, scale) {
	    scale = scale || 1.0;

	    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
	    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
	    var zScale = Math.sqrt(1.0-z*z) * scale;

	    out[0] = Math.cos(r) * zScale;
	    out[1] = Math.sin(r) * zScale;
	    out[2] = z * scale;
	    return out;
	};

	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec3} out
	 */
	vec3.transformMat4 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2];
	    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
	    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
	    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
	    return out;
	};

	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m the 3x3 matrix to transform with
	 * @returns {vec3} out
	 */
	vec3.transformMat3 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2];
	    out[0] = x * m[0] + y * m[3] + z * m[6];
	    out[1] = x * m[1] + y * m[4] + z * m[7];
	    out[2] = x * m[2] + y * m[5] + z * m[8];
	    return out;
	};

	/**
	 * Transforms the vec3 with a quat
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec3} out
	 */
	vec3.transformQuat = function(out, a, q) {
	    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return out;
	};

	/*
	* Rotate a 3D vector around the x-axis
	* @param {vec3} out The receiving vec3
	* @param {vec3} a The vec3 point to rotate
	* @param {vec3} b The origin of the rotation
	* @param {Number} c The angle of rotation
	* @returns {vec3} out
	*/
	vec3.rotateX = function(out, a, b, c){
	   var p = [], r=[];
		  //Translate point to the origin
		  p[0] = a[0] - b[0];
		  p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];

		  //perform rotation
		  r[0] = p[0];
		  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
		  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

		  //translate to correct position
		  out[0] = r[0] + b[0];
		  out[1] = r[1] + b[1];
		  out[2] = r[2] + b[2];

	  	return out;
	};

	/*
	* Rotate a 3D vector around the y-axis
	* @param {vec3} out The receiving vec3
	* @param {vec3} a The vec3 point to rotate
	* @param {vec3} b The origin of the rotation
	* @param {Number} c The angle of rotation
	* @returns {vec3} out
	*/
	vec3.rotateY = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
	  	r[1] = p[1];
	  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};

	/*
	* Rotate a 3D vector around the z-axis
	* @param {vec3} out The receiving vec3
	* @param {vec3} a The vec3 point to rotate
	* @param {vec3} b The origin of the rotation
	* @param {Number} c The angle of rotation
	* @returns {vec3} out
	*/
	vec3.rotateZ = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
	  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
	  	r[2] = p[2];
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};

	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec3.forEach = (function() {
	    var vec = vec3.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 3;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec3} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec3.str = function (a) {
	    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
	};

	if(typeof(exports) !== 'undefined') {
	    exports.vec3 = vec3;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 4 Dimensional Vector
	 * @name vec4
	 */

	var vec4 = {};

	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {vec4} a new 4D vector
	 */
	vec4.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    return out;
	};

	/**
	 * Creates a new vec4 initialized with values from an existing vector
	 *
	 * @param {vec4} a vector to clone
	 * @returns {vec4} a new 4D vector
	 */
	vec4.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} a new 4D vector
	 */
	vec4.fromValues = function(x, y, z, w) {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};

	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the source vector
	 * @returns {vec4} out
	 */
	vec4.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} out
	 */
	vec4.set = function(out, x, y, z, w) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};

	/**
	 * Adds two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.subtract}
	 * @function
	 */
	vec4.sub = vec4.subtract;

	/**
	 * Multiplies two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    out[3] = a[3] * b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.multiply}
	 * @function
	 */
	vec4.mul = vec4.multiply;

	/**
	 * Divides two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    out[3] = a[3] / b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.divide}
	 * @function
	 */
	vec4.div = vec4.divide;

	/**
	 * Returns the minimum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    out[3] = Math.min(a[3], b[3]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    out[3] = Math.max(a[3], b[3]);
	    return out;
	};

	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec4} out
	 */
	vec4.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    return out;
	};

	/**
	 * Adds two vec4's after scaling the second operand by a scalar value
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec4} out
	 */
	vec4.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec4.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};

	/**
	 * Alias for {@link vec4.distance}
	 * @function
	 */
	vec4.dist = vec4.distance;

	/**
	 * Calculates the squared euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec4.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return x*x + y*y + z*z + w*w;
	};

	/**
	 * Alias for {@link vec4.squaredDistance}
	 * @function
	 */
	vec4.sqrDist = vec4.squaredDistance;

	/**
	 * Calculates the length of a vec4
	 *
	 * @param {vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec4.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};

	/**
	 * Alias for {@link vec4.length}
	 * @function
	 */
	vec4.len = vec4.length;

	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec4.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return x*x + y*y + z*z + w*w;
	};

	/**
	 * Alias for {@link vec4.squaredLength}
	 * @function
	 */
	vec4.sqrLen = vec4.squaredLength;

	/**
	 * Negates the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to negate
	 * @returns {vec4} out
	 */
	vec4.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = -a[3];
	    return out;
	};

	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to normalize
	 * @returns {vec4} out
	 */
	vec4.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    var len = x*x + y*y + z*z + w*w;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	        out[2] = a[2] * len;
	        out[3] = a[3] * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec4.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	};

	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec4} out
	 */
	vec4.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2],
	        aw = a[3];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    out[3] = aw + t * (b[3] - aw);
	    return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec4} out
	 */
	vec4.random = function (out, scale) {
	    scale = scale || 1.0;

	    //TODO: This is a pretty awful way of doing this. Find something better.
	    out[0] = GLMAT_RANDOM();
	    out[1] = GLMAT_RANDOM();
	    out[2] = GLMAT_RANDOM();
	    out[3] = GLMAT_RANDOM();
	    vec4.normalize(out, out);
	    vec4.scale(out, out, scale);
	    return out;
	};

	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec4} out
	 */
	vec4.transformMat4 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2], w = a[3];
	    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	    return out;
	};

	/**
	 * Transforms the vec4 with a quat
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec4} out
	 */
	vec4.transformQuat = function(out, a, q) {
	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return out;
	};

	/**
	 * Perform some operation over an array of vec4s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec4.forEach = (function() {
	    var vec = vec4.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 4;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec4} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec4.str = function (a) {
	    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	if(typeof(exports) !== 'undefined') {
	    exports.vec4 = vec4;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 2x2 Matrix
	 * @name mat2
	 */

	var mat2 = {};

	/**
	 * Creates a new identity mat2
	 *
	 * @returns {mat2} a new 2x2 matrix
	 */
	mat2.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Creates a new mat2 initialized with values from an existing matrix
	 *
	 * @param {mat2} a matrix to clone
	 * @returns {mat2} a new 2x2 matrix
	 */
	mat2.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Copy the values from one mat2 to another
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Set a mat2 to the identity matrix
	 *
	 * @param {mat2} out the receiving matrix
	 * @returns {mat2} out
	 */
	mat2.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a1 = a[1];
	        out[1] = a[2];
	        out[2] = a1;
	    } else {
	        out[0] = a[0];
	        out[1] = a[2];
	        out[2] = a[1];
	        out[3] = a[3];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.invert = function(out, a) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

	        // Calculate the determinant
	        det = a0 * a3 - a2 * a1;

	    if (!det) {
	        return null;
	    }
	    det = 1.0 / det;
	    
	    out[0] =  a3 * det;
	    out[1] = -a1 * det;
	    out[2] = -a2 * det;
	    out[3] =  a0 * det;

	    return out;
	};

	/**
	 * Calculates the adjugate of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.adjoint = function(out, a) {
	    // Caching this value is nessecary if out == a
	    var a0 = a[0];
	    out[0] =  a[3];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] =  a0;

	    return out;
	};

	/**
	 * Calculates the determinant of a mat2
	 *
	 * @param {mat2} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat2.determinant = function (a) {
	    return a[0] * a[3] - a[2] * a[1];
	};

	/**
	 * Multiplies two mat2's
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	mat2.multiply = function (out, a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    out[0] = a0 * b0 + a2 * b1;
	    out[1] = a1 * b0 + a3 * b1;
	    out[2] = a0 * b2 + a2 * b3;
	    out[3] = a1 * b2 + a3 * b3;
	    return out;
	};

	/**
	 * Alias for {@link mat2.multiply}
	 * @function
	 */
	mat2.mul = mat2.multiply;

	/**
	 * Rotates a mat2 by the given angle
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	mat2.rotate = function (out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = a0 *  c + a2 * s;
	    out[1] = a1 *  c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    return out;
	};

	/**
	 * Scales the mat2 by the dimensions in the given vec2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2} out
	 **/
	mat2.scale = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0 * v0;
	    out[1] = a1 * v0;
	    out[2] = a2 * v1;
	    out[3] = a3 * v1;
	    return out;
	};

	/**
	 * Returns a string representation of a mat2
	 *
	 * @param {mat2} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat2.str = function (a) {
	    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat2
	 *
	 * @param {mat2} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat2.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
	};

	/**
	 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
	 * @param {mat2} L the lower triangular matrix 
	 * @param {mat2} D the diagonal matrix 
	 * @param {mat2} U the upper triangular matrix 
	 * @param {mat2} a the input matrix to factorize
	 */

	mat2.LDU = function (L, D, U, a) { 
	    L[2] = a[2]/a[0]; 
	    U[0] = a[0]; 
	    U[1] = a[1]; 
	    U[3] = a[3] - L[2] * U[1]; 
	    return [L, D, U];       
	}; 

	if(typeof(exports) !== 'undefined') {
	    exports.mat2 = mat2;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 2x3 Matrix
	 * @name mat2d
	 * 
	 * @description 
	 * A mat2d contains six elements defined as:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty]
	 * </pre>
	 * This is a short form for the 3x3 matrix:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty,
	 *  0, 0, 1]
	 * </pre>
	 * The last row is ignored so the array is shorter and operations are faster.
	 */

	var mat2d = {};

	/**
	 * Creates a new identity mat2d
	 *
	 * @returns {mat2d} a new 2x3 matrix
	 */
	mat2d.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(6);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	};

	/**
	 * Creates a new mat2d initialized with values from an existing matrix
	 *
	 * @param {mat2d} a matrix to clone
	 * @returns {mat2d} a new 2x3 matrix
	 */
	mat2d.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(6);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    return out;
	};

	/**
	 * Copy the values from one mat2d to another
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	mat2d.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    return out;
	};

	/**
	 * Set a mat2d to the identity matrix
	 *
	 * @param {mat2d} out the receiving matrix
	 * @returns {mat2d} out
	 */
	mat2d.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	};

	/**
	 * Inverts a mat2d
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	mat2d.invert = function(out, a) {
	    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
	        atx = a[4], aty = a[5];

	    var det = aa * ad - ab * ac;
	    if(!det){
	        return null;
	    }
	    det = 1.0 / det;

	    out[0] = ad * det;
	    out[1] = -ab * det;
	    out[2] = -ac * det;
	    out[3] = aa * det;
	    out[4] = (ac * aty - ad * atx) * det;
	    out[5] = (ab * atx - aa * aty) * det;
	    return out;
	};

	/**
	 * Calculates the determinant of a mat2d
	 *
	 * @param {mat2d} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat2d.determinant = function (a) {
	    return a[0] * a[3] - a[1] * a[2];
	};

	/**
	 * Multiplies two mat2d's
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	mat2d.multiply = function (out, a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
	    out[0] = a0 * b0 + a2 * b1;
	    out[1] = a1 * b0 + a3 * b1;
	    out[2] = a0 * b2 + a2 * b3;
	    out[3] = a1 * b2 + a3 * b3;
	    out[4] = a0 * b4 + a2 * b5 + a4;
	    out[5] = a1 * b4 + a3 * b5 + a5;
	    return out;
	};

	/**
	 * Alias for {@link mat2d.multiply}
	 * @function
	 */
	mat2d.mul = mat2d.multiply;


	/**
	 * Rotates a mat2d by the given angle
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	mat2d.rotate = function (out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = a0 *  c + a2 * s;
	    out[1] = a1 *  c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    out[4] = a4;
	    out[5] = a5;
	    return out;
	};

	/**
	 * Scales the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2d} out
	 **/
	mat2d.scale = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0 * v0;
	    out[1] = a1 * v0;
	    out[2] = a2 * v1;
	    out[3] = a3 * v1;
	    out[4] = a4;
	    out[5] = a5;
	    return out;
	};

	/**
	 * Translates the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to translate the matrix by
	 * @returns {mat2d} out
	 **/
	mat2d.translate = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0;
	    out[1] = a1;
	    out[2] = a2;
	    out[3] = a3;
	    out[4] = a0 * v0 + a2 * v1 + a4;
	    out[5] = a1 * v0 + a3 * v1 + a5;
	    return out;
	};

	/**
	 * Returns a string representation of a mat2d
	 *
	 * @param {mat2d} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat2d.str = function (a) {
	    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat2d
	 *
	 * @param {mat2d} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat2d.frob = function (a) { 
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
	}; 

	if(typeof(exports) !== 'undefined') {
	    exports.mat2d = mat2d;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 3x3 Matrix
	 * @name mat3
	 */

	var mat3 = {};

	/**
	 * Creates a new identity mat3
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */
	mat3.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(9);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Copies the upper-left 3x3 values into the given mat3.
	 *
	 * @param {mat3} out the receiving 3x3 matrix
	 * @param {mat4} a   the source 4x4 matrix
	 * @returns {mat3} out
	 */
	mat3.fromMat4 = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[4];
	    out[4] = a[5];
	    out[5] = a[6];
	    out[6] = a[8];
	    out[7] = a[9];
	    out[8] = a[10];
	    return out;
	};

	/**
	 * Creates a new mat3 initialized with values from an existing matrix
	 *
	 * @param {mat3} a matrix to clone
	 * @returns {mat3} a new 3x3 matrix
	 */
	mat3.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(9);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Copy the values from one mat3 to another
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Set a mat3 to the identity matrix
	 *
	 * @param {mat3} out the receiving matrix
	 * @returns {mat3} out
	 */
	mat3.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a12 = a[5];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a01;
	        out[5] = a[7];
	        out[6] = a02;
	        out[7] = a12;
	    } else {
	        out[0] = a[0];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a[1];
	        out[4] = a[4];
	        out[5] = a[7];
	        out[6] = a[2];
	        out[7] = a[5];
	        out[8] = a[8];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        b01 = a22 * a11 - a12 * a21,
	        b11 = -a22 * a10 + a12 * a20,
	        b21 = a21 * a10 - a11 * a20,

	        // Calculate the determinant
	        det = a00 * b01 + a01 * b11 + a02 * b21;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = b01 * det;
	    out[1] = (-a22 * a01 + a02 * a21) * det;
	    out[2] = (a12 * a01 - a02 * a11) * det;
	    out[3] = b11 * det;
	    out[4] = (a22 * a00 - a02 * a20) * det;
	    out[5] = (-a12 * a00 + a02 * a10) * det;
	    out[6] = b21 * det;
	    out[7] = (-a21 * a00 + a01 * a20) * det;
	    out[8] = (a11 * a00 - a01 * a10) * det;
	    return out;
	};

	/**
	 * Calculates the adjugate of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.adjoint = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];

	    out[0] = (a11 * a22 - a12 * a21);
	    out[1] = (a02 * a21 - a01 * a22);
	    out[2] = (a01 * a12 - a02 * a11);
	    out[3] = (a12 * a20 - a10 * a22);
	    out[4] = (a00 * a22 - a02 * a20);
	    out[5] = (a02 * a10 - a00 * a12);
	    out[6] = (a10 * a21 - a11 * a20);
	    out[7] = (a01 * a20 - a00 * a21);
	    out[8] = (a00 * a11 - a01 * a10);
	    return out;
	};

	/**
	 * Calculates the determinant of a mat3
	 *
	 * @param {mat3} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat3.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];

	    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	};

	/**
	 * Multiplies two mat3's
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	mat3.multiply = function (out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        b00 = b[0], b01 = b[1], b02 = b[2],
	        b10 = b[3], b11 = b[4], b12 = b[5],
	        b20 = b[6], b21 = b[7], b22 = b[8];

	    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

	    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

	    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	    return out;
	};

	/**
	 * Alias for {@link mat3.multiply}
	 * @function
	 */
	mat3.mul = mat3.multiply;

	/**
	 * Translate a mat3 by the given vector
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to translate
	 * @param {vec2} v vector to translate by
	 * @returns {mat3} out
	 */
	mat3.translate = function(out, a, v) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	        x = v[0], y = v[1];

	    out[0] = a00;
	    out[1] = a01;
	    out[2] = a02;

	    out[3] = a10;
	    out[4] = a11;
	    out[5] = a12;

	    out[6] = x * a00 + y * a10 + a20;
	    out[7] = x * a01 + y * a11 + a21;
	    out[8] = x * a02 + y * a12 + a22;
	    return out;
	};

	/**
	 * Rotates a mat3 by the given angle
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	mat3.rotate = function (out, a, rad) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        s = Math.sin(rad),
	        c = Math.cos(rad);

	    out[0] = c * a00 + s * a10;
	    out[1] = c * a01 + s * a11;
	    out[2] = c * a02 + s * a12;

	    out[3] = c * a10 - s * a00;
	    out[4] = c * a11 - s * a01;
	    out[5] = c * a12 - s * a02;

	    out[6] = a20;
	    out[7] = a21;
	    out[8] = a22;
	    return out;
	};

	/**
	 * Scales the mat3 by the dimensions in the given vec2
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat3} out
	 **/
	mat3.scale = function(out, a, v) {
	    var x = v[0], y = v[1];

	    out[0] = x * a[0];
	    out[1] = x * a[1];
	    out[2] = x * a[2];

	    out[3] = y * a[3];
	    out[4] = y * a[4];
	    out[5] = y * a[5];

	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Copies the values from a mat2d into a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat2d} a the matrix to copy
	 * @returns {mat3} out
	 **/
	mat3.fromMat2d = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = 0;

	    out[3] = a[2];
	    out[4] = a[3];
	    out[5] = 0;

	    out[6] = a[4];
	    out[7] = a[5];
	    out[8] = 1;
	    return out;
	};

	/**
	* Calculates a 3x3 matrix from the given quaternion
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {quat} q Quaternion to create matrix from
	*
	* @returns {mat3} out
	*/
	mat3.fromQuat = function (out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[3] = yx - wz;
	    out[6] = zx + wy;

	    out[1] = yx + wz;
	    out[4] = 1 - xx - zz;
	    out[7] = zy - wx;

	    out[2] = zx - wy;
	    out[5] = zy + wx;
	    out[8] = 1 - xx - yy;

	    return out;
	};

	/**
	* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {mat4} a Mat4 to derive the normal matrix from
	*
	* @returns {mat3} out
	*/
	mat3.normalFromMat4 = function (out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

	    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

	    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

	    return out;
	};

	/**
	 * Returns a string representation of a mat3
	 *
	 * @param {mat3} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat3.str = function (a) {
	    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
	                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat3
	 *
	 * @param {mat3} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat3.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
	};


	if(typeof(exports) !== 'undefined') {
	    exports.mat3 = mat3;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class 4x4 Matrix
	 * @name mat4
	 */

	var mat4 = {};

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */
	mat4.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(16);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {mat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */
	mat4.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	mat4.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];

	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	};

	/**
	 * Calculates the adjugate of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.adjoint = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
	    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
	    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
	    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
	    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
	    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
	    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
	    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
	    return out;
	};

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat4.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;

	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	};

	/**
	 * Multiplies two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.multiply = function (out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	};

	/**
	 * Alias for {@link mat4.multiply}
	 * @function
	 */
	mat4.mul = mat4.multiply;

	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.translate = function (out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	};

	/**
	 * Scales the mat4 by the dimensions in the given vec3
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	mat4.scale = function(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];

	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Rotates a mat4 by the given angle
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	mat4.rotate = function (out, a, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;

	    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
	    
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.rotateX = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.rotateY = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.rotateZ = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	};

	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslation = function (out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    
	    return out;
	};

	mat4.fromQuat = function (out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;

	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;

	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;

	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;

	    return out;
	};

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.frustum = function (out, left, right, bottom, top, near, far) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	};

	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.perspective = function (out, fovy, aspect, near, far) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	};

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.ortho = function (out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	mat4.lookAt = function (out, eye, center, up) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];

	    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
	        Math.abs(eyey - centery) < GLMAT_EPSILON &&
	        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
	        return mat4.identity(out);
	    }

	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;

	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;

	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }

	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;

	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }

	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;

	    return out;
	};

	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {mat4} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat4.str = function (a) {
	    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
	                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
	                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
	                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat4
	 *
	 * @param {mat4} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat4.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
	};


	if(typeof(exports) !== 'undefined') {
	    exports.mat4 = mat4;
	}
	;
	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation 
	    and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

	/**
	 * @class Quaternion
	 * @name quat
	 */

	var quat = {};

	/**
	 * Creates a new identity quat
	 *
	 * @returns {quat} a new quaternion
	 */
	quat.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {quat} out the receiving quaternion.
	 * @param {vec3} a the initial vector
	 * @param {vec3} b the destination vector
	 * @returns {quat} out
	 */
	quat.rotationTo = (function() {
	    var tmpvec3 = vec3.create();
	    var xUnitVec3 = vec3.fromValues(1,0,0);
	    var yUnitVec3 = vec3.fromValues(0,1,0);

	    return function(out, a, b) {
	        var dot = vec3.dot(a, b);
	        if (dot < -0.999999) {
	            vec3.cross(tmpvec3, xUnitVec3, a);
	            if (vec3.length(tmpvec3) < 0.000001)
	                vec3.cross(tmpvec3, yUnitVec3, a);
	            vec3.normalize(tmpvec3, tmpvec3);
	            quat.setAxisAngle(out, tmpvec3, Math.PI);
	            return out;
	        } else if (dot > 0.999999) {
	            out[0] = 0;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            return out;
	        } else {
	            vec3.cross(tmpvec3, a, b);
	            out[0] = tmpvec3[0];
	            out[1] = tmpvec3[1];
	            out[2] = tmpvec3[2];
	            out[3] = 1 + dot;
	            return quat.normalize(out, out);
	        }
	    };
	})();

	/**
	 * Sets the specified quaternion with values corresponding to the given
	 * axes. Each axis is a vec3 and is expected to be unit length and
	 * perpendicular to all other specified axes.
	 *
	 * @param {vec3} view  the vector representing the viewing direction
	 * @param {vec3} right the vector representing the local "right" direction
	 * @param {vec3} up    the vector representing the local "up" direction
	 * @returns {quat} out
	 */
	quat.setAxes = (function() {
	    var matr = mat3.create();

	    return function(out, view, right, up) {
	        matr[0] = right[0];
	        matr[3] = right[1];
	        matr[6] = right[2];

	        matr[1] = up[0];
	        matr[4] = up[1];
	        matr[7] = up[2];

	        matr[2] = -view[0];
	        matr[5] = -view[1];
	        matr[8] = -view[2];

	        return quat.normalize(out, quat.fromMat3(out, matr));
	    };
	})();

	/**
	 * Creates a new quat initialized with values from an existing quaternion
	 *
	 * @param {quat} a quaternion to clone
	 * @returns {quat} a new quaternion
	 * @function
	 */
	quat.clone = vec4.clone;

	/**
	 * Creates a new quat initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} a new quaternion
	 * @function
	 */
	quat.fromValues = vec4.fromValues;

	/**
	 * Copy the values from one quat to another
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the source quaternion
	 * @returns {quat} out
	 * @function
	 */
	quat.copy = vec4.copy;

	/**
	 * Set the components of a quat to the given values
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} out
	 * @function
	 */
	quat.set = vec4.set;

	/**
	 * Set a quat to the identity quaternion
	 *
	 * @param {quat} out the receiving quaternion
	 * @returns {quat} out
	 */
	quat.identity = function(out) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {vec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {quat} out
	 **/
	quat.setAxisAngle = function(out, axis, rad) {
	    rad = rad * 0.5;
	    var s = Math.sin(rad);
	    out[0] = s * axis[0];
	    out[1] = s * axis[1];
	    out[2] = s * axis[2];
	    out[3] = Math.cos(rad);
	    return out;
	};

	/**
	 * Adds two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 * @function
	 */
	quat.add = vec4.add;

	/**
	 * Multiplies two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 */
	quat.multiply = function(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];

	    out[0] = ax * bw + aw * bx + ay * bz - az * by;
	    out[1] = ay * bw + aw * by + az * bx - ax * bz;
	    out[2] = az * bw + aw * bz + ax * by - ay * bx;
	    out[3] = aw * bw - ax * bx - ay * by - az * bz;
	    return out;
	};

	/**
	 * Alias for {@link quat.multiply}
	 * @function
	 */
	quat.mul = quat.multiply;

	/**
	 * Scales a quat by a scalar number
	 *
	 * @param {quat} out the receiving vector
	 * @param {quat} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {quat} out
	 * @function
	 */
	quat.scale = vec4.scale;

	/**
	 * Rotates a quaternion by the given angle about the X axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateX = function (out, a, rad) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw + aw * bx;
	    out[1] = ay * bw + az * bx;
	    out[2] = az * bw - ay * bx;
	    out[3] = aw * bw - ax * bx;
	    return out;
	};

	/**
	 * Rotates a quaternion by the given angle about the Y axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateY = function (out, a, rad) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        by = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw - az * by;
	    out[1] = ay * bw + aw * by;
	    out[2] = az * bw + ax * by;
	    out[3] = aw * bw - ay * by;
	    return out;
	};

	/**
	 * Rotates a quaternion by the given angle about the Z axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateZ = function (out, a, rad) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bz = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw + ay * bz;
	    out[1] = ay * bw - ax * bz;
	    out[2] = az * bw + aw * bz;
	    out[3] = aw * bw - az * bz;
	    return out;
	};

	/**
	 * Calculates the W component of a quat from the X, Y, and Z components.
	 * Assumes that quaternion is 1 unit in length.
	 * Any existing W component will be ignored.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate W component of
	 * @returns {quat} out
	 */
	quat.calculateW = function (out, a) {
	    var x = a[0], y = a[1], z = a[2];

	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
	    return out;
	};

	/**
	 * Calculates the dot product of two quat's
	 *
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 */
	quat.dot = vec4.dot;

	/**
	 * Performs a linear interpolation between two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 * @function
	 */
	quat.lerp = vec4.lerp;

	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 */
	quat.slerp = function (out, a, b, t) {
	    // benchmarks:
	    //    http://jsperf.com/quaternion-slerp-implementations

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];

	    var        omega, cosom, sinom, scale0, scale1;

	    // calc cosine
	    cosom = ax * bx + ay * by + az * bz + aw * bw;
	    // adjust signs (if necessary)
	    if ( cosom < 0.0 ) {
	        cosom = -cosom;
	        bx = - bx;
	        by = - by;
	        bz = - bz;
	        bw = - bw;
	    }
	    // calculate coefficients
	    if ( (1.0 - cosom) > 0.000001 ) {
	        // standard case (slerp)
	        omega  = Math.acos(cosom);
	        sinom  = Math.sin(omega);
	        scale0 = Math.sin((1.0 - t) * omega) / sinom;
	        scale1 = Math.sin(t * omega) / sinom;
	    } else {        
	        // "from" and "to" quaternions are very close 
	        //  ... so we can do a linear interpolation
	        scale0 = 1.0 - t;
	        scale1 = t;
	    }
	    // calculate final values
	    out[0] = scale0 * ax + scale1 * bx;
	    out[1] = scale0 * ay + scale1 * by;
	    out[2] = scale0 * az + scale1 * bz;
	    out[3] = scale0 * aw + scale1 * bw;
	    
	    return out;
	};

	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate inverse of
	 * @returns {quat} out
	 */
	quat.invert = function(out, a) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
	        invDot = dot ? 1.0/dot : 0;
	    
	    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

	    out[0] = -a0*invDot;
	    out[1] = -a1*invDot;
	    out[2] = -a2*invDot;
	    out[3] = a3*invDot;
	    return out;
	};

	/**
	 * Calculates the conjugate of a quat
	 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate conjugate of
	 * @returns {quat} out
	 */
	quat.conjugate = function (out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Calculates the length of a quat
	 *
	 * @param {quat} a vector to calculate length of
	 * @returns {Number} length of a
	 * @function
	 */
	quat.length = vec4.length;

	/**
	 * Alias for {@link quat.length}
	 * @function
	 */
	quat.len = quat.length;

	/**
	 * Calculates the squared length of a quat
	 *
	 * @param {quat} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 */
	quat.squaredLength = vec4.squaredLength;

	/**
	 * Alias for {@link quat.squaredLength}
	 * @function
	 */
	quat.sqrLen = quat.squaredLength;

	/**
	 * Normalize a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quaternion to normalize
	 * @returns {quat} out
	 * @function
	 */
	quat.normalize = vec4.normalize;

	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {mat3} m rotation matrix
	 * @returns {quat} out
	 * @function
	 */
	quat.fromMat3 = function(out, m) {
	    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	    // article "Quaternion Calculus and Fast Animation".
	    var fTrace = m[0] + m[4] + m[8];
	    var fRoot;

	    if ( fTrace > 0.0 ) {
	        // |w| > 1/2, may as well choose w > 1/2
	        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
	        out[3] = 0.5 * fRoot;
	        fRoot = 0.5/fRoot;  // 1/(4w)
	        out[0] = (m[7]-m[5])*fRoot;
	        out[1] = (m[2]-m[6])*fRoot;
	        out[2] = (m[3]-m[1])*fRoot;
	    } else {
	        // |w| <= 1/2
	        var i = 0;
	        if ( m[4] > m[0] )
	          i = 1;
	        if ( m[8] > m[i*3+i] )
	          i = 2;
	        var j = (i+1)%3;
	        var k = (i+2)%3;
	        
	        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
	        out[i] = 0.5 * fRoot;
	        fRoot = 0.5 / fRoot;
	        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
	        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
	        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
	    }
	    
	    return out;
	};

	/**
	 * Returns a string representation of a quatenion
	 *
	 * @param {quat} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	quat.str = function (a) {
	    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	if(typeof(exports) !== 'undefined') {
	    exports.quat = quat;
	}
	;













	  })(shim.exports);
	})(this);


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var Pointable = __webpack_require__(184),
	  glMatrix = __webpack_require__(185)
	  , vec3 = glMatrix.vec3
	  , mat3 = glMatrix.mat3
	  , mat4 = glMatrix.mat4
	  , _ = __webpack_require__(187);


	var Bone = module.exports = function(finger, data) {
	  this.finger = finger;

	  this._center = null, this._matrix = null;

	  /**
	  * An integer code for the name of this bone.
	  *
	  * * 0 -- metacarpal
	  * * 1 -- proximal
	  * * 2 -- medial
	  * * 3 -- distal
	  * * 4 -- arm
	  *
	  * @member type
	  * @type {number}
	  * @memberof Leap.Bone.prototype
	  */
	  this.type = data.type;

	  /**
	   * The position of the previous, or base joint of the bone closer to the wrist.
	   * @type {vector3}
	   */
	  this.prevJoint = data.prevJoint;

	  /**
	   * The position of the next joint, or the end of the bone closer to the finger tip.
	   * @type {vector3}
	   */
	  this.nextJoint = data.nextJoint;

	  /**
	   * The estimated width of the tool in millimeters.
	   *
	   * The reported width is the average width of the visible portion of the
	   * tool from the hand to the tip. If the width isn't known,
	   * then a value of 0 is returned.
	   *
	   * Pointable objects representing fingers do not have a width property.
	   *
	   * @member width
	   * @type {number}
	   * @memberof Leap.Pointable.prototype
	   */
	  this.width = data.width;

	  var displacement = new Array(3);
	  vec3.sub(displacement, data.nextJoint, data.prevJoint);

	  this.length = vec3.length(displacement);


	  /**
	   *
	   * These fully-specify the orientation of the bone.
	   * See examples/threejs-bones.html for more info
	   * Three vec3s:
	   *  x (red): The rotation axis of the finger, pointing outwards.  (In general, away from the thumb )
	   *  y (green): The "up" vector, orienting the top of the finger
	   *  z (blue): The roll axis of the bone.
	   *
	   *  Most up vectors will be pointing the same direction, except for the thumb, which is more rightwards.
	   *
	   *  The thumb has one fewer bones than the fingers, but there are the same number of joints & joint-bases provided
	   *  the first two appear in the same position, but only the second (proximal) rotates.
	   *
	   *  Normalized.
	   */
	  this.basis = data.basis;
	};

	Bone.prototype.left = function(){

	  if (this._left) return this._left;

	  this._left =  mat3.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])) < 0;

	  return this._left;

	};


	/**
	 * The Affine transformation matrix describing the orientation of the bone, in global Leap-space.
	 * It contains a 3x3 rotation matrix (in the "top left"), and center coordinates in the fourth column.
	 *
	 * Unlike the basis, the right and left hands have the same coordinate system.
	 *
	 */
	Bone.prototype.matrix = function(){

	  if (this._matrix) return this._matrix;

	  var b = this.basis,
	      t = this._matrix = mat4.create();

	  // open transform mat4 from rotation mat3
	  t[0] = b[0][0], t[1] = b[0][1], t[2]  = b[0][2];
	  t[4] = b[1][0], t[5] = b[1][1], t[6]  = b[1][2];
	  t[8] = b[2][0], t[9] = b[2][1], t[10] = b[2][2];

	  t[3] = this.center()[0];
	  t[7] = this.center()[1];
	  t[11] = this.center()[2];

	  if ( this.left() ) {
	    // flip the basis to be right-handed
	    t[0] *= -1;
	    t[1] *= -1;
	    t[2] *= -1;
	  }

	  return this._matrix;
	};

	/**
	 * Helper method to linearly interpolate between the two ends of the bone.
	 *
	 * when t = 0, the position of prevJoint will be returned
	 * when t = 1, the position of nextJoint will be returned
	 */
	Bone.prototype.lerp = function(out, t){

	  vec3.lerp(out, this.prevJoint, this.nextJoint, t);

	};

	/**
	 *
	 * The center position of the bone
	 * Returns a vec3 array.
	 *
	 */
	Bone.prototype.center = function(){

	  if (this._center) return this._center;

	  var center = vec3.create();
	  this.lerp(center, 0.5);
	  this._center = center;
	  return center;

	};

	// The negative of the z-basis
	Bone.prototype.direction = function(){

	 return [
	   this.basis[2][0] * -1,
	   this.basis[2][1] * -1,
	   this.basis[2][2] * -1
	 ];

	};


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	//     Underscore.js 1.4.4
	//     http://underscorejs.org
	//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `global` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Establish the object that gets returned to break out of a loop iteration.
	  var breaker = {};

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var push             = ArrayProto.push,
	      slice            = ArrayProto.slice,
	      concat           = ArrayProto.concat,
	      toString         = ObjProto.toString,
	      hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeForEach      = ArrayProto.forEach,
	    nativeMap          = ArrayProto.map,
	    nativeReduce       = ArrayProto.reduce,
	    nativeReduceRight  = ArrayProto.reduceRight,
	    nativeFilter       = ArrayProto.filter,
	    nativeEvery        = ArrayProto.every,
	    nativeSome         = ArrayProto.some,
	    nativeIndexOf      = ArrayProto.indexOf,
	    nativeLastIndexOf  = ArrayProto.lastIndexOf,
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind;

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object via a string identifier,
	  // for Closure Compiler "advanced" mode.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.4.4';

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles objects with the built-in `forEach`, arrays, and raw objects.
	  // Delegates to **ECMAScript 5**'s native `forEach` if available.
	  var each = _.each = _.forEach = function(obj, iterator, context) {
	    if (obj == null) return;
	    if (nativeForEach && obj.forEach === nativeForEach) {
	      obj.forEach(iterator, context);
	    } else if (obj.length === +obj.length) {
	      for (var i = 0, l = obj.length; i < l; i++) {
	        if (iterator.call(context, obj[i], i, obj) === breaker) return;
	      }
	    } else {
	      for (var key in obj) {
	        if (_.has(obj, key)) {
	          if (iterator.call(context, obj[key], key, obj) === breaker) return;
	        }
	      }
	    }
	  };

	  // Return the results of applying the iterator to each element.
	  // Delegates to **ECMAScript 5**'s native `map` if available.
	  _.map = _.collect = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
	    each(obj, function(value, index, list) {
	      results[results.length] = iterator.call(context, value, index, list);
	    });
	    return results;
	  };

	  var reduceError = 'Reduce of empty array with no initial value';

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
	  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduce && obj.reduce === nativeReduce) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	    }
	    each(obj, function(value, index, list) {
	      if (!initial) {
	        memo = value;
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, value, index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };

	  // The right-associative version of reduce, also known as `foldr`.
	  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
	  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
	    }
	    var length = obj.length;
	    if (length !== +length) {
	      var keys = _.keys(obj);
	      length = keys.length;
	    }
	    each(obj, function(value, index, list) {
	      index = keys ? keys[--length] : --length;
	      if (!initial) {
	        memo = obj[index];
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, obj[index], index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, iterator, context) {
	    var result;
	    any(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) {
	        result = value;
	        return true;
	      }
	    });
	    return result;
	  };

	  // Return all the elements that pass a truth test.
	  // Delegates to **ECMAScript 5**'s native `filter` if available.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
	    each(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) results[results.length] = value;
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, iterator, context) {
	    return _.filter(obj, function(value, index, list) {
	      return !iterator.call(context, value, index, list);
	    }, context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Delegates to **ECMAScript 5**'s native `every` if available.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = true;
	    if (obj == null) return result;
	    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
	    each(obj, function(value, index, list) {
	      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Delegates to **ECMAScript 5**'s native `some` if available.
	  // Aliased as `any`.
	  var any = _.some = _.any = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = false;
	    if (obj == null) return result;
	    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
	    each(obj, function(value, index, list) {
	      if (result || (result = iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };

	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `include`.
	  _.contains = _.include = function(obj, target) {
	    if (obj == null) return false;
	    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
	    return any(obj, function(value) {
	      return value === target;
	    });
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      return (isFunc ? method : value[method]).apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, function(value){ return value[key]; });
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs, first) {
	    if (_.isEmpty(attrs)) return first ? null : [];
	    return _[first ? 'find' : 'filter'](obj, function(value) {
	      for (var key in attrs) {
	        if (attrs[key] !== value[key]) return false;
	      }
	      return true;
	    });
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.where(obj, attrs, true);
	  };

	  // Return the maximum element or (element-based computation).
	  // Can't optimize arrays of integers longer than 65,535 elements.
	  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
	  _.max = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.max.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return -Infinity;
	    var result = {computed : -Infinity, value: -Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed >= result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.min.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return Infinity;
	    var result = {computed : Infinity, value: Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed < result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };

	  // Shuffle an array.
	  _.shuffle = function(obj) {
	    var rand;
	    var index = 0;
	    var shuffled = [];
	    each(obj, function(value) {
	      rand = _.random(index++);
	      shuffled[index - 1] = shuffled[rand];
	      shuffled[rand] = value;
	    });
	    return shuffled;
	  };

	  // An internal function to generate lookup iterators.
	  var lookupIterator = function(value) {
	    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
	  };

	  // Sort the object's values by a criterion produced by an iterator.
	  _.sortBy = function(obj, value, context) {
	    var iterator = lookupIterator(value);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value : value,
	        index : index,
	        criteria : iterator.call(context, value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index < right.index ? -1 : 1;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(obj, value, context, behavior) {
	    var result = {};
	    var iterator = lookupIterator(value || _.identity);
	    each(obj, function(value, index) {
	      var key = iterator.call(context, value, index, obj);
	      behavior(result, key, value);
	    });
	    return result;
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = function(obj, value, context) {
	    return group(obj, value, context, function(result, key, value) {
	      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
	    });
	  };

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = function(obj, value, context) {
	    return group(obj, value, context, function(result, key) {
	      if (!_.has(result, key)) result[key] = 0;
	      result[key]++;
	    });
	  };

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iterator, context) {
	    iterator = iterator == null ? _.identity : lookupIterator(iterator);
	    var value = iterator.call(context, obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = (low + high) >>> 1;
	      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
	    }
	    return low;
	  };

	  // Safely convert anything iterable into a real, live array.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (obj.length === +obj.length) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N. The **guard** check allows it to work with
	  // `_.map`.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array. The **guard** check allows it to work with `_.map`.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if ((n != null) && !guard) {
	      return slice.call(array, Math.max(array.length - n, 0));
	    } else {
	      return array[array.length - 1];
	    }
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array. The **guard**
	  // check allows it to work with `_.map`.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, (n == null) || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, output) {
	    each(input, function(value) {
	      if (_.isArray(value)) {
	        shallow ? push.apply(output, value) : flatten(value, shallow, output);
	      } else {
	        output.push(value);
	      }
	    });
	    return output;
	  };

	  // Return a completely flattened version of an array.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, []);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iterator, context) {
	    if (_.isFunction(isSorted)) {
	      context = iterator;
	      iterator = isSorted;
	      isSorted = false;
	    }
	    var initial = iterator ? _.map(array, iterator, context) : array;
	    var results = [];
	    var seen = [];
	    each(initial, function(value, index) {
	      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
	        seen.push(value);
	        results.push(array[index]);
	      }
	    });
	    return results;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(concat.apply(ArrayProto, arguments));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var rest = slice.call(arguments, 1);
	    return _.filter(_.uniq(array), function(item) {
	      return _.every(rest, function(other) {
	        return _.indexOf(other, item) >= 0;
	      });
	    });
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
	    return _.filter(array, function(value){ return !_.contains(rest, value); });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    var args = slice.call(arguments);
	    var length = _.max(_.pluck(args, 'length'));
	    var results = new Array(length);
	    for (var i = 0; i < length; i++) {
	      results[i] = _.pluck(args, "" + i);
	    }
	    return results;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    if (list == null) return {};
	    var result = {};
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
	  // we need this function. Return the position of the first occurrence of an
	  // item in an array, or -1 if the item is not included in the array.
	  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    if (array == null) return -1;
	    var i = 0, l = array.length;
	    if (isSorted) {
	      if (typeof isSorted == 'number') {
	        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
	      } else {
	        i = _.sortedIndex(array, item);
	        return array[i] === item ? i : -1;
	      }
	    }
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
	    for (; i < l; i++) if (array[i] === item) return i;
	    return -1;
	  };

	  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
	  _.lastIndexOf = function(array, item, from) {
	    if (array == null) return -1;
	    var hasIndex = from != null;
	    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
	      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
	    }
	    var i = (hasIndex ? from : array.length);
	    while (i--) if (array[i] === item) return i;
	    return -1;
	  };

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = arguments[2] || 1;

	    var len = Math.max(Math.ceil((stop - start) / step), 0);
	    var idx = 0;
	    var range = new Array(len);

	    while(idx < len) {
	      range[idx++] = start;
	      start += step;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    var args = slice.call(arguments, 2);
	    return function() {
	      return func.apply(context, args.concat(slice.call(arguments)));
	    };
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context.
	  _.partial = function(func) {
	    var args = slice.call(arguments, 1);
	    return function() {
	      return func.apply(this, args.concat(slice.call(arguments)));
	    };
	  };

	  // Bind all of an object's methods to that object. Useful for ensuring that
	  // all callbacks defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var funcs = slice.call(arguments, 1);
	    if (funcs.length === 0) funcs = _.functions(obj);
	    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memo = {};
	    hasher || (hasher = _.identity);
	    return function() {
	      var key = hasher.apply(this, arguments);
	      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
	    };
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){ return func.apply(null, args); }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = function(func) {
	    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	  };

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time.
	  _.throttle = function(func, wait) {
	    var context, args, timeout, result;
	    var previous = 0;
	    var later = function() {
	      previous = new Date;
	      timeout = null;
	      result = func.apply(context, args);
	    };
	    return function() {
	      var now = new Date;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0) {
	        clearTimeout(timeout);
	        timeout = null;
	        previous = now;
	        result = func.apply(context, args);
	      } else if (!timeout) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, result;
	    return function() {
	      var context = this, args = arguments;
	      var later = function() {
	        timeout = null;
	        if (!immediate) result = func.apply(context, args);
	      };
	      var callNow = immediate && !timeout;
	      clearTimeout(timeout);
	      timeout = setTimeout(later, wait);
	      if (callNow) result = func.apply(context, args);
	      return result;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = function(func) {
	    var ran = false, memo;
	    return function() {
	      if (ran) return memo;
	      ran = true;
	      memo = func.apply(this, arguments);
	      func = null;
	      return memo;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return function() {
	      var args = [func];
	      push.apply(args, arguments);
	      return wrapper.apply(this, args);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var funcs = arguments;
	    return function() {
	      var args = arguments;
	      for (var i = funcs.length - 1; i >= 0; i--) {
	        args = [funcs[i].apply(this, args)];
	      }
	      return args[0];
	    };
	  };

	  // Returns a function that will only be executed after being called N times.
	  _.after = function(times, func) {
	    if (times <= 0) return func();
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Object Functions
	  // ----------------

	  // Retrieve the names of an object's properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = nativeKeys || function(obj) {
	    if (obj !== Object(obj)) throw new TypeError('Invalid object');
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var values = [];
	    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
	    return values;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var pairs = [];
	    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    each(keys, function(key) {
	      if (key in obj) copy[key] = obj[key];
	    });
	    return copy;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    for (var key in obj) {
	      if (!_.contains(keys, key)) copy[key] = obj[key];
	    }
	    return copy;
	  };

	  // Fill in a given object with default properties.
	  _.defaults = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          if (obj[prop] == null) obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
	    if (a === b) return a !== 0 || 1 / a == 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className != toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, dates, and booleans are compared by value.
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return a == String(b);
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
	        // other numeric values.
	        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a == +b;
	      // RegExps are compared by their source patterns and flags.
	      case '[object RegExp]':
	        return a.source == b.source &&
	               a.global == b.global &&
	               a.multiline == b.multiline &&
	               a.ignoreCase == b.ignoreCase;
	    }
	    if (typeof a != 'object' || typeof b != 'object') return false;
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] == a) return bStack[length] == b;
	    }
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	    var size = 0, result = true;
	    // Recursively compare objects and arrays.
	    if (className == '[object Array]') {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      size = a.length;
	      result = size == b.length;
	      if (result) {
	        // Deep compare the contents, ignoring non-numeric properties.
	        while (size--) {
	          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
	        }
	      }
	    } else {
	      // Objects with different constructors are not equivalent, but `Object`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
	                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
	        return false;
	      }
	      // Deep compare objects.
	      for (var key in a) {
	        if (_.has(a, key)) {
	          // Count the expected number of properties.
	          size++;
	          // Deep compare each member.
	          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
	        }
	      }
	      // Ensure that both objects contain the same number of properties.
	      if (result) {
	        for (key in b) {
	          if (_.has(b, key) && !(size--)) break;
	        }
	        result = !size;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return result;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b, [], []);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
	    for (var key in obj) if (_.has(obj, key)) return false;
	    return true;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) == '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    return obj === Object(obj);
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) == '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return !!(obj && _.has(obj, 'callee'));
	    };
	  }

	  // Optimize `isFunction` if appropriate.
	  if (true) {
	    _.isFunction = function(obj) {
	      return typeof obj === 'function';
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj != +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iterators.
	  _.identity = function(value) {
	    return value;
	  };

	  // Run a function **n** times.
	  _.times = function(n, iterator, context) {
	    var accum = Array(n);
	    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // List of HTML entities for escaping.
	  var entityMap = {
	    escape: {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#x27;',
	      '/': '&#x2F;'
	    }
	  };
	  entityMap.unescape = _.invert(entityMap.escape);

	  // Regexes containing the keys and values listed immediately above.
	  var entityRegexes = {
	    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
	    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
	  };

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  _.each(['escape', 'unescape'], function(method) {
	    _[method] = function(string) {
	      if (string == null) return '';
	      return ('' + string).replace(entityRegexes[method], function(match) {
	        return entityMap[method][match];
	      });
	    };
	  });

	  // If the value of the named property is a function then invoke it;
	  // otherwise, return it.
	  _.result = function(object, property) {
	    if (object == null) return null;
	    var value = object[property];
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    each(_.functions(obj), function(name){
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result.call(this, func.apply(_, args));
	      };
	    });
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\t':     't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  _.template = function(text, data, settings) {
	    var render;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = new RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset)
	        .replace(escaper, function(match) { return '\\' + escapes[match]; });

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      }
	      if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      }
	      if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	      index = offset + match.length;
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + "return __p;\n";

	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    if (data) return render(data, _);
	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled function source as a convenience for precompilation.
	    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function, which will delegate to the wrapper.
	  _.chain = function(obj) {
	    return _(obj).chain();
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(obj) {
	    return this._chain ? _(obj).chain() : obj;
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
	      return result.call(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result.call(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  _.extend(_.prototype, {

	    // Start chaining a wrapped Underscore object.
	    chain: function() {
	      this._chain = true;
	      return this;
	    },

	    // Extracts the result from a wrapped and chained object.
	    value: function() {
	      return this._wrapped;
	    }

	  });

	}).call(this);


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var glMatrix = __webpack_require__(185)
	  , vec3 = glMatrix.vec3
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , _ = __webpack_require__(187);

	/**
	 * Constructs a new Gesture object.
	 *
	 * An uninitialized Gesture object is considered invalid. Get valid instances
	 * of the Gesture class, which will be one of the Gesture subclasses, from a
	 * Frame object.
	 *
	 * @class Gesture
	 * @abstract
	 * @memberof Leap
	 * @classdesc
	 * The Gesture class represents a recognized movement by the user.
	 *
	 * The Leap watches the activity within its field of view for certain movement
	 * patterns typical of a user gesture or command. For example, a movement from side to
	 * side with the hand can indicate a swipe gesture, while a finger poking forward
	 * can indicate a screen tap gesture.
	 *
	 * When the Leap recognizes a gesture, it assigns an ID and adds a
	 * Gesture object to the frame gesture list. For continuous gestures, which
	 * occur over many frames, the Leap updates the gesture by adding
	 * a Gesture object having the same ID and updated properties in each
	 * subsequent frame.
	 *
	 * **Important:** Recognition for each type of gesture must be enabled;
	 * otherwise **no gestures are recognized or reported**.
	 *
	 * Subclasses of Gesture define the properties for the specific movement patterns
	 * recognized by the Leap.
	 *
	 * The Gesture subclasses for include:
	 *
	 * * CircleGesture -- A circular movement by a finger.
	 * * SwipeGesture -- A straight line movement by the hand with fingers extended.
	 * * ScreenTapGesture -- A forward tapping movement by a finger.
	 * * KeyTapGesture -- A downward tapping movement by a finger.
	 *
	 * Circle and swipe gestures are continuous and these objects can have a
	 * state of start, update, and stop.
	 *
	 * The screen tap gesture is a discrete gesture. The Leap only creates a single
	 * ScreenTapGesture object appears for each tap and it always has a stop state.
	 *
	 * Get valid Gesture instances from a Frame object. You can get a list of gestures
	 * from the Frame gestures array. You can also use the Frame gesture() method
	 * to find a gesture in the current frame using an ID value obtained in a
	 * previous frame.
	 *
	 * Gesture objects can be invalid. For example, when you get a gesture by ID
	 * using Frame.gesture(), and there is no gesture with that ID in the current
	 * frame, then gesture() returns an Invalid Gesture object (rather than a null
	 * value). Always check object validity in situations where a gesture might be
	 * invalid.
	 */
	var createGesture = exports.createGesture = function(data) {
	  var gesture;
	  switch (data.type) {
	    case 'circle':
	      gesture = new CircleGesture(data);
	      break;
	    case 'swipe':
	      gesture = new SwipeGesture(data);
	      break;
	    case 'screenTap':
	      gesture = new ScreenTapGesture(data);
	      break;
	    case 'keyTap':
	      gesture = new KeyTapGesture(data);
	      break;
	    default:
	      throw "unknown gesture type";
	  }

	 /**
	  * The gesture ID.
	  *
	  * All Gesture objects belonging to the same recognized movement share the
	  * same ID value. Use the ID value with the Frame::gesture() method to
	  * find updates related to this Gesture object in subsequent frames.
	  *
	  * @member id
	  * @memberof Leap.Gesture.prototype
	  * @type {number}
	  */
	  gesture.id = data.id;
	 /**
	  * The list of hands associated with this Gesture, if any.
	  *
	  * If no hands are related to this gesture, the list is empty.
	  *
	  * @member handIds
	  * @memberof Leap.Gesture.prototype
	  * @type {Array}
	  */
	  gesture.handIds = data.handIds.slice();
	 /**
	  * The list of fingers and tools associated with this Gesture, if any.
	  *
	  * If no Pointable objects are related to this gesture, the list is empty.
	  *
	  * @member pointableIds
	  * @memberof Leap.Gesture.prototype
	  * @type {Array}
	  */
	  gesture.pointableIds = data.pointableIds.slice();
	 /**
	  * The elapsed duration of the recognized movement up to the
	  * frame containing this Gesture object, in microseconds.
	  *
	  * The duration reported for the first Gesture in the sequence (with the
	  * start state) will typically be a small positive number since
	  * the movement must progress far enough for the Leap to recognize it as
	  * an intentional gesture.
	  *
	  * @member duration
	  * @memberof Leap.Gesture.prototype
	  * @type {number}
	  */
	  gesture.duration = data.duration;
	 /**
	  * The gesture ID.
	  *
	  * Recognized movements occur over time and have a beginning, a middle,
	  * and an end. The 'state()' attribute reports where in that sequence this
	  * Gesture object falls.
	  *
	  * Possible values for the state field are:
	  *
	  * * start
	  * * update
	  * * stop
	  *
	  * @member state
	  * @memberof Leap.Gesture.prototype
	  * @type {String}
	  */
	  gesture.state = data.state;
	 /**
	  * The gesture type.
	  *
	  * Possible values for the type field are:
	  *
	  * * circle
	  * * swipe
	  * * screenTap
	  * * keyTap
	  *
	  * @member type
	  * @memberof Leap.Gesture.prototype
	  * @type {String}
	  */
	  gesture.type = data.type;
	  return gesture;
	}

	/*
	 * Returns a builder object, which uses method chaining for gesture callback binding.
	 */
	var gestureListener = exports.gestureListener = function(controller, type) {
	  var handlers = {};
	  var gestureMap = {};

	  controller.on('gesture', function(gesture, frame) {
	    if (gesture.type == type) {
	      if (gesture.state == "start" || gesture.state == "stop") {
	        if (gestureMap[gesture.id] === undefined) {
	          var gestureTracker = new Gesture(gesture, frame);
	          gestureMap[gesture.id] = gestureTracker;
	          _.each(handlers, function(cb, name) {
	            gestureTracker.on(name, cb);
	          });
	        }
	      }
	      gestureMap[gesture.id].update(gesture, frame);
	      if (gesture.state == "stop") {
	        delete gestureMap[gesture.id];
	      }
	    }
	  });
	  var builder = {
	    start: function(cb) {
	      handlers['start'] = cb;
	      return builder;
	    },
	    stop: function(cb) {
	      handlers['stop'] = cb;
	      return builder;
	    },
	    complete: function(cb) {
	      handlers['stop'] = cb;
	      return builder;
	    },
	    update: function(cb) {
	      handlers['update'] = cb;
	      return builder;
	    }
	  }
	  return builder;
	}

	var Gesture = exports.Gesture = function(gesture, frame) {
	  this.gestures = [gesture];
	  this.frames = [frame];
	}

	Gesture.prototype.update = function(gesture, frame) {
	  this.lastGesture = gesture;
	  this.lastFrame = frame;
	  this.gestures.push(gesture);
	  this.frames.push(frame);
	  this.emit(gesture.state, this);
	}

	Gesture.prototype.translation = function() {
	  return vec3.subtract(vec3.create(), this.lastGesture.startPosition, this.lastGesture.position);
	}

	_.extend(Gesture.prototype, EventEmitter.prototype);

	/**
	 * Constructs a new CircleGesture object.
	 *
	 * An uninitialized CircleGesture object is considered invalid. Get valid instances
	 * of the CircleGesture class from a Frame object.
	 *
	 * @class CircleGesture
	 * @memberof Leap
	 * @augments Leap.Gesture
	 * @classdesc
	 * The CircleGesture classes represents a circular finger movement.
	 *
	 * A circle movement is recognized when the tip of a finger draws a circle
	 * within the Leap field of view.
	 *
	 * ![CircleGesture](images/Leap_Gesture_Circle.png)
	 *
	 * Circle gestures are continuous. The CircleGesture objects for the gesture have
	 * three possible states:
	 *
	 * * start -- The circle gesture has just started. The movement has
	 *  progressed far enough for the recognizer to classify it as a circle.
	 * * update -- The circle gesture is continuing.
	 * * stop -- The circle gesture is finished.
	 */
	var CircleGesture = function(data) {
	 /**
	  * The center point of the circle within the Leap frame of reference.
	  *
	  * @member center
	  * @memberof Leap.CircleGesture.prototype
	  * @type {number[]}
	  */
	  this.center = data.center;
	 /**
	  * The normal vector for the circle being traced.
	  *
	  * If you draw the circle clockwise, the normal vector points in the same
	  * general direction as the pointable object drawing the circle. If you draw
	  * the circle counterclockwise, the normal points back toward the
	  * pointable. If the angle between the normal and the pointable object
	  * drawing the circle is less than 90 degrees, then the circle is clockwise.
	  *
	  * ```javascript
	  *    var clockwiseness;
	  *    if (circle.pointable.direction.angleTo(circle.normal) <= PI/4) {
	  *        clockwiseness = "clockwise";
	  *    }
	  *    else
	  *    {
	  *        clockwiseness = "counterclockwise";
	  *    }
	  * ```
	  *
	  * @member normal
	  * @memberof Leap.CircleGesture.prototype
	  * @type {number[]}
	  */
	  this.normal = data.normal;
	 /**
	  * The number of times the finger tip has traversed the circle.
	  *
	  * Progress is reported as a positive number of the number. For example,
	  * a progress value of .5 indicates that the finger has gone halfway
	  * around, while a value of 3 indicates that the finger has gone around
	  * the the circle three times.
	  *
	  * Progress starts where the circle gesture began. Since the circle
	  * must be partially formed before the Leap can recognize it, progress
	  * will be greater than zero when a circle gesture first appears in the
	  * frame.
	  *
	  * @member progress
	  * @memberof Leap.CircleGesture.prototype
	  * @type {number}
	  */
	  this.progress = data.progress;
	 /**
	  * The radius of the circle in mm.
	  *
	  * @member radius
	  * @memberof Leap.CircleGesture.prototype
	  * @type {number}
	  */
	  this.radius = data.radius;
	}

	CircleGesture.prototype.toString = function() {
	  return "CircleGesture ["+JSON.stringify(this)+"]";
	}

	/**
	 * Constructs a new SwipeGesture object.
	 *
	 * An uninitialized SwipeGesture object is considered invalid. Get valid instances
	 * of the SwipeGesture class from a Frame object.
	 *
	 * @class SwipeGesture
	 * @memberof Leap
	 * @augments Leap.Gesture
	 * @classdesc
	 * The SwipeGesture class represents a swiping motion of a finger or tool.
	 *
	 * ![SwipeGesture](images/Leap_Gesture_Swipe.png)
	 *
	 * Swipe gestures are continuous.
	 */
	var SwipeGesture = function(data) {
	 /**
	  * The starting position within the Leap frame of
	  * reference, in mm.
	  *
	  * @member startPosition
	  * @memberof Leap.SwipeGesture.prototype
	  * @type {number[]}
	  */
	  this.startPosition = data.startPosition;
	 /**
	  * The current swipe position within the Leap frame of
	  * reference, in mm.
	  *
	  * @member position
	  * @memberof Leap.SwipeGesture.prototype
	  * @type {number[]}
	  */
	  this.position = data.position;
	 /**
	  * The unit direction vector parallel to the swipe motion.
	  *
	  * You can compare the components of the vector to classify the swipe as
	  * appropriate for your application. For example, if you are using swipes
	  * for two dimensional scrolling, you can compare the x and y values to
	  * determine if the swipe is primarily horizontal or vertical.
	  *
	  * @member direction
	  * @memberof Leap.SwipeGesture.prototype
	  * @type {number[]}
	  */
	  this.direction = data.direction;
	 /**
	  * The speed of the finger performing the swipe gesture in
	  * millimeters per second.
	  *
	  * @member speed
	  * @memberof Leap.SwipeGesture.prototype
	  * @type {number}
	  */
	  this.speed = data.speed;
	}

	SwipeGesture.prototype.toString = function() {
	  return "SwipeGesture ["+JSON.stringify(this)+"]";
	}

	/**
	 * Constructs a new ScreenTapGesture object.
	 *
	 * An uninitialized ScreenTapGesture object is considered invalid. Get valid instances
	 * of the ScreenTapGesture class from a Frame object.
	 *
	 * @class ScreenTapGesture
	 * @memberof Leap
	 * @augments Leap.Gesture
	 * @classdesc
	 * The ScreenTapGesture class represents a tapping gesture by a finger or tool.
	 *
	 * A screen tap gesture is recognized when the tip of a finger pokes forward
	 * and then springs back to approximately the original postion, as if
	 * tapping a vertical screen. The tapping finger must pause briefly before beginning the tap.
	 *
	 * ![ScreenTap](images/Leap_Gesture_Tap2.png)
	 *
	 * ScreenTap gestures are discrete. The ScreenTapGesture object representing a tap always
	 * has the state, STATE_STOP. Only one ScreenTapGesture object is created for each
	 * screen tap gesture recognized.
	 */
	var ScreenTapGesture = function(data) {
	 /**
	  * The position where the screen tap is registered.
	  *
	  * @member position
	  * @memberof Leap.ScreenTapGesture.prototype
	  * @type {number[]}
	  */
	  this.position = data.position;
	 /**
	  * The direction of finger tip motion.
	  *
	  * @member direction
	  * @memberof Leap.ScreenTapGesture.prototype
	  * @type {number[]}
	  */
	  this.direction = data.direction;
	 /**
	  * The progess value is always 1.0 for a screen tap gesture.
	  *
	  * @member progress
	  * @memberof Leap.ScreenTapGesture.prototype
	  * @type {number}
	  */
	  this.progress = data.progress;
	}

	ScreenTapGesture.prototype.toString = function() {
	  return "ScreenTapGesture ["+JSON.stringify(this)+"]";
	}

	/**
	 * Constructs a new KeyTapGesture object.
	 *
	 * An uninitialized KeyTapGesture object is considered invalid. Get valid instances
	 * of the KeyTapGesture class from a Frame object.
	 *
	 * @class KeyTapGesture
	 * @memberof Leap
	 * @augments Leap.Gesture
	 * @classdesc
	 * The KeyTapGesture class represents a tapping gesture by a finger or tool.
	 *
	 * A key tap gesture is recognized when the tip of a finger rotates down toward the
	 * palm and then springs back to approximately the original postion, as if
	 * tapping. The tapping finger must pause briefly before beginning the tap.
	 *
	 * ![KeyTap](images/Leap_Gesture_Tap.png)
	 *
	 * Key tap gestures are discrete. The KeyTapGesture object representing a tap always
	 * has the state, STATE_STOP. Only one KeyTapGesture object is created for each
	 * key tap gesture recognized.
	 */
	var KeyTapGesture = function(data) {
	    /**
	     * The position where the key tap is registered.
	     *
	     * @member position
	     * @memberof Leap.KeyTapGesture.prototype
	     * @type {number[]}
	     */
	    this.position = data.position;
	    /**
	     * The direction of finger tip motion.
	     *
	     * @member direction
	     * @memberof Leap.KeyTapGesture.prototype
	     * @type {number[]}
	     */
	    this.direction = data.direction;
	    /**
	     * The progess value is always 1.0 for a key tap gesture.
	     *
	     * @member progress
	     * @memberof Leap.KeyTapGesture.prototype
	     * @type {number}
	     */
	    this.progress = data.progress;
	}

	KeyTapGesture.prototype.toString = function() {
	  return "KeyTapGesture ["+JSON.stringify(this)+"]";
	}


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var glMatrix = __webpack_require__(185)
	  , vec3 = glMatrix.vec3;

	/**
	 * Constructs a InteractionBox object.
	 *
	 * @class InteractionBox
	 * @memberof Leap
	 * @classdesc
	 * The InteractionBox class represents a box-shaped region completely within
	 * the field of view of the Leap Motion controller.
	 *
	 * The interaction box is an axis-aligned rectangular prism and provides
	 * normalized coordinates for hands, fingers, and tools within this box.
	 * The InteractionBox class can make it easier to map positions in the
	 * Leap Motion coordinate system to 2D or 3D coordinate systems used
	 * for application drawing.
	 *
	 * ![Interaction Box](images/Leap_InteractionBox.png)
	 *
	 * The InteractionBox region is defined by a center and dimensions along the x, y, and z axes.
	 */
	var InteractionBox = module.exports = function(data) {
	  /**
	   * Indicates whether this is a valid InteractionBox object.
	   *
	   * @member valid
	   * @type {Boolean}
	   * @memberof Leap.InteractionBox.prototype
	   */
	  this.valid = true;
	  /**
	   * The center of the InteractionBox in device coordinates (millimeters).
	   * This point is equidistant from all sides of the box.
	   *
	   * @member center
	   * @type {number[]}
	   * @memberof Leap.InteractionBox.prototype
	   */
	  this.center = data.center;

	  this.size = data.size;
	  /**
	   * The width of the InteractionBox in millimeters, measured along the x-axis.
	   *
	   * @member width
	   * @type {number}
	   * @memberof Leap.InteractionBox.prototype
	   */
	  this.width = data.size[0];
	  /**
	   * The height of the InteractionBox in millimeters, measured along the y-axis.
	   *
	   * @member height
	   * @type {number}
	   * @memberof Leap.InteractionBox.prototype
	   */
	  this.height = data.size[1];
	  /**
	   * The depth of the InteractionBox in millimeters, measured along the z-axis.
	   *
	   * @member depth
	   * @type {number}
	   * @memberof Leap.InteractionBox.prototype
	   */
	  this.depth = data.size[2];
	}

	/**
	 * Converts a position defined by normalized InteractionBox coordinates
	 * into device coordinates in millimeters.
	 *
	 * This function performs the inverse of normalizePoint().
	 *
	 * @method denormalizePoint
	 * @memberof Leap.InteractionBox.prototype
	 * @param {number[]} normalizedPosition The input position in InteractionBox coordinates.
	 * @returns {number[]} The corresponding denormalized position in device coordinates.
	 */
	InteractionBox.prototype.denormalizePoint = function(normalizedPosition) {
	  return vec3.fromValues(
	    (normalizedPosition[0] - 0.5) * this.size[0] + this.center[0],
	    (normalizedPosition[1] - 0.5) * this.size[1] + this.center[1],
	    (normalizedPosition[2] - 0.5) * this.size[2] + this.center[2]
	  );
	}

	/**
	 * Normalizes the coordinates of a point using the interaction box.
	 *
	 * Coordinates from the Leap Motion frame of reference (millimeters) are
	 * converted to a range of [0..1] such that the minimum value of the
	 * InteractionBox maps to 0 and the maximum value of the InteractionBox maps to 1.
	 *
	 * @method normalizePoint
	 * @memberof Leap.InteractionBox.prototype
	 * @param {number[]} position The input position in device coordinates.
	 * @param {Boolean} clamp Whether or not to limit the output value to the range [0,1]
	 * when the input position is outside the InteractionBox. Defaults to true.
	 * @returns {number[]} The normalized position.
	 */
	InteractionBox.prototype.normalizePoint = function(position, clamp) {
	  var vec = vec3.fromValues(
	    ((position[0] - this.center[0]) / this.size[0]) + 0.5,
	    ((position[1] - this.center[1]) / this.size[1]) + 0.5,
	    ((position[2] - this.center[2]) / this.size[2]) + 0.5
	  );

	  if (clamp) {
	    vec[0] = Math.min(Math.max(vec[0], 0), 1);
	    vec[1] = Math.min(Math.max(vec[1], 0), 1);
	    vec[2] = Math.min(Math.max(vec[2], 0), 1);
	  }
	  return vec;
	}

	/**
	 * Writes a brief, human readable description of the InteractionBox object.
	 *
	 * @method toString
	 * @memberof Leap.InteractionBox.prototype
	 * @returns {String} A description of the InteractionBox object as a string.
	 */
	InteractionBox.prototype.toString = function() {
	  return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
	}

	/**
	 * An invalid InteractionBox object.
	 *
	 * You can use this InteractionBox instance in comparisons testing
	 * whether a given InteractionBox instance is valid or invalid. (You can also use the
	 * InteractionBox.valid property.)
	 *
	 * @static
	 * @type {Leap.InteractionBox}
	 * @name Invalid
	 * @memberof Leap.InteractionBox
	 */
	InteractionBox.Invalid = { valid: false };


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var Pointable = __webpack_require__(184),
	  Bone = __webpack_require__(186)
	  , Dialog = __webpack_require__(191)
	  , _ = __webpack_require__(187);

	/**
	* Constructs a Finger object.
	*
	* An uninitialized finger is considered invalid.
	* Get valid Finger objects from a Frame or a Hand object.
	*
	* @class Finger
	* @memberof Leap
	* @classdesc
	* The Finger class reports the physical characteristics of a finger.
	*
	* Both fingers and tools are classified as Pointable objects. Use the
	* Pointable.tool property to determine whether a Pointable object represents a
	* tool or finger. The Leap classifies a detected entity as a tool when it is
	* thinner, straighter, and longer than a typical finger.
	*
	* Note that Finger objects can be invalid, which means that they do not
	* contain valid tracking data and do not correspond to a physical entity.
	* Invalid Finger objects can be the result of asking for a Finger object
	* using an ID from an earlier frame when no Finger objects with that ID
	* exist in the current frame. A Finger object created from the Finger
	* constructor is also invalid. Test for validity with the Pointable.valid
	* property.
	*/
	var Finger = module.exports = function(data) {
	  Pointable.call(this, data); // use pointable as super-constructor
	  
	  /**
	  * The position of the distal interphalangeal joint of the finger.
	  * This joint is closest to the tip.
	  * 
	  * The distal interphalangeal joint is located between the most extreme segment
	  * of the finger (the distal phalanx) and the middle segment (the medial
	  * phalanx).
	  *
	  * @member dipPosition
	  * @type {number[]}
	  * @memberof Leap.Finger.prototype
	  */  
	  this.dipPosition = data.dipPosition;

	  /**
	  * The position of the proximal interphalangeal joint of the finger. This joint is the middle
	  * joint of a finger.
	  *
	  * The proximal interphalangeal joint is located between the two finger segments
	  * closest to the hand (the proximal and the medial phalanges). On a thumb,
	  * which lacks an medial phalanx, this joint index identifies the knuckle joint
	  * between the proximal phalanx and the metacarpal bone.
	  *
	  * @member pipPosition
	  * @type {number[]}
	  * @memberof Leap.Finger.prototype
	  */  
	  this.pipPosition = data.pipPosition;

	  /**
	  * The position of the metacarpopophalangeal joint, or knuckle, of the finger.
	  *
	  * The metacarpopophalangeal joint is located at the base of a finger between
	  * the metacarpal bone and the first phalanx. The common name for this joint is
	  * the knuckle.
	  *
	  * On a thumb, which has one less phalanx than a finger, this joint index
	  * identifies the thumb joint near the base of the hand, between the carpal
	  * and metacarpal bones.
	  *
	  * @member mcpPosition
	  * @type {number[]}
	  * @memberof Leap.Finger.prototype
	  */  
	  this.mcpPosition = data.mcpPosition;

	  /**
	   * The position of the Carpometacarpal joint
	   *
	   * This is at the distal end of the wrist, and has no common name.
	   *
	   */
	  this.carpPosition = data.carpPosition;

	  /**
	  * Whether or not this finger is in an extended posture.
	  *
	  * A finger is considered extended if it is extended straight from the hand as if
	  * pointing. A finger is not extended when it is bent down and curled towards the 
	  * palm.
	  * @member extended
	  * @type {Boolean}
	  * @memberof Leap.Finger.prototype
	  */
	  this.extended = data.extended;

	  /**
	  * An integer code for the name of this finger.
	  * 
	  * * 0 -- thumb
	  * * 1 -- index finger
	  * * 2 -- middle finger
	  * * 3 -- ring finger
	  * * 4 -- pinky
	  *
	  * @member type
	  * @type {number}
	  * @memberof Leap.Finger.prototype
	  */
	  this.type = data.type;

	  this.finger = true;
	  
	  /**
	  * The joint positions of this finger as an array in the order base to tip.
	  *
	  * @member positions
	  * @type {array[]}
	  * @memberof Leap.Finger.prototype
	  */
	  this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];

	  if (data.bases){
	    this.addBones(data);
	  } else {
	    Dialog.warnBones();
	  }

	};

	_.extend(Finger.prototype, Pointable.prototype);


	Finger.prototype.addBones = function(data){
	  /**
	  * Four bones per finger, from wrist outwards:
	  * metacarpal, proximal, medial, and distal.
	  *
	  * See http://en.wikipedia.org/wiki/Interphalangeal_articulations_of_hand
	  */
	  this.metacarpal   = new Bone(this, {
	    type: 0,
	    width: this.width,
	    prevJoint: this.carpPosition,
	    nextJoint: this.mcpPosition,
	    basis: data.bases[0]
	  });

	  this.proximal     = new Bone(this, {
	    type: 1,
	    width: this.width,
	    prevJoint: this.mcpPosition,
	    nextJoint: this.pipPosition,
	    basis: data.bases[1]
	  });

	  this.medial = new Bone(this, {
	    type: 2,
	    width: this.width,
	    prevJoint: this.pipPosition,
	    nextJoint: this.dipPosition,
	    basis: data.bases[2]
	  });

	  /**
	   * Note that the `distal.nextJoint` position is slightly different from the `finger.tipPosition`.
	   * The former is at the very end of the bone, where the latter is the center of a sphere positioned at
	   * the tip of the finger.  The btipPosition "bone tip position" is a few mm closer to the wrist than
	   * the tipPosition.
	   * @type {Bone}
	   */
	  this.distal       = new Bone(this, {
	    type: 3,
	    width: this.width,
	    prevJoint: this.dipPosition,
	    nextJoint: data.btipPosition,
	    basis: data.bases[3]
	  });

	  this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
	};

	Finger.prototype.toString = function() {
	    return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + ' ]';
	};

	Finger.Invalid = { valid: false };


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Dialog = module.exports = function(message, options){
	  this.options = (options || {});
	  this.message = message;

	  this.createElement();
	};

	Dialog.prototype.createElement = function(){
	  this.element = document.createElement('div');
	  this.element.className = "leapjs-dialog";
	  this.element.style.position = "fixed";
	  this.element.style.top = '8px';
	  this.element.style.left = 0;
	  this.element.style.right = 0;
	  this.element.style.textAlign = 'center';
	  this.element.style.zIndex = 1000;

	  var dialog  = document.createElement('div');
	  this.element.appendChild(dialog);
	  dialog.style.className = "leapjs-dialog";
	  dialog.style.display = "inline-block";
	  dialog.style.margin = "auto";
	  dialog.style.padding = "8px";
	  dialog.style.color = "#222";
	  dialog.style.background = "#eee";
	  dialog.style.borderRadius = "4px";
	  dialog.style.border = "1px solid #999";
	  dialog.style.textAlign = "left";
	  dialog.style.cursor = "pointer";
	  dialog.style.whiteSpace = "nowrap";
	  dialog.style.transition = "box-shadow 1s linear";
	  dialog.innerHTML = this.message;


	  if (this.options.onclick){
	    dialog.addEventListener('click', this.options.onclick);
	  }

	  if (this.options.onmouseover){
	    dialog.addEventListener('mouseover', this.options.onmouseover);
	  }

	  if (this.options.onmouseout){
	    dialog.addEventListener('mouseout', this.options.onmouseout);
	  }

	  if (this.options.onmousemove){
	    dialog.addEventListener('mousemove', this.options.onmousemove);
	  }
	};

	Dialog.prototype.show = function(){
	  document.body.appendChild(this.element);
	  return this;
	};

	Dialog.prototype.hide = function(){
	  document.body.removeChild(this.element);
	  return this;
	};




	// Shows a DOM dialog box with links to developer.leapmotion.com to upgrade
	// This will work whether or not the Leap is plugged in,
	// As long as it is called after a call to .connect() and the 'ready' event has fired.
	Dialog.warnOutOfDate = function(params){
	  params || (params = {});

	  var url = "http://developer.leapmotion.com?";

	  params.returnTo = window.location.href;

	  for (var key in params){
	    url += key + '=' + encodeURIComponent(params[key]) + '&';
	  }

	  var dialog,
	    onclick = function(event){

	       if (event.target.id != 'leapjs-decline-upgrade'){

	         var popup = window.open(url,
	           '_blank',
	           'height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1'
	         );

	         if (window.focus) {popup.focus()}

	       }

	       dialog.hide();

	       return true;
	    },


	    message = "This site requires Leap Motion Tracking V2." +
	      "<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button>" +
	      "<button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>";

	  dialog = new Dialog(message, {
	      onclick: onclick,
	      onmousemove: function(e){
	        if (e.target == document.getElementById('leapjs-decline-upgrade')){
	          document.getElementById('leapjs-decline-upgrade').style.color = '#000';
	          document.getElementById('leapjs-decline-upgrade').style.boxShadow = '0px 0px 2px #5daa00';

	          document.getElementById('leapjs-accept-upgrade').style.color = '#444';
	          document.getElementById('leapjs-accept-upgrade').style.boxShadow = 'none';
	        }else{
	          document.getElementById('leapjs-accept-upgrade').style.color = '#000';
	          document.getElementById('leapjs-accept-upgrade').style.boxShadow = '0px 0px 2px #5daa00';

	          document.getElementById('leapjs-decline-upgrade').style.color = '#444';
	          document.getElementById('leapjs-decline-upgrade').style.boxShadow = 'none';
	        }
	      },
	      onmouseout: function(){
	        document.getElementById('leapjs-decline-upgrade').style.color = '#444';
	        document.getElementById('leapjs-decline-upgrade').style.boxShadow = 'none';
	        document.getElementById('leapjs-accept-upgrade').style.color = '#444';
	        document.getElementById('leapjs-accept-upgrade').style.boxShadow = 'none';
	      }
	    }
	  );

	  return dialog.show();
	};


	// Tracks whether we've warned for lack of bones API.  This will be shown only for early private-beta members.
	Dialog.hasWarnedBones = false;

	Dialog.warnBones = function(){
	  if (this.hasWarnedBones) return;
	  this.hasWarnedBones = true;

	  console.warn("Your Leap Service is out of date");

	  if ( !(typeof(process) !== 'undefined' && process.versions && process.versions.node) ){
	    this.warnOutOfDate({reason: 'bones'});
	  }

	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 192 */
/***/ function(module, exports) {

	var CircularBuffer = module.exports = function(size) {
	  this.pos = 0;
	  this._buf = [];
	  this.size = size;
	}

	CircularBuffer.prototype.get = function(i) {
	  if (i == undefined) i = 0;
	  if (i >= this.size) return undefined;
	  if (i >= this._buf.length) return undefined;
	  return this._buf[(this.pos - i - 1) % this.size];
	}

	CircularBuffer.prototype.push = function(o) {
	  this._buf[this.pos % this.size] = o;
	  return this.pos++;
	}


/***/ },
/* 193 */
/***/ function(module, exports) {

	var Pipeline = module.exports = function (controller) {
	  this.steps = [];
	  this.controller = controller;
	}

	Pipeline.prototype.addStep = function (step) {
	  this.steps.push(step);
	}

	Pipeline.prototype.run = function (frame) {
	  var stepsLength = this.steps.length;
	  for (var i = 0; i != stepsLength; i++) {
	    if (!frame) break;
	    frame = this.steps[i](frame);
	  }
	  return frame;
	}

	Pipeline.prototype.removeStep = function(step){
	  var index = this.steps.indexOf(step);
	  if (index === -1) throw "Step not found in pipeline";
	  this.steps.splice(index, 1);
	}

	/*
	 * Wraps a plugin callback method in method which can be run inside the pipeline.
	 * This wrapper method loops the callback over objects within the frame as is appropriate,
	 * calling the callback for each in turn.
	 *
	 * @method createStepFunction
	 * @memberOf Leap.Controller.prototype
	 * @param {Controller} The controller on which the callback is called.
	 * @param {String} type What frame object the callback is run for and receives.
	 *       Can be one of 'frame', 'finger', 'hand', 'pointable', 'tool'
	 * @param {function} callback The method which will be run inside the pipeline loop.  Receives one argument, such as a hand.
	 * @private
	 */
	Pipeline.prototype.addWrappedStep = function (type, callback) {
	  var controller = this.controller,
	    step = function (frame) {
	      var dependencies, i, len;
	      dependencies = (type == 'frame') ? [frame] : (frame[type + 's'] || []);

	      for (i = 0, len = dependencies.length; i < len; i++) {
	        callback.call(controller, dependencies[i]);
	      }

	      return frame;
	    };

	  this.addStep(step);
	  return step;
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var BaseConnection = module.exports = __webpack_require__(195)
	  , _ = __webpack_require__(187);


	var BrowserConnection = module.exports = function(opts) {
	  BaseConnection.call(this, opts);
	  var connection = this;
	  this.on('ready', function() { connection.startFocusLoop(); })
	  this.on('disconnect', function() { connection.stopFocusLoop(); })
	}

	_.extend(BrowserConnection.prototype, BaseConnection.prototype);

	BrowserConnection.__proto__ = BaseConnection;

	BrowserConnection.prototype.useSecure = function(){
	  return location.protocol === 'https:'
	}

	BrowserConnection.prototype.getScheme = function(){
	  return this.useSecure() ? 'wss:' : 'ws:'
	}

	BrowserConnection.prototype.getPort = function(){
	  return this.useSecure() ? 6436 : 6437
	}

	BrowserConnection.prototype.setupSocket = function() {
	  var connection = this;
	  var socket = new WebSocket(this.getUrl());
	  socket.onopen = function() { connection.handleOpen(); };
	  socket.onclose = function(data) { connection.handleClose(data['code'], data['reason']); };
	  socket.onmessage = function(message) { connection.handleData(message.data) };
	  socket.onerror = function(error) {

	    // attempt to degrade to ws: after one failed attempt for older Leap Service installations.
	    if (connection.useSecure() && connection.scheme === 'wss:'){
	      connection.scheme = 'ws:';
	      connection.port = 6437;
	      connection.disconnect();
	      connection.connect();
	    }

	  };
	  return socket;
	}

	BrowserConnection.prototype.startFocusLoop = function() {
	  if (this.focusDetectorTimer) return;
	  var connection = this;
	  var propertyName = null;
	  if (typeof document.hidden !== "undefined") {
	    propertyName = "hidden";
	  } else if (typeof document.mozHidden !== "undefined") {
	    propertyName = "mozHidden";
	  } else if (typeof document.msHidden !== "undefined") {
	    propertyName = "msHidden";
	  } else if (typeof document.webkitHidden !== "undefined") {
	    propertyName = "webkitHidden";
	  } else {
	    propertyName = undefined;
	  }

	  if (connection.windowVisible === undefined) {
	    connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false;
	  }

	  var focusListener = window.addEventListener('focus', function(e) {
	    connection.windowVisible = true;
	    updateFocusState();
	  });

	  var blurListener = window.addEventListener('blur', function(e) {
	    connection.windowVisible = false;
	    updateFocusState();
	  });

	  this.on('disconnect', function() {
	    window.removeEventListener('focus', focusListener);
	    window.removeEventListener('blur', blurListener);
	  });

	  var updateFocusState = function() {
	    var isVisible = propertyName === undefined ? true : document[propertyName] === false;
	    connection.reportFocus(isVisible && connection.windowVisible);
	  }

	  // save 100ms when resuming focus
	  updateFocusState();

	  this.focusDetectorTimer = setInterval(updateFocusState, 100);
	}

	BrowserConnection.prototype.stopFocusLoop = function() {
	  if (!this.focusDetectorTimer) return;
	  clearTimeout(this.focusDetectorTimer);
	  delete this.focusDetectorTimer;
	}


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var chooseProtocol = __webpack_require__(196).chooseProtocol
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , _ = __webpack_require__(187);

	var BaseConnection = module.exports = function(opts) {
	  this.opts = _.defaults(opts || {}, {
	    host : '127.0.0.1',
	    enableGestures: false,
	    scheme: this.getScheme(),
	    port: this.getPort(),
	    background: false,
	    optimizeHMD: false,
	    requestProtocolVersion: BaseConnection.defaultProtocolVersion
	  });
	  this.host = this.opts.host;
	  this.port = this.opts.port;
	  this.scheme = this.opts.scheme;
	  this.protocolVersionVerified = false;
	  this.background = null;
	  this.optimizeHMD = null;
	  this.on('ready', function() {
	    this.enableGestures(this.opts.enableGestures);
	    this.setBackground(this.opts.background);
	    this.setOptimizeHMD(this.opts.optimizeHMD);

	    if (this.opts.optimizeHMD){
	      console.log("Optimized for head mounted display usage.");
	    }else {
	      console.log("Optimized for desktop usage.");
	    }

	  });
	};

	// The latest available:
	BaseConnection.defaultProtocolVersion = 6;

	BaseConnection.prototype.getUrl = function() {
	  return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
	}


	BaseConnection.prototype.getScheme = function(){
	  return 'ws:'
	}

	BaseConnection.prototype.getPort = function(){
	  return 6437
	}


	BaseConnection.prototype.setBackground = function(state) {
	  this.opts.background = state;
	  if (this.protocol && this.protocol.sendBackground && this.background !== this.opts.background) {
	    this.background = this.opts.background;
	    this.protocol.sendBackground(this, this.opts.background);
	  }
	}

	BaseConnection.prototype.setOptimizeHMD = function(state) {
	  this.opts.optimizeHMD = state;
	  if (this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD) {
	    this.optimizeHMD = this.opts.optimizeHMD;
	    this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD);
	  }
	}

	BaseConnection.prototype.handleOpen = function() {
	  if (!this.connected) {
	    this.connected = true;
	    this.emit('connect');
	  }
	}

	BaseConnection.prototype.enableGestures = function(enabled) {
	  this.gesturesEnabled = enabled ? true : false;
	  this.send(this.protocol.encode({"enableGestures": this.gesturesEnabled}));
	}

	BaseConnection.prototype.handleClose = function(code, reason) {
	  if (!this.connected) return;
	  this.disconnect();

	  // 1001 - an active connection is closed
	  // 1006 - cannot connect
	  if (code === 1001 && this.opts.requestProtocolVersion > 1) {
	    if (this.protocolVersionVerified) {
	      this.protocolVersionVerified = false;
	    }else{
	      this.opts.requestProtocolVersion--;
	    }
	  }
	  this.startReconnection();
	}

	BaseConnection.prototype.startReconnection = function() {
	  var connection = this;
	  if(!this.reconnectionTimer){
	    (this.reconnectionTimer = setInterval(function() { connection.reconnect() }, 500));
	  }
	}

	BaseConnection.prototype.stopReconnection = function() {
	  this.reconnectionTimer = clearInterval(this.reconnectionTimer);
	}

	// By default, disconnect will prevent auto-reconnection.
	// Pass in true to allow the reconnection loop not be interrupted continue
	BaseConnection.prototype.disconnect = function(allowReconnect) {
	  if (!allowReconnect) this.stopReconnection();
	  if (!this.socket) return;
	  this.socket.close();
	  delete this.socket;
	  delete this.protocol;
	  delete this.background; // This is not persisted when reconnecting to the web socket server
	  delete this.optimizeHMD;
	  delete this.focusedState;
	  if (this.connected) {
	    this.connected = false;
	    this.emit('disconnect');
	  }
	  return true;
	}

	BaseConnection.prototype.reconnect = function() {
	  if (this.connected) {
	    this.stopReconnection();
	  } else {
	    this.disconnect(true);
	    this.connect();
	  }
	}

	BaseConnection.prototype.handleData = function(data) {
	  var message = JSON.parse(data);

	  var messageEvent;
	  if (this.protocol === undefined) {
	    messageEvent = this.protocol = chooseProtocol(message);
	    this.protocolVersionVerified = true;
	    this.emit('ready');
	  } else {
	    messageEvent = this.protocol(message);
	  }
	  this.emit(messageEvent.type, messageEvent);
	}

	BaseConnection.prototype.connect = function() {
	  if (this.socket) return;
	  this.socket = this.setupSocket();
	  return true;
	}

	BaseConnection.prototype.send = function(data) {
	  this.socket.send(data);
	}

	BaseConnection.prototype.reportFocus = function(state) {
	  if (!this.connected || this.focusedState === state) return;
	  this.focusedState = state;
	  this.emit(this.focusedState ? 'focus' : 'blur');
	  if (this.protocol && this.protocol.sendFocused) {
	    this.protocol.sendFocused(this, this.focusedState);
	  }
	}

	_.extend(BaseConnection.prototype, EventEmitter.prototype);

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var Frame = __webpack_require__(182)
	  , Hand = __webpack_require__(183)
	  , Pointable = __webpack_require__(184)
	  , Finger = __webpack_require__(190)
	  , _ = __webpack_require__(187)
	  , EventEmitter = __webpack_require__(8).EventEmitter;

	var Event = function(data) {
	  this.type = data.type;
	  this.state = data.state;
	};

	exports.chooseProtocol = function(header) {
	  var protocol;
	  switch(header.version) {
	    case 1:
	    case 2:
	    case 3:
	    case 4:
	    case 5:
	    case 6:
	      protocol = JSONProtocol(header);
	      protocol.sendBackground = function(connection, state) {
	        connection.send(protocol.encode({background: state}));
	      }
	      protocol.sendFocused = function(connection, state) {
	        connection.send(protocol.encode({focused: state}));
	      }
	      protocol.sendOptimizeHMD = function(connection, state) {
	        connection.send(protocol.encode({optimizeHMD: state}));
	      }
	      break;
	    default:
	      throw "unrecognized version";
	  }
	  return protocol;
	}

	var JSONProtocol = exports.JSONProtocol = function(header) {

	  var protocol = function(frameData) {

	    if (frameData.event) {

	      return new Event(frameData.event);

	    } else {

	      protocol.emit('beforeFrameCreated', frameData);

	      var frame = new Frame(frameData);

	      protocol.emit('afterFrameCreated', frame, frameData);

	      return frame;

	    }

	  };

	  protocol.encode = function(message) {
	    return JSON.stringify(message);
	  };
	  protocol.version = header.version;
	  protocol.serviceVersion = header.serviceVersion;
	  protocol.versionLong = 'Version ' + header.version;
	  protocol.type = 'protocol';

	  _.extend(protocol, EventEmitter.prototype);

	  return protocol;
	};




/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var WebSocket = __webpack_require__(198)
	  , BaseConnection = __webpack_require__(195)
	  , _ = __webpack_require__(187);

	var NodeConnection = module.exports = function(opts) {
	  BaseConnection.call(this, opts);
	  var connection = this;
	  this.on('ready', function() { connection.reportFocus(true); });
	}

	_.extend(NodeConnection.prototype, BaseConnection.prototype);

	NodeConnection.__proto__ = BaseConnection;

	NodeConnection.prototype.setupSocket = function() {
	  var connection = this;
	  var socket = new WebSocket(this.getUrl());
	  socket.on('open', function() { connection.handleOpen(); });
	  socket.on('message', function(m) { connection.handleData(m); });
	  socket.on('close', function(code, reason) { connection.handleClose(code, reason); });
	  socket.on('error', function() { connection.startReconnection(); });
	  return socket;
	}


/***/ },
/* 198 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/// shim for browser packaging

	module.exports = function() {
	  return global.WebSocket || global.MozWebSocket;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	exports.UI = {
	  Region: __webpack_require__(200),
	  Cursor: __webpack_require__(201)
	};

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var EventEmitter = __webpack_require__(8).EventEmitter
	  , _ = __webpack_require__(187)

	var Region = module.exports = function(start, end) {
	  this.start = new Vector(start)
	  this.end = new Vector(end)
	  this.enteredFrame = null
	}

	Region.prototype.hasPointables = function(frame) {
	  for (var i = 0; i != frame.pointables.length; i++) {
	    var position = frame.pointables[i].tipPosition
	    if (position.x >= this.start.x && position.x <= this.end.x && position.y >= this.start.y && position.y <= this.end.y && position.z >= this.start.z && position.z <= this.end.z) {
	      return true
	    }
	  }
	  return false
	}

	Region.prototype.listener = function(opts) {
	  var region = this
	  if (opts && opts.nearThreshold) this.setupNearRegion(opts.nearThreshold)
	  return function(frame) {
	    return region.updatePosition(frame)
	  }
	}

	Region.prototype.clipper = function() {
	  var region = this
	  return function(frame) {
	    region.updatePosition(frame)
	    return region.enteredFrame ? frame : null
	  }
	}

	Region.prototype.setupNearRegion = function(distance) {
	  var nearRegion = this.nearRegion = new Region(
	    [this.start.x - distance, this.start.y - distance, this.start.z - distance],
	    [this.end.x + distance, this.end.y + distance, this.end.z + distance]
	  )
	  var region = this
	  nearRegion.on("enter", function(frame) {
	    region.emit("near", frame)
	  })
	  nearRegion.on("exit", function(frame) {
	    region.emit("far", frame)
	  })
	  region.on('exit', function(frame) {
	    region.emit("near", frame)
	  })
	}

	Region.prototype.updatePosition = function(frame) {
	  if (this.nearRegion) this.nearRegion.updatePosition(frame)
	  if (this.hasPointables(frame) && this.enteredFrame == null) {
	    this.enteredFrame = frame
	    this.emit("enter", this.enteredFrame)
	  } else if (!this.hasPointables(frame) && this.enteredFrame != null) {
	    this.enteredFrame = null
	    this.emit("exit", this.enteredFrame)
	  }
	  return frame
	}

	Region.prototype.normalize = function(position) {
	  return new Vector([
	    (position.x - this.start.x) / (this.end.x - this.start.x),
	    (position.y - this.start.y) / (this.end.y - this.start.y),
	    (position.z - this.start.z) / (this.end.z - this.start.z)
	  ])
	}

	Region.prototype.mapToXY = function(position, width, height) {
	  var normalized = this.normalize(position)
	  var x = normalized.x, y = normalized.y
	  if (x > 1) x = 1
	  else if (x < -1) x = -1
	  if (y > 1) y = 1
	  else if (y < -1) y = -1
	  return [
	    (x + 1) / 2 * width,
	    (1 - y) / 2 * height,
	    normalized.z
	  ]
	}

	_.extend(Region.prototype, EventEmitter.prototype)

/***/ },
/* 201 */
/***/ function(module, exports) {

	var Cursor = module.exports = function() {
	  return function(frame) {
	    var pointable = frame.pointables.sort(function(a, b) { return a.z - b.z })[0]
	    if (pointable && pointable.valid) {
	      frame.cursorPosition = pointable.tipPosition
	    }
	    return frame
	  }
	}


/***/ },
/* 202 */
/***/ function(module, exports) {

	// This file is automatically updated from package.json by grunt.
	module.exports = {
	  full: '0.6.4',
	  major: 0,
	  minor: 6,
	  dot: 4
	}

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var MqttClient = __webpack_require__(204),
	  url = __webpack_require__(242),
	  xtend = __webpack_require__(247),
	  protocols = {},
	  protocolList = [];

	if ('browser' !== process.title) {
	  protocols.mqtt = __webpack_require__(248);
	  protocols.tcp = __webpack_require__(248);
	  protocols.ssl = __webpack_require__(252);
	  protocols.tls = __webpack_require__(252);
	  protocols.mqtts = __webpack_require__(252);
	}

	protocols.ws = __webpack_require__(253);
	protocols.wss = __webpack_require__(253);

	protocolList = [
	  'mqtt',
	  'mqtts',
	  'ws',
	  'wss'
	];


	/**
	 * Parse the auth attribute and merge username and password in the options object.
	 *
	 * @param {Object} [opts] option object
	 */
	function parseAuthOptions (opts) {
	  var matches;
	  if (opts.auth) {
	    matches = opts.auth.match(/^(.+):(.+)$/);
	    if (matches) {
	      opts.username = matches[1];
	      opts.password = matches[2];
	    } else {
	      opts.username = opts.auth;
	    }
	  }
	}

	/**
	 * connect - connect to an MQTT broker.
	 *
	 * @param {String} [brokerUrl] - url of the broker, optional
	 * @param {Object} opts - see MqttClient#constructor
	 */
	function connect (brokerUrl, opts) {

	  if (('object' === typeof brokerUrl) && !opts) {
	    opts = brokerUrl;
	    brokerUrl = null;
	  }

	  opts = opts || {};

	  if (brokerUrl) {
	    opts = xtend(url.parse(brokerUrl, true), opts);
	    opts.protocol = opts.protocol.replace(/\:$/, '');
	  }

	  // merge in the auth options if supplied
	  parseAuthOptions(opts);

	  // support clientId passed in the query string of the url
	  if (opts.query && 'string' === typeof opts.query.clientId) {
	    opts.clientId = opts.query.clientId;
	  }

	  if (opts.cert && opts.key) {
	    if (opts.protocol) {
	      if (-1 === ['mqtts', 'wss'].indexOf(opts.protocol)) {
	        /*
	         * jshint and eslint
	         * complains that break from default cannot be reached after throw
	         * it is a foced exit from a control structure
	         * maybe add a check after switch to see if it went through default
	         * and then throw the error
	        */
	        /*jshint -W027*/
	        /*eslint no-unreachable:1*/
	        switch (opts.protocol) {
	          case 'mqtt':
	            opts.protocol = 'mqtts';
	            break;
	          case 'ws':
	            opts.protocol = 'wss';
	            break;
	          default:
	            throw new Error('Unknown protocol for secure conenction: "' + opts.protocol + '"!');
	            break;
	        }
	        /*eslint no-unreachable:0*/
	        /*jshint +W027*/
	      }
	    } else {
	      // don't know what protocol he want to use, mqtts or wss
	      throw new Error('Missing secure protocol key');
	    }
	  }

	  if (!protocols[opts.protocol]) {
	    opts.protocol = protocolList.filter(function (key) {
	      return 'function' === typeof protocols[key];
	    })[0];
	  }

	  if (false === opts.clean && !opts.clientId) {
	    throw new Error('Missing clientId for unclean clients');
	  }


	  function wrapper (client) {
	    if (opts.servers) {
	      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {
	        client._reconnectCount = 0;
	      }

	      opts.host = opts.servers[client._reconnectCount].host;
	      opts.port = opts.servers[client._reconnectCount].port;

	      client._reconnectCount++;
	    }

	    return protocols[opts.protocol](client, opts);
	  }

	  return new MqttClient(wrapper, opts);
	}

	module.exports = connect;
	module.exports.connect = connect;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';
	/**
	 * Module dependencies
	 */
	/*global setImmediate:true*/
	var events = __webpack_require__(8),
	  Store = __webpack_require__(205),
	  eos = __webpack_require__(232),
	  mqttPacket = __webpack_require__(235),
	  Writable = __webpack_require__(206).Writable,
	  inherits = __webpack_require__(226),
	  setImmediate = global.setImmediate || function (callback) {
	    // works in node v0.8
	    process.nextTick(callback);
	  },
	  defaultConnectOptions = {
	    keepalive: 10,
	    protocolId: 'MQTT',
	    protocolVersion: 4,
	    reconnectPeriod: 1000,
	    connectTimeout: 30 * 1000,
	    clean: true
	  };

	function defaultId () {
	  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);
	}

	function sendPacket (client, packet, cb) {
	  try {
	    var buf = mqttPacket.generate(packet);
	    if (!client.stream.write(buf) && cb) {
	      client.stream.once('drain', cb);
	    } else if (cb) {
	      cb();
	    }
	  } catch (err) {
	    if (cb) {
	      cb(err);
	    } else {
	      client.emit('error', err);
	    }
	  }
	}

	function storeAndSend (client, packet, cb) {
	  client.outgoingStore.put(packet, function storedPacket (err) {
	    if (err) {
	      return cb && cb(err);
	    }
	    sendPacket(client, packet, cb);
	  });
	}

	function nop () {}

	/**
	 * MqttClient constructor
	 *
	 * @param {Stream} stream - stream
	 * @param {Object} [options] - connection options
	 * (see Connection#connect)
	 */
	function MqttClient (streamBuilder, options) {
	  var k,
	    that = this;

	  if (!(this instanceof MqttClient)) {
	    return new MqttClient(streamBuilder, options);
	  }

	  this.options = options || {};

	  // Defaults
	  for (k in defaultConnectOptions) {
	    if ('undefined' === typeof this.options[k]) {
	      this.options[k] = defaultConnectOptions[k];
	    } else {
	      this.options[k] = options[k];
	    }
	  }

	  this.options.clientId = this.options.clientId || defaultId();

	  this.streamBuilder = streamBuilder;

	  // Inflight message storages
	  this.outgoingStore = this.options.outgoingStore || new Store();
	  this.incomingStore = this.options.incomingStore || new Store();

	  // Ping timer, setup in _setupPingTimer
	  this.pingTimer = null;
	  // Is the client connected?
	  this.connected = false;
	  // Are we disconnecting?
	  this.disconnecting = false;
	  // Packet queue
	  this.queue = [];
	  // Are we intentionally disconnecting?
	  this.disconnecting = false;
	  // connack timer
	  this.connackTimer = null;
	  // Reconnect timer
	  this.reconnectTimer = null;
	  // MessageIDs starting with 1
	  this.nextId = Math.floor(Math.random() * 65535);

	  // Inflight callbacks
	  this.outgoing = {};

	  // Mark connected on connect
	  this.on('connect', function () {
	    this.connected = true;
	    var outStore = null;
	    outStore = this.outgoingStore.createStream();

	    // Control of stored messages
	    outStore.once('readable', function () {
	      function storeDeliver () {
	        var packet = outStore.read(1);
	        if (!packet) {
	          return;
	        }
	        // Avoid unnecesary stream read operations when disconnected
	        if (!that.disconnecting && !that.reconnectTimer && (0 < that.options.reconnectPeriod)) {
	          outStore.read(0);
	          // Ensure that the next message will only be read after callback is issued
	          that.outgoing[packet.messageId] = storeDeliver;
	          that._sendPacket(packet);
	        } else if (outStore.destroy) {
	          outStore.destroy();
	        }
	      }
	      storeDeliver();
	    })
	    .on('error', this.emit.bind(this, 'error'));
	  });

	  // Mark disconnected on stream close
	  this.on('close', function () {
	    this.connected = false;
	  });

	  // Setup ping timer
	  this.on('connect', this._setupPingTimer);

	  // Send queued packets
	  this.on('connect', function () {
	    var queue = this.queue;

	    function deliver () {
	      var entry = queue.shift(),
	        packet = null;

	      if (!entry) {
	        return;
	      }

	      packet = entry.packet;

	      that._sendPacket(
	        packet,
	        function (err) {
	          if (entry.cb) {
	            entry.cb(err);
	          }
	          deliver();
	        }
	      );
	    }

	    deliver();
	  });


	  // Clear ping timer
	  this.on('close', function () {
	    if (null !== that.pingTimer) {
	      clearInterval(that.pingTimer);
	      that.pingTimer = null;
	    }
	  });

	  // Setup reconnect timer on disconnect
	  this.on('close', this._setupReconnect);

	  events.EventEmitter.call(this);

	  this._setupStream();
	}
	inherits(MqttClient, events.EventEmitter);

	/**
	 * setup the event handlers in the inner stream.
	 *
	 * @api private
	 */
	MqttClient.prototype._setupStream = function () {
	  var connectPacket,
	    that = this,
	    writable = new Writable(),
	    parser = mqttPacket.parser(this.options),
	    completeParse = null,
	    packets = [];

	  this._clearReconnect();

	  this.stream = this.streamBuilder(this);

	  parser.on('packet', function (packet) {
	    packets.push(packet);
	  });

	  function process () {
	    var packet = packets.shift(),
	      done = completeParse;
	    if (packet) {
	      that._handlePacket(packet, process);
	    } else {
	      completeParse = null;
	      done();
	    }
	  }

	  writable._write = function (buf, enc, done) {
	    completeParse = done;
	    parser.parse(buf);
	    process();
	  };

	  this.stream.pipe(writable);

	  // Suppress connection errors
	  this.stream.on('error', nop);

	  // Echo stream close
	  eos(this.stream, this.emit.bind(this, 'close'));

	  // Send a connect packet
	  connectPacket = Object.create(this.options);
	  connectPacket.cmd = 'connect';
	  // avoid message queue
	  sendPacket(this, connectPacket);

	  // Echo connection errors
	  parser.on('error', this.emit.bind(this, 'error'));

	  clearTimeout(this.connackTimer);
	  this.connackTimer = setTimeout(function () {
	    that._cleanUp(true);
	  }, this.options.connectTimeout);
	};

	MqttClient.prototype._handlePacket = function (packet, done) {
	  switch (packet.cmd) {
	    case 'publish':
	      this._handlePublish(packet, done);
	      break;
	    case 'puback':
	    case 'pubrec':
	    case 'pubcomp':
	    case 'suback':
	    case 'unsuback':
	      this._handleAck(packet);
	      done();
	      break;
	    case 'pubrel':
	      this._handlePubrel(packet, done);
	      break;
	    case 'connack':
	      this._handleConnack(packet);
	      done();
	      break;
	    case 'pingresp':
	      this._handlePingresp(packet);
	      done();
	      break;
	    default:
	      // do nothing
	      // maybe we should do an error handling
	      // or just log it
	      break;
	  }
	};

	MqttClient.prototype._checkDisconnecting = function (callback) {
	  if (this.disconnecting) {
	    if (callback) {
	      callback(new Error('client disconnecting'));
	    } else {
	      this.emit(new Error('client disconnecting'));
	    }
	  }
	  return this.disconnecting;
	};

	/**
	 * publish - publish <message> to <topic>
	 *
	 * @param {String} topic - topic to publish to
	 * @param {String, Buffer} message - message to publish
	 * @param {Object} [opts] - publish options, includes:
	 *    {Number} qos - qos level to publish on
	 *    {Boolean} retain - whether or not to retain the message
	 * @param {Function} [callback] - function(err){}
	 *    called when publish succeeds or fails
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 *
	 * @example client.publish('topic', 'message');
	 * @example
	 *     client.publish('topic', 'message', {qos: 1, retain: true});
	 * @example client.publish('topic', 'message', console.log);
	 */
	MqttClient.prototype.publish = function (topic, message, opts, callback) {
	  var packet;

	  // .publish(topic, payload, cb);
	  if ('function' === typeof opts) {
	    callback = opts;
	    opts = null;
	  }

	  // Default opts
	  if (!opts) {
	    opts = {qos: 0, retain: false};
	  }

	  if (this._checkDisconnecting(callback)) {
	    return this;
	  }

	  callback = callback || nop;

	  packet = {
	    cmd: 'publish',
	    topic: topic,
	    payload: message,
	    qos: opts.qos,
	    retain: opts.retain,
	    messageId: this._nextId()
	  };

	  switch (opts.qos) {
	    case 1:
	    case 2:
	      // Add to callbacks
	      this.outgoing[packet.messageId] = callback;
	      this._sendPacket(packet);
	      break;
	    default:
	      this._sendPacket(packet, callback);
	      break;
	  }

	  return this;
	};

	/**
	 * subscribe - subscribe to <topic>
	 *
	 * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}
	 * @param {Object} [opts] - optional subscription options, includes:
	 *    {Number} qos - subscribe qos level
	 * @param {Function} [callback] - function(err, granted){} where:
	 *    {Error} err - subscription error (none at the moment!)
	 *    {Array} granted - array of {topic: 't', qos: 0}
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 * @example client.subscribe('topic');
	 * @example client.subscribe('topic', {qos: 1});
	 * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);
	 * @example client.subscribe('topic', console.log);
	 */
	MqttClient.prototype.subscribe = function () {
	  var packet,
	    args = Array.prototype.slice.call(arguments),
	    subs = [],
	    obj = args.shift(),
	    callback = args.pop() || nop,
	    opts = args.pop();

	  if ('string' === typeof obj) {
	    obj = [obj];
	  }

	  if (this._checkDisconnecting(callback)) {
	    return this;
	  }

	  if ('function' !== typeof callback) {
	    opts = callback;
	    callback = nop;
	  }

	  if (!opts) {
	    opts = { qos: 0 };
	  }

	  if (Array.isArray(obj)) {
	    obj.forEach(function (topic) {
	      subs.push({
	        topic: topic,
	        qos: opts.qos
	      });
	    });
	  } else {
	    Object
	      .keys(obj)
	      .forEach(function (k) {
	        subs.push({
	          topic: k,
	          qos: obj[k]
	        });
	      });
	  }

	  packet = {
	    cmd: 'subscribe',
	    subscriptions: subs,
	    qos: 1,
	    retain: false,
	    dup: false,
	    messageId: this._nextId()
	  };

	  this.outgoing[packet.messageId] = callback;

	  this._sendPacket(packet);

	  return this;
	};

	/**
	 * unsubscribe - unsubscribe from topic(s)
	 *
	 * @param {String, Array} topic - topics to unsubscribe from
	 * @param {Function} [callback] - callback fired on unsuback
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 * @example client.unsubscribe('topic');
	 * @example client.unsubscribe('topic', console.log);
	 */
	MqttClient.prototype.unsubscribe = function (topic, callback) {
	  var packet = {
	    cmd: 'unsubscribe',
	    qos: 1,
	    messageId: this._nextId()
	  };

	  callback = callback || nop;

	  if (this._checkDisconnecting(callback)) {
	    return this;
	  }

	  if ('string' === typeof topic) {
	    packet.unsubscriptions = [topic];
	  } else if ('object' === typeof topic && topic.length) {
	    packet.unsubscriptions = topic;
	  }

	  this.outgoing[packet.messageId] = callback;

	  this._sendPacket(packet);

	  return this;
	};

	/**
	 * end - close connection
	 *
	 * @returns {MqttClient} this - for chaining
	 * @param {Boolean} force - do not wait for all in-flight messages to be acked
	 * @param {Function} cb - called when the client has been closed
	 *
	 * @api public
	 */
	MqttClient.prototype.end = function (force, cb) {
	  var that = this;

	  if ('function' === typeof force) {
	    cb = force;
	    force = false;
	  }

	  function closeStores () {
	    that.incomingStore.close(function () {
	      that.outgoingStore.close(cb);
	    });
	  }

	  function finish () {
	    that._cleanUp(force, closeStores);
	  }

	  if (this.disconnecting) {
	    return true;
	  }

	  this.disconnecting = true;

	  if (!force && 0 < Object.keys(this.outgoing).length) {
	    // wait 10ms, just to be sure we received all of it
	    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));
	  } else {
	    finish();
	  }

	  return this;
	};

	/**
	 * _reconnect - implement reconnection
	 * @api privateish
	 */
	MqttClient.prototype._reconnect = function () {
	  this.emit('reconnect');
	  this._setupStream();
	};

	/**
	 * _setupReconnect - setup reconnect timer
	 */
	MqttClient.prototype._setupReconnect = function () {
	  var that = this;

	  if (!that.disconnecting && !that.reconnectTimer && (0 < that.options.reconnectPeriod)) {
	    this.emit('offline');
	    that.reconnectTimer = setInterval(function () {
	      that._reconnect();
	    }, that.options.reconnectPeriod);
	  }
	};

	/**
	 * _clearReconnect - clear the reconnect timer
	 */
	MqttClient.prototype._clearReconnect = function () {
	  if (this.reconnectTimer) {
	    clearInterval(this.reconnectTimer);
	    this.reconnectTimer = false;
	  }
	};


	/**
	 * _cleanUp - clean up on connection end
	 * @api private
	 */
	MqttClient.prototype._cleanUp = function (forced, done) {
	  if (done) {
	    this.stream.on('close', done);
	  }

	  if (forced) {
	    this.stream.destroy();
	  } else {
	    this._sendPacket(
	      { cmd: 'disconnect' },
	      setImmediate.bind(
	        null,
	        this.stream.end.bind(this.stream)
	      )
	    );
	  }

	  this._clearReconnect();

	  if (null !== this.pingTimer) {
	    clearInterval(this.pingTimer);
	    this.pingTimer = null;
	  }
	};

	/**
	 * _sendPacket - send or queue a packet
	 * @param {String} type - packet type (see `protocol`)
	 * @param {Object} packet - packet options
	 * @param {Function} cb - callback when the packet is sent
	 * @api private
	 */
	MqttClient.prototype._sendPacket = function (packet, cb) {
	  if (!this.connected) {
	    return this.queue.push({ packet: packet, cb: cb });
	  }

	  switch (packet.qos) {
	    case 2:
	    case 1:
	      storeAndSend(this, packet, cb);
	      break;
	    /**
	     * no need of case here since it will be caught by default
	     * and jshint comply that before default it must be a break
	     * anyway it will result in -1 evaluation
	     */
	    case 0:
	      /* falls through */
	    default:
	      sendPacket(this, packet, cb);
	      break;
	  }
	};

	/**
	 * _setupPingTimer - setup the ping timer
	 *
	 * @api private
	 */
	MqttClient.prototype._setupPingTimer = function () {
	  var that = this;

	  if (!this.pingTimer && this.options.keepalive) {
	    this.pingResp = true;
	    this.pingTimer = setInterval(function () {
	      that._checkPing();
	    }, this.options.keepalive * 1000);
	  }
	};

	/**
	 * _checkPing - check if a pingresp has come back, and ping the server again
	 *
	 * @api private
	 */
	MqttClient.prototype._checkPing = function () {
	  if (this.pingResp) {
	    this.pingResp = false;
	    this._sendPacket({ cmd: 'pingreq' });
	  } else {
	    // do a forced cleanup since socket will be in bad shape
	    this._cleanUp(true);
	  }
	};

	/**
	 * _handlePingresp - handle a pingresp
	 *
	 * @api private
	 */
	MqttClient.prototype._handlePingresp = function () {
	  this.pingResp = true;
	};

	/**
	 * _handleConnack
	 *
	 * @param {Object} packet
	 * @api private
	 */

	MqttClient.prototype._handleConnack = function (packet) {
	  var rc = packet.returnCode,
	    // TODO: move to protocol
	    errors = [
	      '',
	      'Unacceptable protocol version',
	      'Identifier rejected',
	      'Server unavailable',
	      'Bad username or password',
	      'Not authorized'
	    ];

	  clearTimeout(this.connackTimer);

	  if (0 === rc) {
	    this.emit('connect');
	  } else if (0 < rc) {
	    this.emit('error',
	        new Error('Connection refused: ' + errors[rc]));
	  }
	};

	/**
	 * _handlePublish
	 *
	 * @param {Object} packet
	 * @api private
	 */
	/*
	those late 2 case should be rewrite to comply with coding style:

	case 1:
	case 0:
	  // do not wait sending a puback
	  // no callback passed
	  if (1 === qos) {
	    this._sendPacket({
	      cmd: 'puback',
	      messageId: mid
	    });
	  }
	  // emit the message event for both qos 1 and 0
	  this.emit('message', topic, message, packet);
	  this.handleMessage(packet, done);
	  break;
	default:
	  // do nothing but every switch mus have a default
	  // log or throw an error about unknown qos
	  break;

	for now i just suppressed the warnings
	*/
	MqttClient.prototype._handlePublish = function (packet, done) {
	  var topic = packet.topic.toString(),
	    message = packet.payload,
	    qos = packet.qos,
	    mid = packet.messageId,
	    that = this;

	  switch (qos) {
	    case 2:
	      this.incomingStore.put(packet, function () {
	        that._sendPacket({cmd: 'pubrec', messageId: mid}, done);
	      });
	      break;
	    case 1:
	      // do not wait sending a puback
	      // no callback passed
	      this._sendPacket({
	        cmd: 'puback',
	        messageId: mid
	      });
	      /* falls through */
	    case 0:
	      // emit the message event for both qos 1 and 0
	      this.emit('message', topic, message, packet);
	      this.handleMessage(packet, done);
	      break;
	    default:
	      // do nothing
	      // log or throw an error about unknown qos
	      break;
	  }
	};

	/**
	 * Handle messages with backpressure support, one at a time.
	 * Override at will.
	 *
	 * @param Packet packet the packet
	 * @param Function callback call when finished
	 * @api public
	 */
	MqttClient.prototype.handleMessage = function (packet, callback) {
	  callback();
	};

	/**
	 * _handleAck
	 *
	 * @param {Object} packet
	 * @api private
	 */

	MqttClient.prototype._handleAck = function (packet) {
	  var mid = packet.messageId,
	    type = packet.cmd,
	    response = null,
	    cb = this.outgoing[mid],
	    that = this;

	  if (!cb) {
	    // Server sent an ack in error, ignore it.
	    return;
	  }

	  // Process
	  switch (type) {
	    case 'pubcomp':
	      // same thing as puback for QoS 2
	    case 'puback':
	      // Callback - we're done
	      delete this.outgoing[mid];
	      this.outgoingStore.del(packet, cb);
	      break;
	    case 'pubrec':
	      response = {
	        cmd: 'pubrel',
	        qos: 2,
	        messageId: mid
	      };

	      this._sendPacket(response);
	      break;
	    case 'suback':
	      delete this.outgoing[mid];
	      this.outgoingStore.del(packet, function (err, original) {
	        var i,
	          origSubs = original.subscriptions,
	          granted = packet.granted;

	        if (err) {
	          // missing packet, what should we do?
	          return that.emit('error', err);
	        }

	        for (i = 0; i < granted.length; i += 1) {
	          origSubs[i].qos = granted[i];
	        }

	        cb(null, origSubs);
	      });
	      break;
	    case 'unsuback':
	      delete this.outgoing[mid];
	      this.outgoingStore.del(packet, cb);
	      break;
	    default:
	      that.emit('error', new Error('unrecognized packet type'));
	  }

	  if (this.disconnecting &&
	      0 === Object.keys(this.outgoing).length) {
	    this.emit('outgoingEmpty');
	  }
	};

	/**
	 * _handlePubrel
	 *
	 * @param {Object} packet
	 * @api private
	 */

	MqttClient.prototype._handlePubrel = function (packet, callback) {
	  var mid = packet.messageId,
	    that = this;

	  that.incomingStore.get(packet, function (err, pub) {
	    if (err) {
	      return that.emit('error', err);
	    }

	    if ('pubrel' !== pub.cmd) {
	      that.emit('message', pub.topic, pub.payload, pub);
	      that.incomingStore.put(packet);
	    }

	    that._sendPacket({cmd: 'pubcomp', messageId: mid}, callback);
	  });
	};

	/**
	 * _nextId
	 */
	MqttClient.prototype._nextId = function () {
	  var id = this.nextId++;
	  // Ensure 16 bit unsigned int:
	  if (65535 === id) {
	    this.nextId = 1;
	  }
	  return id;
	};

	module.exports = MqttClient;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var Readable = __webpack_require__(206).Readable,
	  streamsOpts = { objectMode: true };

	/**
	 * In-memory implementation of the message store
	 * This can actually be saved into files.
	 *
	 */
	function Store () {
	  if (!(this instanceof Store)) {
	    return new Store();
	  }

	  this._inflights = {};
	}

	/**
	 * Adds a packet to the store, a packet is
	 * anything that has a messageId property.
	 *
	 */
	Store.prototype.put = function (packet, cb) {
	  this._inflights[packet.messageId] = packet;

	  if (cb) {
	    cb();
	  }

	  return this;
	};

	/**
	 * Creates a stream with all the packets in the store
	 *
	 */
	Store.prototype.createStream = function () {
	  var stream = new Readable(streamsOpts),
	    inflights = this._inflights,
	    ids = Object.keys(this._inflights),
	    destroyed = false,
	    i = 0;

	  stream._read = function () {
	    if (!destroyed && i < ids.length) {
	      this.push(inflights[ids[i++]]);
	    } else {
	      this.push(null);
	    }
	  };

	  stream.destroy = function () {
	    if (destroyed) {
	      return;
	    }

	    var self = this;

	    destroyed = true;

	    process.nextTick(function () {
	      self.emit('close');
	    });
	  };

	  return stream;
	};

	/**
	 * deletes a packet from the store.
	 */
	Store.prototype.del = function (packet, cb) {
	  packet = this._inflights[packet.messageId];
	  if (packet) {
	    delete this._inflights[packet.messageId];
	    cb(null, packet);
	  } else if (cb) {
	    cb(new Error('missing packet'));
	  }

	  return this;
	};

	/**
	 * get a packet from the store.
	 */
	Store.prototype.get = function (packet, cb) {
	  packet = this._inflights[packet.messageId];
	  if (packet) {
	    cb(null, packet);
	  } else if (cb) {
	    cb(new Error('missing packet'));
	  }

	  return this;
	};

	/**
	 * Close the store
	 */
	Store.prototype.close = function (cb) {
	  this._inflights = null;
	  if (cb) {
	    cb();
	  }
	};

	module.exports = Store;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(207); // hack to fix a circular dependency issue when used with browserify
	exports = module.exports = __webpack_require__(223);
	exports.Stream = Stream;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(228);
	exports.Duplex = __webpack_require__(229);
	exports.Transform = __webpack_require__(230);
	exports.PassThrough = __webpack_require__(231);


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(8).EventEmitter;
	var inherits = __webpack_require__(208);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(209);
	Stream.Writable = __webpack_require__(219);
	Stream.Duplex = __webpack_require__(220);
	Stream.Transform = __webpack_require__(221);
	Stream.PassThrough = __webpack_require__(222);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 208 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(210);
	exports.Stream = __webpack_require__(207);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(216);
	exports.Duplex = __webpack_require__(215);
	exports.Transform = __webpack_require__(217);
	exports.PassThrough = __webpack_require__(218);


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(211);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(8).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(207);

	/*<replacement>*/
	var util = __webpack_require__(212);
	util.inherits = __webpack_require__(213);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(214);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(215);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(10).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(215);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(10).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 213 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 214 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(212);
	util.inherits = __webpack_require__(213);
	/*</replacement>*/

	var Readable = __webpack_require__(210);
	var Writable = __webpack_require__(216);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(212);
	util.inherits = __webpack_require__(213);
	/*</replacement>*/

	var Stream = __webpack_require__(207);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(215);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(215);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(215);

	/*<replacement>*/
	var util = __webpack_require__(212);
	util.inherits = __webpack_require__(213);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(217);

	/*<replacement>*/
	var util = __webpack_require__(212);
	util.inherits = __webpack_require__(213);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(216)


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(215)


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(217)


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(218)


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(224);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(8).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(207);

	/*<replacement>*/
	var util = __webpack_require__(225);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(227).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }

	      if (state.needReadable)
	        emitReadable(stream);

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(227).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;

	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }

	    if (state.length === 0)
	      endReadable(this);

	    return ret;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;

	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;

	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}

	function emitReadable_(stream) {
	  stream.emit('readable');
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }

	  function onend() {
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);

	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}

	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;

	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }

	  while (state.pipesCount && null !== (chunk = src.read())) {

	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);

	    src.emit('data', chunk);

	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }

	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;

	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }

	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}

	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};

	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};

	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;

	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }

	  var paused = startPaused || false;
	  var readable = false;

	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;

	  stream.on('readable', function() {
	    readable = true;

	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);

	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });

	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };

	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };

	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 224 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 226 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(2).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(225);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	var Stream = __webpack_require__(207);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(229);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);

	  return ret;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;

	    doWrite(stream, state, len, chunk, encoding, cb);

	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }

	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(225);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	var Readable = __webpack_require__(223);
	var Writable = __webpack_require__(228);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(229);

	/*<replacement>*/
	var util = __webpack_require__(225);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  var ts = this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(230);

	/*<replacement>*/
	var util = __webpack_require__(225);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var once = __webpack_require__(233);

	var noop = function() {};

	var isRequest = function(stream) {
		return stream.setHeader && typeof stream.abort === 'function';
	};

	var isChildProcess = function(stream) {
		return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
	};

	var eos = function(stream, opts, callback) {
		if (typeof opts === 'function') return eos(stream, null, opts);
		if (!opts) opts = {};

		callback = once(callback || noop);

		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || (opts.readable !== false && stream.readable);
		var writable = opts.writable || (opts.writable !== false && stream.writable);

		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};

		var onfinish = function() {
			writable = false;
			if (!readable) callback();
		};

		var onend = function() {
			readable = false;
			if (!writable) callback();
		};

		var onexit = function(exitCode) {
			callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
		};

		var onclose = function() {
			if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
			if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
		};

		var onrequest = function() {
			stream.req.on('finish', onfinish);
		};

		if (isRequest(stream)) {
			stream.on('complete', onfinish);
			stream.on('abort', onclose);
			if (stream.req) onrequest();
			else stream.on('request', onrequest);
		} else if (writable && !ws) { // legacy streams
			stream.on('end', onlegacyfinish);
			stream.on('close', onlegacyfinish);
		}

		if (isChildProcess(stream)) stream.on('exit', onexit);

		stream.on('end', onend);
		stream.on('finish', onfinish);
		if (opts.error !== false) stream.on('error', callback);
		stream.on('close', onclose);

		return function() {
			stream.removeListener('complete', onfinish);
			stream.removeListener('abort', onclose);
			stream.removeListener('request', onrequest);
			if (stream.req) stream.req.removeListener('finish', onfinish);
			stream.removeListener('end', onlegacyfinish);
			stream.removeListener('close', onlegacyfinish);
			stream.removeListener('finish', onfinish);
			stream.removeListener('exit', onexit);
			stream.removeListener('end', onend);
			stream.removeListener('error', callback);
			stream.removeListener('close', onclose);
		};
	};

	module.exports = eos;

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(234)
	module.exports = wrappy(once)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}


/***/ },
/* 234 */
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	
	'use strict';

	exports.parser          = __webpack_require__(236)
	exports.generate        = __webpack_require__(241)


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	
	var bl        = __webpack_require__(237)
	  , inherits  = __webpack_require__(226)
	  , EE        = __webpack_require__(8).EventEmitter
	  , Packet    = __webpack_require__(239)
	  , constants = __webpack_require__(240)

	function Parser() {
	  if (!(this instanceof Parser)) {
	    return new Parser()
	  }

	  this._list = bl()
	  this._newPacket()

	  this._states = [
	      '_parseHeader'
	    , '_parseLength'
	    , '_parsePayload'
	    , '_newPacket'
	  ]
	  this._stateCounter = 0
	}

	inherits(Parser, EE)

	Parser.prototype._newPacket = function () {
	  if (this.packet) {
	    this._list.consume(this.packet.length)
	    this.emit('packet', this.packet)
	  }

	  this.packet = new Packet()

	  return true
	}

	Parser.prototype.parse = function (buf) {
	  this._list.append(buf)

	  while ((this.packet.length != -1 || this._list.length > 0) &&
	         this[this._states[this._stateCounter]]()) {
	    this._stateCounter++

	    if (this._stateCounter >= this._states.length) {
	      this._stateCounter = 0
	    }
	  }

	  return this._list.length
	}

	Parser.prototype._parseHeader = function () {

	  // there is at least one byte in the buffer
	  var zero = this._list.readUInt8(0)
	  this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]
	  this.packet.retain = (zero & constants.RETAIN_MASK) !== 0
	  this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK
	  this.packet.dup = (zero & constants.DUP_MASK) !== 0

	  this._list.consume(1)

	  return true
	}


	Parser.prototype._parseLength = function () {
	  // there is at least one byte in the list
	  var bytes    = 0
	    , mul      = 1
	    , length   = 0
	    , result   = true
	    , current

	  while (bytes < 5) {
	    current = this._list.readUInt8(bytes++)
	    length += mul * (current & constants.LENGTH_MASK)
	    mul *= 0x80

	    if ((current & constants.LENGTH_FIN_MASK) === 0) {
	      break
	    }

	    if (this._list.length <= bytes) {
	      result = false
	      break
	    }
	  }

	  if (result) {
	    this.packet.length = length
	    this._list.consume(bytes)
	  }

	  return result
	}

	Parser.prototype._parsePayload = function () {
	  var result = false

	  // Do we have a payload? Do we have enough data to complete the payload?
	  // PINGs have no payload
	  if (this.packet.length === 0 || this._list.length >= this.packet.length) {

	    this._pos = 0

	    switch (this.packet.cmd) {
	      case 'connect':
	        this._parseConnect()
	        break
	      case 'connack':
	        this._parseConnack()
	        break
	      case 'publish':
	        this._parsePublish()
	        break
	      case 'puback':
	      case 'pubrec':
	      case 'pubrel':
	      case 'pubcomp':
	        this._parseMessageId()
	        break
	      case 'subscribe':
	        this._parseSubscribe()
	        break
	      case 'suback':
	        this._parseSuback()
	        break
	      case 'unsubscribe':
	        this._parseUnsubscribe()
	        break
	      case 'unsuback':
	        this._parseUnsuback()
	        break
	      case 'pingreq':
	      case 'pingresp':
	      case 'disconnect':
	        // these are empty, nothing to do
	        break
	      default:
	        this.emit('error', new Error('not supported'))
	    }

	    result = true
	  }

	  return result
	}

	Parser.prototype._parseConnect = function () {
	  var protocolId // constants id
	    , clientId // Client id
	    , topic // Will topic
	    , payload // Will payload
	    , password // Password
	    , username // Username
	    , flags = {}
	    , packet = this.packet

	  // Parse constants id
	  protocolId = this._parseString()
	  if (protocolId === null)
	    return this.emit('error', new Error('cannot parse protocol id'))

	  packet.protocolId = protocolId

	  // Parse constants version number
	  if(this._pos > this._list.length)
	    return this.emit('error', new Error('packet too short'))

	  packet.protocolVersion = this._list.readUInt8(this._pos)
	  this._pos++

	  // Parse connect flags
	  flags.username  = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)
	  flags.password  = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)
	  flags.will      = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)

	  if (flags.will) {
	    packet.will         = {}
	    packet.will.retain  = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0
	    packet.will.qos     = (this._list.readUInt8(this._pos) &
	                          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT
	  }

	  packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0
	  this._pos++

	  // Parse keepalive
	  packet.keepalive = this._parseNum()
	  if(packet.keepalive === -1)
	    return this.emit('error', new Error('packet too short'))

	  // Parse client ID
	  clientId = this._parseString()
	  if(clientId === null)
	    return this.emit('error', new Error('packet too short'))
	  packet.clientId = clientId

	  if (flags.will) {
	    // Parse will topic
	    topic = this._parseString()
	    if (topic === null)
	      return this.emit('error', new Error('cannot parse will topic'))
	    packet.will.topic = topic

	    // Parse will payload
	    payload = this._parseBuffer()
	    if (payload === null)
	      return this.emit('error', new Error('cannot parse will payload'))
	    packet.will.payload = payload
	  }

	  // Parse username
	  if (flags.username) {
	    username = this._parseString()
	    if(username === null)
	      return this.emit('error', new Error('cannot parse username'))
	    packet.username = username
	  }

	  // Parse password
	  if(flags.password) {
	    password = this._parseBuffer()
	    if(password === null)
	      return this.emit('error', new Error('cannot parse username'))
	    packet.password = password
	  }

	  return packet
	}

	Parser.prototype._parseConnack = function () {
	  var packet = this.packet
	  packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)
	  packet.returnCode = this._list.readUInt8(this._pos)
	  if(packet.returnCode === -1)
	    return this.emit('error', new Error('cannot parse return code'))
	}

	Parser.prototype._parsePublish = function () {
	  var packet = this.packet
	  packet.topic = this._parseString()

	  if(packet.topic === null)
	    return this.emit('error', new Error('cannot parse topic'))

	  // Parse message ID
	  if (packet.qos > 0) {
	    if (!this._parseMessageId()) { return }
	  }

	  packet.payload = this._list.slice(this._pos, packet.length)
	}

	Parser.prototype._parseSubscribe = function() {
	  var packet = this.packet
	    , topic
	    , qos

	  if (packet.qos != 1) {
	    return this.emit('error', new Error('wrong subscribe header'))
	  }

	  packet.subscriptions = []

	  if (!this._parseMessageId()) { return }

	  while (this._pos < packet.length) {

	    // Parse topic
	    topic = this._parseString()
	    if (topic === null)
	      return this.emit('error', new Error('Parse error - cannot parse topic'))

	    qos = this._list.readUInt8(this._pos++)

	    // Push pair to subscriptions
	    packet.subscriptions.push({ topic: topic, qos: qos });
	  }
	}

	Parser.prototype._parseSuback = function() {
	  this.packet.granted = []

	  if (!this._parseMessageId()) { return }

	  // Parse granted QoSes
	  while (this._pos < this.packet.length) {
	    this.packet.granted.push(this._list.readUInt8(this._pos++));
	  }
	}

	Parser.prototype._parseUnsubscribe = function() {
	  var packet = this.packet

	  packet.unsubscriptions = []

	  // Parse message ID
	  if (!this._parseMessageId()) { return }

	  while (this._pos < packet.length) {
	    var topic;

	    // Parse topic
	    topic = this._parseString()
	    if (topic === null)
	      return this.emit('error', new Error('cannot parse topic'))

	    // Push topic to unsubscriptions
	    packet.unsubscriptions.push(topic);
	  }
	}

	Parser.prototype._parseUnsuback = function() {
	  if (!this._parseMessageId())
	    return this.emit('error', new Error('cannot parse message id'))
	}

	Parser.prototype._parseMessageId = function() {
	  var packet = this.packet

	  packet.messageId = this._parseNum()

	  if(packet.messageId === null) {
	    this.emit('error', new Error('cannot parse message id'))
	    return false
	  }

	  return true
	}

	Parser.prototype._parseString = function(maybeBuffer) {
	  var length = this._parseNum()
	    , result

	  if(length === -1 || length + this._pos > this._list.length)
	    return null

	  result = this._list.toString('utf8', this._pos, this._pos + length)

	  this._pos += length

	  return result
	}

	Parser.prototype._parseBuffer = function() {
	  var length = this._parseNum()
	    , result

	  if(length === -1 || length + this._pos > this._list.length)
	    return null

	  result = this._list.slice(this._pos, this._pos + length)

	  this._pos += length

	  return result
	}

	Parser.prototype._parseNum = function() {
	  if(2 > this._pos + this._list.length) return -1

	  var result = this._list.readUInt16BE(this._pos)
	  this._pos += 2
	  return result
	}

	module.exports = Parser


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var DuplexStream = __webpack_require__(238)
	  , util         = __webpack_require__(12)

	function BufferList (callback) {
	  if (!(this instanceof BufferList))
	    return new BufferList(callback)

	  this._bufs  = []
	  this.length = 0

	  if (typeof callback == 'function') {
	    this._callback = callback

	    var piper = function (err) {
	      if (this._callback) {
	        this._callback(err)
	        this._callback = null
	      }
	    }.bind(this)

	    this.on('pipe', function (src) {
	      src.on('error', piper)
	    })
	    this.on('unpipe', function (src) {
	      src.removeListener('error', piper)
	    })
	  }
	  else if (Buffer.isBuffer(callback))
	    this.append(callback)
	  else if (Array.isArray(callback)) {
	    callback.forEach(function (b) {
	      Buffer.isBuffer(b) && this.append(b)
	    }.bind(this))
	  }

	  DuplexStream.call(this)
	}

	util.inherits(BufferList, DuplexStream)

	BufferList.prototype._offset = function (offset) {
	  var tot = 0, i = 0, _t
	  for (; i < this._bufs.length; i++) {
	    _t = tot + this._bufs[i].length
	    if (offset < _t)
	      return [ i, offset - tot ]
	    tot = _t
	  }
	}

	BufferList.prototype.append = function (buf) {
	  var isBuffer = Buffer.isBuffer(buf) ||
	                 buf instanceof BufferList

	  this._bufs.push(isBuffer ? buf : new Buffer(buf))
	  this.length += buf.length
	  return this
	}

	BufferList.prototype._write = function (buf, encoding, callback) {
	  this.append(buf)
	  if (callback)
	    callback()
	}

	BufferList.prototype._read = function (size) {
	  if (!this.length)
	    return this.push(null)
	  size = Math.min(size, this.length)
	  this.push(this.slice(0, size))
	  this.consume(size)
	}

	BufferList.prototype.end = function (chunk) {
	  DuplexStream.prototype.end.call(this, chunk)

	  if (this._callback) {
	    this._callback(null, this.slice())
	    this._callback = null
	  }
	}

	BufferList.prototype.get = function (index) {
	  return this.slice(index, index + 1)[0]
	}

	BufferList.prototype.slice = function (start, end) {
	  return this.copy(null, 0, start, end)
	}

	BufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart != 'number' || srcStart < 0)
	    srcStart = 0
	  if (typeof srcEnd != 'number' || srcEnd > this.length)
	    srcEnd = this.length
	  if (srcStart >= this.length)
	    return dst || new Buffer(0)
	  if (srcEnd <= 0)
	    return dst || new Buffer(0)

	  var copy   = !!dst
	    , off    = this._offset(srcStart)
	    , len    = srcEnd - srcStart
	    , bytes  = len
	    , bufoff = (copy && dstStart) || 0
	    , start  = off[1]
	    , l
	    , i

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd == this.length) {
	    if (!copy) // slice, just return a full concat
	      return Buffer.concat(this._bufs)

	    // copy, need to copy individual buffers
	    for (i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff)
	      bufoff += this._bufs[i].length
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) // a slice, we need something to copy in to
	    dst = new Buffer(len)

	  for (i = off[0]; i < this._bufs.length; i++) {
	    l = this._bufs[i].length - start

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start)
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes)
	      break
	    }

	    bufoff += l
	    bytes -= l

	    if (start)
	      start = 0
	  }

	  return dst
	}

	BufferList.prototype.toString = function (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	}

	BufferList.prototype.consume = function (bytes) {
	  while (this._bufs.length) {
	    if (bytes > this._bufs[0].length) {
	      bytes -= this._bufs[0].length
	      this.length -= this._bufs[0].length
	      this._bufs.shift()
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes)
	      this.length -= bytes
	      break
	    }
	  }
	  return this
	}

	BufferList.prototype.duplicate = function () {
	  var i = 0
	    , copy = new BufferList()

	  for (; i < this._bufs.length; i++)
	    copy.append(this._bufs[i])

	  return copy
	}

	BufferList.prototype.destroy = function () {
	  this._bufs.length = 0;
	  this.length = 0;
	  this.push(null);
	}

	;(function () {
	  var methods = {
	      'readDoubleBE' : 8
	    , 'readDoubleLE' : 8
	    , 'readFloatBE'  : 4
	    , 'readFloatLE'  : 4
	    , 'readInt32BE'  : 4
	    , 'readInt32LE'  : 4
	    , 'readUInt32BE' : 4
	    , 'readUInt32LE' : 4
	    , 'readInt16BE'  : 2
	    , 'readInt16LE'  : 2
	    , 'readUInt16BE' : 2
	    , 'readUInt16LE' : 2
	    , 'readInt8'     : 1
	    , 'readUInt8'    : 1
	  }

	  for (var m in methods) {
	    (function (m) {
	      BufferList.prototype[m] = function (offset) {
	        return this.slice(offset, offset + methods[m])[m](0)
	      }
	    }(m))
	  }
	}())

	module.exports = BufferList

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(229)


/***/ },
/* 239 */
/***/ function(module, exports) {

	
	function Packet() {
	  this.cmd = null
	  this.retain = false
	  this.qos = 0
	  this.dup = false
	  this.length = -1
	  this.topic = null
	  this.payload = null
	}

	module.exports = Packet


/***/ },
/* 240 */
/***/ function(module, exports) {

	/* Protocol - protocol constants */

	/* Command code => mnemonic */
	module.exports.types = {
	  0: 'reserved',
	  1: 'connect',
	  2: 'connack',
	  3: 'publish',
	  4: 'puback',
	  5: 'pubrec',
	  6: 'pubrel',
	  7: 'pubcomp',
	  8: 'subscribe',
	  9: 'suback',
	  10: 'unsubscribe',
	  11: 'unsuback',
	  12: 'pingreq',
	  13: 'pingresp',
	  14: 'disconnect',
	  15: 'reserved'
	};

	/* Mnemonic => Command code */
	module.exports.codes = {}
	for(var k in module.exports.types) {
	  var v = module.exports.types[k];
	  module.exports.codes[v] = k;
	}

	/* Header */
	module.exports.CMD_SHIFT = 4;
	module.exports.CMD_MASK = 0xF0;
	module.exports.DUP_MASK = 0x08;
	module.exports.QOS_MASK = 0x03;
	module.exports.QOS_SHIFT = 1;
	module.exports.RETAIN_MASK = 0x01;

	/* Length */
	module.exports.LENGTH_MASK = 0x7F;
	module.exports.LENGTH_FIN_MASK = 0x80;

	/* Connack */
	module.exports.SESSIONPRESENT_MASK = 0x01;

	/* Connect */
	module.exports.USERNAME_MASK = 0x80;
	module.exports.PASSWORD_MASK = 0x40;
	module.exports.WILL_RETAIN_MASK = 0x20;
	module.exports.WILL_QOS_MASK = 0x18;
	module.exports.WILL_QOS_SHIFT = 3;
	module.exports.WILL_FLAG_MASK = 0x04;
	module.exports.CLEAN_SESSION_MASK = 0x02;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	'use strict';

	var protocol = __webpack_require__(240)
	  , empty = new Buffer(0)

	function generate(packet) {

	  switch (packet.cmd) {
	    case 'connect':
	      return connect(packet)
	    case 'connack':
	      return connack(packet)
	    case 'publish':
	      return publish(packet)
	    case 'puback':
	    case 'pubrec':
	    case 'pubrel':
	    case 'pubcomp':
	    case 'unsuback':
	      return confirmation(packet)
	    case 'subscribe':
	      return subscribe(packet)
	    case 'suback':
	      return suback(packet)
	    case 'unsubscribe':
	      return unsubscribe(packet)
	    case 'pingreq':
	    case 'pingresp':
	    case 'disconnect':
	      return emptyPacket(packet)
	    default:
	      throw new Error('unknown command')
	  }
	}

	function connect(opts) {
	  var opts = opts || {}
	    , protocolId = opts.protocolId || 'MQTT'
	    , protocolVersion = opts.protocolVersion || 4
	    , will = opts.will
	    , clean = opts.clean
	    , keepalive = opts.keepalive || 0
	    , clientId = opts.clientId ||""
	    , username = opts.username
	    , password = opts.password

	  if (clean === undefined) {
	    clean = true
	  }

	  var length = 0

	  // Must be a string and non-falsy
	  if (!protocolId ||
	     (typeof protocolId !== "string" && !Buffer.isBuffer(protocolId))) {
	    throw new Error('Invalid protocol id')
	  } else {
	    length += protocolId.length + 2
	  }

	  // Must be a 1 byte number
	  if (!protocolVersion ||
	      'number' !== typeof protocolVersion ||
	      protocolVersion > 255 ||
	      protocolVersion < 0) {

	    throw new Error('Invalid protocol version')
	  } else {
	    length += 1
	  }

	  // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1
	  if ((typeof clientId === "string" || Buffer.isBuffer(clientId)) &&
	     (clientId || protocolVersion == 4) &&
	     (clientId ||clean)) {

	    length += clientId.length + 2
	  } else {
	    
	    if(protocolVersion < 4) {
	    
	      throw new Error('clientId must be supplied before 3.1.1');
	    }
	    
	    if(clean == 0) {

	      throw new Error('clientId must be given if cleanSession set to 0');
	    } 
	  }

	  // Must be a two byte number
	  if ('number' !== typeof keepalive ||
	      keepalive < 0 ||
	      keepalive > 65535) {
	    throw new Error('Invalid keepalive')
	  } else {
	    length += 2
	  }

	  // Connect flags
	  length += 1

	  // If will exists...
	  if (will) {
	    // It must be an object
	    if ('object' !== typeof will) {
	      throw new Error('Invalid will')
	    }
	    // It must have topic typeof string
	    if (!will.topic || 'string' !== typeof will.topic) {
	      throw new Error('Invalid will topic')
	    } else {
	      length += will.topic.length + 2
	    }

	    // Payload
	    if (will.payload && will.payload) {
	      if (will.payload.length >= 0) {
	        if ('string' === typeof will.payload) {
	          length += Buffer.byteLength(will.payload) + 2
	        } else {
	          length += will.payload.length + 2
	        }
	      } else {
	        throw new Error('Invalid will payload')
	      }
	    } else {
	      length += 2
	    }
	  }

	  // Username
	  if (username) {
	    if (username.length) {
	      length += username.length + 2
	    } else {
	      throw new Error('Invalid username')
	    }
	  }

	  // Password
	  if (password) {
	    if (password.length) {
	      length += password.length + 2
	    } else {
	      throw new Error('Invalid password')
	    }
	  }

	  var buffer = new Buffer(1 + calcLengthLength(length) + length)
	    , pos = 0

	  // Generate header
	  buffer.writeUInt8(protocol.codes['connect'] << protocol.CMD_SHIFT, pos++)

	  // Generate length
	  pos += writeLength(buffer, pos, length)

	  // Generate protocol ID
	  pos += writeStringOrBuffer(buffer, pos, protocolId)
	  buffer.writeUInt8(protocolVersion, pos++)

	  // Connect flags
	  var flags = 0
	  flags |= username ? protocol.USERNAME_MASK : 0
	  flags |= password ? protocol.PASSWORD_MASK : 0
	  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0
	  flags |= (will && will.qos) ?
	    will.qos << protocol.WILL_QOS_SHIFT : 0
	  flags |= will ? protocol.WILL_FLAG_MASK : 0
	  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0

	  buffer.writeUInt8(flags, pos++)

	  // Keepalive
	  pos += writeNumber(buffer, pos, keepalive)

	  // Client ID
	  pos += writeStringOrBuffer(buffer, pos, clientId)

	  // Will
	  if (will) {
	  	pos += writeString(buffer, pos, will.topic)
	    pos += writeStringOrBuffer(buffer, pos, will.payload)
	  }

	  // Username and password
	  if (username)
	    pos += writeStringOrBuffer(buffer, pos, username)

	  if (password)
	    pos += writeStringOrBuffer(buffer, pos, password)

	  return buffer
	}

	function connack(opts) {
	  var opts = opts || {}
	    , rc = opts.returnCode;

	  // Check return code
	  if ('number' !== typeof rc)
	    throw new Error('Invalid return code');

	  var buffer = new Buffer(4)
	    , pos = 0;

	  buffer.writeUInt8(protocol.codes['connack'] << protocol.CMD_SHIFT, pos++);
	  pos += writeLength(buffer, pos, 2);
	  buffer.writeUInt8(opts.sessionPresent && protocol.SESSIONPRESENT_MASK || 0, pos++);
	  buffer.writeUInt8(rc, pos++);

	  return buffer;
	}

	function publish(opts) {
	  var opts = opts || {}
	    , dup = opts.dup ? protocol.DUP_MASK : 0
	    , qos = opts.qos
	    , retain = opts.retain ? protocol.RETAIN_MASK : 0
	    , topic = opts.topic
	    , payload = opts.payload || empty
	    , id = opts.messageId;

	  var length = 0;

	  // Topic must be a non-empty string or Buffer
	  if (typeof topic === "string")
	    length += Buffer.byteLength(topic) + 2;
	  else if (Buffer.isBuffer(topic))
	    length += topic.length + 2;
	  else
	    throw new Error('Invalid topic');

	  // get the payload length
	  if (!Buffer.isBuffer(payload)) {
	    length += Buffer.byteLength(payload);
	  } else {
	    length += payload.length;
	  }

	  // Message id must a number if qos > 0
	  if (qos && 'number' !== typeof id) {
	    throw new Error('Invalid message id')
	  } else if (qos) {
	    length += 2;
	  }

	  var buffer = new Buffer(1 + calcLengthLength(length) + length)
	    , pos = 0;

	  // Header
	  buffer[pos++] =
	    protocol.codes['publish'] << protocol.CMD_SHIFT |
	    dup |
	    qos << protocol.QOS_SHIFT |
	    retain;

	  // Remaining length
	  pos += writeLength(buffer, pos, length);

	  // Topic
	  pos += writeStringOrBuffer(buffer, pos, topic);

	  // Message ID
	  if (qos > 0) {
	    pos += writeNumber(buffer, pos, id);
	  }

	  // Payload
	  if (!Buffer.isBuffer(payload)) {
	    writeStringNoPos(buffer, pos, payload);
	  } else {
	    writeBuffer(buffer, pos, payload);
	  }

	  return buffer;
	}

	/* Puback, pubrec, pubrel and pubcomp */
	function confirmation(opts) {
	  var opts = opts || {}
	    , type = opts.cmd || 'puback'
	    , id = opts.messageId
	    , dup = (opts.dup && type === 'pubrel') ? protocol.DUP_MASK : 0
	    , qos = 0

	  if (type === 'pubrel')
	    qos = 1
	  else if (type === 'pubcomp')
	    qos = 2

	  // Check message ID
	  if ('number' !== typeof id)
	    throw new Error('Invalid message id');

	  var buffer = new Buffer(4)
	    , pos = 0;

	  // Header
	  buffer[pos++] =
	    protocol.codes[type] << protocol.CMD_SHIFT |
	    dup |
	    qos << protocol.QOS_SHIFT;

	  // Length
	  pos += writeLength(buffer, pos, 2);

	  // Message ID
	  pos += writeNumber(buffer, pos, id);

	  return buffer;
	}

	function subscribe(opts) {
	  var opts = opts || {}
	    , dup = opts.dup ? protocol.DUP_MASK : 0
	    , qos = opts.qos || 0
	    , id = opts.messageId
	    , subs = opts.subscriptions;

	  var length = 0;

	  // Check mid
	  if ('number' !== typeof id) {
	    throw new Error('Invalid message id');
	  } else {
	    length += 2;
	  }
	  // Check subscriptions
	  if ('object' === typeof subs && subs.length) {
	    for (var i = 0; i < subs.length; i += 1) {
	      var topic = subs[i].topic
	        , qos = subs[i].qos;

	      if ('string' !== typeof topic) {
	        throw new Error('Invalid subscriptions - invalid topic');
	      }
	      if ('number' !== typeof qos) {
	        throw new Error('Invalid subscriptions - invalid qos');
	      }

	      length += Buffer.byteLength(topic) + 2 + 1;
	    }
	  } else {
	    throw new Error('Invalid subscriptions');
	  }

	  var buffer = new Buffer(1 + calcLengthLength(length) + length)
	    , pos = 0;

	  // Generate header
	  buffer.writeUInt8(
	    protocol.codes['subscribe'] << protocol.CMD_SHIFT |
	    dup |
	    1 << protocol.QOS_SHIFT, pos++);

	  // Generate length
	  pos += writeLength(buffer, pos, length);

	  // Generate message ID
	  pos += writeNumber(buffer, pos, id);

	  // Generate subs
	  for (var i = 0; i < subs.length; i++) {
	    var sub = subs[i]
	      , topic = sub.topic
	      , qos = sub.qos;

	    // Write topic string
	    pos += writeString(buffer, pos, topic);
	    // Write qos
	    buffer.writeUInt8(qos, pos++);
	  }

	  return buffer;
	}

	function suback(opts) {
	  var opts = opts || {}
	    , id = opts.messageId
	    , granted = opts.granted;

	  var length = 0;

	  // Check message id
	  if ('number' !== typeof id) {
	    throw new Error('Invalid message id');
	  } else {
	    length += 2;
	  }
	  // Check granted qos vector
	  if ('object' === typeof granted && granted.length) {
	    for (var i = 0; i < granted.length; i += 1) {
	      if ('number' !== typeof granted[i]) {
	        throw new Error('Invalid qos vector');
	      }
	      length += 1;
	    }
	  } else {
	    throw new Error('Invalid qos vector');
	  }

	  var buffer = new Buffer(1 + calcLengthLength(length) + length)
	    , pos = 0;

	  // Header
	  buffer.writeUInt8(protocol.codes['suback'] << protocol.CMD_SHIFT, pos++);

	  // Length
	  pos += writeLength(buffer, pos, length);

	  // Message ID
	  pos += writeNumber(buffer, pos, id);

	  // Subscriptions
	  for (var i = 0; i < granted.length; i++) {
	    buffer.writeUInt8(granted[i], pos++);
	  }

	  return buffer;
	}

	function unsubscribe(opts) {
	  var opts = opts || {}
	    , id = opts.messageId
	    , dup = opts.dup ? protocol.DUP_MASK : 0
	    , unsubs = opts.unsubscriptions;

	  var length = 0;

	  // Check message id
	  if ('number' !== typeof id) {
	    throw new Error('Invalid message id');
	  } else {
	    length += 2;
	  }
	  // Check unsubs
	  if ('object' === typeof unsubs && unsubs.length) {
	    for (var i = 0; i < unsubs.length; i += 1) {
	      if ('string' !== typeof unsubs[i]) {
	        throw new Error('Invalid unsubscriptions');
	      }
	      length += Buffer.byteLength(unsubs[i]) + 2;
	    }
	  } else {
	    throw new Error('Invalid unsubscriptions');
	  }

	  var buffer = new Buffer(1 + calcLengthLength(length) + length)
	    , pos = 0;

	  // Header
	  buffer[pos++] =
	    protocol.codes['unsubscribe'] << protocol.CMD_SHIFT |
	    dup |
	    1 << protocol.QOS_SHIFT;

	  // Length
	  pos += writeLength(buffer, pos, length);

	  // Message ID
	  pos += writeNumber(buffer, pos, id);

	  // Unsubs
	  for (var i = 0; i < unsubs.length; i++) {
	    pos += writeString(buffer, pos, unsubs[i]);
	  }

	  return buffer;
	}

	function emptyPacket(opts) {
	  var buf = new Buffer(2);
	  buf[0] = protocol.codes[opts.cmd] << 4;
	  buf[1] = 0;
	  return buf;
	}

	/**
	 * calcLengthLength - calculate the length of the remaining
	 * length field
	 *
	 * @api private
	 */
	function calcLengthLength(length) {
	  if (length >= 0 && length < 128) {
	    return 1
	  } else if (length >= 128 && length < 16384) {
	    return 2
	  } else if (length >= 16384 && length < 2097152) {
	    return 3
	  } else if (length >= 2097152 && length < 268435456) {
	    return 4
	  } else {
	    return 0
	  }
	}

	/**
	 * writeLength - write an MQTT style length field to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <Number> length - length (>0)
	 * @returns <Number> number of bytes written
	 *
	 * @api private
	 */

	function writeLength(buffer, pos, length) {
	  var digit = 0
	    , origPos = pos

	  do {
	    digit = length % 128 | 0
	    length = length / 128 | 0
	    if (length > 0) {
	        digit = digit | 0x80
	    }
	    buffer.writeUInt8(digit, pos++)
	  } while (length > 0)

	  return pos - origPos
	}

	/**
	 * writeString - write a utf8 string to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <String> string - string to write
	 * @return <Number> number of bytes written
	 *
	 * @api private
	 */

	function writeString(buffer, pos, string) {
	  var strlen = Buffer.byteLength(string)
	  writeNumber(buffer, pos, strlen)

	  writeStringNoPos(buffer, pos + 2, string)

	  return strlen + 2
	}

	function writeStringNoPos(buffer, pos, string) {
	  buffer.write(string, pos)
	}

	/**
	 * write_buffer - write buffer to buffer
	 *
	 * @param <Buffer> buffer - dest buffer
	 * @param <Number> pos - offset
	 * @param <Buffer> src - source buffer
	 * @return <Number> number of bytes written
	 *
	 * @api private
	 */

	function writeBuffer(buffer, pos, src) {
	  src.copy(buffer, pos)
	  return src.length
	}

	/**
	 * writeNumber - write a two byte number to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <String> number - number to write
	 * @return <Number> number of bytes written
	 *
	 * @api private
	 */
	function writeNumber(buffer, pos, number) {
	  buffer.writeUInt8(number >> 8, pos)
	  buffer.writeUInt8(number & 0x00FF, pos + 1)

	  return 2
	}

	/**
	 * writeStringOrBuffer - write a String or Buffer with the its length prefix
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <String> toWrite - String or Buffer
	 * @return <Number> number of bytes written
	 */
	function writeStringOrBuffer(buffer, pos, toWrite) {
	  var written = 0

	  if (toWrite && typeof toWrite === 'string') {
	    written += writeString(buffer, pos + written, toWrite)
	  } else if (toWrite) {
	    written += writeNumber(buffer, pos + written, toWrite.length)
	    written += writeBuffer(buffer, pos + written, toWrite)
	  } else {
	    written += writeNumber(buffer, pos + written, 0)
	  }

	  return written
	}

	module.exports = generate

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(243);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(244);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module), (function() { return this; }())))

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(245);
	exports.encode = exports.stringify = __webpack_require__(246);


/***/ },
/* 245 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 246 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 247 */
/***/ function(module, exports) {

	module.exports = extend

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var net = __webpack_require__(249);

	/*
	  variables port and host can be removed since
	  you have all required information in opts object
	*/
	function buildBuilder (client, opts) {
	  var port, host;
	  opts.port = opts.port || 1883;
	  opts.hostname = opts.hostname || opts.host || 'localhost';

	  port = opts.port;
	  host = opts.hostname;

	  return net.createConnection(port, host);
	}

	module.exports = buildBuilder;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {/*global chrome */

	/**
	 * net
	 * ===
	 *
	 * The net module provides you with an asynchronous network wrapper. It
	 * contains methods for creating both servers and clients (called streams).
	 * You can include this module with require('chrome-net')
	 */

	var EventEmitter = __webpack_require__(8).EventEmitter
	var inherits = __webpack_require__(250)
	var is = __webpack_require__(251)
	var stream = __webpack_require__(207)
	var deprecate = __webpack_require__(12).deprecate
	var timers = __webpack_require__(170)

	// Track open servers and sockets to route incoming sockets (via onAccept and onReceive)
	// to the right handlers.
	var servers = {}
	var sockets = {}

	if (typeof chrome !== 'undefined') {
	  chrome.sockets.tcpServer.onAccept.addListener(onAccept)
	  chrome.sockets.tcpServer.onAcceptError.addListener(onAcceptError)
	  chrome.sockets.tcp.onReceive.addListener(onReceive)
	  chrome.sockets.tcp.onReceiveError.addListener(onReceiveError)
	}

	function onAccept (info) {
	  if (info.socketId in servers) {
	    servers[info.socketId]._onAccept(info.clientSocketId)
	  } else {
	    console.error('Unknown server socket id: ' + info.socketId)
	  }
	}

	function onAcceptError (info) {
	  if (info.socketId in servers) {
	    servers[info.socketId]._onAcceptError(info.resultCode)
	  } else {
	    console.error('Unknown server socket id: ' + info.socketId)
	  }
	}

	function onReceive (info) {
	  if (info.socketId in sockets) {
	    sockets[info.socketId]._onReceive(info.data)
	  } else {
	    console.error('Unknown socket id: ' + info.socketId)
	  }
	}

	function onReceiveError (info) {
	  if (info.socketId in sockets) {
	    sockets[info.socketId]._onReceiveError(info.resultCode)
	  } else {
	    if (info.resultCode === -100) return // net::ERR_CONNECTION_CLOSED
	    console.error('Unknown socket id: ' + info.socketId)
	  }
	}

	/**
	 * Creates a new TCP server. The connectionListener argument is automatically
	 * set as a listener for the 'connection' event.
	 *
	 * @param  {Object} options
	 * @param  {function} listener
	 * @return {Server}
	 */
	exports.createServer = function (options, listener) {
	  return new Server(options, listener)
	}

	/**
	 * net.connect(options, [connectionListener])
	 * net.createConnection(options, [connectionListener])
	 *
	 * Constructs a new socket object and opens the socket to the given location.
	 * When the socket is established, the 'connect' event will be emitted.
	 *
	 * For TCP sockets, options argument should be an object which specifies:
	 *
	 *   port: Port the client should connect to (Required).
	 *   host: Host the client should connect to. Defaults to 'localhost'.
	 *   localAddress: Local interface to bind to for network connections.
	 *
	 * ===============================================================
	 *
	 * net.connect(port, [host], [connectListener])
	 * net.createConnection(port, [host], [connectListener])
	 *
	 * Creates a TCP connection to port on host. If host is omitted,
	 * 'localhost' will be assumed. The connectListener parameter will be
	 * added as an listener for the 'connect' event.
	 *
	 * @param {Object} options
	 * @param {function} listener
	 * @return {Socket}
	 */
	exports.connect = exports.createConnection = function () {
	  var args = normalizeConnectArgs(arguments)
	  var s = new Socket(args[0])
	  return Socket.prototype.connect.apply(s, args)
	}

	inherits(Server, EventEmitter)

	/**
	 * Class: net.Server
	 * =================
	 *
	 * This class is used to create a TCP server.
	 *
	 * Event: 'listening'
	 *   Emitted when the server has been bound after calling server.listen.
	 *
	 * Event: 'connection'
	 *   - Socket object The connection object
	 *   Emitted when a new connection is made. socket is an instance of net.Socket.
	 *
	 * Event: 'close'
	 *   Emitted when the server closes. Note that if connections exist, this event
	 *   is not emitted until all connections are ended.
	 *
	 * Event: 'error'
	 *   - Error Object
	 *   Emitted when an error occurs. The 'close' event will be called directly
	 *   following this event. See example in discussion of server.listen.
	 */
	function Server (/* [options], listener */) {
	  var self = this
	  if (!(self instanceof Server)) return new Server(arguments[0], arguments[1])
	  EventEmitter.call(self)

	  var options

	  if (is.isFunction(arguments[0])) {
	    options = {}
	    self.on('connection', arguments[0])
	  } else {
	    options = arguments[0] || {}

	    if (is.isFunction(arguments[1])) {
	      self.on('connection', arguments[1])
	    }
	  }

	  self._connections = 0

	  Object.defineProperty(self, 'connections', {
	    get: deprecate(function () {
	      return self._connections
	    }, 'connections property is deprecated. Use getConnections() method'),
	    set: deprecate(function (val) {
	      return (self._connections = val)
	    }, 'connections property is deprecated. Use getConnections() method'),
	    configurable: true, enumerable: false
	  })

	  self.id = null // a number > 0
	  self._connecting = false

	  self.allowHalfOpen = options.allowHalfOpen || false
	  self.pauseOnConnect = !!options.pauseOnConnect
	  self._address = null

	  self._host = null
	  self._port = null
	  self._backlog = null
	}
	exports.Server = Server

	Server.prototype._usingSlaves = false // not used

	/**
	 * server.listen(port, [host], [backlog], [callback])
	 *
	 * Begin accepting connections on the specified port and host. If the host is
	 * omitted, the server will accept connections directed to any IPv4 address
	 * (INADDR_ANY). A port value of zero will assign a random port.
	 *
	 * Backlog is the maximum length of the queue of pending connections. The
	 * actual length will be determined by your OS through sysctl settings such as
	 * tcp_max_syn_backlog and somaxconn on linux. The default value of this
	 * parameter is 511 (not 512).
	 *
	 * This function is asynchronous. When the server has been bound, 'listening'
	 * event will be emitted. The last parameter callback will be added as an
	 * listener for the 'listening' event.
	 *
	 * @return {Socket}
	 */
	Server.prototype.listen = function (/* variable arguments... */) {
	  var self = this

	  var lastArg = arguments[arguments.length - 1]
	  if (is.isFunction(lastArg)) {
	    self.once('listening', lastArg)
	  }

	  var port = toNumber(arguments[0])

	  var address

	  // The third optional argument is the backlog size.
	  // When the ip is omitted it can be the second argument.
	  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]) || undefined

	  if (is.isObject(arguments[0])) {
	    var h = arguments[0]

	    if (h._handle || h.handle) {
	      throw new Error('handle is not supported in Chrome Apps.')
	    }
	    if (is.isNumber(h.fd) && h.fd >= 0) {
	      throw new Error('fd is not supported in Chrome Apps.')
	    }

	    // The first argument is a configuration object
	    if (h.backlog) {
	      backlog = h.backlog
	    }

	    if (is.isNumber(h.port)) {
	      address = h.host || null
	      port = h.port
	    } else if (h.path && isPipeName(h.path)) {
	      throw new Error('Pipes are not supported in Chrome Apps.')
	    } else {
	      throw new Error('Invalid listen argument: ' + h)
	    }
	  } else if (isPipeName(arguments[0])) {
	    // UNIX socket or Windows pipe.
	    throw new Error('Pipes are not supported in Chrome Apps.')
	  } else if (is.isUndefined(arguments[1]) ||
	             is.isFunction(arguments[1]) ||
	             is.isNumber(arguments[1])) {
	    // The first argument is the port, no IP given.
	    address = null
	  } else {
	    // The first argument is the port, the second an IP.
	    address = arguments[1]
	  }

	  // now do something with port, address, backlog

	  if (self.id) {
	    self.close()
	  }

	  // If port is invalid or undefined, bind to a random port.
	  self._port = port | 0
	  if (self._port < 0 || self._port > 65535) { // allow 0 for random port
	    throw new RangeError('port should be >= 0 and < 65536: ' + self._port)
	  }

	  self._host = address

	  var isAny6 = !self._host
	  if (isAny6) {
	    self._host = '::'
	  }

	  self._backlog = is.isNumber(backlog) ? backlog : undefined

	  self._connecting = true

	  chrome.sockets.tcpServer.create(function (createInfo) {
	    if (!self._connecting || self.id) {
	      ignoreLastError()
	      chrome.sockets.tcpServer.close(createInfo.socketId)
	      return
	    }
	    if (chrome.runtime.lastError) {
	      self.emit('error', new Error(chrome.runtime.lastError.message))
	      return
	    }

	    var socketId = self.id = createInfo.socketId
	    servers[self.id] = self

	    function listen () {
	      chrome.sockets.tcpServer.listen(self.id, self._host, self._port,
	          self._backlog, function (result) {
	        // callback may be after close
	        if (self.id !== socketId) {
	          ignoreLastError()
	          return
	        }
	        if (result !== 0 && isAny6) {
	          ignoreLastError()
	          self._host = '0.0.0.0' // try IPv4
	          isAny6 = false
	          return listen()
	        }

	        self._onListen(result)
	      })
	    }
	    listen()
	  })

	  return self
	}

	Server.prototype._onListen = function (result) {
	  var self = this
	  self._connecting = false

	  if (result === 0) {
	    var idBefore = self.id
	    chrome.sockets.tcpServer.getInfo(self.id, function (info) {
	      if (self.id !== idBefore) {
	        ignoreLastError()
	        return
	      }
	      if (chrome.runtime.lastError) {
	        self._onListen(-2) // net::ERR_FAILED
	        return
	      }

	      self._address = {
	        port: info.localPort,
	        family: info.localAddress &&
	          info.localAddress.indexOf(':') !== -1 ? 'IPv6' : 'IPv4',
	        address: info.localAddress
	      }
	      self.emit('listening')
	    })
	  } else {
	    self.emit('error', errnoException(result, 'listen'))
	    chrome.sockets.tcpServer.close(self.id)
	    delete servers[self.id]
	    self.id = null
	  }
	}

	Server.prototype._onAccept = function (clientSocketId) {
	  var self = this

	  // Set the `maxConnections` property to reject connections when the server's
	  // connection count gets high.
	  if (self.maxConnections && self._connections >= self.maxConnections) {
	    chrome.sockets.tcp.close(clientSocketId)
	    console.warn('Rejected connection - hit `maxConnections` limit')
	    return
	  }

	  self._connections += 1

	  var acceptedSocket = new Socket({
	    server: self,
	    id: clientSocketId,
	    allowHalfOpen: self.allowHalfOpen,
	    pauseOnCreate: self.pauseOnConnect
	  })
	  acceptedSocket.on('connect', function () {
	    self.emit('connection', acceptedSocket)
	  })
	}

	Server.prototype._onAcceptError = function (resultCode) {
	  var self = this
	  self.emit('error', errnoException(resultCode, 'accept'))
	  self.close()
	}

	/**
	 * Stops the server from accepting new connections and keeps existing
	 * connections. This function is asynchronous, the server is finally closed
	 * when all connections are ended and the server emits a 'close' event.
	 * Optionally, you can pass a callback to listen for the 'close' event.
	 * @param  {function} callback
	 */
	Server.prototype.close = function (callback) {
	  var self = this

	  if (callback) {
	    if (!self.id) {
	      self.once('close', function () {
	        callback(new Error('Not running'))
	      })
	    } else {
	      self.once('close', callback)
	    }
	  }

	  if (self.id) {
	    chrome.sockets.tcpServer.close(self.id)
	    delete servers[self.id]
	    self.id = null
	  }
	  self._address = null
	  self._connecting = false

	  self._emitCloseIfDrained()

	  return self
	}

	Server.prototype._emitCloseIfDrained = function () {
	  var self = this

	  if (self.id || self._connecting || self._connections) {
	    return
	  }

	  process.nextTick(function () {
	    if (self.id || self._connecting || self._connections) {
	      return
	    }
	    self.emit('close')
	  })
	}

	/**
	 * Returns the bound address, the address family name and port of the socket
	 * as reported by the operating system. Returns an object with three
	 * properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }
	 *
	 * @return {Object} information
	 */
	Server.prototype.address = function () {
	  return this._address
	}

	Server.prototype.unref = function () {
	  // No chrome.socket equivalent
	}

	Server.prototype.ref = function () {
	  // No chrome.socket equivalent
	}

	/**
	 * Asynchronously get the number of concurrent connections on the server.
	 * Works when sockets were sent to forks.
	 *
	 * Callback should take two arguments err and count.
	 *
	 * @param  {function} callback
	 */
	Server.prototype.getConnections = function (callback) {
	  var self = this
	  process.nextTick(function () {
	    callback(null, self._connections)
	  })
	}

	inherits(Socket, stream.Duplex)

	/**
	 * Class: net.Socket
	 * =================
	 *
	 * This object is an abstraction of a TCP or UNIX socket. net.Socket instances
	 * implement a duplex Stream interface. They can be created by the user and
	 * used as a client (with connect()) or they can be created by Node and passed
	 * to the user through the 'connection' event of a server.
	 *
	 * Construct a new socket object.
	 *
	 * options is an object with the following defaults:
	 *
	 *   { fd: null // NO CHROME EQUIVALENT
	 *     type: null
	 *     allowHalfOpen: false // NO CHROME EQUIVALENT
	 *   }
	 *
	 * `type` can only be 'tcp4' (for now).
	 *
	 * Event: 'connect'
	 *   Emitted when a socket connection is successfully established. See
	 *   connect().
	 *
	 * Event: 'data'
	 *   - Buffer object
	 *   Emitted when data is received. The argument data will be a Buffer or
	 *   String. Encoding of data is set by socket.setEncoding(). (See the Readable
	 *   Stream section for more information.)
	 *
	 *   Note that the data will be lost if there is no listener when a Socket
	 *   emits a 'data' event.
	 *
	 * Event: 'end'
	 *   Emitted when the other end of the socket sends a FIN packet.
	 *
	 *   By default (allowHalfOpen == false) the socket will destroy its file
	 *   descriptor once it has written out its pending write queue. However,
	 *   by setting allowHalfOpen == true the socket will not automatically
	 *   end() its side allowing the user to write arbitrary amounts of data,
	 *   with the caveat that the user is required to end() their side now.
	 *
	 * Event: 'timeout'
	 *   Emitted if the socket times out from inactivity. This is only to notify
	 *   that the socket has been idle. The user must manually close the connection.
	 *
	 *   See also: socket.setTimeout()
	 *
	 * Event: 'drain'
	 *   Emitted when the write buffer becomes empty. Can be used to throttle
	 *   uploads.
	 *
	 *   See also: the return values of socket.write()
	 *
	 * Event: 'error'
	 *   - Error object
	 *   Emitted when an error occurs. The 'close' event will be called directly
	 *   following this event.
	 *
	 * Event: 'close'
	 *   - had_error Boolean true if the socket had a transmission error
	 *   Emitted once the socket is fully closed. The argument had_error is a
	 *   boolean which says if the socket was closed due to a transmission error.
	 */
	function Socket (options) {
	  var self = this
	  if (!(self instanceof Socket)) return new Socket(options)

	  if (is.isNumber(options)) {
	    options = { fd: options } // Legacy interface.
	  } else if (is.isUndefined(options)) {
	    options = {}
	  }

	  if (options.handle) {
	    throw new Error('handle is not supported in Chrome Apps.')
	  } else if (!is.isUndefined(options.fd)) {
	    throw new Error('fd is not supported in Chrome Apps.')
	  }

	  options.decodeStrings = true
	  options.objectMode = false
	  stream.Duplex.call(self, options)

	  self.destroyed = false
	  self._hadError = false // Used by _http_client.js
	  self.id = null // a number > 0
	  self._parent = null
	  self._host = null
	  self._port = null
	  self._pendingData = null

	  self.ondata = null
	  self.onend = null

	  self._init()
	  self._reset()

	  // default to *not* allowing half open sockets
	  // Note: this is not possible in Chrome Apps, see https://crbug.com/124952
	  self.allowHalfOpen = options.allowHalfOpen || false

	  // shut down the socket when we're finished with it.
	  self.on('finish', self.destroy)

	  if (options.server) {
	    self.server = options.server
	    self.id = options.id
	    sockets[self.id] = self

	    if (options.pauseOnCreate) {
	      // stop the handle from reading and pause the stream
	      // (Already paused in Chrome version)
	      self._readableState.flowing = false
	    }

	    // For incoming sockets (from server), it's already connected.
	    self._connecting = true
	    self.writable = true
	    self._onConnect()
	  }
	}
	exports.Socket = Socket

	// called when creating new Socket, or when re-using a closed Socket
	Socket.prototype._init = function () {
	  var self = this

	  // The amount of received bytes.
	  self.bytesRead = 0

	  self._bytesDispatched = 0
	}

	// called when creating new Socket, or when closing a Socket
	Socket.prototype._reset = function () {
	  var self = this

	  self.remoteAddress = self.remotePort =
	      self.localAddress = self.localPort = null
	  self.remoteFamily = 'IPv4'
	  self.readable = self.writable = false
	  self._connecting = false
	}

	/**
	 * socket.connect(port, [host], [connectListener])
	 * socket.connect(options, [connectListener])
	 *
	 * Opens the connection for a given socket. If port and host are given, then
	 * the socket will be opened as a TCP socket, if host is omitted, localhost
	 * will be assumed. If a path is given, the socket will be opened as a unix
	 * socket to that path.
	 *
	 * Normally this method is not needed, as net.createConnection opens the
	 * socket. Use this only if you are implementing a custom Socket.
	 *
	 * This function is asynchronous. When the 'connect' event is emitted the
	 * socket is established. If there is a problem connecting, the 'connect'
	 * event will not be emitted, the 'error' event will be emitted with the
	 * exception.
	 *
	 * The connectListener parameter will be added as an listener for the
	 * 'connect' event.
	 *
	 * @param  {Object} options
	 * @param  {function} cb
	 * @return {Socket}   this socket (for chaining)
	 */
	Socket.prototype.connect = function () {
	  var self = this
	  var args = normalizeConnectArgs(arguments)
	  var options = args[0]
	  var cb = args[1]

	  if (options.path) {
	    throw new Error('Pipes are not supported in Chrome Apps.')
	  }

	  if (self.id) {
	    // already connected, destroy and connect again
	    self.destroy()
	  }

	  if (self.destroyed) {
	    self._readableState.reading = false
	    self._readableState.ended = false
	    self._readableState.endEmitted = false
	    self._writableState.ended = false
	    self._writableState.ending = false
	    self._writableState.finished = false
	    self._writableState.errorEmitted = false
	    self._writableState.length = 0
	    self.destroyed = false
	  }

	  self._connecting = true
	  self.writable = true

	  self._host = options.host || 'localhost'
	  self._port = Number(options.port)

	  if (self._port < 0 || self._port > 65535 || isNaN(self._port)) {
	    throw new RangeError('port should be >= 0 and < 65536: ' + options.port)
	  }

	  self._init()

	  self._unrefTimer()

	  if (is.isFunction(cb)) {
	    self.once('connect', cb)
	  }

	  chrome.sockets.tcp.create(function (createInfo) {
	    if (!self._connecting || self.id) {
	      ignoreLastError()
	      chrome.sockets.tcp.close(createInfo.socketId)
	      return
	    }
	    if (chrome.runtime.lastError) {
	      self.destroy(new Error(chrome.runtime.lastError.message))
	      return
	    }

	    self.id = createInfo.socketId
	    sockets[self.id] = self

	    chrome.sockets.tcp.setPaused(self.id, true)

	    chrome.sockets.tcp.connect(self.id, self._host, self._port, function (result) {
	      // callback may come after call to destroy
	      if (self.id !== createInfo.socketId) {
	        ignoreLastError()
	        return
	      }
	      if (result !== 0) {
	        self.destroy(errnoException(result, 'connect'))
	        return
	      }

	      self._unrefTimer()
	      self._onConnect()
	    })
	  })

	  return self
	}

	Socket.prototype._onConnect = function () {
	  var self = this

	  var idBefore = self.id
	  chrome.sockets.tcp.getInfo(self.id, function (result) {
	    if (self.id !== idBefore) {
	      ignoreLastError()
	      return
	    }
	    if (chrome.runtime.lastError) {
	      self.destroy(new Error(chrome.runtime.lastError.message))
	      return
	    }

	    self.remoteAddress = result.peerAddress
	    self.remoteFamily = result.peerAddress &&
	        result.peerAddress.indexOf(':') !== -1 ? 'IPv6' : 'IPv4'
	    self.remotePort = result.peerPort
	    self.localAddress = result.localAddress
	    self.localPort = result.localPort

	    self._connecting = false
	    self.readable = true

	    self.emit('connect')
	    // start the first read, or get an immediate EOF.
	    // this doesn't actually consume any bytes, because len=0
	    // TODO: replace _readableState.flowing with isPaused() after https://github.com/substack/node-browserify/issues/1341
	    if (self._readableState.flowing) self.read(0)
	  })
	}

	/**
	 * The number of characters currently buffered to be written.
	 * @type {number}
	 */
	Object.defineProperty(Socket.prototype, 'bufferSize', {
	  get: function () {
	    var self = this
	    if (self.id) {
	      var bytes = this._writableState.length
	      if (self._pendingData) bytes += self._pendingData.length
	      return bytes
	    }
	  }
	})

	Socket.prototype.end = function (data, encoding) {
	  var self = this
	  stream.Duplex.prototype.end.call(self, data, encoding)
	  self.writable = false
	}

	Socket.prototype._write = function (chunk, encoding, callback) {
	  var self = this
	  if (!callback) callback = function () {}

	  if (self._connecting) {
	    self._pendingData = chunk
	    self.once('connect', function () {
	      self._write(chunk, encoding, callback)
	    })
	    return
	  }
	  self._pendingData = null

	  if (!this.id) {
	    callback(new Error('This socket is closed.'))
	    return
	  }

	  // assuming buffer is browser implementation (`buffer` package on npm)
	  var buffer = chunk.buffer
	  if (chunk.byteOffset || chunk.byteLength !== buffer.byteLength) {
	    buffer = buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.byteLength)
	  }

	  var idBefore = self.id
	  chrome.sockets.tcp.send(self.id, buffer, function (sendInfo) {
	    if (self.id !== idBefore) {
	      ignoreLastError()
	      return
	    }

	    if (sendInfo.resultCode < 0) {
	      self.destroy(errnoException(sendInfo.resultCode, 'write'), callback)
	    } else {
	      self._unrefTimer()
	      callback(null)
	    }
	  })

	  self._bytesDispatched += chunk.length
	}

	Socket.prototype._read = function (bufferSize) {
	  var self = this
	  if (self._connecting || !self.id) {
	    self.once('connect', self._read.bind(self, bufferSize))
	    return
	  }

	  chrome.sockets.tcp.setPaused(self.id, false)

	  var idBefore = self.id
	  chrome.sockets.tcp.getInfo(self.id, function (result) {
	    if (self.id !== idBefore) {
	      ignoreLastError()
	      return
	    }
	    if (chrome.runtime.lastError || !result.connected) {
	      self._onReceiveError(-15) // workaround for https://crbug.com/518161
	    }
	  })
	}

	Socket.prototype._onReceive = function (data) {
	  var self = this
	  // assuming buffer is browser implementation (`buffer` package on npm)
	  var buffer = Buffer._augment(new Uint8Array(data))
	  var offset = self.bytesRead

	  self.bytesRead += buffer.length
	  self._unrefTimer()

	  if (self.ondata) {
	    console.error('socket.ondata = func is non-standard, use socket.on(\'data\', func)')
	    self.ondata(buffer, offset, self.bytesRead)
	  }
	  if (!self.push(buffer)) { // if returns false, then apply backpressure
	    chrome.sockets.tcp.setPaused(self.id, true)
	  }
	}

	Socket.prototype._onReceiveError = function (resultCode) {
	  var self = this
	  if (resultCode === -100) { // net::ERR_CONNECTION_CLOSED
	    if (self.onend) {
	      console.error('socket.onend = func is non-standard, use socket.on(\'end\', func)')
	      self.once('end', self.onend)
	    }
	    self.push(null)
	    self.destroy()
	  } else if (resultCode < 0) {
	    self.destroy(errnoException(resultCode, 'read'))
	  }
	}

	/**
	 * The amount of bytes sent.
	 * @return {number}
	 */
	Object.defineProperty(Socket.prototype, 'bytesWritten', {
	  get: function () {
	    var self = this
	    if (self.id) return self._bytesDispatched + self.bufferSize
	  }
	})

	Socket.prototype.destroy = function (exception) {
	  var self = this
	  self._destroy(exception)
	}

	Socket.prototype._destroy = function (exception, cb) {
	  var self = this

	  function fireErrorCallbacks () {
	    if (cb) cb(exception)
	    if (exception && !self._writableState.errorEmitted) {
	      process.nextTick(function () {
	        self.emit('error', exception)
	      })
	      self._writableState.errorEmitted = true
	    }
	  }

	  if (self.destroyed) {
	    // already destroyed, fire error callbacks
	    fireErrorCallbacks()
	    return
	  }

	  if (self.server) {
	    self.server._connections -= 1
	    if (self.server._emitCloseIfDrained) self.server._emitCloseIfDrained()
	    self.server = null
	  }

	  self._reset()

	  for (var s = self; s !== null; s = s._parent) timers.unenroll(s)

	  self.destroyed = true

	  // If _destroy() has been called before chrome.sockets.tcp.create()
	  // callback, we don't have an id. Therefore we don't need to close
	  // or disconnect
	  if (self.id) {
	    delete sockets[self.id]
	    chrome.sockets.tcp.close(self.id, function () {
	      if (self.destroyed) {
	        self.emit('close', !!exception)
	      }
	    })
	    self.id = null
	  }

	  fireErrorCallbacks()
	}

	Socket.prototype.destroySoon = function () {
	  var self = this

	  if (self.writable) self.end()

	  if (self._writableState.finished) self.destroy()
	}

	/**
	 * Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
	 * By default net.Socket do not have a timeout. When an idle timeout is triggered the
	 * socket will receive a 'timeout' event but the connection will not be severed. The
	 * user must manually end() or destroy() the socket.
	 *
	 * If timeout is 0, then the existing idle timeout is disabled.
	 *
	 * The optional callback parameter will be added as a one time listener for the 'timeout' event.
	 *
	 * @param {number}   timeout
	 * @param {function} callback
	 */
	Socket.prototype.setTimeout = function (timeout, callback) {
	  var self = this

	  if (timeout === 0) {
	    timers.unenroll(self)
	    if (callback) {
	      self.removeListener('timeout', callback)
	    }
	  } else {
	    timers.enroll(self, timeout)
	    timers._unrefActive(self)
	    if (callback) {
	      self.once('timeout', callback)
	    }
	  }
	}

	Socket.prototype._onTimeout = function () {
	  this.emit('timeout')
	}

	Socket.prototype._unrefTimer = function unrefTimer () {
	  for (var s = this; s !== null; s = s._parent) {
	    timers._unrefActive(s)
	  }
	}

	/**
	 * Disables the Nagle algorithm. By default TCP connections use the Nagle
	 * algorithm, they buffer data before sending it off. Setting true for noDelay
	 * will immediately fire off data each time socket.write() is called. noDelay
	 * defaults to true.
	 *
	 * NOTE: The Chrome version of this function is async, whereas the node
	 * version is sync. Keep this in mind.
	 *
	 * @param {boolean} [noDelay] Optional
	 * @param {function} callback CHROME-SPECIFIC: Called when the configuration
	 *                            operation is done.
	 */
	Socket.prototype.setNoDelay = function (noDelay, callback) {
	  var self = this
	  if (self.id) {
	    // backwards compatibility: assume true when `enable` is omitted
	    noDelay = is.isUndefined(noDelay) ? true : !!noDelay
	    chrome.sockets.tcp.setNoDelay(self.id, noDelay, chromeCallbackWrap(callback))
	  }
	}

	/**
	 * Enable/disable keep-alive functionality, and optionally set the initial
	 * delay before the first keepalive probe is sent on an idle socket. enable
	 * defaults to false.
	 *
	 * Set initialDelay (in milliseconds) to set the delay between the last data
	 * packet received and the first keepalive probe. Setting 0 for initialDelay
	 * will leave the value unchanged from the default (or previous) setting.
	 * Defaults to 0.
	 *
	 * NOTE: The Chrome version of this function is async, whereas the node
	 * version is sync. Keep this in mind.
	 *
	 * @param {boolean} [enable] Optional
	 * @param {number} [initialDelay]
	 * @param {function} callback CHROME-SPECIFIC: Called when the configuration
	 *                            operation is done.
	 */
	Socket.prototype.setKeepAlive = function (enable, initialDelay, callback) {
	  var self = this
	  if (self.id) {
	    chrome.sockets.tcp.setKeepAlive(self.id, !!enable, ~~(initialDelay / 1000),
	        chromeCallbackWrap(callback))
	  }
	}

	/**
	 * Returns the bound address, the address family name and port of the socket
	 * as reported by the operating system. Returns an object with three
	 * properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }
	 *
	 * @return {Object} information
	 */
	Socket.prototype.address = function () {
	  var self = this
	  return {
	    address: self.localAddress,
	    port: self.localPort,
	    family: self.localAddress &&
	      self.localAddress.indexOf(':') !== -1 ? 'IPv6' : 'IPv4'
	  }
	}

	Object.defineProperty(Socket.prototype, 'readyState', {
	  get: function () {
	    var self = this
	    if (self._connecting) {
	      return 'opening'
	    } else if (self.readable && self.writable) {
	      return 'open'
	    } else {
	      return 'closed'
	    }
	  }
	})

	Socket.prototype.unref = function () {
	  // No chrome.socket equivalent
	}

	Socket.prototype.ref = function () {
	  // No chrome.socket equivalent
	}

	//
	// EXPORTED HELPERS
	//

	// Source: https://developers.google.com/web/fundamentals/input/form/provide-real-time-validation#use-these-attributes-to-validate-input
	var IPv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
	var IPv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/

	exports.isIPv4 = IPv4Regex.test.bind(IPv4Regex)
	exports.isIPv6 = IPv6Regex.test.bind(IPv6Regex)

	exports.isIP = function (ip) {
	  return exports.isIPv4(ip) ? 4 : exports.isIPv6(ip) ? 6 : 0
	}

	//
	// HELPERS
	//

	/**
	 * Returns an array [options] or [options, cb]
	 * It is the same as the argument of Socket.prototype.connect().
	 */
	function normalizeConnectArgs (args) {
	  var options = {}

	  if (is.isObject(args[0])) {
	    // connect(options, [cb])
	    options = args[0]
	  } else if (isPipeName(args[0])) {
	    // connect(path, [cb])
	    throw new Error('Pipes are not supported in Chrome Apps.')
	  } else {
	    // connect(port, [host], [cb])
	    options.port = args[0]
	    if (is.isString(args[1])) {
	      options.host = args[1]
	    }
	  }

	  var cb = args[args.length - 1]
	  return is.isFunction(cb) ? [options, cb] : [options]
	}

	function toNumber (x) {
	  return (x = Number(x)) >= 0 ? x : false
	}

	function isPipeName (s) {
	  return is.isString(s) && toNumber(s) === false
	}

	 // This prevents "Unchecked runtime.lastError" errors
	function ignoreLastError () {
	  chrome.runtime.lastError // call the getter function
	}

	function chromeCallbackWrap (callback) {
	  return function () {
	    var error
	    if (chrome.runtime.lastError) {
	      console.error(chrome.runtime.lastError.message)
	      error = new Error(chrome.runtime.lastError.message)
	    }
	    if (callback) callback(error)
	  }
	}

	// Full list of possible error codes: https://code.google.com/p/chrome-browser/source/browse/trunk/src/net/base/net_error_list.h
	// TODO: Try to reproduce errors in both node & Chrome Apps and extend this list
	//       (what conditions lead to EPIPE?)
	var errorChromeToUv = {
	  '-10': 'EACCES',
	  '-22': 'EACCES',
	  '-138': 'EACCES',
	  '-147': 'EADDRINUSE',
	  '-108': 'EADDRNOTAVAIL',
	  '-103': 'ECONNABORTED',
	  '-102': 'ECONNREFUSED',
	  '-101': 'ECONNRESET',
	  '-16': 'EEXIST',
	  '-8': 'EFBIG',
	  '-109': 'EHOSTUNREACH',
	  '-4': 'EINVAL',
	  '-23': 'EISCONN',
	  '-6': 'ENOENT',
	  '-13': 'ENOMEM',
	  '-106': 'ENONET',
	  '-18': 'ENOSPC',
	  '-11': 'ENOSYS',
	  '-15': 'ENOTCONN',
	  '-105': 'ENOTFOUND',
	  '-118': 'ETIMEDOUT',
	  '-100': 'EOF'
	}
	function errnoException (err, syscall) {
	  var uvCode = errorChromeToUv[err] || 'UNKNOWN'
	  var message = syscall + ' ' + err
	  if (chrome.runtime.lastError) {
	    message += ' ' + chrome.runtime.lastError.message
	  }
	  message += ' (mapped uv code: ' + uvCode + ')'
	  var e = new Error(message)
	  e.code = e.errno = uvCode
	  // TODO: expose chrome error code; what property name?
	  e.syscall = syscall
	  return e
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2).Buffer))

/***/ },
/* 250 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	function buildBuilder (mqttClient, opts) {
	  var connection;
	  opts.port = opts.port || 8883;
	  opts.host = opts.hostname || opts.host || 'localhost';

	  /**
	   * this should be further investigated
	   * the result is opts.rejectUnauthorized = opts.rejectUnauthorized
	   * do you want to check for undefined and set it to false default ?
	   */
	  /*jshint ignore:start */
	  opts.rejectUnauthorized = !(false === opts.rejectUnauthorized);
	  /*jshint ignore:end */

	  connection = tls.connect(opts);
	  /*eslint no-use-before-define: [2, "nofunc"]*/
	  connection.on('secureConnect', function () {
	    if (opts.rejectUnauthorized && !connection.authorized) {
	      connection.emit('error', new Error('TLS not authorized'));
	    } else {
	      connection.removeListener('error', handleTLSerrors);
	    }
	  });

	  /*
	   * to comply with strict rules, a function must be
	   * declared before it can be used
	   * so i moved it has to be  moved before its first call
	   * later on maybe we can move all of them to the top of the file
	   * for now i just suppressed the warning
	   */
	  /*jshint latedef:false*/
	  function handleTLSerrors (err) {
	    // How can I get verify this error is a tls error?
	    if (opts.rejectUnauthorized) {
	      mqttClient.emit('error', err);
	    }

	    // close this connection to match the behaviour of net
	    // otherwise all we get is an error from the connection
	    // and close event doesn't fire. This is a work around
	    // to enable the reconnect code to work the same as with
	    // net.createConnection
	    connection.end();
	  }
	  /*jshint latedef:false*/

	  connection.on('error', handleTLSerrors);
	  return connection;
	}

	module.exports = buildBuilder;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var websocket = __webpack_require__(254),
	  _URL = __webpack_require__(242);

	function buildBuilder (client, opts) {
	  var wsOpt = {
	      protocol: 'mqttv3.1'
	    },
	    host = opts.hostname || 'localhost',
	    port = String(opts.port || 80),
	    path = opts.path || '/',
	    url = opts.protocol + '://' + host + ':' + port + path;

	  if ('wss' === opts.protocol) {
	    if (opts.hasOwnProperty('rejectUnauthorized')) {
	      wsOpt.rejectUnauthorized = opts.rejectUnauthorized;
	    }
	  }

	  return websocket(url, wsOpt);
	}

	function buildBuilderBrowser (mqttClient, opts) {
	  var url, parsed;
	  if ('undefined' !== typeof (document)) { // for Web Workers! P.S: typeof(document) !== undefined may be becoming the faster one these days.
	    parsed = _URL.parse(document.URL);
	  } else {
	    throw new Error('Could not determine host. Specify host manually.');
	  }

	  if (!opts.protocol) {
	    if ('https:' === parsed.protocol) {
	      opts.protocol = 'wss';
	    } else {
	      opts.protocol = 'ws';
	    }
	  }

	  if (!opts.hostname) {
	    opts.hostname = opts.host;
	  }

	  if (!opts.hostname) {
	    opts.hostname = parsed.hostname;
	    if (!opts.port) {
	      opts.port = parsed.port;
	    }
	  }

	  if (!opts.port) {
	    if ('wss' === opts.protocol) {
	      opts.port = 443;
	    } else {
	      opts.port = 80;
	    }
	  }

	  if (!opts.path) {
	    opts.path = '/';
	  }

	  url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;

	  return websocket(url, 'mqttv3.1');
	}

	if ('browser' !== process.title) {
	  module.exports = buildBuilder;
	} else {
	  module.exports = buildBuilderBrowser;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {var through = __webpack_require__(255)
	var duplexify = __webpack_require__(257)
	var WS = __webpack_require__(273)

	module.exports = WebSocketStream

	function WebSocketStream(target, protocols) {
	  var stream, socket
	  var socketWrite = process.title === 'browser' ? socketWriteBrowser : socketWriteNode
	  var proxy = through(socketWrite, socketEnd)

	  // use existing WebSocket object that was passed in
	  if (typeof target === 'object') {
	    socket = target
	  // otherwise make a new one
	  } else {
	    socket = new WS(target, protocols)
	    socket.binaryType = 'arraybuffer'
	  }

	  // was already open when passed in
	  if (socket.readyState === 1) {
	    stream = proxy
	  } else {
	    stream = duplexify()
	    socket.addEventListener("open", onready)
	  }

	  stream.socket = socket

	  socket.addEventListener("close", onclose)
	  socket.addEventListener("error", onerror)
	  socket.addEventListener("message", onmessage)

	  proxy.on('close', destroy)

	  function socketWriteNode(chunk, enc, next) {
	    socket.send(chunk, next)
	  }

	  function socketWriteBrowser(chunk, enc, next) {
	    try {
	      socket.send(chunk)
	    } catch(err) {
	      return next(err)
	    }

	    next()
	  }

	  function socketEnd(done) {
	    socket.close()
	    done()
	  }

	  function onready() {
	    stream.setReadable(proxy)
	    stream.setWritable(proxy)
	    stream.emit('connect')
	  }

	  function onclose() {
	    stream.end();
	    stream.destroy()
	  }

	  function onerror(err) {
	    stream.destroy(err)
	  }

	  function onmessage(event) {
	    var data = event.data
	    if (data instanceof ArrayBuffer) data = new Buffer(new Uint8Array(data))
	    proxy.push(data)
	  }

	  function destroy() {
	    socket.close()
	  }

	  return stream
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2).Buffer))

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Transform = __webpack_require__(256)
	  , inherits  = __webpack_require__(12).inherits
	  , xtend     = __webpack_require__(247)

	function DestroyableTransform(opts) {
	  Transform.call(this, opts)
	  this._destroyed = false
	}

	inherits(DestroyableTransform, Transform)

	DestroyableTransform.prototype.destroy = function(err) {
	  if (this._destroyed) return
	  this._destroyed = true
	  
	  var self = this
	  process.nextTick(function() {
	    if (err)
	      self.emit('error', err)
	    self.emit('close')
	  })
	}

	// a noop _transform function
	function noop (chunk, enc, callback) {
	  callback(null, chunk)
	}


	// create a new export function, used by both the main export and
	// the .ctor export, contains common logic for dealing with arguments
	function through2 (construct) {
	  return function (options, transform, flush) {
	    if (typeof options == 'function') {
	      flush     = transform
	      transform = options
	      options   = {}
	    }

	    if (typeof transform != 'function')
	      transform = noop

	    if (typeof flush != 'function')
	      flush = null

	    return construct(options, transform, flush)
	  }
	}


	// main export, just make me a transform stream!
	module.exports = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(options)

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


	// make me a reusable prototype that I can `new`, or implicitly `new`
	// with a constructor call
	module.exports.ctor = through2(function (options, transform, flush) {
	  function Through2 (override) {
	    if (!(this instanceof Through2))
	      return new Through2(override)

	    this.options = xtend(options, override)

	    DestroyableTransform.call(this, this.options)
	  }

	  inherits(Through2, DestroyableTransform)

	  Through2.prototype._transform = transform

	  if (flush)
	    Through2.prototype._flush = flush

	  return Through2
	})


	module.exports.obj = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(230)


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {var stream = __webpack_require__(258)
	var eos = __webpack_require__(270)
	var util = __webpack_require__(12)

	var SIGNAL_FLUSH = new Buffer([0])

	var onuncork = function(self, fn) {
	  if (self._corked) self.once('uncork', fn)
	  else fn()
	}

	var destroyer = function(self, end) {
	  return function(err) {
	    if (err) self.destroy(err.message === 'premature close' ? null : err)
	    else if (end && !self._ended) self.end()
	  }
	}

	var end = function(ws, fn) {
	  if (!ws) return fn()
	  if (ws._writableState && ws._writableState.finished) return fn()
	  if (ws._writableState) return ws.end(fn)
	  ws.end()
	  fn()
	}

	var toStreams2 = function(rs) {
	  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
	}

	var Duplexify = function(writable, readable, opts) {
	  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
	  stream.Duplex.call(this, opts)

	  this._writable = null
	  this._readable = null
	  this._readable2 = null

	  this._forwardDestroy = !opts || opts.destroy !== false
	  this._forwardEnd = !opts || opts.end !== false
	  this._corked = 1 // start corked
	  this._ondrain = null
	  this._drained = false
	  this._forwarding = false
	  this._unwrite = null
	  this._unread = null
	  this._ended = false

	  this.destroyed = false

	  if (writable) this.setWritable(writable)
	  if (readable) this.setReadable(readable)
	}

	util.inherits(Duplexify, stream.Duplex)

	Duplexify.obj = function(writable, readable, opts) {
	  if (!opts) opts = {}
	  opts.objectMode = true
	  opts.highWaterMark = 16
	  return new Duplexify(writable, readable, opts)
	}

	Duplexify.prototype.cork = function() {
	  if (++this._corked === 1) this.emit('cork')
	}

	Duplexify.prototype.uncork = function() {
	  if (this._corked && --this._corked === 0) this.emit('uncork')
	}

	Duplexify.prototype.setWritable = function(writable) {
	  if (this._unwrite) this._unwrite()

	  if (this.destroyed) {
	    if (writable && writable.destroy) writable.destroy()
	    return
	  }

	  if (writable === null || writable === false) {
	    this.end()
	    return
	  }

	  var self = this
	  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

	  var ondrain = function() {
	    var ondrain = self._ondrain
	    self._ondrain = null
	    if (ondrain) ondrain()
	  }

	  var clear = function() {
	    self._writable.removeListener('drain', ondrain)
	    unend()
	  }

	  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

	  this._writable = writable
	  this._writable.on('drain', ondrain)
	  this._unwrite = clear

	  this.uncork() // always uncork setWritable
	}

	Duplexify.prototype.setReadable = function(readable) {
	  if (this._unread) this._unread()

	  if (this.destroyed) {
	    if (readable && readable.destroy) readable.destroy()
	    return
	  }

	  if (readable === null || readable === false) {
	    this.push(null)
	    this.resume()
	    return
	  }

	  var self = this
	  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

	  var onreadable = function() {
	    self._forward()
	  }

	  var onend = function() {
	    self.push(null)
	  }

	  var clear = function() {
	    self._readable2.removeListener('readable', onreadable)
	    self._readable2.removeListener('end', onend)
	    unend()
	  }

	  this._drained = true
	  this._readable = readable
	  this._readable2 = readable._readableState ? readable : toStreams2(readable)
	  this._readable2.on('readable', onreadable)
	  this._readable2.on('end', onend)
	  this._unread = clear

	  this._forward()
	}

	Duplexify.prototype._read = function() {
	  this._drained = true
	  this._forward()
	}

	Duplexify.prototype._forward = function() {
	  if (this._forwarding || !this._readable2 || !this._drained) return
	  this._forwarding = true

	  var data
	  var state = this._readable2._readableState

	  while ((data = this._readable2.read(state.buffer.length ? state.buffer[0].length : state.length)) !== null) {
	    this._drained = this.push(data)
	  }

	  this._forwarding = false
	}

	Duplexify.prototype.destroy = function(err) {
	  if (this.destroyed) return
	  this.destroyed = true

	  var self = this
	  process.nextTick(function() {
	    self._destroy(err)
	  })
	}

	Duplexify.prototype._destroy = function(err) {
	  if (err) {
	    var ondrain = this._ondrain
	    this._ondrain = null
	    if (ondrain) ondrain(err)
	    else this.emit('error', err)
	  }

	  if (this._forwardDestroy) {
	    if (this._readable && this._readable.destroy) this._readable.destroy()
	    if (this._writable && this._writable.destroy) this._writable.destroy()
	  }

	  this.emit('close')
	}

	Duplexify.prototype._write = function(data, enc, cb) {
	  if (this.destroyed) return cb()
	  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
	  if (data === SIGNAL_FLUSH) return this._finish(cb)
	  if (!this._writable) return cb()

	  if (this._writable.write(data) === false) this._ondrain = cb
	  else cb()
	}


	Duplexify.prototype._finish = function(cb) {
	  var self = this
	  this.emit('preend')
	  onuncork(this, function() {
	    end(self._forwardEnd && self._writable, function() {
	      // haxx to not emit prefinish twice
	      if (self._writableState.prefinished === false) self._writableState.prefinished = true
	      self.emit('prefinish')
	      onuncork(self, cb)
	    })
	  })
	}

	Duplexify.prototype.end = function(data, enc, cb) {
	  if (typeof data === 'function') return this.end(null, null, data)
	  if (typeof enc === 'function') return this.end(data, null, enc)
	  this._ended = true
	  if (data) this.write(data)
	  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
	  return stream.Writable.prototype.end.call(this, cb)
	}

	module.exports = Duplexify
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer, __webpack_require__(1)))

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = (function (){
	  try {
	    return __webpack_require__(207); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(259);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(265);
	exports.Duplex = __webpack_require__(264);
	exports.Transform = __webpack_require__(268);
	exports.PassThrough = __webpack_require__(269);


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(260);
	/*</replacement>*/


	/*<replacement>*/
	var isArray = __webpack_require__(261);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(8).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/



	/*<replacement>*/
	var Stream;
	(function (){try{
	  Stream = __webpack_require__(207);
	}catch(_){}finally{
	  if (!Stream)
	    Stream = __webpack_require__(8).EventEmitter;
	}}())
	/*</replacement>*/

	var Buffer = __webpack_require__(2).Buffer;

	/*<replacement>*/
	var util = __webpack_require__(262);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/



	/*<replacement>*/
	var debug = __webpack_require__(263);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(264);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(267).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(264);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function')
	    this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function() {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(267).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else {
	      return state.length;
	    }
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (ret !== null)
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!(Buffer.isBuffer(chunk)) &&
	      typeof chunk !== 'string' &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      processNextTick(emitReadable_, stream);
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    processNextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }; }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	module.exports = nextTick;

	function nextTick(fn) {
	  var args = new Array(arguments.length - 1);
	  var i = 0;
	  while (i < arguments.length) {
	    args[i++] = arguments[i];
	  }
	  process.nextTick(function afterTick() {
	    fn.apply(null, args);
	  });
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 261 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 263 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(260);
	/*</replacement>*/



	/*<replacement>*/
	var util = __webpack_require__(262);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	var Readable = __webpack_require__(259);
	var Writable = __webpack_require__(265);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(260);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(262);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/



	/*<replacement>*/
	var Stream;
	(function (){try{
	  Stream = __webpack_require__(207);
	}catch(_){}finally{
	  if (!Stream)
	    Stream = __webpack_require__(8).EventEmitter;
	}}())
	/*</replacement>*/

	var Buffer = __webpack_require__(2).Buffer;

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(264);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function (){try {
	Object.defineProperty(WritableState.prototype, 'buffer', {
	  get: __webpack_require__(266)(function() {
	    return this.getBuffer();
	  }, '_writableState.buffer is deprecated. Use ' +
	      '_writableState.getBuffer() instead.')
	});
	}catch(_){}}());


	function Writable(options) {
	  var Duplex = __webpack_require__(264);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function')
	      this._write = options.write;

	    if (typeof options.writev === 'function')
	      this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;

	  if (!(Buffer.isBuffer(chunk)) &&
	      typeof chunk !== 'string' &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = nop;

	  if (state.ended)
	    writeAfterEnd(this, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.bufferedRequest)
	      clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string')
	    encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
	'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
	.indexOf((encoding + '').toLowerCase()) > -1))
	    throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync)
	    processNextTick(cb, er);
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      processNextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var buffer = [];
	    var cbs = [];
	    while (entry) {
	      cbs.push(entry.callback);
	      buffer.push(entry);
	      entry = entry.next;
	    }

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    doWrite(stream, state, true, state.length, buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null)
	      state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined)
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(state) {
	  return (state.ending &&
	          state.length === 0 &&
	          state.bufferedRequest === null &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      processNextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 266 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  if (!global.localStorage) return false;
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(2).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(264);

	/*<replacement>*/
	var util = __webpack_require__(262);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function')
	      this._transform = options.transform;

	    if (typeof options.flush === 'function')
	      this._flush = options.flush;
	  }

	  this.once('prefinish', function() {
	    if (typeof this._flush === 'function')
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(268);

	/*<replacement>*/
	var util = __webpack_require__(262);
	util.inherits = __webpack_require__(226);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var once = __webpack_require__(271);

	var noop = function() {};

	var isRequest = function(stream) {
		return stream.setHeader && typeof stream.abort === 'function';
	};

	var eos = function(stream, opts, callback) {
		if (typeof opts === 'function') return eos(stream, null, opts);
		if (!opts) opts = {};

		callback = once(callback || noop);

		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || (opts.readable !== false && stream.readable);
		var writable = opts.writable || (opts.writable !== false && stream.writable);

		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};

		var onfinish = function() {
			writable = false;
			if (!readable) callback();
		};

		var onend = function() {
			readable = false;
			if (!writable) callback();
		};

		var onclose = function() {
			if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
			if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
		};

		var onrequest = function() {
			stream.req.on('finish', onfinish);
		};

		if (isRequest(stream)) {
			stream.on('complete', onfinish);
			stream.on('abort', onclose);
			if (stream.req) onrequest();
			else stream.on('request', onrequest);
		} else if (writable && !ws) { // legacy streams
			stream.on('end', onlegacyfinish);
			stream.on('close', onlegacyfinish);
		}

		stream.on('end', onend);
		stream.on('finish', onfinish);
		if (opts.error !== false) stream.on('error', callback);
		stream.on('close', onclose);

		return function() {
			stream.removeListener('complete', onfinish);
			stream.removeListener('abort', onclose);
			stream.removeListener('request', onrequest);
			if (stream.req) stream.req.removeListener('finish', onfinish);
			stream.removeListener('end', onlegacyfinish);
			stream.removeListener('close', onlegacyfinish);
			stream.removeListener('finish', onfinish);
			stream.removeListener('end', onend);
			stream.removeListener('error', callback);
			stream.removeListener('close', onclose);
		};
	};

	module.exports = eos;

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(272)
	module.exports = wrappy(once)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}


/***/ },
/* 272 */
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 273 */
/***/ function(module, exports) {

	
	/**
	 * Module dependencies.
	 */

	var global = (function() { return this; })();

	/**
	 * WebSocket constructor.
	 */

	var WebSocket = global.WebSocket || global.MozWebSocket;

	/**
	 * Module exports.
	 */

	module.exports = WebSocket ? ws : null;

	/**
	 * WebSocket constructor.
	 *
	 * The third `opts` options object gets ignored in web browsers, since it's
	 * non-standard, and throws a TypeError if passed to the constructor.
	 * See: https://github.com/einaros/ws/issues/227
	 *
	 * @param {String} uri
	 * @param {Array} protocols (optional)
	 * @param {Object) opts (optional)
	 * @api public
	 */

	function ws(uri, protocols, opts) {
	  var instance;
	  if (protocols) {
	    instance = new WebSocket(uri, protocols);
	  } else {
	    instance = new WebSocket(uri);
	  }
	  return instance;
	}

	if (WebSocket) ws.prototype = WebSocket.prototype;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var util = __webpack_require__(12);
	var stream = __webpack_require__(207);


	function MQTTSerialPort(options) {
	  this.client = options.client;
	  this.receiveTopic = options.receiveTopic;
	  this.transmitTopic = options.transmitTopic;
	  this.qos = options.qos || 0;

	  this.buffer = null;
	  this.lastCheck = 0;
	  this.lastSend = 0;
	  this.base64 = options.base64 || false;

	  var self = this;

	  this.client.subscribe(this.receiveTopic, {qos: this.qos});

	  this.client.on('message', function(topic, data){
	    try{
	      if(topic === self.receiveTopic){
	        if(self.base64){
	          self.emit('data', new Buffer(data.toString(), 'base64'));
	        }else{
	          self.emit('data', data);
	        }
	      }

	    }catch(exp){
	      console.log('error on message', exp);
	      //self.emit('error', 'error receiving message: ' + exp);
	    }
	  });

	}

	util.inherits(MQTTSerialPort, stream.Stream);


	MQTTSerialPort.prototype.open = function (callback) {
	  this.emit('open');
	  if (callback) {
	    callback();
	  }

	};



	MQTTSerialPort.prototype.write = function (data, callback) {


	  if (!Buffer.isBuffer(data)) {
	    data = new Buffer(data);
	  }

	  if(this.base64){
	    data = data.toString('base64');
	  }

	  this.client.publish(this.transmitTopic, data, {qos: this.qos});
	};



	MQTTSerialPort.prototype.close = function (callback) {
	  console.log('closing');
	  if(this.client){
	    this.client.end();
	  }
	  if(callback){
	    callback();
	  }
	};

	MQTTSerialPort.prototype.flush = function (callback) {
	  console.log('flush');
	  if(callback){
	    callback();
	  }
	};

	MQTTSerialPort.prototype.drain = function (callback) {
	  console.log('drain');
	  if(callback){
	    callback();
	  }
	};


	function bindPhysical(options){
	  var client = options.client;
	  var serialPort = options.serialPort;
	  var receiveTopic = options.receiveTopic;
	  var transmitTopic = options.transmitTopic;
	  var qos = options.qos || 0;
	  var useBase64 = options.base64 || false;

	  function serialWrite(data){
	    try{
	      if(useBase64){
	        data = new Buffer(data.toString(), 'base64');
	      }
	      console.log('writing to serialPort', data);
	      serialPort.write(data);
	    }catch(exp){
	      console.log('error reading message', exp);
	    }
	  }

	  client.subscribe(receiveTopic, {qos: qos});

	  serialPort.on('data', function(data){
	    if (!Buffer.isBuffer(data)) {
	      data = new Buffer(data);
	    }

	    if(useBase64){
	      data = data.toString('base64');
	    }

	    client.publish(transmitTopic, data, {qos: qos});
	  });


	  client.on('message', function(topic, data, packet){
	    try{
	      if(topic === receiveTopic){
	        serialWrite(data);
	      }
	    }catch(exp){
	      console.log('error on message', exp);
	      //self.emit('error', 'error receiving message: ' + exp);
	    }
	  });


	}


	module.exports = {
	  SerialPort: MQTTSerialPort,
	  bindPhysical: bindPhysical
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Defines a set of WS2812 LED Pixels for use

	// TODO:
	//
	// Pixels can be arranged into different structures // NICE TO HAVE
	// Do we want to call it strip and pixels? 
	// Do we have a grid which can be 1D, 2D or 3D and any size
	// Pixels needs to have a length, various deets on where it is (clock etc)
	// Pixels can be on a single pin or separate ones (possible with I2C as well)
	// Deal with different pixel types
	// Keyframing // NICE TO HAVE
	// Pixel grid should be able to:
	//      - Set pixels in a range from X->Y a colour
	//
	//
	__webpack_require__(276);

	var ColorString = __webpack_require__(277); // used for color parsing
	var events = __webpack_require__(8);
	var util = __webpack_require__(12);


	// create a helper to output an int so messages can be shorter
	ColorString.colorValue = function colorValue (colors) {
	    // colors are assumed to be an array of [r, g, b] bytes
	    // colorValue returns a packed value able to be pushed to firmata rather than
	    // text values.

	    return ((colors[0] << 16) + (colors[1] << 8) + (colors[2]));
	}

	// CONSTANTS
	var START_SYSEX =   0xF0,
	STRING_DATA =       0x71,
	END_SYSEX =         0xF7,
	FIRMATA_7BIT_MASK = 0x7F,
	PIXEL_COMMAND =     0x51,
	PIXEL_OFF =         0x00,
	PIXEL_CONFIG =      0x01,
	PIXEL_SHOW =        0x02,
	PIXEL_SET_PIXEL =   0x03,        
	PIXEL_SET_STRIP =   0x04;

	var PIN_DEFAULT = 6; // use this if not supplied

	var I2C_DEFAULT =   0x42; 

	var Controllers = {
	    FIRMATA: {
	        initialize: {
	            value: function(opts) {

	                var strip_length = opts.length || 6; // just an arbitrary val
	                var data_pin = opts.data || DEFAULT_PIN; 
	                var firmata = opts.firmata || opts.board.io;

	                if (firmata == undefined) {
	                    throw "Either a firmata object or board object is required";
	                }

	                var pixels = [];

	                for (var i=0; i< strip_length; i++) {
	                    pixels.push(new Pixel({
	                        addr: i,
	                        firmata: firmata,
	                        controller: "FIRMATA"
	                    }) );
	                }

	                if (opts.board != undefined && opts.board.io.name != "Firmata") {
	                    throw "Node Pixel FIRMATA controller only supports firmata boards";
	                    return;
	                }

	                strips.set(this, {
	                    pixels: pixels,
	                    data: 6,
	                    firmata: firmata,
	                });

	                // now send the config message with length and data point.
	                var data   = [];

	                data[0] = START_SYSEX;
	                data[1] = PIXEL_COMMAND;
	                data[2] = PIXEL_CONFIG;
	                data[3] = data_pin;
	                data[4] = strip_length & FIRMATA_7BIT_MASK;
	                data[5] = (strip_length >> 7) & FIRMATA_7BIT_MASK;
	                data[6] = END_SYSEX;

	                firmata.sp.write(new Buffer(data), function(error, res) {
	                    var err = null;
	                    if (error) {
	                        err = error;
	                        this.emit("error", err);
	                    }
	                    this.emit("ready", err);

	                }.bind(this) );
	            },
	        },
	        show: {
	            value: function() {

	                // call the frame on the strip.
	                var strip = strips.get(this);

	                var data   = [];
	                data[0] = START_SYSEX;
	                data[1] = PIXEL_COMMAND;
	                data[2] = PIXEL_SHOW;
	                data[3] = END_SYSEX;

	                // now just write that to the serialport and it should show the frame.
	                strip.firmata.sp.write(new Buffer(data));
	            },
	        },
	        strip_color: {
	            value: function(color) {
	                // colour work is already done this just sets it the appropriate
	                // way.
	                var strip = strips.get(this);
	                var data   = [];

	                data[0] = START_SYSEX;
	                data[1] = PIXEL_COMMAND;
	                data[2] = PIXEL_SET_STRIP;
	                data[3] = color & FIRMATA_7BIT_MASK;
	                data[4] = (color >> 7) & FIRMATA_7BIT_MASK;
	                data[5] = (color >> 14) & FIRMATA_7BIT_MASK;
	                data[6] = (color >> 21) & FIRMATA_7BIT_MASK;
	                data[7] = END_SYSEX;

	                strip.firmata.sp.write(new Buffer(data));
	            },
	        },
	    },
	    I2CBACKPACK: {
	        initialize: {
	            value: function(opts) {

	                var strip_length = opts.length || 6; // just an arbitrary val

	                var io = opts.firmata || opts.board.io;
	                var i2caddr = opts.address || I2C_DEFAULT;
	                if (io == undefined) {
	                    throw "An IO object is required to I2C controller";
	                }

	                var pixels = [];

	                for (var i=0; i< strip_length; i++) {
	                    pixels.push(new Pixel({
	                        addr: i,
	                        io: io,
	                        controller: "I2CBACKPACK",
	                        i2c_address: i2caddr,
	                    }) );
	                }

	                strips.set(this, {
	                    pixels: pixels,
	                    io: io,
	                    i2c_address: i2caddr,
	                });

	                // send the I2C config message.
	                io.i2cConfig();
	                process.nextTick(function() {
	                    this.emit("ready", null)
	                }.bind(this) );
	            },
	        },
	        show: {
	            value: function() {

	                var strip = strips.get(this);
	                strip.io.i2cWrite(strip.i2c_address, [PIXEL_SHOW]);
	            },
	        },
	        strip_color: {
	            value: function(color) {
	                var strip = strips.get(this);
	                var data   = [];

	                data[0] = PIXEL_SET_STRIP;

	                data[1] = color & FIRMATA_7BIT_MASK;
	                data[2] = (color >> 7) & FIRMATA_7BIT_MASK;
	                data[3] = (color >> 14) & FIRMATA_7BIT_MASK;
	                data[4] = (color >> 21) & FIRMATA_7BIT_MASK;

	                strip.io.i2cWrite(strip.i2c_address, data);
	            },
	        },
	    },
	};


	var strips = new WeakMap();

	function Strip(opts) {

	    // opts contains an object with.
	    // data: data pin for the pixel strip
	    // board: johnny five board object.
	    // controller: controller type to use
	    // firmata: actual firmata object if preferred
	    // length: length of the pixel strip.

	    if (!(this instanceof Strip)) {
	        return new Strip(opts);
	    }

	    var controller;

	    if (typeof opts.controller === "string") {
	        controller = Controllers[opts.controller];
	    } else {
	        controller = opts.controller || Controllers["FIRMATA"];
	    }

	    Object.defineProperties(this, controller);

	    if (typeof this.initialize === "function") {
	        this.initialize(opts);
	    }

	}

	util.inherits(Strip, events.EventEmitter);

	Strip.prototype.pixel = function(addr) {
	    var strip = strips.get(this);

	    return strip.pixels[addr];
	};

	Strip.prototype.color = function(color, opts) {
	    // sets the color of the entire strip
	    // use a particular form to set the color either
	    // color = hex value or named colors
	    // or set color null and set opt which is an object as {rgb: [rx, gx, bx]}
	    // values where x is an 8-bit value (0-255);
	    var strip = strips.get(this);

	    var stripcolor = null;

	    if (color) { 
	        // use text to determine the color
	        stripcolor = ColorString.getRgb(color) || null;

	    } else if (opts) {
	        // use rgb array to determine color
	        stripcolor = opts.rgb || null;
	    }

	    if (stripcolor != null) {
	        // fill out the values for the pixels and then update the strip

	        for (var i = 0; i < strip.pixels.length; i++) {
	            strip.pixels[i].color(color, {sendmsg: false});
	        }

	        color = ColorString.colorValue(stripcolor);

	        this.strip_color(color);

	    } else {
	        console.log("color supplied couldn't be parsed: " + stripcolor);
	    }
	}


	Strip.prototype.stripLength = function() {
	    // gets the number of pixels in the strip
	    var strip = strips.get(this);
	    return (strip.pixels.length);
	}

	var pixels = new WeakMap();

	// controllers for the pixel side as well.
	var Pixel_Controllers = {
	    FIRMATA: {
	        initialize: {
	            value: function(opts) {
	                // initialises the base object
	            
	                var pixel = {
	                    addr: opts.addr,
	                    color: {
	                        r: 0, g: 0, b: 0, hexcode: "#000000", color: "black", rgb: [0,0,0],
	                    },
	                    firmata: opts.firmata,
	                };

	                return pixel;
	            },
	        },
	        pixel_color: {
	            value: function(color) {
	                // sets the actual pixel colour
	                var pixel = pixels.get(this);

	                var data   = [];

	                data.push(START_SYSEX);
	                data.push(PIXEL_COMMAND);
	                data.push(PIXEL_SET_PIXEL);
	                data.push(pixel.addr & FIRMATA_7BIT_MASK);
	                data.push((pixel.addr >> 7) & FIRMATA_7BIT_MASK);
	                data.push(color & FIRMATA_7BIT_MASK);
	                data.push((color >> 7) & FIRMATA_7BIT_MASK);
	                data.push((color >> 14) & FIRMATA_7BIT_MASK);
	                data.push((color >> 21) & FIRMATA_7BIT_MASK);
	                data.push(END_SYSEX);

	                pixel.firmata.sp.write(new Buffer(data));
	            },
	        },
	    },
	    I2CBACKPACK: {
	        initialize: {
	            value: function(opts) {
	                // initialises the base object
	            
	                var pixel = {
	                    addr: opts.addr,
	                    color: {
	                        r: 0, g: 0, b: 0, hexcode: "#000000", color: "black", rgb: [0,0,0],
	                    },
	                    io: opts.io,
	                    i2c_address: opts.i2c_address,
	                };

	                return pixel;
	            },
	        },
	        pixel_color: {
	            value: function(color) {
	                // sets the actual pixel colour
	                var pixel = pixels.get(this);

	                var data   = [];

	                data.push(PIXEL_SET_PIXEL);
	                data.push(pixel.addr & FIRMATA_7BIT_MASK);
	                data.push((pixel.addr >> 7) & FIRMATA_7BIT_MASK);
	                data.push(color & FIRMATA_7BIT_MASK);
	                data.push((color >> 7) & FIRMATA_7BIT_MASK);
	                data.push((color >> 14) & FIRMATA_7BIT_MASK);
	                data.push((color >> 21) & FIRMATA_7BIT_MASK);

	                pixel.io.i2cWrite(pixel.i2c_address, data);
	            },
	        },
	    },
	};


	function Pixel(opts) {

	    if (!(this instanceof Pixel)) {
	        return new Pixel(opts);
	    }

	    var controller;

	    if (typeof opts.controller === "string") {
	        controller = Pixel_Controllers[opts.controller];
	    } else {
	        controller = opts.controller || Pixel_Controllers["FIRMATA"];
	    }

	    Object.defineProperties(this, controller);

	    pixels.set(this, this.initialize(opts));
	}

	Pixel.prototype.color = function(color, opts) {
	    // use a particular form to set the color either
	    // color = hex value or named colors
	    // or set color null and set opt which is an object as {r:x, g:x, b:x}
	    // values where x is an 8-bit value (0-255);
	    // opts can contain _sendmsg_ as bool. If set to false message won't be
	    // sent to firmata - useful for strip level updates to keep message choke down

	    var pixel = pixels.get(this);

	    var options = opts || {};
	    var sendmsg = true;
	    if (options.sendmsg != undefined) { sendmsg = options.sendmsg; }

	    var pixelcolor = null;
	    if (color) {
	        // get the color based on a string
	        pixelcolor = ColorString.getRgb(color) || null;
	    } else if (opts) {
	        // set using rgb value
	        pixelcolor = options.rgb || null;
	    } else {
	        return pixel.color;
	    }

	    if (pixelcolor != null) {
	        // fill out the values for the pixel and then send the message to update
	        // it on the strip

	        with (pixel.color) {
	            r = pixelcolor[0];
	            g = pixelcolor[1];
	            b = pixelcolor[2];
	            hexcode = ColorString.hexString(pixelcolor);
	            color = ColorString.keyword(pixelcolor);
	            rgb = pixelcolor;
	        }

	        color = ColorString.colorValue(pixelcolor);
	        if (sendmsg) {
	            this.pixel_color(color);
	        }
	    } else {
	        console.log("color supplied couldn't be parsed: " + pixelcolor);
	    }
	};

	module.exports = { Strip: Strip};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer, __webpack_require__(1)))

/***/ },
/* 276 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function (exports) {'use strict';
	  //shared pointer
	  var i;
	  //shortcuts
	  var defineProperty = Object.defineProperty, is = function(a,b) { return isNaN(a)? isNaN(b): a === b; };


	  //Polyfill global objects
	  if (typeof WeakMap == 'undefined') {
	    exports.WeakMap = createCollection({
	      // WeakMap#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // WeakMap#clear():
	      clear: sharedClear,
	      // WeakMap#get(key:void*):void*
	      get: sharedGet,
	      // WeakMap#has(key:void*):boolean
	      has: mapHas,
	      // WeakMap#set(key:void*, value:void*):void
	      set: sharedSet
	    }, true);
	  }

	  if (typeof Map == 'undefined' || !(new Map).values().next) {
	    exports.Map = createCollection({
	      // WeakMap#delete(key:void*):boolean
	      'delete': sharedDelete,
	      //:was Map#get(key:void*[, d3fault:void*]):void*
	      // Map#has(key:void*):boolean
	      has: mapHas,
	      // Map#get(key:void*):boolean
	      get: sharedGet,
	      // Map#set(key:void*, value:void*):void
	      set: sharedSet,
	      // Map#keys(void):Iterator
	      keys: sharedKeys,
	      // Map#values(void):Iterator
	      values: sharedValues,
	      // Map#entries(void):Iterator
	      entries: mapEntries,
	      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
	      forEach: sharedForEach,
	      // Map#clear():
	      clear: sharedClear
	    });
	  }

	  if (typeof Set == 'undefined' || !(new Set).values().next) {
	    exports.Set = createCollection({
	      // Set#has(value:void*):boolean
	      has: setHas,
	      // Set#add(value:void*):boolean
	      add: sharedAdd,
	      // Set#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // Set#clear():
	      clear: sharedClear,
	      // Set#keys(void):Iterator
	      keys: sharedValues, // specs actually say "the same function object as the initial value of the values property"
	      // Set#values(void):Iterator
	      values: sharedValues,
	      // Set#entries(void):Iterator
	      entries: setEntries,
	      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
	      forEach: sharedForEach
	    });
	  }

	  if (typeof WeakSet == 'undefined') {
	    exports.WeakSet = createCollection({
	      // WeakSet#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // WeakSet#add(value:void*):boolean
	      add: sharedAdd,
	      // WeakSet#clear():
	      clear: sharedClear,
	      // WeakSet#has(value:void*):boolean
	      has: setHas
	    }, true);
	  }


	  /**
	   * ES6 collection constructor
	   * @return {Function} a collection class
	   */
	  function createCollection(proto, objectOnly){
	    function Collection(a){
	      if (!this || this.constructor !== Collection) return new Collection(a);
	      this._keys = [];
	      this._values = [];
	      this._itp = []; // iteration pointers
	      this.objectOnly = objectOnly;

	      //parse initial iterable argument passed
	      if (a) init.call(this, a);
	    }

	    //define size for non object-only collections
	    if (!objectOnly) {
	      defineProperty(proto, 'size', {
	        get: sharedSize
	      });
	    }

	    //set prototype
	    proto.constructor = Collection;
	    Collection.prototype = proto;

	    return Collection;
	  }


	  /** parse initial iterable argument passed */
	  function init(a){
	    var i;
	    //init Set argument, like `[1,2,3,{}]`
	    if (this.add)
	      a.forEach(this.add, this);
	    //init Map argument like `[[1,2], [{}, 4]]`
	    else
	      a.forEach(function(a){this.set(a[0],a[1])}, this);
	  }


	  /** delete */
	  function sharedDelete(key) {
	    if (this.has(key)) {
	      this._keys.splice(i, 1);
	      this._values.splice(i, 1);
	      // update iteration pointers
	      this._itp.forEach(function(p) { if (i < p[0]) p[0]--; });
	    }
	    // Aurora here does it while Canary doesn't
	    return -1 < i;
	  };

	  function sharedGet(key) {
	    return this.has(key) ? this._values[i] : undefined;
	  }

	  function has(list, key) {
	    if (this.objectOnly && key !== Object(key))
	      throw new TypeError("Invalid value used as weak collection key");
	    //NaN or 0 passed
	    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);){}
	    else i = list.indexOf(key);
	    return -1 < i;
	  }

	  function setHas(value) {
	    return has.call(this, this._values, value);
	  }

	  function mapHas(value) {
	    return has.call(this, this._keys, value);
	  }

	  /** @chainable */
	  function sharedSet(key, value) {
	    this.has(key) ?
	      this._values[i] = value
	      :
	      this._values[this._keys.push(key) - 1] = value
	    ;
	    return this;
	  }

	  /** @chainable */
	  function sharedAdd(value) {
	    if (!this.has(value)) this._values.push(value);
	    return this;
	  }

	  function sharedClear() {
	    this._values.length = 0;
	  }

	  /** keys, values, and iterate related methods */
	  function sharedKeys() {
	    return sharedIterator(this._itp, this._keys);
	  }

	  function sharedValues() {
	    return sharedIterator(this._itp, this._values);
	  }

	  function mapEntries() {
	    return sharedIterator(this._itp, this._keys, this._values);
	  }

	  function setEntries() {
	    return sharedIterator(this._itp, this._values, this._values);
	  }

	  function sharedIterator(itp, array, array2) {
	    var p = [0], done = false;
	    itp.push(p);
	    return {
	      next: function() {
	        var v, k = p[0];
	        if (!done && k < array.length) {
	          v = array2 ? [array[k], array2[k]]: array[k];
	          p[0]++;
	        } else {
	          done = true;
	          itp.splice(itp.indexOf(p), 1);
	        }
	        return { done: done, value: v };
	      }
	    };
	  }

	  function sharedSize() {
	    return this._values.length;
	  }

	  function sharedForEach(callback, context) {
	    var it = this.entries();
	    for (;;) {
	      var r = it.next();
	      if (r.done) break;
	      callback.call(context, r.value[1], r.value[0], this);
	    }
	  }

	})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window );

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/* MIT license */
	var colorNames = __webpack_require__(278);

	module.exports = {
	   getRgba: getRgba,
	   getHsla: getHsla,
	   getRgb: getRgb,
	   getHsl: getHsl,
	   getHwb: getHwb,
	   getAlpha: getAlpha,

	   hexString: hexString,
	   rgbString: rgbString,
	   rgbaString: rgbaString,
	   percentString: percentString,
	   percentaString: percentaString,
	   hslString: hslString,
	   hslaString: hslaString,
	   hwbString: hwbString,
	   keyword: keyword
	}

	function getRgba(string) {
	   if (!string) {
	      return;
	   }
	   var abbr =  /^#([a-fA-F0-9]{3})$/,
	       hex =  /^#([a-fA-F0-9]{6})$/,
	       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
	       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
	       keyword = /(\D+)/;

	   var rgb = [0, 0, 0],
	       a = 1,
	       match = string.match(abbr);
	   if (match) {
	      match = match[1];
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match[i] + match[i], 16);
	      }
	   }
	   else if (match = string.match(hex)) {
	      match = match[1];
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
	      }
	   }
	   else if (match = string.match(rgba)) {
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match[i + 1]);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(per)) {
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(keyword)) {
	      if (match[1] == "transparent") {
	         return [0, 0, 0, 0];
	      }
	      rgb = colorNames[match[1]];
	      if (!rgb) {
	         return;
	      }
	   }

	   for (var i = 0; i < rgb.length; i++) {
	      rgb[i] = scale(rgb[i], 0, 255);
	   }
	   if (!a && a != 0) {
	      a = 1;
	   }
	   else {
	      a = scale(a, 0, 1);
	   }
	   rgb[3] = a;
	   return rgb;
	}

	function getHsla(string) {
	   if (!string) {
	      return;
	   }
	   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hsl);
	   if (match) {
	      var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          s = scale(parseFloat(match[2]), 0, 100),
	          l = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, s, l, a];
	   }
	}

	function getHwb(string) {
	   if (!string) {
	      return;
	   }
	   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hwb);
	   if (match) {
	    var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          w = scale(parseFloat(match[2]), 0, 100),
	          b = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, w, b, a];
	   }
	}

	function getRgb(string) {
	   var rgba = getRgba(string);
	   return rgba && rgba.slice(0, 3);
	}

	function getHsl(string) {
	  var hsla = getHsla(string);
	  return hsla && hsla.slice(0, 3);
	}

	function getAlpha(string) {
	   var vals = getRgba(string);
	   if (vals) {
	      return vals[3];
	   }
	   else if (vals = getHsla(string)) {
	      return vals[3];
	   }
	   else if (vals = getHwb(string)) {
	      return vals[3];
	   }
	}

	// generators
	function hexString(rgb) {
	   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
	              + hexDouble(rgb[2]);
	}

	function rgbString(rgba, alpha) {
	   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
	      return rgbaString(rgba, alpha);
	   }
	   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
	}

	function rgbaString(rgba, alpha) {
	   if (alpha === undefined) {
	      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
	   }
	   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
	           + ", " + alpha + ")";
	}

	function percentString(rgba, alpha) {
	   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
	      return percentaString(rgba, alpha);
	   }
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);

	   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
	}

	function percentaString(rgba, alpha) {
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);
	   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
	}

	function hslString(hsla, alpha) {
	   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
	      return hslaString(hsla, alpha);
	   }
	   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
	}

	function hslaString(hsla, alpha) {
	   if (alpha === undefined) {
	      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
	   }
	   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
	           + alpha + ")";
	}

	// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional & 1 is default value)
	function hwbString(hwb, alpha) {
	   if (alpha === undefined) {
	      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
	   }
	   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
	           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
	}

	function keyword(rgb) {
	  return reverseNames[rgb.slice(0, 3)];
	}

	// helpers
	function scale(num, min, max) {
	   return Math.min(Math.max(min, num), max);
	}

	function hexDouble(num) {
	  var str = num.toString(16).toUpperCase();
	  return (str.length < 2) ? "0" + str : str;
	}


	//create a list of reverse color names
	var reverseNames = {};
	for (var name in colorNames) {
	   reverseNames[colorNames[name]] = name;
	}


/***/ },
/* 278 */
/***/ function(module, exports) {

	module.exports = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Oled = function(board, five, opts) {

	  this.HEIGHT = opts.height || 32;
	  this.WIDTH = opts.width || 128;
	  this.ADDRESS = opts.address || 0x3C;
	  this.PROTOCOL = (opts.address) ? 'I2C' : 'SPI';
	  this.MICROVIEW = opts.microview || false;
	  this.SLAVEPIN = opts.slavePin || 12;
	  this.RESETPIN = opts.resetPin || 4;

	  // create command buffers
	  this.DISPLAY_OFF = 0xAE;
	  this.DISPLAY_ON = 0xAF;
	  this.SET_DISPLAY_CLOCK_DIV = 0xD5;
	  this.SET_MULTIPLEX = 0xA8;
	  this.SET_DISPLAY_OFFSET = 0xD3;
	  this.SET_START_LINE = 0x00;
	  this.CHARGE_PUMP = 0x8D;
	  this.EXTERNAL_VCC = false;
	  this.MEMORY_MODE = 0x20;
	  this.SEG_REMAP = 0xA1; // using 0xA0 will flip screen
	  this.COM_SCAN_DEC = 0xC8;
	  this.COM_SCAN_INC = 0xC0;
	  this.SET_COM_PINS = 0xDA;
	  this.SET_CONTRAST = 0x81;
	  this.SET_PRECHARGE = 0xd9;
	  this.SET_VCOM_DETECT = 0xDB;
	  this.DISPLAY_ALL_ON_RESUME = 0xA4;
	  this.NORMAL_DISPLAY = 0xA6;
	  this.COLUMN_ADDR = 0x21;
	  this.PAGE_ADDR = 0x22;
	  this.INVERT_DISPLAY = 0xA7;
	  this.ACTIVATE_SCROLL = 0x2F;
	  this.DEACTIVATE_SCROLL = 0x2E;
	  this.SET_VERTICAL_SCROLL_AREA = 0xA3;
	  this.RIGHT_HORIZONTAL_SCROLL = 0x26;
	  this.LEFT_HORIZONTAL_SCROLL = 0x27;
	  this.VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL = 0x29;
	  this.VERTICAL_AND_LEFT_HORIZONTAL_SCROLL = 0x2A;

	  this.cursor_x = 0;
	  this.cursor_y = 0;

	  // new blank buffer
	  this.buffer = new Buffer((this.WIDTH * this.HEIGHT) / 8);
	  this.buffer.fill(0x00);

	  this.dirtyBytes = [];

	  // this is necessary as we're not natively sitting within johnny-five lib
	  this.board = board;
	  this.five = five;

	  var config = {
	    '128x32': {
	      'multiplex': 0x1F,
	      'compins': 0x02,
	      'coloffset': 0
	    },
	    '128x64': {
	      'multiplex': 0x3F,
	      'compins': 0x12,
	      'coloffset': 0
	    },
	    '96x16': {
	      'multiplex': 0x0F,
	      'compins': 0x2,
	      'coloffset': 0,
	    },
	    // this is blended microview / normal 64 x 48, currently wip
	    '64x48': {
	      'multiplex': 0x2F,
	      'compins': 0x12,
	      'coloffset': (this.MICROVIEW) ? 32 : 0
	    }
	  };

	  // microview is wip
	  if (this.MICROVIEW) {
	    // microview spi pins
	    this.SPIconfig = {
	      'dcPin': 8,
	      'ssPin': 10,
	      'rstPin': 7,
	      'clkPin': 13,
	      'mosiPin': 11
	    };
	  } else if (this.PROTOCOL === 'SPI') {
	    // generic spi pins
	    this.SPIconfig = {
	      'dcPin': 11,
	      'ssPin': this.SLAVEPIN,
	      'rstPin': 13,
	      'clkPin': 10,
	      'mosiPin': 9
	    };
	  }

	  var screenSize = this.WIDTH + 'x' + this.HEIGHT;
	  this.screenConfig = config[screenSize];

	  if (this.PROTOCOL === 'I2C') {
	    this._setUpI2C();
	  } else {
	    this._setUpSPI();
	  }

	  this._initialise();
	}

	Oled.prototype._initialise = function() {

	  // sequence of bytes to initialise with
	  var initSeq = [
	    this.DISPLAY_OFF,
	    this.SET_DISPLAY_CLOCK_DIV, 0x80,
	    this.SET_MULTIPLEX, this.screenConfig.multiplex, // set the last value dynamically based on screen size requirement
	    this.SET_DISPLAY_OFFSET, 0x00, // sets offset pro to 0
	    this.SET_START_LINE,
	    this.CHARGE_PUMP, 0x14, // charge pump val
	    this.MEMORY_MODE, 0x00, // 0x0 act like ks0108
	    this.SEG_REMAP, // screen orientation
	    this.COM_SCAN_DEC, // screen orientation change to INC to flip
	    this.SET_COM_PINS, this.screenConfig.compins, // com pins val sets dynamically to match each screen size requirement
	    this.SET_CONTRAST, 0x8F, // contrast val
	    this.SET_PRECHARGE, 0xF1, // precharge val
	    this.SET_VCOM_DETECT, 0x40, // vcom detect
	    this.DISPLAY_ALL_ON_RESUME,
	    this.NORMAL_DISPLAY,
	    this.DISPLAY_ON
	  ];

	  var i, initSeqLen = initSeq.length;

	  // write init seq commands
	  for (i = 0; i < initSeqLen; i ++) {
	    this._transfer('cmd', initSeq[i]);
	  }
	}

	Oled.prototype._setUpSPI = function() {

	    // set up spi pins
	    this.dcPin = new this.five.Pin(this.SPIconfig.dcPin);
	    this.ssPin = new this.five.Pin(this.SPIconfig.ssPin);
	    this.clkPin = new this.five.Pin(this.SPIconfig.clkPin);
	    this.mosiPin = new this.five.Pin(this.SPIconfig.mosiPin);
	    // reset won't be used as it causes a bunch of default initialisations
	    this.rstPin = new this.five.Pin(this.SPIconfig.rstPin);

	    // get the screen out of default mode
	    this.rstPin.low();
	    this.rstPin.high();
	    // Set SS to high so a connected chip will be "deselected" by default
	    this.ssPin.high();
	}

	Oled.prototype._setUpI2C = function() {
	  // enable i2C in firmata
	  this.board.io.i2cConfig(0);
	  // set up reset pin and hold high
	  this.rstPin = new this.five.Pin(this.RESETPIN);
	  this.rstPin.low();
	  this.rstPin.high();
	}

	// writes both commands and data buffers to this device
	Oled.prototype._transfer = function(type, val) {
	  var control;
	  if (type === 'data') {
	    control = 0x40;
	  } else if (type === 'cmd') {
	    control = 0x00;
	  } else {
	    return;
	  }

	  if (this.PROTOCOL === 'I2C') {
	    // send control and actual val
	    this.board.io.i2cWrite(this.ADDRESS, [control, val]);
	  } else {
	    // send val via SPI, no control byte
	    this._writeSPI(val, type);
	  }
	}

	Oled.prototype._writeSPI = function(byte, mode) {
	  var bit;

	  // set dc to low if command byte, high if data byte
	  if (mode === 'cmd') {
	    this.dcPin.low();
	  } else {
	    this.dcPin.high();
	  }

	  // select the device as slave
	  this.ssPin.low();

	  for (bit = 7; bit >= 0; bit--) {

	    // pull clock low
	    this.clkPin.low();

	    // shift out a bit for mosi
	    if (byte & (1 << bit)) {
	      this.mosiPin.high();
	    } else {
	      this.mosiPin.low();
	    }

	    // pull clock high to collect bit
	    this.clkPin.high();

	  }

	  // turn off slave select so other devices can use SPI
	  // don't be an SPI hogging jerk basically
	  this.ssPin.high();
	}

	// read a byte from the oled
	Oled.prototype._readI2C = function(fn) {
	  this.board.io.i2cReadOnce(this.ADDRESS, 1, function(data) {
	    fn(data);
	  });
	}

	// sometimes the oled gets a bit busy with lots of bytes.
	// Read the response byte to see if this is the case
	Oled.prototype._waitUntilReady = function(callback) {
	  var done,
	      oled = this;

	  function tick(callback) {
	    oled._readI2C(function(byte) {
	      // read the busy byte in the response
	      busy = byte >> 7 & 1;
	      if (!busy) {
	        // if not busy, it's ready for callback
	        callback();
	      } else {
	        console.log('I\'m busy!');
	        setTimeout(tick, 0);
	      }
	    });
	  };

	  if (this.PROTOCOL === 'I2C') {
	    setTimeout(tick(callback), 0);
	  } else {
	    callback();
	  }
	}

	// set starting position of a text string on the oled
	Oled.prototype.setCursor = function(x, y) {
	  this.cursor_x = x;
	  this.cursor_y = y;
	}

	// write text to the oled
	Oled.prototype.writeString = function(font, size, string, color, wrap, linespacing, sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;
	  var wordArr = string.split(' '),
	      len = wordArr.length,
	      // start x offset at cursor pos
	      offset = this.cursor_x,
	      padding = 0, letspace = 1;
	  var leading = linespacing || 2;

	  // loop through words
	  for (var w = 0; w < len; w += 1) {
	    // put the word space back in
	    wordArr[w] += ' ';
	    var stringArr = wordArr[w].split(''),
	        slen = stringArr.length,
	        compare = (font.width * size * slen) + (size * (len -1));

	    // wrap words if necessary
	    if (wrap && len > 1 && (offset >= (this.WIDTH - compare)) ) {
	      offset = 1;
	      this.cursor_y += (font.height * size) + size + leading;
	      this.setCursor(offset, this.cursor_y);
	    }

	    // loop through the array of each char to draw
	    for (var i = 0; i < slen; i += 1) {
	      // look up the position of the char, pull out the buffer slice
	      var charBuf = this._findCharBuf(font, stringArr[i]);
	      // read the bits in the bytes that make up the char
	      var charBytes = this._readCharBytes(charBuf);
	      // draw the entire character
	      this._drawChar(font, charBytes, size, false);

	      // calc new x position for the next char, add a touch of padding too if it's a non space char
	      padding = (stringArr[i] === ' ') ? 0 : size + letspace;
	      offset += (font.width * size) + padding;

	      // wrap letters if necessary
	      if (wrap && (offset >= (this.WIDTH - font.width - letspace))) {
	        offset = 1;
	        this.cursor_y += (font.height * size) + size + leading;
	      }
	      // set the 'cursor' for the next char to be drawn, then loop again for next char
	      this.setCursor(offset, this.cursor_y);
	    }
	  }
	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	}

	// draw an individual character to the screen
	Oled.prototype._drawChar = function(font, byteArray, size, sync) {
	  // take your positions...
	  var x = this.cursor_x,
	      y = this.cursor_y;

	  var pagePos = 0;
	  var c = 0;
	  // loop through the byte array containing the hexes for the char
	  for (var i = 0; i < byteArray.length; i += 1) {
	    pagePos = Math.floor(i / font.width) * 8;
	    for (var j = 0; j < 8; j += 1) {
	      // pull color out
	      var color = byteArray[i][j],
	          xpos, ypos;
	      // standard font size
	      if (size === 1) {
	        xpos = x + c;
	        ypos = y + j + pagePos;
	        this.drawPixel([xpos, ypos, color], false);
	      } else {
	        // MATH! Calculating pixel size multiplier to primitively scale the font
	        xpos = x + (i * size);
	        ypos = y + (j * size);
	        this.fillRect(xpos, ypos, size, size, color, false);
	      }
	    }
	    c = (c < font.width -1) ? c += 1 : 0;
	  }
	}

	// get character bytes from the supplied font object in order to send to framebuffer
	Oled.prototype._readCharBytes = function(byteArray) {
	  var bitArr = [],
	      bitCharArr = [];
	  // loop through each byte supplied for a char
	  for (var i = 0; i < byteArray.length; i += 1) {
	    // set current byte
	    var byte = byteArray[i];
	    // read each byte
	    for (var j = 0; j < 8; j += 1) {
	      // shift bits right until all are read
	      var bit = byte >> j & 1;
	      bitArr.push(bit);
	    }
	    // push to array containing flattened bit sequence
	    bitCharArr.push(bitArr);
	    // clear bits for next byte
	    bitArr = [];
	  }
	  return bitCharArr;
	}

	// find where the character exists within the font object
	Oled.prototype._findCharBuf = function(font, c) {
	  var charLength = Math.ceil((font.width * font.height) / 8);
	  // use the lookup array as a ref to find where the current char bytes start
	  var cBufPos = font.lookup.indexOf(c) * charLength;
	  // slice just the current char's bytes out of the fontData array and return
	  var cBuf = font.fontData.slice(cBufPos, cBufPos + charLength);
	  return cBuf;
	}

	// send the entire framebuffer to the oled
	Oled.prototype.update = function() {
	  // wait for oled to be ready
	  this._waitUntilReady(function() {
	    // set the start and endbyte locations for oled display update
	    var displaySeq = [
	      this.COLUMN_ADDR,
	      this.screenConfig.coloffset,
	      this.screenConfig.coloffset + this.WIDTH - 1, // column start and end address
	      this.PAGE_ADDR, 0, (this.HEIGHT / 8) - 1 // page start and end address
	    ];

	    var displaySeqLen = displaySeq.length,
	        bufferLen = this.buffer.length,
	        i, v;

	    // send intro seq
	    for (i = 0; i < displaySeqLen; i += 1) {
	      this._transfer('cmd', displaySeq[i]);
	    }

	    // write buffer data
	    for (v = 0; v < bufferLen; v += 1) {
	      this._transfer('data', this.buffer[v]);
	    }

	  }.bind(this));
	}

	// send dim display command to oled
	Oled.prototype.dimDisplay = function(bool) {
	  var contrast;

	  if (bool) {
	    contrast = 0; // Dimmed display
	  } else {
	    contrast = 0xCF; // Bright display
	  }

	  this._transfer('cmd', this.SET_CONTRAST);
	  this._transfer('cmd', contrast);
	}

	// turn oled off
	Oled.prototype.turnOffDisplay = function() {
	  this._transfer('cmd', this.DISPLAY_OFF);
	}

	// turn oled on
	Oled.prototype.turnOnDisplay = function() {
	  this._transfer('cmd', this.DISPLAY_ON);
	}

	// clear all pixels currently on the display
	Oled.prototype.clearDisplay = function(sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;
	  // write off pixels
	  //this.buffer.fill(0x00);
	  for (var i = 0; i < this.buffer.length; i += 1) {
	    if (this.buffer[i] !== 0x00) {
	      this.buffer[i] = 0x00;
	      if (this.dirtyBytes.indexOf(i) === -1) {
	        this.dirtyBytes.push(i);
	      }
	    }
	  }
	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	}

	// invert pixels on oled
	Oled.prototype.invertDisplay = function(bool) {
	  if (bool) {
	    this._transfer('cmd', this.INVERT_DISPLAY); // inverted
	  } else {
	    this._transfer('cmd', this.NORMAL_DISPLAY); // non inverted
	  }
	}

	// draw an image pixel array on the screen
	Oled.prototype.drawBitmap = function(pixels, sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;
	  var x, y,
	      pixelArray = [];

	  for (var i = 0; i < pixels.length; i++) {
	    x = Math.floor(i % this.WIDTH);
	    y = Math.floor(i / this.WIDTH);

	    this.drawPixel([x, y, pixels[i]], false);
	  }

	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	}

	// draw one or many pixels on oled
	Oled.prototype.drawPixel = function(pixels, sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;

	  // handle lazy single pixel case
	  if (typeof pixels[0] !== 'object') pixels = [pixels];

	  pixels.forEach(function(el) {
	    // return if the pixel is out of range
	    var x = el[0], y = el[1], color = el[2];
	    if (x > this.WIDTH || y > this.HEIGHT) return;

	    // thanks, Martin Richards.
	    // I wanna can this, this tool is for devs who get 0 indexes
	    //x -= 1; y -=1;
	    var byte = 0,
	        page = Math.floor(y / 8),
	        pageShift = 0x01 << (y - 8 * page);

	    // is the pixel on the first row of the page?
	    (page == 0) ? byte = x : byte = x + (this.WIDTH * page);

	    // colors! Well, monochrome.
	    if (color === 'BLACK' || color === 0) {
	      this.buffer[byte] &= ~pageShift;
	    }
	    if (color === 'WHITE' || color > 0) {
	      this.buffer[byte] |= pageShift;
	    }

	    // push byte to dirty if not already there
	    if (this.dirtyBytes.indexOf(byte) === -1) {
	      this.dirtyBytes.push(byte);
	    }

	  }, this);

	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	}

	// looks at dirty bytes, and sends the updated bytes to the display
	Oled.prototype._updateDirtyBytes = function(byteArray) {
	  var blen = byteArray.length, i,
	      displaySeq = [];

	  // check to see if this will even save time
	  if (blen > (this.buffer.length / 7)) {
	    // just call regular update at this stage, saves on bytes sent
	    this.update();
	    // now that all bytes are synced, reset dirty state
	    this.dirtyBytes = [];

	  } else {

	    this._waitUntilReady(function() {
	      // iterate through dirty bytes
	      for (var i = 0; i < blen; i += 1) {

	        var byte = byteArray[i];
	        var page = Math.floor(byte / this.WIDTH);
	        var col = Math.floor(byte % this.WIDTH);

	        var displaySeq = [
	          this.COLUMN_ADDR, col, col, // column start and end address
	          this.PAGE_ADDR, page, page // page start and end address
	        ];

	        var displaySeqLen = displaySeq.length, v;

	        // send intro seq
	        for (v = 0; v < displaySeqLen; v += 1) {
	          this._transfer('cmd', displaySeq[v]);
	        }
	        // send byte, then move on to next byte
	        this._transfer('data', this.buffer[byte]);
	      }
	    }.bind(this));
	  }
	  // now that all bytes are synced, reset dirty state
	  this.dirtyBytes = [];
	}

	// using Bresenham's line algorithm
	Oled.prototype.drawLine = function(x0, y0, x1, y1, color, sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;

	  var dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1,
	      dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1,
	      err = (dx > dy ? dx : -dy) / 2;

	  while (true) {
	    this.drawPixel([x0, y0, color], false);

	    if (x0 === x1 && y0 === y1) break;

	    var e2 = err;

	    if (e2 > -dx) {err -= dy; x0 += sx;}
	    if (e2 < dy) {err += dx; y0 += sy;}
	  }

	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	}

	// Draw an outlined  rectangle
	Oled.prototype.drawRect = function(x, y, w, h, color, sync){
	  var immed = (typeof sync === 'undefined') ? true : sync;
	  //top 
	  this.drawLine(x, y, x + w, y,color,false);

	  //left
	  this.drawLine(x, y + 1, x, y + h - 1, color, false);

	  //right
	  this.drawLine(x + w, y + 1, x + w, y + h - 1, color, false);

	  //bottom
	  this.drawLine(x, y + h - 1, x + w, y + h - 1, color, false);

	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	};

	// draw a filled rectangle on the oled
	Oled.prototype.fillRect = function(x, y, w, h, color, sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;
	  // one iteration for each column of the rectangle
	  for (var i = x; i < x + w; i += 1) {
	    // draws a vert line
	    this.drawLine(i, y, i, y+h-1, color, false);
	  }
	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	}

	/**
	 * Draw a circle outline
	 *
	 * This method is ad verbatim translation from the corresponding
	 * method on the Adafruit GFX library
	 * https://github.com/adafruit/Adafruit-GFX-Library
	 */
	Oled.prototype.drawCircle = function(x0, y0, r, color, sync) {
	  var immed = (typeof sync === 'undefined') ? true : sync;

	  var f = 1 - r;
	  var ddF_x = 1;
	  var ddF_y = -2 * r;
	  var x = 0;
	  var y = r;

	  this.drawPixel(
	    [[x0, y0 + r, color],
	    [x0, y0 - r, color],
	    [x0 + r, y0, color],
	    [x0 - r, y0, color]],
	    false
	  );

	  while(x < y) {
	    if (f >=0) {
	      y--;
	      ddF_y += 2;
	      f += ddF_y;
	    }
	    x++;
	    ddF_x += 2;
	    f += ddF_x;

	    this.drawPixel(
	      [[x0 + x, y0 + y, color],
	      [x0 - x, y0 + y, color],
	      [x0 + x, y0 - y, color],
	      [x0 - x, y0 - y, color],
	      [x0 + y, y0 + x, color],
	      [x0 - y, y0 + x, color],
	      [x0 + y, y0 - x, color],
	      [x0 - y, y0 - x, color]],
	      false
	    );
	  }

	  if (immed) {
	    this._updateDirtyBytes(this.dirtyBytes);
	  }
	};

	// activate scrolling for rows start through stop
	Oled.prototype.startScroll = function(dir, start, stop) {
	  var scrollHeader,
	      cmdSeq = [];

	  switch (dir) {
	    case 'right':
	      cmdSeq.push(this.RIGHT_HORIZONTAL_SCROLL); break;
	    case 'left':
	      cmdSeq.push(this.LEFT_HORIZONTAL_SCROLL); break;
	    case 'left diagonal':
	      cmdSeq.push(
	        this.SET_VERTICAL_SCROLL_AREA,
	        0x00,
	        this.HEIGHT,
	        this.VERTICAL_AND_LEFT_HORIZONTAL_SCROLL,
	        0x00,
	        start,
	        0x00,
	        stop,
	        0x01,
	        this.ACTIVATE_SCROLL
	      );
	      break;
	    case 'right diagonal':
	      cmdSeq.push(
	        this.SET_VERTICAL_SCROLL_AREA,
	        0x00,
	        this.HEIGHT,
	        this.VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL,
	        0x00,
	        start,
	        0x00,
	        stop,
	        0x01,
	        this.ACTIVATE_SCROLL
	      );
	      break;
	  }

	  this._waitUntilReady(function() {
	    if(dir === 'right' || dir === 'left'){
	      cmdSeq.push(
	        0x00, start,
	        0x00, stop,
	        0x00, 0xFF,
	        this.ACTIVATE_SCROLL
	      );
	    }

	    var i, cmdSeqLen = cmdSeq.length;

	    for (i = 0; i < cmdSeqLen; i += 1) {
	      this._transfer('cmd', cmdSeq[i]);
	    }
	  }.bind(this));
	}

	// stop scrolling display contents
	Oled.prototype.stopScroll = function() {
	  this._transfer('cmd', this.DEACTIVATE_SCROLL); // stahp
	}

	module.exports = Oled;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Browser Request
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.

	// UMD HEADER START 
	(function (root, factory) {
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	  }
	}(this, function () {
	// UMD HEADER END

	var XHR = XMLHttpRequest
	if (!XHR) throw new Error('missing XMLHttpRequest')
	request.log = {
	  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
	}

	var DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes

	//
	// request
	//

	function request(options, callback) {
	  // The entry-point to the API: prep the options object and pass the real work to run_xhr.
	  if(typeof callback !== 'function')
	    throw new Error('Bad callback given: ' + callback)

	  if(!options)
	    throw new Error('No options given')

	  var options_onResponse = options.onResponse; // Save this for later.

	  if(typeof options === 'string')
	    options = {'uri':options};
	  else
	    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

	  options.onResponse = options_onResponse // And put it back.

	  if (options.verbose) request.log = getLogger();

	  if(options.url) {
	    options.uri = options.url;
	    delete options.url;
	  }

	  if(!options.uri && options.uri !== "")
	    throw new Error("options.uri is a required argument");

	  if(typeof options.uri != "string")
	    throw new Error("options.uri must be a string");

	  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']
	  for (var i = 0; i < unsupported_options.length; i++)
	    if(options[ unsupported_options[i] ])
	      throw new Error("options." + unsupported_options[i] + " is not supported")

	  options.callback = callback
	  options.method = options.method || 'GET';
	  options.headers = options.headers || {};
	  options.body    = options.body || null
	  options.timeout = options.timeout || request.DEFAULT_TIMEOUT

	  if(options.headers.host)
	    throw new Error("Options.headers.host is not supported");

	  if(options.json) {
	    options.headers.accept = options.headers.accept || 'application/json'
	    if(options.method !== 'GET')
	      options.headers['content-type'] = 'application/json'

	    if(typeof options.json !== 'boolean')
	      options.body = JSON.stringify(options.json)
	    else if(typeof options.body !== 'string')
	      options.body = JSON.stringify(options.body)
	  }
	  
	  //BEGIN QS Hack
	  var serialize = function(obj) {
	    var str = [];
	    for(var p in obj)
	      if (obj.hasOwnProperty(p)) {
	        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
	      }
	    return str.join("&");
	  }
	  
	  if(options.qs){
	    var qs = (typeof options.qs == 'string')? options.qs : serialize(options.qs);
	    if(options.uri.indexOf('?') !== -1){ //no get params
	        options.uri = options.uri+'&'+qs;
	    }else{ //existing get params
	        options.uri = options.uri+'?'+qs;
	    }
	  }
	  //END QS Hack
	  
	  //BEGIN FORM Hack
	  var multipart = function(obj) {
	    //todo: support file type (useful?)
	    var result = {};
	    result.boundry = '-------------------------------'+Math.floor(Math.random()*1000000000);
	    var lines = [];
	    for(var p in obj){
	        if (obj.hasOwnProperty(p)) {
	            lines.push(
	                '--'+result.boundry+"\n"+
	                'Content-Disposition: form-data; name="'+p+'"'+"\n"+
	                "\n"+
	                obj[p]+"\n"
	            );
	        }
	    }
	    lines.push( '--'+result.boundry+'--' );
	    result.body = lines.join('');
	    result.length = result.body.length;
	    result.type = 'multipart/form-data; boundary='+result.boundry;
	    return result;
	  }
	  
	  if(options.form){
	    if(typeof options.form == 'string') throw('form name unsupported');
	    if(options.method === 'POST'){
	        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
	        options.headers['content-type'] = encoding;
	        switch(encoding){
	            case 'application/x-www-form-urlencoded':
	                options.body = serialize(options.form).replace(/%20/g, "+");
	                break;
	            case 'multipart/form-data':
	                var multi = multipart(options.form);
	                //options.headers['content-length'] = multi.length;
	                options.body = multi.body;
	                options.headers['content-type'] = multi.type;
	                break;
	            default : throw new Error('unsupported encoding:'+encoding);
	        }
	    }
	  }
	  //END FORM Hack

	  // If onResponse is boolean true, call back immediately when the response is known,
	  // not when the full request is complete.
	  options.onResponse = options.onResponse || noop
	  if(options.onResponse === true) {
	    options.onResponse = callback
	    options.callback = noop
	  }

	  // XXX Browsers do not like this.
	  //if(options.body)
	  //  options.headers['content-length'] = options.body.length;

	  // HTTP basic authentication
	  if(!options.headers.authorization && options.auth)
	    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

	  return run_xhr(options)
	}

	var req_seq = 0
	function run_xhr(options) {
	  var xhr = new XHR
	    , timed_out = false
	    , is_cors = is_crossDomain(options.uri)
	    , supports_cors = ('withCredentials' in xhr)

	  req_seq += 1
	  xhr.seq_id = req_seq
	  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri
	  xhr._id = xhr.id // I know I will type "_id" from habit all the time.

	  if(is_cors && !supports_cors) {
	    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)
	    cors_err.cors = 'unsupported'
	    return options.callback(cors_err, xhr)
	  }

	  xhr.timeoutTimer = setTimeout(too_late, options.timeout)
	  function too_late() {
	    timed_out = true
	    var er = new Error('ETIMEDOUT')
	    er.code = 'ETIMEDOUT'
	    er.duration = options.timeout

	    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })
	    return options.callback(er, xhr)
	  }

	  // Some states can be skipped over, so remember what is still incomplete.
	  var did = {'response':false, 'loading':false, 'end':false}

	  xhr.onreadystatechange = on_state_change
	  xhr.open(options.method, options.uri, true) // asynchronous
	  if(is_cors)
	    xhr.withCredentials = !! options.withCredentials
	  xhr.send(options.body)
	  return xhr

	  function on_state_change(event) {
	    if(timed_out)
	      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})

	    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})

	    if(xhr.readyState === XHR.OPENED) {
	      request.log.debug('Request started', {'id':xhr.id})
	      for (var key in options.headers)
	        xhr.setRequestHeader(key, options.headers[key])
	    }

	    else if(xhr.readyState === XHR.HEADERS_RECEIVED)
	      on_response()

	    else if(xhr.readyState === XHR.LOADING) {
	      on_response()
	      on_loading()
	    }

	    else if(xhr.readyState === XHR.DONE) {
	      on_response()
	      on_loading()
	      on_end()
	    }
	  }

	  function on_response() {
	    if(did.response)
	      return

	    did.response = true
	    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})
	    clearTimeout(xhr.timeoutTimer)
	    xhr.statusCode = xhr.status // Node request compatibility

	    // Detect failed CORS requests.
	    if(is_cors && xhr.statusCode == 0) {
	      var cors_err = new Error('CORS request rejected: ' + options.uri)
	      cors_err.cors = 'rejected'

	      // Do not process this request further.
	      did.loading = true
	      did.end = true

	      return options.callback(cors_err, xhr)
	    }

	    options.onResponse(null, xhr)
	  }

	  function on_loading() {
	    if(did.loading)
	      return

	    did.loading = true
	    request.log.debug('Response body loading', {'id':xhr.id})
	    // TODO: Maybe simulate "data" events by watching xhr.responseText
	  }

	  function on_end() {
	    if(did.end)
	      return

	    did.end = true
	    request.log.debug('Request done', {'id':xhr.id})

	    xhr.body = xhr.responseText
	    if(options.json) {
	      try        { xhr.body = JSON.parse(xhr.responseText) }
	      catch (er) { return options.callback(er, xhr)        }
	    }

	    options.callback(null, xhr, xhr.body)
	  }

	} // request

	request.withCredentials = false;
	request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

	//
	// defaults
	//

	request.defaults = function(options, requester) {
	  var def = function (method) {
	    var d = function (params, callback) {
	      if(typeof params === 'string')
	        params = {'uri': params};
	      else {
	        params = JSON.parse(JSON.stringify(params));
	      }
	      for (var i in options) {
	        if (params[i] === undefined) params[i] = options[i]
	      }
	      return method(params, callback)
	    }
	    return d
	  }
	  var de = def(request)
	  de.get = def(request.get)
	  de.post = def(request.post)
	  de.put = def(request.put)
	  de.head = def(request.head)
	  return de
	}

	//
	// HTTP method shortcuts
	//

	var shortcuts = [ 'get', 'put', 'post', 'head' ];
	shortcuts.forEach(function(shortcut) {
	  var method = shortcut.toUpperCase();
	  var func   = shortcut.toLowerCase();

	  request[func] = function(opts) {
	    if(typeof opts === 'string')
	      opts = {'method':method, 'uri':opts};
	    else {
	      opts = JSON.parse(JSON.stringify(opts));
	      opts.method = method;
	    }

	    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
	    return request.apply(this, args);
	  }
	})

	//
	// CouchDB shortcut
	//

	request.couch = function(options, callback) {
	  if(typeof options === 'string')
	    options = {'uri':options}

	  // Just use the request API to do JSON.
	  options.json = true
	  if(options.body)
	    options.json = options.body
	  delete options.body

	  callback = callback || noop

	  var xhr = request(options, couch_handler)
	  return xhr

	  function couch_handler(er, resp, body) {
	    if(er)
	      return callback(er, resp, body)

	    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
	      // The body is a Couch JSON object indicating the error.
	      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))
	      for (var key in body)
	        er[key] = body[key]
	      return callback(er, resp, body);
	    }

	    return callback(er, resp, body);
	  }
	}

	//
	// Utility
	//

	function noop() {}

	function getLogger() {
	  var logger = {}
	    , levels = ['trace', 'debug', 'info', 'warn', 'error']
	    , level, i

	  for(i = 0; i < levels.length; i++) {
	    level = levels[i]

	    logger[level] = noop
	    if(typeof console !== 'undefined' && console && console[level])
	      logger[level] = formatted(console, level)
	  }

	  return logger
	}

	function formatted(obj, method) {
	  return formatted_logger

	  function formatted_logger(str, context) {
	    if(typeof context === 'object')
	      str += ' ' + JSON.stringify(context)

	    return obj[method].call(obj, str)
	  }
	}

	// Return whether a URL is a cross-domain request.
	function is_crossDomain(url) {
	  var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/

	  // jQuery #8138, IE may throw an exception when accessing
	  // a field from window.location if document.domain has been set
	  var ajaxLocation
	  try { ajaxLocation = location.href }
	  catch (e) {
	    // Use the href attribute of an A element since IE will modify it given document.location
	    ajaxLocation = document.createElement( "a" );
	    ajaxLocation.href = "";
	    ajaxLocation = ajaxLocation.href;
	  }

	  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
	    , parts = rurl.exec(url.toLowerCase() )

	  var result = !!(
	    parts &&
	    (  parts[1] != ajaxLocParts[1]
	    || parts[2] != ajaxLocParts[2]
	    || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
	    )
	  )

	  //console.debug('is_crossDomain('+url+') -> ' + result)
	  return result
	}

	// MIT License from http://phpjs.org/functions/base64_encode:358
	function b64_enc (data) {
	    // Encodes string using MIME base64 algorithm
	    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

	    if (!data) {
	        return data;
	    }

	    // assume utf8 data
	    // data = this.utf8_encode(data+'');

	    do { // pack three octets into four hexets
	        o1 = data.charCodeAt(i++);
	        o2 = data.charCodeAt(i++);
	        o3 = data.charCodeAt(i++);

	        bits = o1<<16 | o2<<8 | o3;

	        h1 = bits>>18 & 0x3f;
	        h2 = bits>>12 & 0x3f;
	        h3 = bits>>6 & 0x3f;
	        h4 = bits & 0x3f;

	        // use hexets to index into b64, and append result to encoded string
	        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
	    } while (i < data.length);

	    enc = tmp_arr.join('');

	    switch (data.length % 3) {
	        case 1:
	            enc = enc.slice(0, -2) + '==';
	        break;
	        case 2:
	            enc = enc.slice(0, -1) + '=';
	        break;
	    }

	    return enc;
	}
	    return request;
	//UMD FOOTER START
	}));
	//UMD FOOTER END


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var rest = __webpack_require__(282),
			    browser = __webpack_require__(285);

			rest.setPlatformDefaultClient(browser);

			return rest;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		var undef;

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			/**
			 * Plain JS Object containing properties that represent an HTTP request.
			 *
			 * Depending on the capabilities of the underlying client, a request
			 * may be cancelable. If a request may be canceled, the client will add
			 * a canceled flag and cancel function to the request object. Canceling
			 * the request will put the response into an error state.
			 *
			 * @field {string} [method='GET'] HTTP method, commonly GET, POST, PUT, DELETE or HEAD
			 * @field {string|UrlBuilder} [path=''] path template with optional path variables
			 * @field {Object} [params] parameters for the path template and query string
			 * @field {Object} [headers] custom HTTP headers to send, in addition to the clients default headers
			 * @field [entity] the HTTP entity, common for POST or PUT requests
			 * @field {boolean} [canceled] true if the request has been canceled, set by the client
			 * @field {Function} [cancel] cancels the request if invoked, provided by the client
			 * @field {Client} [originator] the client that first handled this request, provided by the interceptor
			 *
			 * @class Request
			 */

			/**
			 * Plain JS Object containing properties that represent an HTTP response
			 *
			 * @field {Object} [request] the request object as received by the root client
			 * @field {Object} [raw] the underlying request object, like XmlHttpRequest in a browser
			 * @field {number} [status.code] status code of the response (i.e. 200, 404)
			 * @field {string} [status.text] status phrase of the response
			 * @field {Object] [headers] response headers hash of normalized name, value pairs
			 * @field [entity] the response body
			 *
			 * @class Response
			 */

			/**
			 * HTTP client particularly suited for RESTful operations.
			 *
			 * @field {function} wrap wraps this client with a new interceptor returning the wrapped client
			 *
			 * @param {Request} the HTTP request
			 * @returns {ResponsePromise<Response>} a promise the resolves to the HTTP response
			 *
			 * @class Client
			 */

			 /**
			  * Extended when.js Promises/A+ promise with HTTP specific helpers
			  *q
			  * @method entity promise for the HTTP entity
			  * @method status promise for the HTTP status code
			  * @method headers promise for the HTTP response headers
			  * @method header promise for a specific HTTP response header
			  *
			  * @class ResponsePromise
			  * @extends Promise
			  */

			var client, target, platformDefault;

			client = __webpack_require__(283);

			/**
			 * Make a request with the default client
			 * @param {Request} the HTTP request
			 * @returns {Promise<Response>} a promise the resolves to the HTTP response
			 */
			function defaultClient() {
				return target.apply(undef, arguments);
			}

			/**
			 * Change the default client
			 * @param {Client} client the new default client
			 */
			defaultClient.setDefaultClient = function setDefaultClient(client) {
				target = client;
			};

			/**
			 * Obtain a direct reference to the current default client
			 * @returns {Client} the default client
			 */
			defaultClient.getDefaultClient = function getDefaultClient() {
				return target;
			};

			/**
			 * Reset the default client to the platform default
			 */
			defaultClient.resetDefaultClient = function resetDefaultClient() {
				target = platformDefault;
			};

			/**
			 * @private
			 */
			defaultClient.setPlatformDefaultClient = function setPlatformDefaultClient(client) {
				if (platformDefault) {
					throw new Error('Unable to redefine platformDefaultClient');
				}
				target = platformDefault = client;
			};

			return client(defaultClient);

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			/**
			 * Add common helper methods to a client impl
			 *
			 * @param {function} impl the client implementation
			 * @param {Client} [target] target of this client, used when wrapping other clients
			 * @returns {Client} the client impl with additional methods
			 */
			return function client(impl, target) {

				if (target) {

					/**
					 * @returns {Client} the target client
					 */
					impl.skip = function skip() {
						return target;
					};

				}

				/**
				 * Allow a client to easily be wrapped by an interceptor
				 *
				 * @param {Interceptor} interceptor the interceptor to wrap this client with
				 * @param [config] configuration for the interceptor
				 * @returns {Client} the newly wrapped client
				 */
				impl.wrap = function wrap(interceptor, config) {
					return interceptor(impl, config);
				};

				/**
				 * @deprecated
				 */
				impl.chain = function chain() {
					if (typeof console !== 'undefined') {
						console.log('rest.js: client.chain() is deprecated, use client.wrap() instead');
					}

					return impl.wrap.apply(this, arguments);
				};

				return impl;

			};

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 284 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define, global) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var when, UrlBuilder, normalizeHeaderName, responsePromise, client, headerSplitRE;

			when = __webpack_require__(286);
			UrlBuilder = __webpack_require__(305);
			normalizeHeaderName = __webpack_require__(307);
			responsePromise = __webpack_require__(308);
			client = __webpack_require__(283);

			// according to the spec, the line break is '\r\n', but doesn't hold true in practice
			headerSplitRE = /[\r|\n]+/;

			function parseHeaders(raw) {
				// Note: Set-Cookie will be removed by the browser
				var headers = {};

				if (!raw) { return headers; }

				raw.trim().split(headerSplitRE).forEach(function (header) {
					var boundary, name, value;
					boundary = header.indexOf(':');
					name = normalizeHeaderName(header.substring(0, boundary).trim());
					value = header.substring(boundary + 1).trim();
					if (headers[name]) {
						if (Array.isArray(headers[name])) {
							// add to an existing array
							headers[name].push(value);
						}
						else {
							// convert single value to array
							headers[name] = [headers[name], value];
						}
					}
					else {
						// new, single value
						headers[name] = value;
					}
				});

				return headers;
			}

			function safeMixin(target, source) {
				Object.keys(source || {}).forEach(function (prop) {
					// make sure the property already exists as
					// IE 6 will blow up if we add a new prop
					if (source.hasOwnProperty(prop) && prop in target) {
						try {
							target[prop] = source[prop];
						}
						catch (e) {
							// ignore, expected for some properties at some points in the request lifecycle
						}
					}
				});

				return target;
			}

			return client(function xhr(request) {
				return responsePromise.promise(function (resolve, reject) {
					/*jshint maxcomplexity:20 */

					var client, method, url, headers, entity, headerName, response, XMLHttpRequest;

					request = typeof request === 'string' ? { path: request } : request || {};
					response = { request: request };

					if (request.canceled) {
						response.error = 'precanceled';
						reject(response);
						return;
					}

					XMLHttpRequest = request.engine || global.XMLHttpRequest;
					if (!XMLHttpRequest) {
						reject({ request: request, error: 'xhr-not-available' });
						return;
					}

					entity = request.entity;
					request.method = request.method || (entity ? 'POST' : 'GET');
					method = request.method;
					url = new UrlBuilder(request.path || '', request.params).build();

					try {
						client = response.raw = new XMLHttpRequest();

						// mixin extra request properties before and after opening the request as some properties require being set at different phases of the request
						safeMixin(client, request.mixin);
						client.open(method, url, true);
						safeMixin(client, request.mixin);

						headers = request.headers;
						for (headerName in headers) {
							/*jshint forin:false */
							if (headerName === 'Content-Type' && headers[headerName] === 'multipart/form-data') {
								// XMLHttpRequest generates its own Content-Type header with the
								// appropriate multipart boundary when sending multipart/form-data.
								continue;
							}

							client.setRequestHeader(headerName, headers[headerName]);
						}

						request.canceled = false;
						request.cancel = function cancel() {
							request.canceled = true;
							client.abort();
							reject(response);
						};

						client.onreadystatechange = function (/* e */) {
							if (request.canceled) { return; }
							if (client.readyState === (XMLHttpRequest.DONE || 4)) {
								response.status = {
									code: client.status,
									text: client.statusText
								};
								response.headers = parseHeaders(client.getAllResponseHeaders());
								response.entity = client.responseText;

								if (response.status.code > 0) {
									// check status code as readystatechange fires before error event
									resolve(response);
								}
								else {
									// give the error callback a chance to fire before resolving
									// requests for file:// URLs do not have a status code
									setTimeout(function () {
										resolve(response);
									}, 0);
								}
							}
						};

						try {
							client.onerror = function (/* e */) {
								response.error = 'loaderror';
								reject(response);
							};
						}
						catch (e) {
							// IE 6 will not support error handling
						}

						client.send(entity);
					}
					catch (e) {
						response.error = 'loaderror';
						reject(response);
					}

				});
			});

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284),
		typeof window !== 'undefined' ? window : void 0
		// Boilerplate for AMD and Node
	));


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */

	/**
	 * Promises/A+ and when() implementation
	 * when is part of the cujoJS family of libraries (http://cujojs.com/)
	 * @author Brian Cavalier
	 * @author John Hann
	 */
	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

		var timed = __webpack_require__(287);
		var array = __webpack_require__(291);
		var flow = __webpack_require__(294);
		var fold = __webpack_require__(295);
		var inspect = __webpack_require__(296);
		var generate = __webpack_require__(297);
		var progress = __webpack_require__(298);
		var withThis = __webpack_require__(299);
		var unhandledRejection = __webpack_require__(300);
		var TimeoutError = __webpack_require__(290);

		var Promise = [array, flow, fold, generate, progress,
			inspect, withThis, timed, unhandledRejection]
			.reduce(function(Promise, feature) {
				return feature(Promise);
			}, __webpack_require__(302));

		var apply = __webpack_require__(293)(Promise);

		// Public API

		when.promise     = promise;              // Create a pending promise
		when.resolve     = Promise.resolve;      // Create a resolved promise
		when.reject      = Promise.reject;       // Create a rejected promise

		when.lift        = lift;                 // lift a function to return promises
		when['try']      = attempt;              // call a function and return a promise
		when.attempt     = attempt;              // alias for when.try

		when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
		when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

		when.join        = join;                 // Join 2 or more promises

		when.all         = all;                  // Resolve a list of promises
		when.settle      = settle;               // Settle a list of promises

		when.any         = lift(Promise.any);    // One-winner race
		when.some        = lift(Promise.some);   // Multi-winner race
		when.race        = lift(Promise.race);   // First-to-settle race

		when.map         = map;                  // Array.map() for promises
		when.filter      = filter;               // Array.filter() for promises
		when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
		when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

		when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

		when.Promise     = Promise;              // Promise constructor
		when.defer       = defer;                // Create a {promise, resolve, reject} tuple

		// Error types

		when.TimeoutError = TimeoutError;

		/**
		 * Get a trusted promise for x, or by transforming x with onFulfilled
		 *
		 * @param {*} x
		 * @param {function?} onFulfilled callback to be called when x is
		 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
		 *   will be invoked immediately.
		 * @param {function?} onRejected callback to be called when x is
		 *   rejected.
		 * @param {function?} onProgress callback to be called when progress updates
		 *   are issued for x. @deprecated
		 * @returns {Promise} a new promise that will fulfill with the return
		 *   value of callback or errback or the completion value of promiseOrValue if
		 *   callback and/or errback is not supplied.
		 */
		function when(x, onFulfilled, onRejected, onProgress) {
			var p = Promise.resolve(x);
			if (arguments.length < 2) {
				return p;
			}

			return p.then(onFulfilled, onRejected, onProgress);
		}

		/**
		 * Creates a new promise whose fate is determined by resolver.
		 * @param {function} resolver function(resolve, reject, notify)
		 * @returns {Promise} promise whose fate is determine by resolver
		 */
		function promise(resolver) {
			return new Promise(resolver);
		}

		/**
		 * Lift the supplied function, creating a version of f that returns
		 * promises, and accepts promises as arguments.
		 * @param {function} f
		 * @returns {Function} version of f that returns promises
		 */
		function lift(f) {
			return function() {
				for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
					a[i] = arguments[i];
				}
				return apply(f, this, a);
			};
		}

		/**
		 * Call f in a future turn, with the supplied args, and return a promise
		 * for the result.
		 * @param {function} f
		 * @returns {Promise}
		 */
		function attempt(f /*, args... */) {
			/*jshint validthis:true */
			for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i+1];
			}
			return apply(f, this, a);
		}

		/**
		 * Creates a {promise, resolver} pair, either or both of which
		 * may be given out safely to consumers.
		 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
		 */
		function defer() {
			return new Deferred();
		}

		function Deferred() {
			var p = Promise._defer();

			function resolve(x) { p._handler.resolve(x); }
			function reject(x) { p._handler.reject(x); }
			function notify(x) { p._handler.notify(x); }

			this.promise = p;
			this.resolve = resolve;
			this.reject = reject;
			this.notify = notify;
			this.resolver = { resolve: resolve, reject: reject, notify: notify };
		}

		/**
		 * Determines if x is promise-like, i.e. a thenable object
		 * NOTE: Will return true for *any thenable object*, and isn't truly
		 * safe, since it may attempt to access the `then` property of x (i.e.
		 *  clever/malicious getters may do weird things)
		 * @param {*} x anything
		 * @returns {boolean} true if x is promise-like
		 */
		function isPromiseLike(x) {
			return x && typeof x.then === 'function';
		}

		/**
		 * Return a promise that will resolve only once all the supplied arguments
		 * have resolved. The resolution value of the returned promise will be an array
		 * containing the resolution values of each of the arguments.
		 * @param {...*} arguments may be a mix of promises and values
		 * @returns {Promise}
		 */
		function join(/* ...promises */) {
			return Promise.all(arguments);
		}

		/**
		 * Return a promise that will fulfill once all input promises have
		 * fulfilled, or reject when any one input promise rejects.
		 * @param {array|Promise} promises array (or promise for an array) of promises
		 * @returns {Promise}
		 */
		function all(promises) {
			return when(promises, Promise.all);
		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will only reject if `promises` itself is a rejected promise.
		 * @param {array|Promise} promises array (or promise for an array) of promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return when(promises, Promise.settle);
		}

		/**
		 * Promise-aware array map function, similar to `Array.prototype.map()`,
		 * but input array may contain promises or values.
		 * @param {Array|Promise} promises array of anything, may contain promises and values
		 * @param {function(x:*, index:Number):*} mapFunc map function which may
		 *  return a promise or value
		 * @returns {Promise} promise that will fulfill with an array of mapped values
		 *  or reject if any input promise rejects.
		 */
		function map(promises, mapFunc) {
			return when(promises, function(promises) {
				return Promise.map(promises, mapFunc);
			});
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array|Promise} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			return when(promises, function(promises) {
				return Promise.filter(promises, predicate);
			});
		}

		return when;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(284));


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

		var env = __webpack_require__(288);
		var TimeoutError = __webpack_require__(290);

		function setTimeout(f, ms, x, y) {
			return env.setTimer(function() {
				f(x, y, ms);
			}, ms);
		}

		return function timed(Promise) {
			/**
			 * Return a new promise whose fulfillment value is revealed only
			 * after ms milliseconds
			 * @param {number} ms milliseconds
			 * @returns {Promise}
			 */
			Promise.prototype.delay = function(ms) {
				var p = this._beget();
				this._handler.fold(handleDelay, ms, void 0, p._handler);
				return p;
			};

			function handleDelay(ms, x, h) {
				setTimeout(resolveDelay, ms, x, h);
			}

			function resolveDelay(x, h) {
				h.resolve(x);
			}

			/**
			 * Return a new promise that rejects after ms milliseconds unless
			 * this promise fulfills earlier, in which case the returned promise
			 * fulfills with the same value.
			 * @param {number} ms milliseconds
			 * @param {Error|*=} reason optional rejection reason to use, defaults
			 *   to a TimeoutError if not provided
			 * @returns {Promise}
			 */
			Promise.prototype.timeout = function(ms, reason) {
				var p = this._beget();
				var h = p._handler;

				var t = setTimeout(onTimeout, ms, reason, p._handler);

				this._handler.visit(h,
					function onFulfill(x) {
						env.clearTimer(t);
						this.resolve(x); // this = h
					},
					function onReject(x) {
						env.clearTimer(t);
						this.reject(x); // this = h
					},
					h.notify);

				return p;
			};

			function onTimeout(reason, h, ms) {
				var e = typeof reason === 'undefined'
					? new TimeoutError('timed out after ' + ms + 'ms')
					: reason;
				h.reject(e);
			}

			return Promise;
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
		/*jshint maxcomplexity:6*/

		// Sniff "best" async scheduling option
		// Prefer process.nextTick or MutationObserver, then check for
		// setTimeout, and finally vertx, since its the only env that doesn't
		// have setTimeout

		var MutationObs;
		var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

		// Default env
		var setTimer = function(f, ms) { return setTimeout(f, ms); };
		var clearTimer = function(t) { return clearTimeout(t); };
		var asap = function (f) { return capturedSetTimeout(f, 0); };

		// Detect specific env
		if (isNode()) { // Node
			asap = function (f) { return process.nextTick(f); };

		} else if (MutationObs = hasMutationObserver()) { // Modern browser
			asap = initMutationObserver(MutationObs);

		} else if (!capturedSetTimeout) { // vert.x
			var vertxRequire = require;
			var vertx = __webpack_require__(289);
			setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
			clearTimer = vertx.cancelTimer;
			asap = vertx.runOnLoop || vertx.runOnContext;
		}

		return {
			setTimer: setTimer,
			clearTimer: clearTimer,
			asap: asap
		};

		function isNode () {
			return typeof process !== 'undefined' &&
				Object.prototype.toString.call(process) === '[object process]';
		}

		function hasMutationObserver () {
			return (typeof MutationObserver === 'function' && MutationObserver) ||
				(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
		}

		function initMutationObserver(MutationObserver) {
			var scheduled;
			var node = document.createTextNode('');
			var o = new MutationObserver(run);
			o.observe(node, { characterData: true });

			function run() {
				var f = scheduled;
				scheduled = void 0;
				f();
			}

			var i = 0;
			return function (f) {
				scheduled = f;
				node.data = (i ^= 1);
			};
		}
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 289 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		/**
		 * Custom error type for promises rejected by promise.timeout
		 * @param {string} message
		 * @constructor
		 */
		function TimeoutError (message) {
			Error.call(this);
			this.message = message;
			this.name = TimeoutError.name;
			if (typeof Error.captureStackTrace === 'function') {
				Error.captureStackTrace(this, TimeoutError);
			}
		}

		TimeoutError.prototype = Object.create(Error.prototype);
		TimeoutError.prototype.constructor = TimeoutError;

		return TimeoutError;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

		var state = __webpack_require__(292);
		var applier = __webpack_require__(293);

		return function array(Promise) {

			var applyFold = applier(Promise);
			var toPromise = Promise.resolve;
			var all = Promise.all;

			var ar = Array.prototype.reduce;
			var arr = Array.prototype.reduceRight;
			var slice = Array.prototype.slice;

			// Additional array combinators

			Promise.any = any;
			Promise.some = some;
			Promise.settle = settle;

			Promise.map = map;
			Promise.filter = filter;
			Promise.reduce = reduce;
			Promise.reduceRight = reduceRight;

			/**
			 * When this promise fulfills with an array, do
			 * onFulfilled.apply(void 0, array)
			 * @param {function} onFulfilled function to apply
			 * @returns {Promise} promise for the result of applying onFulfilled
			 */
			Promise.prototype.spread = function(onFulfilled) {
				return this.then(all).then(function(array) {
					return onFulfilled.apply(this, array);
				});
			};

			return Promise;

			/**
			 * One-winner competitive race.
			 * Return a promise that will fulfill when one of the promises
			 * in the input array fulfills, or will reject when all promises
			 * have rejected.
			 * @param {array} promises
			 * @returns {Promise} promise for the first fulfilled value
			 */
			function any(promises) {
				var p = Promise._defer();
				var resolver = p._handler;
				var l = promises.length>>>0;

				var pending = l;
				var errors = [];

				for (var h, x, i = 0; i < l; ++i) {
					x = promises[i];
					if(x === void 0 && !(i in promises)) {
						--pending;
						continue;
					}

					h = Promise._handler(x);
					if(h.state() > 0) {
						resolver.become(h);
						Promise._visitRemaining(promises, i, h);
						break;
					} else {
						h.visit(resolver, handleFulfill, handleReject);
					}
				}

				if(pending === 0) {
					resolver.reject(new RangeError('any(): array must not be empty'));
				}

				return p;

				function handleFulfill(x) {
					/*jshint validthis:true*/
					errors = null;
					this.resolve(x); // this === resolver
				}

				function handleReject(e) {
					/*jshint validthis:true*/
					if(this.resolved) { // this === resolver
						return;
					}

					errors.push(e);
					if(--pending === 0) {
						this.reject(errors);
					}
				}
			}

			/**
			 * N-winner competitive race
			 * Return a promise that will fulfill when n input promises have
			 * fulfilled, or will reject when it becomes impossible for n
			 * input promises to fulfill (ie when promises.length - n + 1
			 * have rejected)
			 * @param {array} promises
			 * @param {number} n
			 * @returns {Promise} promise for the earliest n fulfillment values
			 *
			 * @deprecated
			 */
			function some(promises, n) {
				/*jshint maxcomplexity:7*/
				var p = Promise._defer();
				var resolver = p._handler;

				var results = [];
				var errors = [];

				var l = promises.length>>>0;
				var nFulfill = 0;
				var nReject;
				var x, i; // reused in both for() loops

				// First pass: count actual array items
				for(i=0; i<l; ++i) {
					x = promises[i];
					if(x === void 0 && !(i in promises)) {
						continue;
					}
					++nFulfill;
				}

				// Compute actual goals
				n = Math.max(n, 0);
				nReject = (nFulfill - n + 1);
				nFulfill = Math.min(n, nFulfill);

				if(n > nFulfill) {
					resolver.reject(new RangeError('some(): array must contain at least '
					+ n + ' item(s), but had ' + nFulfill));
				} else if(nFulfill === 0) {
					resolver.resolve(results);
				}

				// Second pass: observe each array item, make progress toward goals
				for(i=0; i<l; ++i) {
					x = promises[i];
					if(x === void 0 && !(i in promises)) {
						continue;
					}

					Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
				}

				return p;

				function fulfill(x) {
					/*jshint validthis:true*/
					if(this.resolved) { // this === resolver
						return;
					}

					results.push(x);
					if(--nFulfill === 0) {
						errors = null;
						this.resolve(results);
					}
				}

				function reject(e) {
					/*jshint validthis:true*/
					if(this.resolved) { // this === resolver
						return;
					}

					errors.push(e);
					if(--nReject === 0) {
						results = null;
						this.reject(errors);
					}
				}
			}

			/**
			 * Apply f to the value of each promise in a list of promises
			 * and return a new list containing the results.
			 * @param {array} promises
			 * @param {function(x:*, index:Number):*} f mapping function
			 * @returns {Promise}
			 */
			function map(promises, f) {
				return Promise._traverse(f, promises);
			}

			/**
			 * Filter the provided array of promises using the provided predicate.  Input may
			 * contain promises and values
			 * @param {Array} promises array of promises and values
			 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
			 *  Must return truthy (or promise for truthy) for items to retain.
			 * @returns {Promise} promise that will fulfill with an array containing all items
			 *  for which predicate returned truthy.
			 */
			function filter(promises, predicate) {
				var a = slice.call(promises);
				return Promise._traverse(predicate, a).then(function(keep) {
					return filterSync(a, keep);
				});
			}

			function filterSync(promises, keep) {
				// Safe because we know all promises have fulfilled if we've made it this far
				var l = keep.length;
				var filtered = new Array(l);
				for(var i=0, j=0; i<l; ++i) {
					if(keep[i]) {
						filtered[j++] = Promise._handler(promises[i]).value;
					}
				}
				filtered.length = j;
				return filtered;

			}

			/**
			 * Return a promise that will always fulfill with an array containing
			 * the outcome states of all input promises.  The returned promise
			 * will never reject.
			 * @param {Array} promises
			 * @returns {Promise} promise for array of settled state descriptors
			 */
			function settle(promises) {
				return all(promises.map(settleOne));
			}

			function settleOne(p) {
				var h = Promise._handler(p);
				if(h.state() === 0) {
					return toPromise(p).then(state.fulfilled, state.rejected);
				}

				h._unreport();
				return state.inspect(h);
			}

			/**
			 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
			 * input may contain promises and/or values, and reduceFunc
			 * may return either a value or a promise, *and* initialValue may
			 * be a promise for the starting value.
			 * @param {Array|Promise} promises array or promise for an array of anything,
			 *      may contain a mix of promises and values.
			 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
			 * @returns {Promise} that will resolve to the final reduced value
			 */
			function reduce(promises, f /*, initialValue */) {
				return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
						: ar.call(promises, liftCombine(f));
			}

			/**
			 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
			 * input may contain promises and/or values, and reduceFunc
			 * may return either a value or a promise, *and* initialValue may
			 * be a promise for the starting value.
			 * @param {Array|Promise} promises array or promise for an array of anything,
			 *      may contain a mix of promises and values.
			 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
			 * @returns {Promise} that will resolve to the final reduced value
			 */
			function reduceRight(promises, f /*, initialValue */) {
				return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
						: arr.call(promises, liftCombine(f));
			}

			function liftCombine(f) {
				return function(z, x, i) {
					return applyFold(f, void 0, [z,x,i]);
				};
			}
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return {
			pending: toPendingState,
			fulfilled: toFulfilledState,
			rejected: toRejectedState,
			inspect: inspect
		};

		function toPendingState() {
			return { state: 'pending' };
		}

		function toRejectedState(e) {
			return { state: 'rejected', reason: e };
		}

		function toFulfilledState(x) {
			return { state: 'fulfilled', value: x };
		}

		function inspect(handler) {
			var state = handler.state();
			return state === 0 ? toPendingState()
				 : state > 0   ? toFulfilledState(handler.value)
				               : toRejectedState(handler.value);
		}

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		makeApply.tryCatchResolve = tryCatchResolve;

		return makeApply;

		function makeApply(Promise, call) {
			if(arguments.length < 2) {
				call = tryCatchResolve;
			}

			return apply;

			function apply(f, thisArg, args) {
				var p = Promise._defer();
				var l = args.length;
				var params = new Array(l);
				callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

				return p;
			}

			function callAndResolve(c, h) {
				if(c.i < 0) {
					return call(c.f, c.thisArg, c.params, h);
				}

				var handler = Promise._handler(c.args[c.i]);
				handler.fold(callAndResolveNext, c, void 0, h);
			}

			function callAndResolveNext(c, x, h) {
				c.params[c.i] = x;
				c.i -= 1;
				callAndResolve(c, h);
			}
		}

		function tryCatchResolve(f, thisArg, args, resolver) {
			try {
				resolver.resolve(f.apply(thisArg, args));
			} catch(e) {
				resolver.reject(e);
			}
		}

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));




/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return function flow(Promise) {

			var resolve = Promise.resolve;
			var reject = Promise.reject;
			var origCatch = Promise.prototype['catch'];

			/**
			 * Handle the ultimate fulfillment value or rejection reason, and assume
			 * responsibility for all errors.  If an error propagates out of result
			 * or handleFatalError, it will be rethrown to the host, resulting in a
			 * loud stack track on most platforms and a crash on some.
			 * @param {function?} onResult
			 * @param {function?} onError
			 * @returns {undefined}
			 */
			Promise.prototype.done = function(onResult, onError) {
				this._handler.visit(this._handler.receiver, onResult, onError);
			};

			/**
			 * Add Error-type and predicate matching to catch.  Examples:
			 * promise.catch(TypeError, handleTypeError)
			 *   .catch(predicate, handleMatchedErrors)
			 *   .catch(handleRemainingErrors)
			 * @param onRejected
			 * @returns {*}
			 */
			Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
				if (arguments.length < 2) {
					return origCatch.call(this, onRejected);
				}

				if(typeof onRejected !== 'function') {
					return this.ensure(rejectInvalidPredicate);
				}

				return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
			};

			/**
			 * Wraps the provided catch handler, so that it will only be called
			 * if the predicate evaluates truthy
			 * @param {?function} handler
			 * @param {function} predicate
			 * @returns {function} conditional catch handler
			 */
			function createCatchFilter(handler, predicate) {
				return function(e) {
					return evaluatePredicate(e, predicate)
						? handler.call(this, e)
						: reject(e);
				};
			}

			/**
			 * Ensures that onFulfilledOrRejected will be called regardless of whether
			 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
			 * receive the promises' value or reason.  Any returned value will be disregarded.
			 * onFulfilledOrRejected may throw or return a rejected promise to signal
			 * an additional error.
			 * @param {function} handler handler to be called regardless of
			 *  fulfillment or rejection
			 * @returns {Promise}
			 */
			Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
				if(typeof handler !== 'function') {
					return this;
				}

				return this.then(function(x) {
					return runSideEffect(handler, this, identity, x);
				}, function(e) {
					return runSideEffect(handler, this, reject, e);
				});
			};

			function runSideEffect (handler, thisArg, propagate, value) {
				var result = handler.call(thisArg);
				return maybeThenable(result)
					? propagateValue(result, propagate, value)
					: propagate(value);
			}

			function propagateValue (result, propagate, x) {
				return resolve(result).then(function () {
					return propagate(x);
				});
			}

			/**
			 * Recover from a failure by returning a defaultValue.  If defaultValue
			 * is a promise, it's fulfillment value will be used.  If defaultValue is
			 * a promise that rejects, the returned promise will reject with the
			 * same reason.
			 * @param {*} defaultValue
			 * @returns {Promise} new promise
			 */
			Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
				return this.then(void 0, function() {
					return defaultValue;
				});
			};

			/**
			 * Shortcut for .then(function() { return value; })
			 * @param  {*} value
			 * @return {Promise} a promise that:
			 *  - is fulfilled if value is not a promise, or
			 *  - if value is a promise, will fulfill with its value, or reject
			 *    with its reason.
			 */
			Promise.prototype['yield'] = function(value) {
				return this.then(function() {
					return value;
				});
			};

			/**
			 * Runs a side effect when this promise fulfills, without changing the
			 * fulfillment value.
			 * @param {function} onFulfilledSideEffect
			 * @returns {Promise}
			 */
			Promise.prototype.tap = function(onFulfilledSideEffect) {
				return this.then(onFulfilledSideEffect)['yield'](this);
			};

			return Promise;
		};

		function rejectInvalidPredicate() {
			throw new TypeError('catch predicate must be a function');
		}

		function evaluatePredicate(e, predicate) {
			return isError(predicate) ? e instanceof predicate : predicate(e);
		}

		function isError(predicate) {
			return predicate === Error
				|| (predicate != null && predicate.prototype instanceof Error);
		}

		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function identity(x) {
			return x;
		}

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */
	/** @author Jeff Escalante */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return function fold(Promise) {

			Promise.prototype.fold = function(f, z) {
				var promise = this._beget();

				this._handler.fold(function(z, x, to) {
					Promise._handler(z).fold(function(x, z, to) {
						to.resolve(f.call(this, z, x));
					}, x, this, to);
				}, z, promise._handler.receiver, promise._handler);

				return promise;
			};

			return Promise;
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

		var inspect = __webpack_require__(292).inspect;

		return function inspection(Promise) {

			Promise.prototype.inspect = function() {
				return inspect(Promise._handler(this));
			};

			return Promise;
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return function generate(Promise) {

			var resolve = Promise.resolve;

			Promise.iterate = iterate;
			Promise.unfold = unfold;

			return Promise;

			/**
			 * @deprecated Use github.com/cujojs/most streams and most.iterate
			 * Generate a (potentially infinite) stream of promised values:
			 * x, f(x), f(f(x)), etc. until condition(x) returns true
			 * @param {function} f function to generate a new x from the previous x
			 * @param {function} condition function that, given the current x, returns
			 *  truthy when the iterate should stop
			 * @param {function} handler function to handle the value produced by f
			 * @param {*|Promise} x starting value, may be a promise
			 * @return {Promise} the result of the last call to f before
			 *  condition returns true
			 */
			function iterate(f, condition, handler, x) {
				return unfold(function(x) {
					return [x, f(x)];
				}, condition, handler, x);
			}

			/**
			 * @deprecated Use github.com/cujojs/most streams and most.unfold
			 * Generate a (potentially infinite) stream of promised values
			 * by applying handler(generator(seed)) iteratively until
			 * condition(seed) returns true.
			 * @param {function} unspool function that generates a [value, newSeed]
			 *  given a seed.
			 * @param {function} condition function that, given the current seed, returns
			 *  truthy when the unfold should stop
			 * @param {function} handler function to handle the value produced by unspool
			 * @param x {*|Promise} starting value, may be a promise
			 * @return {Promise} the result of the last value produced by unspool before
			 *  condition returns true
			 */
			function unfold(unspool, condition, handler, x) {
				return resolve(x).then(function(seed) {
					return resolve(condition(seed)).then(function(done) {
						return done ? seed : resolve(unspool(seed)).spread(next);
					});
				});

				function next(item, newSeed) {
					return resolve(handler(item)).then(function() {
						return unfold(unspool, condition, handler, newSeed);
					});
				}
			}
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return function progress(Promise) {

			/**
			 * @deprecated
			 * Register a progress handler for this promise
			 * @param {function} onProgress
			 * @returns {Promise}
			 */
			Promise.prototype.progress = function(onProgress) {
				return this.then(void 0, void 0, onProgress);
			};

			return Promise;
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return function addWith(Promise) {
			/**
			 * Returns a promise whose handlers will be called with `this` set to
			 * the supplied receiver.  Subsequent promises derived from the
			 * returned promise will also have their handlers called with receiver
			 * as `this`. Calling `with` with undefined or no arguments will return
			 * a promise whose handlers will again be called in the usual Promises/A+
			 * way (no `this`) thus safely undoing any previous `with` in the
			 * promise chain.
			 *
			 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
			 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
			 *
			 * @param {object} receiver `this` value for all handlers attached to
			 *  the returned promise.
			 * @returns {Promise}
			 */
			Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
				var p = this._beget();
				var child = p._handler;
				child.receiver = receiver;
				this._handler.chain(child, receiver);
				return p;
			};

			return Promise;
		};

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));



/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {

		var setTimer = __webpack_require__(288).setTimer;
		var format = __webpack_require__(301);

		return function unhandledRejection(Promise) {

			var logError = noop;
			var logInfo = noop;
			var localConsole;

			if(typeof console !== 'undefined') {
				// Alias console to prevent things like uglify's drop_console option from
				// removing console.log/error. Unhandled rejections fall into the same
				// category as uncaught exceptions, and build tools shouldn't silence them.
				localConsole = console;
				logError = typeof localConsole.error !== 'undefined'
					? function (e) { localConsole.error(e); }
					: function (e) { localConsole.log(e); };

				logInfo = typeof localConsole.info !== 'undefined'
					? function (e) { localConsole.info(e); }
					: function (e) { localConsole.log(e); };
			}

			Promise.onPotentiallyUnhandledRejection = function(rejection) {
				enqueue(report, rejection);
			};

			Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
				enqueue(unreport, rejection);
			};

			Promise.onFatalRejection = function(rejection) {
				enqueue(throwit, rejection.value);
			};

			var tasks = [];
			var reported = [];
			var running = null;

			function report(r) {
				if(!r.handled) {
					reported.push(r);
					logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
				}
			}

			function unreport(r) {
				var i = reported.indexOf(r);
				if(i >= 0) {
					reported.splice(i, 1);
					logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
				}
			}

			function enqueue(f, x) {
				tasks.push(f, x);
				if(running === null) {
					running = setTimer(flush, 0);
				}
			}

			function flush() {
				running = null;
				while(tasks.length > 0) {
					tasks.shift()(tasks.shift());
				}
			}

			return Promise;
		};

		function throwit(e) {
			throw e;
		}

		function noop() {}

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return {
			formatError: formatError,
			formatObject: formatObject,
			tryStringify: tryStringify
		};

		/**
		 * Format an error into a string.  If e is an Error and has a stack property,
		 * it's returned.  Otherwise, e is formatted using formatObject, with a
		 * warning added about e not being a proper Error.
		 * @param {*} e
		 * @returns {String} formatted string, suitable for output to developers
		 */
		function formatError(e) {
			var s = typeof e === 'object' && e !== null && e.stack ? e.stack : formatObject(e);
			return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
		}

		/**
		 * Format an object, detecting "plain" objects and running them through
		 * JSON.stringify if possible.
		 * @param {Object} o
		 * @returns {string}
		 */
		function formatObject(o) {
			var s = String(o);
			if(s === '[object Object]' && typeof JSON !== 'undefined') {
				s = tryStringify(o, s);
			}
			return s;
		}

		/**
		 * Try to return the result of JSON.stringify(x).  If that fails, return
		 * defaultValue
		 * @param {*} x
		 * @param {*} defaultValue
		 * @returns {String|*} JSON.stringify(x) or defaultValue
		 */
		function tryStringify(x, defaultValue) {
			try {
				return JSON.stringify(x);
			} catch(e) {
				return defaultValue;
			}
		}

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

		var makePromise = __webpack_require__(303);
		var Scheduler = __webpack_require__(304);
		var async = __webpack_require__(288).asap;

		return makePromise({
			scheduler: new Scheduler(async)
		});

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(284));


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		return function makePromise(environment) {

			var tasks = environment.scheduler;
			var emitRejection = initEmitRejection();

			var objectCreate = Object.create ||
				function(proto) {
					function Child() {}
					Child.prototype = proto;
					return new Child();
				};

			/**
			 * Create a promise whose fate is determined by resolver
			 * @constructor
			 * @returns {Promise} promise
			 * @name Promise
			 */
			function Promise(resolver, handler) {
				this._handler = resolver === Handler ? handler : init(resolver);
			}

			/**
			 * Run the supplied resolver
			 * @param resolver
			 * @returns {Pending}
			 */
			function init(resolver) {
				var handler = new Pending();

				try {
					resolver(promiseResolve, promiseReject, promiseNotify);
				} catch (e) {
					promiseReject(e);
				}

				return handler;

				/**
				 * Transition from pre-resolution state to post-resolution state, notifying
				 * all listeners of the ultimate fulfillment or rejection
				 * @param {*} x resolution value
				 */
				function promiseResolve (x) {
					handler.resolve(x);
				}
				/**
				 * Reject this promise with reason, which will be used verbatim
				 * @param {Error|*} reason rejection reason, strongly suggested
				 *   to be an Error type
				 */
				function promiseReject (reason) {
					handler.reject(reason);
				}

				/**
				 * @deprecated
				 * Issue a progress event, notifying all progress listeners
				 * @param {*} x progress event payload to pass to all listeners
				 */
				function promiseNotify (x) {
					handler.notify(x);
				}
			}

			// Creation

			Promise.resolve = resolve;
			Promise.reject = reject;
			Promise.never = never;

			Promise._defer = defer;
			Promise._handler = getHandler;

			/**
			 * Returns a trusted promise. If x is already a trusted promise, it is
			 * returned, otherwise returns a new trusted Promise which follows x.
			 * @param  {*} x
			 * @return {Promise} promise
			 */
			function resolve(x) {
				return isPromise(x) ? x
					: new Promise(Handler, new Async(getHandler(x)));
			}

			/**
			 * Return a reject promise with x as its reason (x is used verbatim)
			 * @param {*} x
			 * @returns {Promise} rejected promise
			 */
			function reject(x) {
				return new Promise(Handler, new Async(new Rejected(x)));
			}

			/**
			 * Return a promise that remains pending forever
			 * @returns {Promise} forever-pending promise.
			 */
			function never() {
				return foreverPendingPromise; // Should be frozen
			}

			/**
			 * Creates an internal {promise, resolver} pair
			 * @private
			 * @returns {Promise}
			 */
			function defer() {
				return new Promise(Handler, new Pending());
			}

			// Transformation and flow control

			/**
			 * Transform this promise's fulfillment value, returning a new Promise
			 * for the transformed result.  If the promise cannot be fulfilled, onRejected
			 * is called with the reason.  onProgress *may* be called with updates toward
			 * this promise's fulfillment.
			 * @param {function=} onFulfilled fulfillment handler
			 * @param {function=} onRejected rejection handler
			 * @param {function=} onProgress @deprecated progress handler
			 * @return {Promise} new promise
			 */
			Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
				var parent = this._handler;
				var state = parent.join().state();

				if ((typeof onFulfilled !== 'function' && state > 0) ||
					(typeof onRejected !== 'function' && state < 0)) {
					// Short circuit: value will not change, simply share handler
					return new this.constructor(Handler, parent);
				}

				var p = this._beget();
				var child = p._handler;

				parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

				return p;
			};

			/**
			 * If this promise cannot be fulfilled due to an error, call onRejected to
			 * handle the error. Shortcut for .then(undefined, onRejected)
			 * @param {function?} onRejected
			 * @return {Promise}
			 */
			Promise.prototype['catch'] = function(onRejected) {
				return this.then(void 0, onRejected);
			};

			/**
			 * Creates a new, pending promise of the same type as this promise
			 * @private
			 * @returns {Promise}
			 */
			Promise.prototype._beget = function() {
				return begetFrom(this._handler, this.constructor);
			};

			function begetFrom(parent, Promise) {
				var child = new Pending(parent.receiver, parent.join().context);
				return new Promise(Handler, child);
			}

			// Array combinators

			Promise.all = all;
			Promise.race = race;
			Promise._traverse = traverse;

			/**
			 * Return a promise that will fulfill when all promises in the
			 * input array have fulfilled, or will reject when one of the
			 * promises rejects.
			 * @param {array} promises array of promises
			 * @returns {Promise} promise for array of fulfillment values
			 */
			function all(promises) {
				return traverseWith(snd, null, promises);
			}

			/**
			 * Array<Promise<X>> -> Promise<Array<f(X)>>
			 * @private
			 * @param {function} f function to apply to each promise's value
			 * @param {Array} promises array of promises
			 * @returns {Promise} promise for transformed values
			 */
			function traverse(f, promises) {
				return traverseWith(tryCatch2, f, promises);
			}

			function traverseWith(tryMap, f, promises) {
				var handler = typeof f === 'function' ? mapAt : settleAt;

				var resolver = new Pending();
				var pending = promises.length >>> 0;
				var results = new Array(pending);

				for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
					x = promises[i];

					if (x === void 0 && !(i in promises)) {
						--pending;
						continue;
					}

					traverseAt(promises, handler, i, x, resolver);
				}

				if(pending === 0) {
					resolver.become(new Fulfilled(results));
				}

				return new Promise(Handler, resolver);

				function mapAt(i, x, resolver) {
					if(!resolver.resolved) {
						traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
					}
				}

				function settleAt(i, x, resolver) {
					results[i] = x;
					if(--pending === 0) {
						resolver.become(new Fulfilled(results));
					}
				}
			}

			function traverseAt(promises, handler, i, x, resolver) {
				if (maybeThenable(x)) {
					var h = getHandlerMaybeThenable(x);
					var s = h.state();

					if (s === 0) {
						h.fold(handler, i, void 0, resolver);
					} else if (s > 0) {
						handler(i, h.value, resolver);
					} else {
						resolver.become(h);
						visitRemaining(promises, i+1, h);
					}
				} else {
					handler(i, x, resolver);
				}
			}

			Promise._visitRemaining = visitRemaining;
			function visitRemaining(promises, start, handler) {
				for(var i=start; i<promises.length; ++i) {
					markAsHandled(getHandler(promises[i]), handler);
				}
			}

			function markAsHandled(h, handler) {
				if(h === handler) {
					return;
				}

				var s = h.state();
				if(s === 0) {
					h.visit(h, void 0, h._unreport);
				} else if(s < 0) {
					h._unreport();
				}
			}

			/**
			 * Fulfill-reject competitive race. Return a promise that will settle
			 * to the same state as the earliest input promise to settle.
			 *
			 * WARNING: The ES6 Promise spec requires that race()ing an empty array
			 * must return a promise that is pending forever.  This implementation
			 * returns a singleton forever-pending promise, the same singleton that is
			 * returned by Promise.never(), thus can be checked with ===
			 *
			 * @param {array} promises array of promises to race
			 * @returns {Promise} if input is non-empty, a promise that will settle
			 * to the same outcome as the earliest input promise to settle. if empty
			 * is empty, returns a promise that will never settle.
			 */
			function race(promises) {
				if(typeof promises !== 'object' || promises === null) {
					return reject(new TypeError('non-iterable passed to race()'));
				}

				// Sigh, race([]) is untestable unless we return *something*
				// that is recognizable without calling .then() on it.
				return promises.length === 0 ? never()
					 : promises.length === 1 ? resolve(promises[0])
					 : runRace(promises);
			}

			function runRace(promises) {
				var resolver = new Pending();
				var i, x, h;
				for(i=0; i<promises.length; ++i) {
					x = promises[i];
					if (x === void 0 && !(i in promises)) {
						continue;
					}

					h = getHandler(x);
					if(h.state() !== 0) {
						resolver.become(h);
						visitRemaining(promises, i+1, h);
						break;
					} else {
						h.visit(resolver, resolver.resolve, resolver.reject);
					}
				}
				return new Promise(Handler, resolver);
			}

			// Promise internals
			// Below this, everything is @private

			/**
			 * Get an appropriate handler for x, without checking for cycles
			 * @param {*} x
			 * @returns {object} handler
			 */
			function getHandler(x) {
				if(isPromise(x)) {
					return x._handler.join();
				}
				return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
			}

			/**
			 * Get a handler for thenable x.
			 * NOTE: You must only call this if maybeThenable(x) == true
			 * @param {object|function|Promise} x
			 * @returns {object} handler
			 */
			function getHandlerMaybeThenable(x) {
				return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
			}

			/**
			 * Get a handler for potentially untrusted thenable x
			 * @param {*} x
			 * @returns {object} handler
			 */
			function getHandlerUntrusted(x) {
				try {
					var untrustedThen = x.then;
					return typeof untrustedThen === 'function'
						? new Thenable(untrustedThen, x)
						: new Fulfilled(x);
				} catch(e) {
					return new Rejected(e);
				}
			}

			/**
			 * Handler for a promise that is pending forever
			 * @constructor
			 */
			function Handler() {}

			Handler.prototype.when
				= Handler.prototype.become
				= Handler.prototype.notify // deprecated
				= Handler.prototype.fail
				= Handler.prototype._unreport
				= Handler.prototype._report
				= noop;

			Handler.prototype._state = 0;

			Handler.prototype.state = function() {
				return this._state;
			};

			/**
			 * Recursively collapse handler chain to find the handler
			 * nearest to the fully resolved value.
			 * @returns {object} handler nearest the fully resolved value
			 */
			Handler.prototype.join = function() {
				var h = this;
				while(h.handler !== void 0) {
					h = h.handler;
				}
				return h;
			};

			Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
				this.when({
					resolver: to,
					receiver: receiver,
					fulfilled: fulfilled,
					rejected: rejected,
					progress: progress
				});
			};

			Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
				this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
			};

			Handler.prototype.fold = function(f, z, c, to) {
				this.when(new Fold(f, z, c, to));
			};

			/**
			 * Handler that invokes fail() on any handler it becomes
			 * @constructor
			 */
			function FailIfRejected() {}

			inherit(Handler, FailIfRejected);

			FailIfRejected.prototype.become = function(h) {
				h.fail();
			};

			var failIfRejected = new FailIfRejected();

			/**
			 * Handler that manages a queue of consumers waiting on a pending promise
			 * @constructor
			 */
			function Pending(receiver, inheritedContext) {
				Promise.createContext(this, inheritedContext);

				this.consumers = void 0;
				this.receiver = receiver;
				this.handler = void 0;
				this.resolved = false;
			}

			inherit(Handler, Pending);

			Pending.prototype._state = 0;

			Pending.prototype.resolve = function(x) {
				this.become(getHandler(x));
			};

			Pending.prototype.reject = function(x) {
				if(this.resolved) {
					return;
				}

				this.become(new Rejected(x));
			};

			Pending.prototype.join = function() {
				if (!this.resolved) {
					return this;
				}

				var h = this;

				while (h.handler !== void 0) {
					h = h.handler;
					if (h === this) {
						return this.handler = cycle();
					}
				}

				return h;
			};

			Pending.prototype.run = function() {
				var q = this.consumers;
				var handler = this.handler;
				this.handler = this.handler.join();
				this.consumers = void 0;

				for (var i = 0; i < q.length; ++i) {
					handler.when(q[i]);
				}
			};

			Pending.prototype.become = function(handler) {
				if(this.resolved) {
					return;
				}

				this.resolved = true;
				this.handler = handler;
				if(this.consumers !== void 0) {
					tasks.enqueue(this);
				}

				if(this.context !== void 0) {
					handler._report(this.context);
				}
			};

			Pending.prototype.when = function(continuation) {
				if(this.resolved) {
					tasks.enqueue(new ContinuationTask(continuation, this.handler));
				} else {
					if(this.consumers === void 0) {
						this.consumers = [continuation];
					} else {
						this.consumers.push(continuation);
					}
				}
			};

			/**
			 * @deprecated
			 */
			Pending.prototype.notify = function(x) {
				if(!this.resolved) {
					tasks.enqueue(new ProgressTask(x, this));
				}
			};

			Pending.prototype.fail = function(context) {
				var c = typeof context === 'undefined' ? this.context : context;
				this.resolved && this.handler.join().fail(c);
			};

			Pending.prototype._report = function(context) {
				this.resolved && this.handler.join()._report(context);
			};

			Pending.prototype._unreport = function() {
				this.resolved && this.handler.join()._unreport();
			};

			/**
			 * Wrap another handler and force it into a future stack
			 * @param {object} handler
			 * @constructor
			 */
			function Async(handler) {
				this.handler = handler;
			}

			inherit(Handler, Async);

			Async.prototype.when = function(continuation) {
				tasks.enqueue(new ContinuationTask(continuation, this));
			};

			Async.prototype._report = function(context) {
				this.join()._report(context);
			};

			Async.prototype._unreport = function() {
				this.join()._unreport();
			};

			/**
			 * Handler that wraps an untrusted thenable and assimilates it in a future stack
			 * @param {function} then
			 * @param {{then: function}} thenable
			 * @constructor
			 */
			function Thenable(then, thenable) {
				Pending.call(this);
				tasks.enqueue(new AssimilateTask(then, thenable, this));
			}

			inherit(Pending, Thenable);

			/**
			 * Handler for a fulfilled promise
			 * @param {*} x fulfillment value
			 * @constructor
			 */
			function Fulfilled(x) {
				Promise.createContext(this);
				this.value = x;
			}

			inherit(Handler, Fulfilled);

			Fulfilled.prototype._state = 1;

			Fulfilled.prototype.fold = function(f, z, c, to) {
				runContinuation3(f, z, this, c, to);
			};

			Fulfilled.prototype.when = function(cont) {
				runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
			};

			var errorId = 0;

			/**
			 * Handler for a rejected promise
			 * @param {*} x rejection reason
			 * @constructor
			 */
			function Rejected(x) {
				Promise.createContext(this);

				this.id = ++errorId;
				this.value = x;
				this.handled = false;
				this.reported = false;

				this._report();
			}

			inherit(Handler, Rejected);

			Rejected.prototype._state = -1;

			Rejected.prototype.fold = function(f, z, c, to) {
				to.become(this);
			};

			Rejected.prototype.when = function(cont) {
				if(typeof cont.rejected === 'function') {
					this._unreport();
				}
				runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
			};

			Rejected.prototype._report = function(context) {
				tasks.afterQueue(new ReportTask(this, context));
			};

			Rejected.prototype._unreport = function() {
				if(this.handled) {
					return;
				}
				this.handled = true;
				tasks.afterQueue(new UnreportTask(this));
			};

			Rejected.prototype.fail = function(context) {
				this.reported = true;
				emitRejection('unhandledRejection', this);
				Promise.onFatalRejection(this, context === void 0 ? this.context : context);
			};

			function ReportTask(rejection, context) {
				this.rejection = rejection;
				this.context = context;
			}

			ReportTask.prototype.run = function() {
				if(!this.rejection.handled && !this.rejection.reported) {
					this.rejection.reported = true;
					emitRejection('unhandledRejection', this.rejection) ||
						Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
				}
			};

			function UnreportTask(rejection) {
				this.rejection = rejection;
			}

			UnreportTask.prototype.run = function() {
				if(this.rejection.reported) {
					emitRejection('rejectionHandled', this.rejection) ||
						Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
				}
			};

			// Unhandled rejection hooks
			// By default, everything is a noop

			Promise.createContext
				= Promise.enterContext
				= Promise.exitContext
				= Promise.onPotentiallyUnhandledRejection
				= Promise.onPotentiallyUnhandledRejectionHandled
				= Promise.onFatalRejection
				= noop;

			// Errors and singletons

			var foreverPendingHandler = new Handler();
			var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

			function cycle() {
				return new Rejected(new TypeError('Promise cycle'));
			}

			// Task runners

			/**
			 * Run a single consumer
			 * @constructor
			 */
			function ContinuationTask(continuation, handler) {
				this.continuation = continuation;
				this.handler = handler;
			}

			ContinuationTask.prototype.run = function() {
				this.handler.join().when(this.continuation);
			};

			/**
			 * Run a queue of progress handlers
			 * @constructor
			 */
			function ProgressTask(value, handler) {
				this.handler = handler;
				this.value = value;
			}

			ProgressTask.prototype.run = function() {
				var q = this.handler.consumers;
				if(q === void 0) {
					return;
				}

				for (var c, i = 0; i < q.length; ++i) {
					c = q[i];
					runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
				}
			};

			/**
			 * Assimilate a thenable, sending it's value to resolver
			 * @param {function} then
			 * @param {object|function} thenable
			 * @param {object} resolver
			 * @constructor
			 */
			function AssimilateTask(then, thenable, resolver) {
				this._then = then;
				this.thenable = thenable;
				this.resolver = resolver;
			}

			AssimilateTask.prototype.run = function() {
				var h = this.resolver;
				tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

				function _resolve(x) { h.resolve(x); }
				function _reject(x)  { h.reject(x); }
				function _notify(x)  { h.notify(x); }
			};

			function tryAssimilate(then, thenable, resolve, reject, notify) {
				try {
					then.call(thenable, resolve, reject, notify);
				} catch (e) {
					reject(e);
				}
			}

			/**
			 * Fold a handler value with z
			 * @constructor
			 */
			function Fold(f, z, c, to) {
				this.f = f; this.z = z; this.c = c; this.to = to;
				this.resolver = failIfRejected;
				this.receiver = this;
			}

			Fold.prototype.fulfilled = function(x) {
				this.f.call(this.c, this.z, x, this.to);
			};

			Fold.prototype.rejected = function(x) {
				this.to.reject(x);
			};

			Fold.prototype.progress = function(x) {
				this.to.notify(x);
			};

			// Other helpers

			/**
			 * @param {*} x
			 * @returns {boolean} true iff x is a trusted Promise
			 */
			function isPromise(x) {
				return x instanceof Promise;
			}

			/**
			 * Test just enough to rule out primitives, in order to take faster
			 * paths in some code
			 * @param {*} x
			 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
			 */
			function maybeThenable(x) {
				return (typeof x === 'object' || typeof x === 'function') && x !== null;
			}

			function runContinuation1(f, h, receiver, next) {
				if(typeof f !== 'function') {
					return next.become(h);
				}

				Promise.enterContext(h);
				tryCatchReject(f, h.value, receiver, next);
				Promise.exitContext();
			}

			function runContinuation3(f, x, h, receiver, next) {
				if(typeof f !== 'function') {
					return next.become(h);
				}

				Promise.enterContext(h);
				tryCatchReject3(f, x, h.value, receiver, next);
				Promise.exitContext();
			}

			/**
			 * @deprecated
			 */
			function runNotify(f, x, h, receiver, next) {
				if(typeof f !== 'function') {
					return next.notify(x);
				}

				Promise.enterContext(h);
				tryCatchReturn(f, x, receiver, next);
				Promise.exitContext();
			}

			function tryCatch2(f, a, b) {
				try {
					return f(a, b);
				} catch(e) {
					return reject(e);
				}
			}

			/**
			 * Return f.call(thisArg, x), or if it throws return a rejected promise for
			 * the thrown exception
			 */
			function tryCatchReject(f, x, thisArg, next) {
				try {
					next.become(getHandler(f.call(thisArg, x)));
				} catch(e) {
					next.become(new Rejected(e));
				}
			}

			/**
			 * Same as above, but includes the extra argument parameter.
			 */
			function tryCatchReject3(f, x, y, thisArg, next) {
				try {
					f.call(thisArg, x, y, next);
				} catch(e) {
					next.become(new Rejected(e));
				}
			}

			/**
			 * @deprecated
			 * Return f.call(thisArg, x), or if it throws, *return* the exception
			 */
			function tryCatchReturn(f, x, thisArg, next) {
				try {
					next.notify(f.call(thisArg, x));
				} catch(e) {
					next.notify(e);
				}
			}

			function inherit(Parent, Child) {
				Child.prototype = objectCreate(Parent.prototype);
				Child.prototype.constructor = Child;
			}

			function snd(x, y) {
				return y;
			}

			function noop() {}

			function initEmitRejection() {
				/*global process, self, CustomEvent*/
				if(typeof process !== 'undefined' && process !== null
					&& typeof process.emit === 'function') {
					// Returning falsy here means to call the default
					// onPotentiallyUnhandledRejection API.  This is safe even in
					// browserify since process.emit always returns falsy in browserify:
					// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
					return function(type, rejection) {
						return type === 'unhandledRejection'
							? process.emit(type, rejection.value, rejection)
							: process.emit(type, rejection);
					};
				} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
					return (function(noop, self, CustomEvent) {
						var hasCustomEvent = false;
						try {
							var ev = new CustomEvent('unhandledRejection');
							hasCustomEvent = ev instanceof CustomEvent;
						} catch (e) {}

						return !hasCustomEvent ? noop : function(type, rejection) {
							var ev = new CustomEvent(type, {
								detail: {
									reason: rejection.value,
									key: rejection
								},
								bubbles: false,
								cancelable: true
							});

							return !self.dispatchEvent(ev);
						};
					}(noop, self, CustomEvent));
				}

				return noop;
			}

			return Promise;
		};
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		// Credit to Twisol (https://github.com/Twisol) for suggesting
		// this type of extensible queue + trampoline approach for next-tick conflation.

		/**
		 * Async task scheduler
		 * @param {function} async function to schedule a single async function
		 * @constructor
		 */
		function Scheduler(async) {
			this._async = async;
			this._running = false;

			this._queue = this;
			this._queueLen = 0;
			this._afterQueue = {};
			this._afterQueueLen = 0;

			var self = this;
			this.drain = function() {
				self._drain();
			};
		}

		/**
		 * Enqueue a task
		 * @param {{ run:function }} task
		 */
		Scheduler.prototype.enqueue = function(task) {
			this._queue[this._queueLen++] = task;
			this.run();
		};

		/**
		 * Enqueue a task to run after the main task queue
		 * @param {{ run:function }} task
		 */
		Scheduler.prototype.afterQueue = function(task) {
			this._afterQueue[this._afterQueueLen++] = task;
			this.run();
		};

		Scheduler.prototype.run = function() {
			if (!this._running) {
				this._running = true;
				this._async(this.drain);
			}
		};

		/**
		 * Drain the handler queue entirely, and then the after queue
		 */
		Scheduler.prototype._drain = function() {
			var i = 0;
			for (; i < this._queueLen; ++i) {
				this._queue[i].run();
				this._queue[i] = void 0;
			}

			this._queueLen = 0;
			this._running = false;

			for (i = 0; i < this._afterQueueLen; ++i) {
				this._afterQueue[i].run();
				this._afterQueue[i] = void 0;
			}

			this._afterQueueLen = 0;
		};

		return Scheduler;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(284)));


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2013 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define, location) {
		'use strict';

		var undef;

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var mixin, origin, urlRE, absoluteUrlRE, fullyQualifiedUrlRE;

			mixin = __webpack_require__(306);

			urlRE = /([a-z][a-z0-9\+\-\.]*:)\/\/([^@]+@)?(([^:\/]+)(:([0-9]+))?)?(\/[^?#]*)?(\?[^#]*)?(#\S*)?/i;
			absoluteUrlRE = /^([a-z][a-z0-9\-\+\.]*:\/\/|\/)/i;
			fullyQualifiedUrlRE = /([a-z][a-z0-9\+\-\.]*:)\/\/([^@]+@)?(([^:\/]+)(:([0-9]+))?)?\//i;

			/**
			 * Apply params to the template to create a URL.
			 *
			 * Parameters that are not applied directly to the template, are appended
			 * to the URL as query string parameters.
			 *
			 * @param {string} template the URI template
			 * @param {Object} params parameters to apply to the template
			 * @return {string} the resulting URL
			 */
			function buildUrl(template, params) {
				// internal builder to convert template with params.
				var url, name, queryStringParams, re;

				url = template;
				queryStringParams = {};

				if (params) {
					for (name in params) {
						/*jshint forin:false */
						re = new RegExp('\\{' + name + '\\}');
						if (re.test(url)) {
							url = url.replace(re, encodeURIComponent(params[name]), 'g');
						}
						else {
							queryStringParams[name] = params[name];
						}
					}
					for (name in queryStringParams) {
						url += url.indexOf('?') === -1 ? '?' : '&';
						url += encodeURIComponent(name);
						if (queryStringParams[name] !== null && queryStringParams[name] !== undefined) {
							url += '=';
							url += encodeURIComponent(queryStringParams[name]);
						}
					}
				}
				return url;
			}

			function startsWith(str, test) {
				return str.indexOf(test) === 0;
			}

			/**
			 * Create a new URL Builder
			 *
			 * @param {string|UrlBuilder} template the base template to build from, may be another UrlBuilder
			 * @param {Object} [params] base parameters
			 * @constructor
			 */
			function UrlBuilder(template, params) {
				if (!(this instanceof UrlBuilder)) {
					// invoke as a constructor
					return new UrlBuilder(template, params);
				}

				if (template instanceof UrlBuilder) {
					this._template = template.template;
					this._params = mixin({}, this._params, params);
				}
				else {
					this._template = (template || '').toString();
					this._params = params || {};
				}
			}

			UrlBuilder.prototype = {

				/**
				 * Create a new UrlBuilder instance that extends the current builder.
				 * The current builder is unmodified.
				 *
				 * @param {string} [template] URL template to append to the current template
				 * @param {Object} [params] params to combine with current params.  New params override existing params
				 * @return {UrlBuilder} the new builder
				 */
				append: function (template,  params) {
					// TODO consider query strings and fragments
					return new UrlBuilder(this._template + template, mixin({}, this._params, params));
				},

				/**
				 * Create a new UrlBuilder with a fully qualified URL based on the
				 * window's location or base href and the current templates relative URL.
				 *
				 * Path variables are preserved.
				 *
				 * *Browser only*
				 *
				 * @return {UrlBuilder} the fully qualified URL template
				 */
				fullyQualify: function () {
					if (!location) { return this; }
					if (this.isFullyQualified()) { return this; }

					var template = this._template;

					if (startsWith(template, '//')) {
						template = origin.protocol + template;
					}
					else if (startsWith(template, '/')) {
						template = origin.origin + template;
					}
					else if (!this.isAbsolute()) {
						template = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf('/') + 1);
					}

					if (template.indexOf('/', 8) === -1) {
						// default the pathname to '/'
						template = template + '/';
					}

					return new UrlBuilder(template, this._params);
				},

				/**
				 * True if the URL is absolute
				 *
				 * @return {boolean}
				 */
				isAbsolute: function () {
					return absoluteUrlRE.test(this.build());
				},

				/**
				 * True if the URL is fully qualified
				 *
				 * @return {boolean}
				 */
				isFullyQualified: function () {
					return fullyQualifiedUrlRE.test(this.build());
				},

				/**
				 * True if the URL is cross origin. The protocol, host and port must not be
				 * the same in order to be cross origin,
				 *
				 * @return {boolean}
				 */
				isCrossOrigin: function () {
					if (!origin) {
						return true;
					}
					var url = this.parts();
					return url.protocol !== origin.protocol ||
					       url.hostname !== origin.hostname ||
					       url.port !== origin.port;
				},

				/**
				 * Split a URL into its consituent parts following the naming convention of
				 * 'window.location'. One difference is that the port will contain the
				 * protocol default if not specified.
				 *
				 * @see https://developer.mozilla.org/en-US/docs/DOM/window.location
				 *
				 * @returns {Object} a 'window.location'-like object
				 */
				parts: function () {
					/*jshint maxcomplexity:20 */
					var url, parts;
					url = this.fullyQualify().build().match(urlRE);
					parts = {
						href: url[0],
						protocol: url[1],
						host: url[3] || '',
						hostname: url[4] || '',
						port: url[6],
						pathname: url[7] || '',
						search: url[8] || '',
						hash: url[9] || ''
					};
					parts.origin = parts.protocol + '//' + parts.host;
					parts.port = parts.port || (parts.protocol === 'https:' ? '443' : parts.protocol === 'http:' ? '80' : '');
					return parts;
				},

				/**
				 * Expand the template replacing path variables with parameters
				 *
				 * @param {Object} [params] params to combine with current params.  New params override existing params
				 * @return {string} the expanded URL
				 */
				build: function (params) {
					return buildUrl(this._template, mixin({}, this._params, params));
				},

				/**
				 * @see build
				 */
				toString: function () {
					return this.build();
				}

			};

			origin = location ? new UrlBuilder(location.href).parts() : undef;

			return UrlBuilder;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284),
		typeof window !== 'undefined' ? window.location : void 0
		// Boilerplate for AMD and Node
	));


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2013 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		// derived from dojo.mixin
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			var empty = {};

			/**
			 * Mix the properties from the source object into the destination object.
			 * When the same property occurs in more then one object, the right most
			 * value wins.
			 *
			 * @param {Object} dest the object to copy properties to
			 * @param {Object} sources the objects to copy properties from.  May be 1 to N arguments, but not an Array.
			 * @return {Object} the destination object
			 */
			function mixin(dest /*, sources... */) {
				var i, l, source, name;

				if (!dest) { dest = {}; }
				for (i = 1, l = arguments.length; i < l; i += 1) {
					source = arguments[i];
					for (name in source) {
						if (!(name in dest) || (dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name]))) {
							dest[name] = source[name];
						}
					}
				}

				return dest; // Object
			}

			return mixin;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			/**
			 * Normalize HTTP header names using the pseudo camel case.
			 *
			 * For example:
			 *   content-type         -> Content-Type
			 *   accepts              -> Accepts
			 *   x-custom-header-name -> X-Custom-Header-Name
			 *
			 * @param {string} name the raw header name
			 * @return {string} the normalized header name
			 */
			function normalizeHeaderName(name) {
				return name.toLowerCase()
					.split('-')
					.map(function (chunk) { return chunk.charAt(0).toUpperCase() + chunk.slice(1); })
					.join('-');
			}

			return normalizeHeaderName;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2014-2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var when = __webpack_require__(286),
				normalizeHeaderName = __webpack_require__(307);

			function property(promise, name) {
				return promise.then(
					function (value) {
						return value && value[name];
					},
					function (value) {
						return when.reject(value && value[name]);
					}
				);
			}

			/**
			 * Obtain the response entity
			 *
			 * @returns {Promise} for the response entity
			 */
			function entity() {
				/*jshint validthis:true */
				return property(this, 'entity');
			}

			/**
			 * Obtain the response status
			 *
			 * @returns {Promise} for the response status
			 */
			function status() {
				/*jshint validthis:true */
				return property(property(this, 'status'), 'code');
			}

			/**
			 * Obtain the response headers map
			 *
			 * @returns {Promise} for the response headers map
			 */
			function headers() {
				/*jshint validthis:true */
				return property(this, 'headers');
			}

			/**
			 * Obtain a specific response header
			 *
			 * @param {String} headerName the header to retrieve
			 * @returns {Promise} for the response header's value
			 */
			function header(headerName) {
				/*jshint validthis:true */
				headerName = normalizeHeaderName(headerName);
				return property(this.headers(), headerName);
			}

			/**
			 * Follow a related resource
			 *
			 * The relationship to follow may be define as a plain string, an object
			 * with the rel and params, or an array containing one or more entries
			 * with the previous forms.
			 *
			 * Examples:
			 *   response.follow('next')
			 *
			 *   response.follow({ rel: 'next', params: { pageSize: 100 } })
			 *
			 *   response.follow([
			 *       { rel: 'items', params: { projection: 'noImages' } },
			 *       'search',
			 *       { rel: 'findByGalleryIsNull', params: { projection: 'noImages' } },
			 *       'items'
			 *   ])
			 *
			 * @param {String|Object|Array} rels one, or more, relationships to follow
			 * @returns ResponsePromise<Response> related resource
			 */
			function follow(rels) {
				/*jshint validthis:true */
				rels = [].concat(rels);
				return make(when.reduce(rels, function (response, rel) {
					if (typeof rel === 'string') {
						rel = { rel: rel };
					}
					if (typeof response.entity.clientFor !== 'function') {
						throw new Error('Hypermedia response expected');
					}
					var client = response.entity.clientFor(rel.rel);
					return client({ params: rel.params });
				}, this));
			}

			/**
			 * Wrap a Promise as an ResponsePromise
			 *
			 * @param {Promise<Response>} promise the promise for an HTTP Response
			 * @returns {ResponsePromise<Response>} wrapped promise for Response with additional helper methods
			 */
			function make(promise) {
				promise.status = status;
				promise.headers = headers;
				promise.header = header;
				promise.entity = entity;
				promise.follow = follow;
				return promise;
			}

			function responsePromise() {
				return make(when.apply(when, arguments));
			}

			responsePromise.make = make;
			responsePromise.reject = function (val) {
				return make(when.reject(val));
			};
			responsePromise.promise = function (func) {
				return make(when.promise(func));
			};

			return responsePromise;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var defaultClient, mixin, responsePromise, client, when;

			defaultClient = __webpack_require__(282);
			mixin = __webpack_require__(306);
			responsePromise = __webpack_require__(308);
			client = __webpack_require__(283);
			when = __webpack_require__(286);

			/**
			 * Interceptors have the ability to intercept the request and/org response
			 * objects.  They may augment, prune, transform or replace the
			 * request/response as needed.  Clients may be composed by wrapping
			 * together multiple interceptors.
			 *
			 * Configured interceptors are functional in nature.  Wrapping a client in
			 * an interceptor will not affect the client, merely the data that flows in
			 * and out of that client.  A common configuration can be created once and
			 * shared; specialization can be created by further wrapping that client
			 * with custom interceptors.
			 *
			 * @param {Client} [target] client to wrap
			 * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation
			 * @returns {Client} A client wrapped with the interceptor
			 *
			 * @class Interceptor
			 */

			function defaultInitHandler(config) {
				return config;
			}

			function defaultRequestHandler(request /*, config, meta */) {
				return request;
			}

			function defaultResponseHandler(response /*, config, meta */) {
				return response;
			}

			function race(promisesOrValues) {
				// this function is different than when.any as the first to reject also wins
				return when.promise(function (resolve, reject) {
					promisesOrValues.forEach(function (promiseOrValue) {
						when(promiseOrValue, resolve, reject);
					});
				});
			}

			/**
			 * Alternate return type for the request handler that allows for more complex interactions.
			 *
			 * @param properties.request the traditional request return object
			 * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted
			 * @param {Client} [properties.client] override the defined client with an alternate client
			 * @param [properties.response] response for the request, short circuit the request
			 */
			function ComplexRequest(properties) {
				if (!(this instanceof ComplexRequest)) {
					// in case users forget the 'new' don't mix into the interceptor
					return new ComplexRequest(properties);
				}
				mixin(this, properties);
			}

			/**
			 * Create a new interceptor for the provided handlers.
			 *
			 * @param {Function} [handlers.init] one time intialization, must return the config object
			 * @param {Function} [handlers.request] request handler
			 * @param {Function} [handlers.response] response handler regardless of error state
			 * @param {Function} [handlers.success] response handler when the request is not in error
			 * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state
			 * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client
			 *
			 * @returns {Interceptor}
			 */
			function interceptor(handlers) {

				var initHandler, requestHandler, successResponseHandler, errorResponseHandler;

				handlers = handlers || {};

				initHandler            = handlers.init    || defaultInitHandler;
				requestHandler         = handlers.request || defaultRequestHandler;
				successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;
				errorResponseHandler   = handlers.error   || function () {
					// Propagate the rejection, with the result of the handler
					return when((handlers.response || defaultResponseHandler).apply(this, arguments), when.reject, when.reject);
				};

				return function (target, config) {

					if (typeof target === 'object') {
						config = target;
					}
					if (typeof target !== 'function') {
						target = handlers.client || defaultClient;
					}

					config = initHandler(config || {});

					function interceptedClient(request) {
						var context, meta;
						context = {};
						meta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };
						request = typeof request === 'string' ? { path: request } : request || {};
						request.originator = request.originator || interceptedClient;
						return responsePromise(
							requestHandler.call(context, request, config, meta),
							function (request) {
								var response, abort, next;
								next = target;
								if (request instanceof ComplexRequest) {
									// unpack request
									abort = request.abort;
									next = request.client || next;
									response = request.response;
									// normalize request, must be last
									request = request.request;
								}
								response = response || when(request, function (request) {
									return when(
										next(request),
										function (response) {
											return successResponseHandler.call(context, response, config, meta);
										},
										function (response) {
											return errorResponseHandler.call(context, response, config, meta);
										}
									);
								});
								return abort ? race([response, abort]) : response;
							},
							function (error) {
								return when.reject({ request: request, error: error });
							}
						);
					}

					return client(interceptedClient, target);
				};
			}

			interceptor.ComplexRequest = ComplexRequest;

			return interceptor;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2013 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var interceptor, when;

			interceptor = __webpack_require__(309);
			when = __webpack_require__(286);

			/**
			 * Rejects the response promise based on the status code.
			 *
			 * Codes greater than or equal to the provided value are rejected.  Default
			 * value 400.
			 *
			 * @param {Client} [client] client to wrap
			 * @param {number} [config.code=400] code to indicate a rejection
			 *
			 * @returns {Client}
			 */
			return interceptor({
				init: function (config) {
					config.code = config.code || 400;
					return config;
				},
				response: function (response, config) {
					if (response.status && response.status.code >= config.code) {
						return when.reject(response);
					}
					return response;
				}
			});

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2013 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var interceptor, UrlBuilder;

			interceptor = __webpack_require__(309);
			UrlBuilder = __webpack_require__(305);

			function startsWith(str, prefix) {
				return str.indexOf(prefix) === 0;
			}

			function endsWith(str, suffix) {
				return str.lastIndexOf(suffix) + suffix.length === str.length;
			}

			/**
			 * Prefixes the request path with a common value.
			 *
			 * @param {Client} [client] client to wrap
			 * @param {number} [config.prefix] path prefix
			 *
			 * @returns {Client}
			 */
			return interceptor({
				request: function (request, config) {
					var path;

					if (config.prefix && !(new UrlBuilder(request.path).isFullyQualified())) {
						path = config.prefix;
						if (request.path) {
							if (!endsWith(path, '/') && !startsWith(request.path, '/')) {
								// add missing '/' between path sections
								path += '/';
							}
							path += request.path;
						}
						request.path = path;
					}

					return request;
				}
			});

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var interceptor;

			interceptor = __webpack_require__(309);

			if (typeof console !== 'undefined') {
				console.log('rest.js: rest/interceptor/entity is deprecated, please use response.entity() instead');
			}

			/**
			 * @deprecated use response.entity() instead
			 *
			 * Returns the response entity as the response, discarding other response
			 * properties.
			 *
			 * @param {Client} [client] client to wrap
			 *
			 * @returns {Client}
			 */
			return interceptor({
				response: function (response) {
					if ('entity' in response) {
						return response.entity;
					}
					return response;
				}
			});

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var interceptor, mime, registry, noopConverter, when;

			interceptor = __webpack_require__(309);
			mime = __webpack_require__(314);
			registry = __webpack_require__(315);
			when = __webpack_require__(286);

			noopConverter = {
				read: function (obj) { return obj; },
				write: function (obj) { return obj; }
			};

			/**
			 * MIME type support for request and response entities.  Entities are
			 * (de)serialized using the converter for the MIME type.
			 *
			 * Request entities are converted using the desired converter and the
			 * 'Accept' request header prefers this MIME.
			 *
			 * Response entities are converted based on the Content-Type response header.
			 *
			 * @param {Client} [client] client to wrap
			 * @param {string} [config.mime='text/plain'] MIME type to encode the request
			 *   entity
			 * @param {string} [config.accept] Accept header for the request
			 * @param {Client} [config.client=<request.originator>] client passed to the
			 *   converter, defaults to the client originating the request
			 * @param {Registry} [config.registry] MIME registry, defaults to the root
			 *   registry
			 * @param {boolean} [config.permissive] Allow an unkown request MIME type
			 *
			 * @returns {Client}
			 */
			return interceptor({
				init: function (config) {
					config.registry = config.registry || registry;
					return config;
				},
				request: function (request, config) {
					var type, headers;

					headers = request.headers || (request.headers = {});
					type = mime.parse(headers['Content-Type'] = headers['Content-Type'] || config.mime || 'text/plain');
					headers.Accept = headers.Accept || config.accept || type.raw + ', application/json;q=0.8, text/plain;q=0.5, */*;q=0.2';

					if (!('entity' in request)) {
						return request;
					}

					return config.registry.lookup(type).otherwise(function () {
						// failed to resolve converter
						if (config.permissive) {
							return noopConverter;
						}
						throw 'mime-unknown';
					}).then(function (converter) {
						var client = config.client || request.originator;

						return when.attempt(converter.write, request.entity, { client: client, request: request, mime: type, registry: config.registry })
							.otherwise(function() {
								throw 'mime-serialization';
							})
							.then(function(entity) {
								request.entity = entity;
								return request;
							});
					});
				},
				response: function (response, config) {
					if (!(response.headers && response.headers['Content-Type'] && response.entity)) {
						return response;
					}

					var type = mime.parse(response.headers['Content-Type']);

					return config.registry.lookup(type).otherwise(function () { return noopConverter; }).then(function (converter) {
						var client = config.client || response.request && response.request.originator;

						return when.attempt(converter.read, response.entity, { client: client, response: response, mime: type, registry: config.registry })
							.otherwise(function (e) {
								response.error = 'mime-deserialization';
								response.cause = e;
								throw response;
							})
							.then(function (entity) {
								response.entity = entity;
								return response;
							});
					});
				}
			});

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	* Copyright 2014 the original author or authors
	* @license MIT, see LICENSE.txt for details
	*
	* @author Scott Andrews
	*/

	(function (define) {
		'use strict';

		var undef;

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			/**
			 * Parse a MIME type into it's constituent parts
			 *
			 * @param {string} mime MIME type to parse
			 * @return {{
			 *   {string} raw the original MIME type
			 *   {string} type the type and subtype
			 *   {string} [suffix] mime suffix, including the plus, if any
			 *   {Object} params key/value pair of attributes
			 * }}
			 */
			function parse(mime) {
				var params, type;

				params = mime.split(';');
				type = params[0].trim().split('+');

				return {
					raw: mime,
					type: type[0],
					suffix: type[1] ? '+' + type[1] : '',
					params: params.slice(1).reduce(function (params, pair) {
						pair = pair.split('=');
						params[pair[0].trim()] = pair[1] ? pair[1].trim() : undef;
						return params;
					}, {})
				};
			}

			return {
				parse: parse
			};

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var mime, when, registry;

			mime = __webpack_require__(314);
			when = __webpack_require__(286);

			function Registry(mimes) {

				/**
				 * Lookup the converter for a MIME type
				 *
				 * @param {string} type the MIME type
				 * @return a promise for the converter
				 */
				this.lookup = function lookup(type) {
					var parsed;

					parsed = typeof type === 'string' ? mime.parse(type) : type;

					if (mimes[parsed.raw]) {
						return mimes[parsed.raw];
					}
					if (mimes[parsed.type + parsed.suffix]) {
						return mimes[parsed.type + parsed.suffix];
					}
					if (mimes[parsed.type]) {
						return mimes[parsed.type];
					}
					if (mimes[parsed.suffix]) {
						return mimes[parsed.suffix];
					}

					return when.reject(new Error('Unable to locate converter for mime "' + parsed.raw + '"'));
				};

				/**
				 * Create a late dispatched proxy to the target converter.
				 *
				 * Common when a converter is registered under multiple names and
				 * should be kept in sync if updated.
				 *
				 * @param {string} type mime converter to dispatch to
				 * @returns converter whose read/write methods target the desired mime converter
				 */
				this.delegate = function delegate(type) {
					return {
						read: function () {
							var args = arguments;
							return this.lookup(type).then(function (converter) {
								return converter.read.apply(this, args);
							}.bind(this));
						}.bind(this),
						write: function () {
							var args = arguments;
							return this.lookup(type).then(function (converter) {
								return converter.write.apply(this, args);
							}.bind(this));
						}.bind(this)
					};
				};

				/**
				 * Register a custom converter for a MIME type
				 *
				 * @param {string} type the MIME type
				 * @param converter the converter for the MIME type
				 * @return a promise for the converter
				 */
				this.register = function register(type, converter) {
					mimes[type] = when(converter);
					return mimes[type];
				};

				/**
				 * Create a child registry whoes registered converters remain local, while
				 * able to lookup converters from its parent.
				 *
				 * @returns child MIME registry
				 */
				this.child = function child() {
					return new Registry(Object.create(mimes));
				};

			}

			registry = new Registry({});

			// include provided serializers
			registry.register('application/hal', __webpack_require__(316));
			registry.register('application/json', __webpack_require__(322));
			registry.register('application/x-www-form-urlencoded', __webpack_require__(323));
			registry.register('multipart/form-data', __webpack_require__(324));
			registry.register('text/plain', __webpack_require__(325));

			registry.register('+json', registry.delegate('application/json'));

			return registry;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2013-2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var pathPrefix, template, find, lazyPromise, responsePromise, when;

			pathPrefix = __webpack_require__(311);
			template = __webpack_require__(317);
			find = __webpack_require__(320);
			lazyPromise = __webpack_require__(321);
			responsePromise = __webpack_require__(308);
			when = __webpack_require__(286);

			function defineProperty(obj, name, value) {
				Object.defineProperty(obj, name, {
					value: value,
					configurable: true,
					enumerable: false,
					writeable: true
				});
			}

			/**
			 * Hypertext Application Language serializer
			 *
			 * Implemented to https://tools.ietf.org/html/draft-kelly-json-hal-06
			 *
			 * As the spec is still a draft, this implementation will be updated as the
			 * spec evolves
			 *
			 * Objects are read as HAL indexing links and embedded objects on to the
			 * resource. Objects are written as plain JSON.
			 *
			 * Embedded relationships are indexed onto the resource by the relationship
			 * as a promise for the related resource.
			 *
			 * Links are indexed onto the resource as a lazy promise that will GET the
			 * resource when a handler is first registered on the promise.
			 *
			 * A `requestFor` method is added to the entity to make a request for the
			 * relationship.
			 *
			 * A `clientFor` method is added to the entity to get a full Client for a
			 * relationship.
			 *
			 * The `_links` and `_embedded` properties on the resource are made
			 * non-enumerable.
			 */
			return {

				read: function (str, opts) {
					var client, console;

					opts = opts || {};
					client = opts.client;
					console = opts.console || console;

					function deprecationWarning(relationship, deprecation) {
						if (deprecation && console && console.warn || console.log) {
							(console.warn || console.log).call(console, 'Relationship \'' + relationship + '\' is deprecated, see ' + deprecation);
						}
					}

					return opts.registry.lookup(opts.mime.suffix).then(function (converter) {
						return when(converter.read(str, opts)).then(function (root) {

							find.findProperties(root, '_embedded', function (embedded, resource, name) {
								Object.keys(embedded).forEach(function (relationship) {
									if (relationship in resource) { return; }
									var related = responsePromise({
										entity: embedded[relationship]
									});
									defineProperty(resource, relationship, related);
								});
								defineProperty(resource, name, embedded);
							});
							find.findProperties(root, '_links', function (links, resource, name) {
								Object.keys(links).forEach(function (relationship) {
									var link = links[relationship];
									if (relationship in resource) { return; }
									defineProperty(resource, relationship, responsePromise.make(lazyPromise(function () {
										if (link.deprecation) { deprecationWarning(relationship, link.deprecation); }
										if (link.templated === true) {
											return template(client)({ path: link.href });
										}
										return client({ path: link.href });
									})));
								});
								defineProperty(resource, name, links);
								defineProperty(resource, 'clientFor', function (relationship, clientOverride) {
									var link = links[relationship];
									if (!link) {
										throw new Error('Unknown relationship: ' + relationship);
									}
									if (link.deprecation) { deprecationWarning(relationship, link.deprecation); }
									if (link.templated === true) {
										return template(
											clientOverride || client,
											{ template: link.href }
										);
									}
									return pathPrefix(
										clientOverride || client,
										{ prefix: link.href }
									);
								});
								defineProperty(resource, 'requestFor', function (relationship, request, clientOverride) {
									var client = this.clientFor(relationship, clientOverride);
									return client(request);
								});
							});

							return root;
						});
					});

				},

				write: function (obj, opts) {
					return opts.registry.lookup(opts.mime.suffix).then(function (converter) {
						return converter.write(obj, opts);
					});
				}

			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var interceptor, uriTemplate, mixin;

			interceptor = __webpack_require__(309);
			uriTemplate = __webpack_require__(318);
			mixin = __webpack_require__(306);

			/**
			 * Applies request params to the path as a URI Template
			 *
			 * Params are removed from the request object, as they have been consumed.
			 *
			 * @param {Client} [client] client to wrap
			 * @param {Object} [config.params] default param values
			 * @param {string} [config.template] default template
			 *
			 * @returns {Client}
			 */
			return interceptor({
				init: function (config) {
					config.params = config.params || {};
					config.template = config.template || '';
					return config;
				},
				request: function (request, config) {
					var template, params;

					template = request.path || config.template;
					params = mixin({}, request.params, config.params);

					request.path = uriTemplate.expand(template, params);
					delete request.params;

					return request;
				}
			});

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		var undef;

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var uriEncoder, operations, prefixRE;

			uriEncoder = __webpack_require__(319);

			prefixRE = /^([^:]*):([0-9]+)$/;
			operations = {
				'':  { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encode },
				'+': { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },
				'#': { first: '#', separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },
				'.': { first: '.', separator: '.', named: false, empty: '',  encoder: uriEncoder.encode },
				'/': { first: '/', separator: '/', named: false, empty: '',  encoder: uriEncoder.encode },
				';': { first: ';', separator: ';', named: true,  empty: '',  encoder: uriEncoder.encode },
				'?': { first: '?', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },
				'&': { first: '&', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },
				'=': { reserved: true },
				',': { reserved: true },
				'!': { reserved: true },
				'@': { reserved: true },
				'|': { reserved: true }
			};

			function apply(operation, expression, params) {
				/*jshint maxcomplexity:11 */
				return expression.split(',').reduce(function (result, variable) {
					var opts, value;

					opts = {};
					if (variable.slice(-1) === '*') {
						variable = variable.slice(0, -1);
						opts.explode = true;
					}
					if (prefixRE.test(variable)) {
						var prefix = prefixRE.exec(variable);
						variable = prefix[1];
						opts.maxLength = parseInt(prefix[2]);
					}

					variable = uriEncoder.decode(variable);
					value = params[variable];

					if (value === undef || value === null) {
						return result;
					}
					if (Array.isArray(value)) {
						result += value.reduce(function (result, value) {
							if (result.length) {
								result += opts.explode ? operation.separator : ',';
								if (operation.named && opts.explode) {
									result += operation.encoder(variable);
									result += value.length ? '=' : operation.empty;
								}
							}
							else {
								result += operation.first;
								if (operation.named) {
									result += operation.encoder(variable);
									result += value.length ? '=' : operation.empty;
								}
							}
							result += operation.encoder(value);
							return result;
						}, '');
					}
					else if (typeof value === 'object') {
						result += Object.keys(value).reduce(function (result, name) {
							if (result.length) {
								result += opts.explode ? operation.separator : ',';
							}
							else {
								result += operation.first;
								if (operation.named && !opts.explode) {
									result += operation.encoder(variable);
									result += value[name].length ? '=' : operation.empty;
								}
							}
							result += operation.encoder(name);
							result += opts.explode ? '=' : ',';
							result += operation.encoder(value[name]);
							return result;
						}, '');
					}
					else {
						value = String(value);
						if (opts.maxLength) {
							value = value.slice(0, opts.maxLength);
						}
						result += result.length ? operation.separator : operation.first;
						if (operation.named) {
							result += operation.encoder(variable);
							result += value.length ? '=' : operation.empty;
						}
						result += operation.encoder(value);
					}

					return result;
				}, '');
			}

			function expandExpression(expression, params) {
				var operation;

				operation = operations[expression.slice(0,1)];
				if (operation) {
					expression = expression.slice(1);
				}
				else {
					operation = operations[''];
				}

				if (operation.reserved) {
					throw new Error('Reserved expression operations are not supported');
				}

				return apply(operation, expression, params);
			}

			function expandTemplate(template, params) {
				var start, end, uri;

				uri = '';
				end = 0;
				while (true) {
					start = template.indexOf('{', end);
					if (start === -1) {
						// no more expressions
						uri += template.slice(end);
						break;
					}
					uri += template.slice(end, start);
					end = template.indexOf('}', start) + 1;
					uri += expandExpression(template.slice(start + 1, end - 1), params);
				}

				return uri;
			}

			return {

				/**
				 * Expand a URI Template with parameters to form a URI.
				 *
				 * Full implementation (level 4) of rfc6570.
				 * @see https://tools.ietf.org/html/rfc6570
				 *
				 * @param {string} template URI template
				 * @param {Object} [params] params to apply to the template durring expantion
				 * @returns {string} expanded URI
				 */
				expand: expandTemplate

			};

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			var charMap;

			charMap = (function () {
				var strings = {
					alpha: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
					digit: '0123456789'
				};

				strings.genDelims = ':/?#[]@';
				strings.subDelims = '!$&\'()*+,;=';
				strings.reserved = strings.genDelims + strings.subDelims;
				strings.unreserved = strings.alpha + strings.digit + '-._~';
				strings.url = strings.reserved + strings.unreserved;
				strings.scheme = strings.alpha + strings.digit + '+-.';
				strings.userinfo = strings.unreserved + strings.subDelims + ':';
				strings.host = strings.unreserved + strings.subDelims;
				strings.port = strings.digit;
				strings.pchar = strings.unreserved + strings.subDelims + ':@';
				strings.segment = strings.pchar;
				strings.path = strings.segment + '/';
				strings.query = strings.pchar + '/?';
				strings.fragment = strings.pchar + '/?';

				return Object.keys(strings).reduce(function (charMap, set) {
					charMap[set] = strings[set].split('').reduce(function (chars, myChar) {
						chars[myChar] = true;
						return chars;
					}, {});
					return charMap;
				}, {});
			}());

			function encode(str, allowed) {
				if (typeof str !== 'string') {
					throw new Error('String required for URL encoding');
				}
				return str.split('').map(function (myChar) {
					if (allowed.hasOwnProperty(myChar)) {
						return myChar;
					}
					var code = myChar.charCodeAt(0);
					if (code <= 127) {
						return '%' + code.toString(16).toUpperCase();
					}
					else {
						return encodeURIComponent(myChar).toUpperCase();
					}
				}).join('');
			}

			function makeEncoder(allowed) {
				allowed = allowed || charMap.unreserved;
				return function (str) {
					return encode(str, allowed);
				};
			}

			function decode(str) {
				return decodeURIComponent(str);
			}

			return {

				/*
				 * Decode URL encoded strings
				 *
				 * @param {string} URL encoded string
				 * @returns {string} URL decoded string
				 */
				decode: decode,

				/*
				 * URL encode a string
				 *
				 * All but alpha-numerics and a very limited set of punctuation - . _ ~ are
				 * encoded.
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encode: makeEncoder(),

				/*
				* URL encode a URL
				*
				* All character permitted anywhere in a URL are left unencoded even
				* if that character is not permitted in that portion of a URL.
				*
				* Note: This method is typically not what you want.
				*
				* @param {string} string to encode
				* @returns {string} URL encoded string
				*/
				encodeURL: makeEncoder(charMap.url),

				/*
				 * URL encode the scheme portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodeScheme: makeEncoder(charMap.scheme),

				/*
				 * URL encode the user info portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodeUserInfo: makeEncoder(charMap.userinfo),

				/*
				 * URL encode the host portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodeHost: makeEncoder(charMap.host),

				/*
				 * URL encode the port portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodePort: makeEncoder(charMap.port),

				/*
				 * URL encode a path segment portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodePathSegment: makeEncoder(charMap.segment),

				/*
				 * URL encode the path portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodePath: makeEncoder(charMap.path),

				/*
				 * URL encode the query portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodeQuery: makeEncoder(charMap.query),

				/*
				 * URL encode the fragment portion of a URL
				 *
				 * @param {string} string to encode
				 * @returns {string} URL encoded string
				 */
				encodeFragment: makeEncoder(charMap.fragment)

			};

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2013 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			return {

				/**
				 * Find objects within a graph the contain a property of a certain name.
				 *
				 * NOTE: this method will not discover object graph cycles.
				 *
				 * @param {*} obj object to search on
				 * @param {string} prop name of the property to search for
				 * @param {Function} callback function to receive the found properties and their parent
				 */
				findProperties: function findProperties(obj, prop, callback) {
					if (typeof obj !== 'object' || obj === null) { return; }
					if (prop in obj) {
						callback(obj[prop], obj, prop);
					}
					Object.keys(obj).forEach(function (key) {
						findProperties(obj[key], prop, callback);
					});
				}

			};

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2013 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var when;

			when = __webpack_require__(286);

			/**
			 * Create a promise whose work is started only when a handler is registered.
			 *
			 * The work function will be invoked at most once. Thrown values will result
			 * in promise rejection.
			 *
			 * @param {Function} work function whose ouput is used to resolve the
			 *   returned promise.
			 * @returns {Promise} a lazy promise
			 */
			function lazyPromise(work) {
				var defer, started, resolver, promise, then;

				defer = when.defer();
				started = false;

				resolver = defer.resolver;
				promise = defer.promise;
				then = promise.then;

				promise.then = function () {
					if (!started) {
						started = true;
						when.attempt(work).then(resolver.resolve, resolver.reject);
					}
					return then.apply(promise, arguments);
				};

				return promise;
			}

			return lazyPromise;

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012-2015 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			/**
			 * Create a new JSON converter with custom reviver/replacer.
			 *
			 * The extended converter must be published to a MIME registry in order
			 * to be used. The existing converter will not be modified.
			 *
			 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
			 *
			 * @param {function} [reviver=undefined] custom JSON.parse reviver
			 * @param {function|Array} [replacer=undefined] custom JSON.stringify replacer
			 */
			function createConverter(reviver, replacer) {
				return {

					read: function (str) {
						return JSON.parse(str, reviver);
					},

					write: function (obj) {
						return JSON.stringify(obj, replacer);
					},

					extend: createConverter

				};
			}

			return createConverter();

		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			var encodedSpaceRE, urlEncodedSpaceRE;

			encodedSpaceRE = /%20/g;
			urlEncodedSpaceRE = /\+/g;

			function urlEncode(str) {
				str = encodeURIComponent(str);
				// spec says space should be encoded as '+'
				return str.replace(encodedSpaceRE, '+');
			}

			function urlDecode(str) {
				// spec says space should be encoded as '+'
				str = str.replace(urlEncodedSpaceRE, ' ');
				return decodeURIComponent(str);
			}

			function append(str, name, value) {
				if (Array.isArray(value)) {
					value.forEach(function (value) {
						str = append(str, name, value);
					});
				}
				else {
					if (str.length > 0) {
						str += '&';
					}
					str += urlEncode(name);
					if (value !== undefined && value !== null) {
						str += '=' + urlEncode(value);
					}
				}
				return str;
			}

			return {

				read: function (str) {
					var obj = {};
					str.split('&').forEach(function (entry) {
						var pair, name, value;
						pair = entry.split('=');
						name = urlDecode(pair[0]);
						if (pair.length === 2) {
							value = urlDecode(pair[1]);
						}
						else {
							value = null;
						}
						if (name in obj) {
							if (!Array.isArray(obj[name])) {
								// convert to an array, perserving currnent value
								obj[name] = [obj[name]];
							}
							obj[name].push(value);
						}
						else {
							obj[name] = value;
						}
					});
					return obj;
				},

				write: function (obj) {
					var str = '';
					Object.keys(obj).forEach(function (name) {
						str = append(str, name, obj[name]);
					});
					return str;
				}

			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2014 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Michael Jackson
	 */

	/* global FormData, File, Blob */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			function isFormElement(object) {
				return object &&
					object.nodeType === 1 && // Node.ELEMENT_NODE
					object.tagName === 'FORM';
			}

			function createFormDataFromObject(object) {
				var formData = new FormData();

				var value;
				for (var property in object) {
					if (object.hasOwnProperty(property)) {
						value = object[property];

						if (value instanceof File) {
							formData.append(property, value, value.name);
						} else if (value instanceof Blob) {
							formData.append(property, value);
						} else {
							formData.append(property, String(value));
						}
					}
				}

				return formData;
			}

			return {

				write: function (object) {
					if (typeof FormData === 'undefined') {
						throw new Error('The multipart/form-data mime serializer requires FormData support');
					}

					// Support FormData directly.
					if (object instanceof FormData) {
						return object;
					}

					// Support <form> elements.
					if (isFormElement(object)) {
						return new FormData(object);
					}

					// Support plain objects, may contain File/Blob as value.
					if (typeof object === 'object' && object !== null) {
						return createFormDataFromObject(object);
					}

					throw new Error('Unable to create FormData from object ' + object);
				}

			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright 2012 the original author or authors
	 * @license MIT, see LICENSE.txt for details
	 *
	 * @author Scott Andrews
	 */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (/* require */) {

			return {

				read: function (str) {
					return str;
				},

				write: function (obj) {
					return obj.toString();
				}

			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	}(
		__webpack_require__(284)
		// Boilerplate for AMD and Node
	));


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(327);


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(328);
	var parser = __webpack_require__(331);
	var Manager = __webpack_require__(338);
	var debug = __webpack_require__(330)('socket.io-client');

	/**
	 * Module exports.
	 */

	module.exports = exports = lookup;

	/**
	 * Managers cache.
	 */

	var cache = exports.managers = {};

	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */

	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }

	  opts = opts || {};

	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var io;

	  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }

	  return io.socket(parsed.path);
	}

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = parser.protocol;

	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */

	exports.connect = lookup;

	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */

	exports.Manager = __webpack_require__(338);
	exports.Socket = __webpack_require__(369);


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module dependencies.
	 */

	var parseuri = __webpack_require__(329);
	var debug = __webpack_require__(330)('socket.io-client:url');

	/**
	 * Module exports.
	 */

	module.exports = url;

	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */

	function url(uri, loc){
	  var obj = uri;

	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;

	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.hostname + uri;
	      }
	    }

	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }

	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }

	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }

	  obj.path = obj.path || '/';

	  // define unique id
	  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

	  return obj;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 329 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
	  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];

	module.exports = function parseuri(str) {
	  var m = re.exec(str || '')
	    , uri = {}
	    , i = 14;

	  while (i--) {
	    uri[parts[i]] = m[i] || '';
	  }

	  return uri;
	};


/***/ },
/* 330 */
/***/ function(module, exports) {

	
	/**
	 * Expose `debug()` as the module.
	 */

	module.exports = debug;

	/**
	 * Create a debugger with the given `name`.
	 *
	 * @param {String} name
	 * @return {Type}
	 * @api public
	 */

	function debug(name) {
	  if (!debug.enabled(name)) return function(){};

	  return function(fmt){
	    fmt = coerce(fmt);

	    var curr = new Date;
	    var ms = curr - (debug[name] || curr);
	    debug[name] = curr;

	    fmt = name
	      + ' '
	      + fmt
	      + ' +' + debug.humanize(ms);

	    // This hackery is required for IE8
	    // where `console.log` doesn't have 'apply'
	    window.console
	      && console.log
	      && Function.prototype.apply.call(console.log, console, arguments);
	  }
	}

	/**
	 * The currently active debug mode names.
	 */

	debug.names = [];
	debug.skips = [];

	/**
	 * Enables a debug mode by name. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} name
	 * @api public
	 */

	debug.enable = function(name) {
	  try {
	    localStorage.debug = name;
	  } catch(e){}

	  var split = (name || '').split(/[\s,]+/)
	    , len = split.length;

	  for (var i = 0; i < len; i++) {
	    name = split[i].replace('*', '.*?');
	    if (name[0] === '-') {
	      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
	    }
	    else {
	      debug.names.push(new RegExp('^' + name + '$'));
	    }
	  }
	};

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	debug.disable = function(){
	  debug.enable('');
	};

	/**
	 * Humanize the given `ms`.
	 *
	 * @param {Number} m
	 * @return {String}
	 * @api private
	 */

	debug.humanize = function(ms) {
	  var sec = 1000
	    , min = 60 * 1000
	    , hour = 60 * min;

	  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
	  if (ms >= min) return (ms / min).toFixed(1) + 'm';
	  if (ms >= sec) return (ms / sec | 0) + 's';
	  return ms + 'ms';
	};

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	debug.enabled = function(name) {
	  for (var i = 0, len = debug.skips.length; i < len; i++) {
	    if (debug.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (var i = 0, len = debug.names.length; i < len; i++) {
	    if (debug.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	};

	/**
	 * Coerce `val`.
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

	// persist

	try {
	  if (window.localStorage) debug.enable(localStorage.debug);
	} catch(e){}


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var debug = __webpack_require__(330)('socket.io-parser');
	var json = __webpack_require__(332);
	var isArray = __webpack_require__(334);
	var Emitter = __webpack_require__(335);
	var binary = __webpack_require__(336);
	var isBuf = __webpack_require__(337);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = 4;

	/**
	 * Packet types.
	 *
	 * @api public
	 */

	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'BINARY_EVENT',
	  'ACK',
	  'BINARY_ACK',
	  'ERROR'
	];

	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */

	exports.CONNECT = 0;

	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */

	exports.DISCONNECT = 1;

	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */

	exports.EVENT = 2;

	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */

	exports.ACK = 3;

	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */

	exports.ERROR = 4;

	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */

	exports.BINARY_EVENT = 5;

	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */

	exports.BINARY_ACK = 6;

	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */

	exports.Encoder = Encoder;

	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */

	exports.Decoder = Decoder;

	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */

	function Encoder() {}

	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */

	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);

	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};

	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */

	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;

	  // first is type
	  str += obj.type;

	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }

	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }

	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }

	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }

	  debug('encoded %j as %s', obj, str);
	  return str;
	}

	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */

	function encodeAsBinary(obj, callback) {

	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;

	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }

	  binary.removeBlobs(obj, writeEncoding);
	}

	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */

	function Decoder() {
	  this.reconstructor = null;
	}

	/**
	 * Mix in `Emitter` with Decoder.
	 */

	Emitter(Decoder.prototype);

	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */

	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);

	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};

	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */

	function decodeString(str) {
	  var p = {};
	  var i = 0;

	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();

	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }

	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }

	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }

	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }

	  debug('decoded %s as %j', str, p);
	  return p;
	}

	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */

	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};

	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */

	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}

	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */

	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};

	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */

	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};

	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
	;(function (window) {
	  // Convenience aliases.
	  var getClass = {}.toString, isProperty, forEach, undef;

	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(333);

	  // Detect native implementations.
	  var nativeJSON = typeof JSON == "object" && JSON;

	  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
	  // available.
	  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

	  if (JSON3 && nativeJSON) {
	    // Explicitly delegate to the native `stringify` and `parse`
	    // implementations in CommonJS environments.
	    JSON3.stringify = nativeJSON.stringify;
	    JSON3.parse = nativeJSON.parse;
	  } else {
	    // Export for web browsers, JavaScript engines, and asynchronous module
	    // loaders, using the global `JSON` object if available.
	    JSON3 = window.JSON = nativeJSON || {};
	  }

	  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	  var isExtended = new Date(-3509827334573292);
	  try {
	    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	    // results for certain dates in Opera >= 10.53.
	    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	      // Safari < 2.0.2 stores the internal millisecond time value correctly,
	      // but clips the values returned by the date methods to the range of
	      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	  } catch (exception) {}

	  // Internal: Determines whether the native `JSON.stringify` and `parse`
	  // implementations are spec-compliant. Based on work by Ken Snyder.
	  function has(name) {
	    if (has[name] !== undef) {
	      // Return cached feature test result.
	      return has[name];
	    }

	    var isSupported;
	    if (name == "bug-string-char-index") {
	      // IE <= 7 doesn't support accessing string characters using square
	      // bracket notation. IE 8 only supports this for primitives.
	      isSupported = "a"[0] != "a";
	    } else if (name == "json") {
	      // Indicates whether both `JSON.stringify` and `JSON.parse` are
	      // supported.
	      isSupported = has("json-stringify") && has("json-parse");
	    } else {
	      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	      // Test `JSON.stringify`.
	      if (name == "json-stringify") {
	        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	        if (stringifySupported) {
	          // A test function object with a custom `toJSON` method.
	          (value = function () {
	            return 1;
	          }).toJSON = value;
	          try {
	            stringifySupported =
	              // Firefox 3.1b1 and b2 serialize string, number, and boolean
	              // primitives as object literals.
	              stringify(0) === "0" &&
	              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	              // literals.
	              stringify(new Number()) === "0" &&
	              stringify(new String()) == '""' &&
	              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	              // does not define a canonical JSON representation (this applies to
	              // objects with `toJSON` properties as well, *unless* they are nested
	              // within an object or array).
	              stringify(getClass) === undef &&
	              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	              // FF 3.1b3 pass this test.
	              stringify(undef) === undef &&
	              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	              // respectively, if the value is omitted entirely.
	              stringify() === undef &&
	              // FF 3.1b1, 2 throw an error if the given value is not a number,
	              // string, array, object, Boolean, or `null` literal. This applies to
	              // objects with custom `toJSON` methods as well, unless they are nested
	              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	              // methods entirely.
	              stringify(value) === "1" &&
	              stringify([value]) == "[1]" &&
	              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	              // `"[null]"`.
	              stringify([undef]) == "[null]" &&
	              // YUI 3.0.0b1 fails to serialize `null` literals.
	              stringify(null) == "null" &&
	              // FF 3.1b1, 2 halts serialization if an array contains a function:
	              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	              // elides non-JSON values from objects and arrays, unless they
	              // define custom `toJSON` methods.
	              stringify([undef, getClass, null]) == "[null,null,null]" &&
	              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	              // where character escape codes are expected (e.g., `\b` => `\u0008`).
	              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	              stringify(null, value) === "1" &&
	              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	              // serialize extended years.
	              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	              // The milliseconds are optional in ES 5, but required in 5.1.
	              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	              // four-digit years instead of six-digit years. Credits: @Yaffle.
	              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	              // values less than 1000. Credits: @Yaffle.
	              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	          } catch (exception) {
	            stringifySupported = false;
	          }
	        }
	        isSupported = stringifySupported;
	      }
	      // Test `JSON.parse`.
	      if (name == "json-parse") {
	        var parse = JSON3.parse;
	        if (typeof parse == "function") {
	          try {
	            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	            // Conforming implementations should also coerce the initial argument to
	            // a string prior to parsing.
	            if (parse("0") === 0 && !parse(false)) {
	              // Simple parsing test.
	              value = parse(serialized);
	              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	              if (parseSupported) {
	                try {
	                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                  parseSupported = !parse('"\t"');
	                } catch (exception) {}
	                if (parseSupported) {
	                  try {
	                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                    // certain octal literals.
	                    parseSupported = parse("01") !== 1;
	                  } catch (exception) {}
	                }
	                if (parseSupported) {
	                  try {
	                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                    // points. These environments, along with FF 3.1b1 and 2,
	                    // also allow trailing commas in JSON objects and arrays.
	                    parseSupported = parse("1.") !== 1;
	                  } catch (exception) {}
	                }
	              }
	            }
	          } catch (exception) {
	            parseSupported = false;
	          }
	        }
	        isSupported = parseSupported;
	      }
	    }
	    return has[name] = !!isSupported;
	  }

	  if (!has("json")) {
	    // Common `[[Class]]` name aliases.
	    var functionClass = "[object Function]";
	    var dateClass = "[object Date]";
	    var numberClass = "[object Number]";
	    var stringClass = "[object String]";
	    var arrayClass = "[object Array]";
	    var booleanClass = "[object Boolean]";

	    // Detect incomplete support for accessing string characters by index.
	    var charIndexBuggy = has("bug-string-char-index");

	    // Define additional utility methods if the `Date` methods are buggy.
	    if (!isExtended) {
	      var floor = Math.floor;
	      // A mapping between the months of the year and the number of days between
	      // January 1st and the first of the respective month.
	      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	      // Internal: Calculates the number of days between the Unix epoch and the
	      // first day of the given month.
	      var getDay = function (year, month) {
	        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	      };
	    }

	    // Internal: Determines if a property is a direct property of the given
	    // object. Delegates to the native `Object#hasOwnProperty` method.
	    if (!(isProperty = {}.hasOwnProperty)) {
	      isProperty = function (property) {
	        var members = {}, constructor;
	        if ((members.__proto__ = null, members.__proto__ = {
	          // The *proto* property cannot be set multiple times in recent
	          // versions of Firefox and SeaMonkey.
	          "toString": 1
	        }, members).toString != getClass) {
	          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	          // supports the mutable *proto* property.
	          isProperty = function (property) {
	            // Capture and break the object's prototype chain (see section 8.6.2
	            // of the ES 5.1 spec). The parenthesized expression prevents an
	            // unsafe transformation by the Closure Compiler.
	            var original = this.__proto__, result = property in (this.__proto__ = null, this);
	            // Restore the original prototype chain.
	            this.__proto__ = original;
	            return result;
	          };
	        } else {
	          // Capture a reference to the top-level `Object` constructor.
	          constructor = members.constructor;
	          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	          // other environments.
	          isProperty = function (property) {
	            var parent = (this.constructor || constructor).prototype;
	            return property in this && !(property in parent && this[property] === parent[property]);
	          };
	        }
	        members = null;
	        return isProperty.call(this, property);
	      };
	    }

	    // Internal: A set of primitive types used by `isHostType`.
	    var PrimitiveTypes = {
	      'boolean': 1,
	      'number': 1,
	      'string': 1,
	      'undefined': 1
	    };

	    // Internal: Determines if the given object `property` value is a
	    // non-primitive.
	    var isHostType = function (object, property) {
	      var type = typeof object[property];
	      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
	    };

	    // Internal: Normalizes the `for...in` iteration algorithm across
	    // environments. Each enumerated key is yielded to a `callback` function.
	    forEach = function (object, callback) {
	      var size = 0, Properties, members, property;

	      // Tests for bugs in the current environment's `for...in` algorithm. The
	      // `valueOf` property inherits the non-enumerable flag from
	      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	      (Properties = function () {
	        this.valueOf = 0;
	      }).prototype.valueOf = 0;

	      // Iterate over a new instance of the `Properties` class.
	      members = new Properties();
	      for (property in members) {
	        // Ignore all properties inherited from `Object.prototype`.
	        if (isProperty.call(members, property)) {
	          size++;
	        }
	      }
	      Properties = members = null;

	      // Normalize the iteration algorithm.
	      if (!size) {
	        // A list of non-enumerable properties inherited from `Object.prototype`.
	        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	        // properties.
	        forEach = function (object, callback) {
	          var isFunction = getClass.call(object) == functionClass, property, length;
	          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
	          for (property in object) {
	            // Gecko <= 1.0 enumerates the `prototype` property of functions under
	            // certain conditions; IE does not.
	            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	              callback(property);
	            }
	          }
	          // Manually invoke the callback for each non-enumerable property.
	          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	        };
	      } else if (size == 2) {
	        // Safari <= 2.0.4 enumerates shadowed properties twice.
	        forEach = function (object, callback) {
	          // Create a set of iterated properties.
	          var members = {}, isFunction = getClass.call(object) == functionClass, property;
	          for (property in object) {
	            // Store each property name to prevent double enumeration. The
	            // `prototype` property of functions is not enumerated due to cross-
	            // environment inconsistencies.
	            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	              callback(property);
	            }
	          }
	        };
	      } else {
	        // No bugs detected; use the standard `for...in` algorithm.
	        forEach = function (object, callback) {
	          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	          for (property in object) {
	            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	              callback(property);
	            }
	          }
	          // Manually invoke the callback for the `constructor` property due to
	          // cross-environment inconsistencies.
	          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	            callback(property);
	          }
	        };
	      }
	      return forEach(object, callback);
	    };

	    // Public: Serializes a JavaScript `value` as a JSON string. The optional
	    // `filter` argument may specify either a function that alters how object and
	    // array members are serialized, or an array of strings and numbers that
	    // indicates which properties should be serialized. The optional `width`
	    // argument may be either a string or number that specifies the indentation
	    // level of the output.
	    if (!has("json-stringify")) {
	      // Internal: A map of control characters and their escaped equivalents.
	      var Escapes = {
	        92: "\\\\",
	        34: '\\"',
	        8: "\\b",
	        12: "\\f",
	        10: "\\n",
	        13: "\\r",
	        9: "\\t"
	      };

	      // Internal: Converts `value` into a zero-padded string such that its
	      // length is at least equal to `width`. The `width` must be <= 6.
	      var leadingZeroes = "000000";
	      var toPaddedString = function (width, value) {
	        // The `|| 0` expression is necessary to work around a bug in
	        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	        return (leadingZeroes + (value || 0)).slice(-width);
	      };

	      // Internal: Double-quotes a string `value`, replacing all ASCII control
	      // characters (characters with code unit values between 0 and 31) with
	      // their escaped equivalents. This is an implementation of the
	      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	      var unicodePrefix = "\\u00";
	      var quote = function (value) {
	        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
	        if (isLarge) {
	          symbols = value.split("");
	        }
	        for (; index < length; index++) {
	          var charCode = value.charCodeAt(index);
	          // If the character is a control character, append its Unicode or
	          // shorthand escape sequence; otherwise, append the character as-is.
	          switch (charCode) {
	            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	              result += Escapes[charCode];
	              break;
	            default:
	              if (charCode < 32) {
	                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                break;
	              }
	              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
	          }
	        }
	        return result + '"';
	      };

	      // Internal: Recursively serializes an object. Implements the
	      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	        try {
	          // Necessary for host object support.
	          value = object[property];
	        } catch (exception) {}
	        if (typeof value == "object" && value) {
	          className = getClass.call(value);
	          if (className == dateClass && !isProperty.call(value, "toJSON")) {
	            if (value > -1 / 0 && value < 1 / 0) {
	              // Dates are serialized according to the `Date#toJSON` method
	              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	              // for the ISO 8601 date time string format.
	              if (getDay) {
	                // Manually compute the year, month, date, hours, minutes,
	                // seconds, and milliseconds if the `getUTC*` methods are
	                // buggy. Adapted from @Yaffle's `date-shim` project.
	                date = floor(value / 864e5);
	                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                date = 1 + date - getDay(year, month);
	                // The `time` value specifies the time within the day (see ES
	                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                // to compute `A modulo B`, as the `%` operator does not
	                // correspond to the `modulo` operation for negative numbers.
	                time = (value % 864e5 + 864e5) % 864e5;
	                // The hours, minutes, seconds, and milliseconds are obtained by
	                // decomposing the time within the day. See section 15.9.1.10.
	                hours = floor(time / 36e5) % 24;
	                minutes = floor(time / 6e4) % 60;
	                seconds = floor(time / 1e3) % 60;
	                milliseconds = time % 1e3;
	              } else {
	                year = value.getUTCFullYear();
	                month = value.getUTCMonth();
	                date = value.getUTCDate();
	                hours = value.getUTCHours();
	                minutes = value.getUTCMinutes();
	                seconds = value.getUTCSeconds();
	                milliseconds = value.getUTCMilliseconds();
	              }
	              // Serialize extended years correctly.
	              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                // Months, dates, hours, minutes, and seconds should have two
	                // digits; milliseconds should have three.
	                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                // Milliseconds are optional in ES 5.0, but required in 5.1.
	                "." + toPaddedString(3, milliseconds) + "Z";
	            } else {
	              value = null;
	            }
	          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	            // ignores all `toJSON` methods on these objects unless they are
	            // defined directly on an instance.
	            value = value.toJSON(property);
	          }
	        }
	        if (callback) {
	          // If a replacement function was provided, call it to obtain the value
	          // for serialization.
	          value = callback.call(object, property, value);
	        }
	        if (value === null) {
	          return "null";
	        }
	        className = getClass.call(value);
	        if (className == booleanClass) {
	          // Booleans are represented literally.
	          return "" + value;
	        } else if (className == numberClass) {
	          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	          // `"null"`.
	          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	        } else if (className == stringClass) {
	          // Strings are double-quoted and escaped.
	          return quote("" + value);
	        }
	        // Recursively serialize objects and arrays.
	        if (typeof value == "object") {
	          // Check for cyclic structures. This is a linear search; performance
	          // is inversely proportional to the number of unique nested objects.
	          for (length = stack.length; length--;) {
	            if (stack[length] === value) {
	              // Cyclic structures cannot be serialized by `JSON.stringify`.
	              throw TypeError();
	            }
	          }
	          // Add the object to the stack of traversed objects.
	          stack.push(value);
	          results = [];
	          // Save the current indentation level and indent one additional level.
	          prefix = indentation;
	          indentation += whitespace;
	          if (className == arrayClass) {
	            // Recursively serialize array elements.
	            for (index = 0, length = value.length; index < length; index++) {
	              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	              results.push(element === undef ? "null" : element);
	            }
	            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	          } else {
	            // Recursively serialize object members. Members are selected from
	            // either a user-specified list of property names, or the object
	            // itself.
	            forEach(properties || value, function (property) {
	              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	              if (element !== undef) {
	                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                // is not the empty string, let `member` {quote(property) + ":"}
	                // be the concatenation of `member` and the `space` character."
	                // The "`space` character" refers to the literal space
	                // character, not the `space` {width} argument provided to
	                // `JSON.stringify`.
	                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	              }
	            });
	            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	          }
	          // Remove the object from the traversed object stack.
	          stack.pop();
	          return result;
	        }
	      };

	      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	      JSON3.stringify = function (source, filter, width) {
	        var whitespace, callback, properties, className;
	        if (typeof filter == "function" || typeof filter == "object" && filter) {
	          if ((className = getClass.call(filter)) == functionClass) {
	            callback = filter;
	          } else if (className == arrayClass) {
	            // Convert the property names array into a makeshift set.
	            properties = {};
	            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	          }
	        }
	        if (width) {
	          if ((className = getClass.call(width)) == numberClass) {
	            // Convert the `width` to an integer and create a string containing
	            // `width` number of space characters.
	            if ((width -= width % 1) > 0) {
	              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	            }
	          } else if (className == stringClass) {
	            whitespace = width.length <= 10 ? width : width.slice(0, 10);
	          }
	        }
	        // Opera <= 7.54u2 discards the values associated with empty string keys
	        // (`""`) only if they are used directly within an object member list
	        // (e.g., `!("" in { "": 1})`).
	        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	      };
	    }

	    // Public: Parses a JSON source string.
	    if (!has("json-parse")) {
	      var fromCharCode = String.fromCharCode;

	      // Internal: A map of escaped control characters and their unescaped
	      // equivalents.
	      var Unescapes = {
	        92: "\\",
	        34: '"',
	        47: "/",
	        98: "\b",
	        116: "\t",
	        110: "\n",
	        102: "\f",
	        114: "\r"
	      };

	      // Internal: Stores the parser state.
	      var Index, Source;

	      // Internal: Resets the parser state and throws a `SyntaxError`.
	      var abort = function() {
	        Index = Source = null;
	        throw SyntaxError();
	      };

	      // Internal: Returns the next token, or `"$"` if the parser has reached
	      // the end of the source string. A token may be a string, number, `null`
	      // literal, or Boolean literal.
	      var lex = function () {
	        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	        while (Index < length) {
	          charCode = source.charCodeAt(Index);
	          switch (charCode) {
	            case 9: case 10: case 13: case 32:
	              // Skip whitespace tokens, including tabs, carriage returns, line
	              // feeds, and space characters.
	              Index++;
	              break;
	            case 123: case 125: case 91: case 93: case 58: case 44:
	              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	              // the current position.
	              value = charIndexBuggy ? source.charAt(Index) : source[Index];
	              Index++;
	              return value;
	            case 34:
	              // `"` delimits a JSON string; advance to the next character and
	              // begin parsing the string. String tokens are prefixed with the
	              // sentinel `@` character to distinguish them from punctuators and
	              // end-of-string tokens.
	              for (value = "@", Index++; Index < length;) {
	                charCode = source.charCodeAt(Index);
	                if (charCode < 32) {
	                  // Unescaped ASCII control characters (those with a code unit
	                  // less than the space character) are not permitted.
	                  abort();
	                } else if (charCode == 92) {
	                  // A reverse solidus (`\`) marks the beginning of an escaped
	                  // control character (including `"`, `\`, and `/`) or Unicode
	                  // escape sequence.
	                  charCode = source.charCodeAt(++Index);
	                  switch (charCode) {
	                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                      // Revive escaped control characters.
	                      value += Unescapes[charCode];
	                      Index++;
	                      break;
	                    case 117:
	                      // `\u` marks the beginning of a Unicode escape sequence.
	                      // Advance to the first character and validate the
	                      // four-digit code point.
	                      begin = ++Index;
	                      for (position = Index + 4; Index < position; Index++) {
	                        charCode = source.charCodeAt(Index);
	                        // A valid sequence comprises four hexdigits (case-
	                        // insensitive) that form a single hexadecimal value.
	                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                          // Invalid Unicode escape sequence.
	                          abort();
	                        }
	                      }
	                      // Revive the escaped character.
	                      value += fromCharCode("0x" + source.slice(begin, Index));
	                      break;
	                    default:
	                      // Invalid escape sequence.
	                      abort();
	                  }
	                } else {
	                  if (charCode == 34) {
	                    // An unescaped double-quote character marks the end of the
	                    // string.
	                    break;
	                  }
	                  charCode = source.charCodeAt(Index);
	                  begin = Index;
	                  // Optimize for the common case where a string is valid.
	                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                    charCode = source.charCodeAt(++Index);
	                  }
	                  // Append the string as-is.
	                  value += source.slice(begin, Index);
	                }
	              }
	              if (source.charCodeAt(Index) == 34) {
	                // Advance to the next character and return the revived string.
	                Index++;
	                return value;
	              }
	              // Unterminated string.
	              abort();
	            default:
	              // Parse numbers and literals.
	              begin = Index;
	              // Advance past the negative sign, if one is specified.
	              if (charCode == 45) {
	                isSigned = true;
	                charCode = source.charCodeAt(++Index);
	              }
	              // Parse an integer or floating-point value.
	              if (charCode >= 48 && charCode <= 57) {
	                // Leading zeroes are interpreted as octal literals.
	                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                  // Illegal octal literal.
	                  abort();
	                }
	                isSigned = false;
	                // Parse the integer component.
	                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                // Floats cannot contain a leading decimal point; however, this
	                // case is already accounted for by the parser.
	                if (source.charCodeAt(Index) == 46) {
	                  position = ++Index;
	                  // Parse the decimal component.
	                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                  if (position == Index) {
	                    // Illegal trailing decimal.
	                    abort();
	                  }
	                  Index = position;
	                }
	                // Parse exponents. The `e` denoting the exponent is
	                // case-insensitive.
	                charCode = source.charCodeAt(Index);
	                if (charCode == 101 || charCode == 69) {
	                  charCode = source.charCodeAt(++Index);
	                  // Skip past the sign following the exponent, if one is
	                  // specified.
	                  if (charCode == 43 || charCode == 45) {
	                    Index++;
	                  }
	                  // Parse the exponential component.
	                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                  if (position == Index) {
	                    // Illegal empty exponent.
	                    abort();
	                  }
	                  Index = position;
	                }
	                // Coerce the parsed value to a JavaScript number.
	                return +source.slice(begin, Index);
	              }
	              // A negative sign may only precede numbers.
	              if (isSigned) {
	                abort();
	              }
	              // `true`, `false`, and `null` literals.
	              if (source.slice(Index, Index + 4) == "true") {
	                Index += 4;
	                return true;
	              } else if (source.slice(Index, Index + 5) == "false") {
	                Index += 5;
	                return false;
	              } else if (source.slice(Index, Index + 4) == "null") {
	                Index += 4;
	                return null;
	              }
	              // Unrecognized token.
	              abort();
	          }
	        }
	        // Return the sentinel `$` character if the parser has reached the end
	        // of the source string.
	        return "$";
	      };

	      // Internal: Parses a JSON `value` token.
	      var get = function (value) {
	        var results, hasMembers;
	        if (value == "$") {
	          // Unexpected end of input.
	          abort();
	        }
	        if (typeof value == "string") {
	          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	            // Remove the sentinel `@` character.
	            return value.slice(1);
	          }
	          // Parse object and array literals.
	          if (value == "[") {
	            // Parses a JSON array, returning a new JavaScript array.
	            results = [];
	            for (;; hasMembers || (hasMembers = true)) {
	              value = lex();
	              // A closing square bracket marks the end of the array literal.
	              if (value == "]") {
	                break;
	              }
	              // If the array literal contains elements, the current token
	              // should be a comma separating the previous element from the
	              // next.
	              if (hasMembers) {
	                if (value == ",") {
	                  value = lex();
	                  if (value == "]") {
	                    // Unexpected trailing `,` in array literal.
	                    abort();
	                  }
	                } else {
	                  // A `,` must separate each array element.
	                  abort();
	                }
	              }
	              // Elisions and leading commas are not permitted.
	              if (value == ",") {
	                abort();
	              }
	              results.push(get(value));
	            }
	            return results;
	          } else if (value == "{") {
	            // Parses a JSON object, returning a new JavaScript object.
	            results = {};
	            for (;; hasMembers || (hasMembers = true)) {
	              value = lex();
	              // A closing curly brace marks the end of the object literal.
	              if (value == "}") {
	                break;
	              }
	              // If the object literal contains members, the current token
	              // should be a comma separator.
	              if (hasMembers) {
	                if (value == ",") {
	                  value = lex();
	                  if (value == "}") {
	                    // Unexpected trailing `,` in object literal.
	                    abort();
	                  }
	                } else {
	                  // A `,` must separate each object member.
	                  abort();
	                }
	              }
	              // Leading commas are not permitted, object property names must be
	              // double-quoted strings, and a `:` must separate each property
	              // name and value.
	              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                abort();
	              }
	              results[value.slice(1)] = get(lex());
	            }
	            return results;
	          }
	          // Unexpected token encountered.
	          abort();
	        }
	        return value;
	      };

	      // Internal: Updates a traversed object member.
	      var update = function(source, property, callback) {
	        var element = walk(source, property, callback);
	        if (element === undef) {
	          delete source[property];
	        } else {
	          source[property] = element;
	        }
	      };

	      // Internal: Recursively traverses a parsed JSON object, invoking the
	      // `callback` function for each value. This is an implementation of the
	      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	      var walk = function (source, property, callback) {
	        var value = source[property], length;
	        if (typeof value == "object" && value) {
	          // `forEach` can't be used to traverse an array in Opera <= 8.54
	          // because its `Object#hasOwnProperty` implementation returns `false`
	          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	          if (getClass.call(value) == arrayClass) {
	            for (length = value.length; length--;) {
	              update(value, length, callback);
	            }
	          } else {
	            forEach(value, function (property) {
	              update(value, property, callback);
	            });
	          }
	        }
	        return callback.call(source, property, value);
	      };

	      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	      JSON3.parse = function (source, callback) {
	        var result, value;
	        Index = 0;
	        Source = "" + source;
	        result = get(lex());
	        // If a JSON string contains multiple tokens, it is invalid.
	        if (lex() != "$") {
	          abort();
	        }
	        // Reset the parser state.
	        Index = Source = null;
	        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	      };
	    }
	  }

	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}(this));


/***/ },
/* 333 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 334 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 335 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};

	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

	/**
	 * Module requirements
	 */

	var isArray = __webpack_require__(334);
	var isBuf = __webpack_require__(337);

	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */

	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;

	  function _deconstructPacket(data) {
	    if (!data) return data;

	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }

	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};

	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */

	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;

	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }

	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};

	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */

	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;

	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;

	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }

	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };

	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }

	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 337 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;

	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */

	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(328);
	var eio = __webpack_require__(339);
	var Socket = __webpack_require__(369);
	var Emitter = __webpack_require__(335);
	var parser = __webpack_require__(331);
	var on = __webpack_require__(371);
	var bind = __webpack_require__(372);
	var object = __webpack_require__(375);
	var debug = __webpack_require__(330)('socket.io-client:manager');
	var indexOf = __webpack_require__(366);
	var Backoff = __webpack_require__(376);

	/**
	 * Module exports
	 */

	module.exports = Manager;

	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */

	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};

	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connected = [];
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}

	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */

	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	  }
	};

	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */

	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    this.nsps[nsp].id = this.engine.id;
	  }
	};

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Manager.prototype);

	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};

	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};

	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};

	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};

	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};

	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};

	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */

	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};


	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */

	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;

	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;

	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });

	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });

	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);

	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);

	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }

	  this.subs.push(openSub);
	  this.subs.push(errorSub);

	  return this;
	};

	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */

	Manager.prototype.onopen = function(){
	  debug('open');

	  // clear old subs
	  this.cleanup();

	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');

	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	};

	/**
	 * Called with data.
	 *
	 * @api private
	 */

	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};

	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */

	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */

	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};

	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */

	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	      if (!~indexOf(self.connected, socket)) {
	        self.connected.push(socket);
	      }
	    });
	  }
	  return socket;
	};

	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */

	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connected, socket);
	  if (~index) this.connected.splice(index, 1);
	  if (this.connected.length) return;

	  this.close();
	};

	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;

	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i]);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};

	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */

	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};

	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */

	Manager.prototype.cleanup = function(){
	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();

	  this.packetBuffer = [];
	  this.encoding = false;

	  this.decoder.destroy();
	};

	/**
	 * Close the current socket.
	 *
	 * @api private
	 */

	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  this.skipReconnect = true;
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.engine && this.engine.close();
	};

	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */

	Manager.prototype.onclose = function(reason){
	  debug('close');
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};

	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */

	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;

	  var self = this;

	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);

	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;

	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);

	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;

	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);

	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};

	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */

	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(340);


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(341);

	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(349);


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var transports = __webpack_require__(342);
	var Emitter = __webpack_require__(335);
	var debug = __webpack_require__(360)('engine.io-client:socket');
	var index = __webpack_require__(366);
	var parser = __webpack_require__(349);
	var parseuri = __webpack_require__(367);
	var parsejson = __webpack_require__(368);
	var parseqs = __webpack_require__(358);

	/**
	 * Module exports.
	 */

	module.exports = Socket;

	/**
	 * Noop function.
	 *
	 * @api private
	 */

	function noop(){}

	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */

	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);

	  opts = opts || {};

	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }

	  if (uri) {
	    uri = parseuri(uri);
	    opts.host = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  }

	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);

	  if (opts.host) {
	    var pieces = opts.host.split(':');
	    opts.hostname = pieces.shift();
	    if (pieces.length) {
	      opts.port = pieces.pop();
	    } else if (!opts.port) {
	      // if no port is specified manually, use the protocol default
	      opts.port = this.secure ? '443' : '80';
	    }
	  }

	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.callbackBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized || null;

	  this.open();
	}

	Socket.priorWebsocketSuccess = false;

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	Socket.protocol = parser.protocol; // this is an int

	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */

	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(348);
	Socket.transports = __webpack_require__(342);
	Socket.parser = __webpack_require__(349);

	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */

	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);

	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;

	  // transport name
	  query.transport = name;

	  // session id if we already have one
	  if (this.id) query.sid = this.id;

	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized
	  });

	  return transport;
	};

	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}

	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 == this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';

	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  var transport;
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }

	  transport.open();
	  this.setTransport(transport);
	};

	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */

	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;

	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }

	  // set up transport
	  this.transport = transport;

	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};

	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */

	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;

	  Socket.priorWebsocketSuccess = false;

	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;

	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');

	          cleanup();

	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }

	  function freezeTransport() {
	    if (failed) return;

	    // Any callback called by transport should be ignored since now
	    failed = true;

	    cleanup();

	    transport.close();
	    transport = null;
	  }

	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;

	    freezeTransport();

	    debug('probe transport "%s" failed because of error: %s', name, err);

	    self.emit('upgradeError', error);
	  }

	  function onTransportClose(){
	    onerror("transport closed");
	  }

	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }

	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }

	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }

	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);

	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);

	  transport.open();

	};

	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */

	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();

	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};

	/**
	 * Handles a packet.
	 *
	 * @api private
	 */

	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

	    this.emit('packet', packet);

	    // Socket is live - any packet counts
	    this.emit('heartbeat');

	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;

	      case 'pong':
	        this.setPing();
	        break;

	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.emit('error', err);
	        break;

	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};

	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */

	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();

	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};

	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */

	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};

	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */

	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};

	/**
	* Sends a ping packet.
	*
	* @api public
	*/

	Socket.prototype.ping = function () {
	  this.sendPacket('ping');
	};

	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */

	Socket.prototype.onDrain = function() {
	  for (var i = 0; i < this.prevBufferLen; i++) {
	    if (this.callbackBuffer[i]) {
	      this.callbackBuffer[i]();
	    }
	  }

	  this.writeBuffer.splice(0, this.prevBufferLen);
	  this.callbackBuffer.splice(0, this.prevBufferLen);

	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;

	  if (this.writeBuffer.length == 0) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};

	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */

	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};

	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @return {Socket} for chaining.
	 * @api public
	 */

	Socket.prototype.write =
	Socket.prototype.send = function (msg, fn) {
	  this.sendPacket('message', msg, fn);
	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Function} callback function.
	 * @api private
	 */

	Socket.prototype.sendPacket = function (type, data, fn) {
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }

	  var packet = { type: type, data: data };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  this.callbackBuffer.push(fn);
	  this.flush();
	};

	/**
	 * Closes the connection.
	 *
	 * @api private
	 */

	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';

	    var self = this;

	    function close() {
	      self.onClose('forced close');
	      debug('socket closing - telling transport to close');
	      self.transport.close();
	    }

	    function cleanupAndClose() {
	      self.removeListener('upgrade', cleanupAndClose);
	      self.removeListener('upgradeError', cleanupAndClose);
	      close();
	    }

	    function waitForUpgrade() {
	      // wait for upgrade to finish since we can't send packets while pausing a transport
	      self.once('upgrade', cleanupAndClose);
	      self.once('upgradeError', cleanupAndClose);
	    }

	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }

	  return this;
	};

	/**
	 * Called upon transport error
	 *
	 * @api private
	 */

	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};

	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */

	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;

	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);

	    // clean buffers in next tick, so developers can still
	    // grab the buffers on `close` event
	    setTimeout(function() {
	      self.writeBuffer = [];
	      self.callbackBuffer = [];
	      self.prevBufferLen = 0;
	    }, 0);

	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');

	    // ensure transport won't stay open
	    this.transport.close();

	    // ignore further transport communication
	    this.transport.removeAllListeners();

	    // set ready state
	    this.readyState = 'closed';

	    // clear session id
	    this.id = null;

	    // emit close event
	    this.emit('close', reason, desc);
	  }
	};

	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */

	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */

	var XMLHttpRequest = __webpack_require__(343);
	var XHR = __webpack_require__(346);
	var JSONP = __webpack_require__(363);
	var websocket = __webpack_require__(364);

	/**
	 * Export transports.
	 */

	exports.polling = polling;
	exports.websocket = websocket;

	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */

	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }

	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);

	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(344);

	module.exports = function(opts) {
	  var xdomain = opts.xdomain;

	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;

	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;

	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }

	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }

	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var global = __webpack_require__(345);

	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */

	try {
	  module.exports = 'XMLHttpRequest' in global &&
	    'withCredentials' in new global.XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 345 */
/***/ function(module, exports) {

	
	/**
	 * Returns `this`. Execute this without a "context" (i.e. without it being
	 * attached to an object of the left-hand side), and `this` points to the
	 * "global" scope of the current JS execution.
	 */

	module.exports = (function () { return this; })();


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */

	var XMLHttpRequest = __webpack_require__(343);
	var Polling = __webpack_require__(347);
	var Emitter = __webpack_require__(335);
	var inherit = __webpack_require__(359);
	var debug = __webpack_require__(360)('engine.io-client:polling-xhr');

	/**
	 * Module exports.
	 */

	module.exports = XHR;
	module.exports.Request = Request;

	/**
	 * Empty function
	 */

	function empty(){}

	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function XHR(opts){
	  Polling.call(this, opts);

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(XHR, Polling);

	/**
	 * XHR supports binary
	 */

	XHR.prototype.supportsBinary = true;

	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */

	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  return new Request(opts);
	};

	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */

	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};

	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */

	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  this.create();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Request.prototype);

	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */

	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;

	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }

	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }

	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }

	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }

	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }

	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};

	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */

	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};

	/**
	 * Called if we have data.
	 *
	 * @api private
	 */

	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};

	/**
	 * Called upon error.
	 *
	 * @api private
	 */

	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};

	/**
	 * Cleans up house.
	 *
	 * @api private
	 */

	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }

	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }

	  if (global.document) {
	    delete Request.requests[this.index];
	  }

	  this.xhr = null;
	};

	/**
	 * Called upon load.
	 *
	 * @api private
	 */

	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        data = 'ok';
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};

	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */

	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};

	/**
	 * Aborts the request.
	 *
	 * @api public
	 */

	Request.prototype.abort = function(){
	  this.cleanup();
	};

	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */

	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}

	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(348);
	var parseqs = __webpack_require__(358);
	var parser = __webpack_require__(349);
	var inherit = __webpack_require__(359);
	var debug = __webpack_require__(360)('engine.io-client:polling');

	/**
	 * Module exports.
	 */

	module.exports = Polling;

	/**
	 * Is XHR2 supported?
	 */

	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(343);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();

	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */

	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(Polling, Transport);

	/**
	 * Transport name.
	 */

	Polling.prototype.name = 'polling';

	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */

	Polling.prototype.doOpen = function(){
	  this.poll();
	};

	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */

	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;

	  this.readyState = 'pausing';

	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }

	  if (this.polling || !this.writable) {
	    var total = 0;

	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }

	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};

	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */

	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};

	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */

	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }

	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }

	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };

	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);

	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');

	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};

	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */

	Polling.prototype.doClose = function(){
	  var self = this;

	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }

	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};

	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */

	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };

	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';

	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
	  }

	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  return schema + '://' + this.hostname + port + this.path + query;
	};


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(349);
	var Emitter = __webpack_require__(335);

	/**
	 * Module exports.
	 */

	module.exports = Transport;

	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */

	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Transport.prototype);

	/**
	 * A counter used to prevent collisions in the timestamps used
	 * for cache busting.
	 */

	Transport.timestamps = 0;

	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */

	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};

	/**
	 * Opens the transport.
	 *
	 * @api public
	 */

	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }

	  return this;
	};

	/**
	 * Closes the transport.
	 *
	 * @api private
	 */

	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }

	  return this;
	};

	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */

	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};

	/**
	 * Called upon open
	 *
	 * @api private
	 */

	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};

	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */

	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};

	/**
	 * Called with a decoded packet.
	 */

	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon close.
	 *
	 * @api private
	 */

	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var keys = __webpack_require__(350);
	var hasBinary = __webpack_require__(351);
	var sliceBuffer = __webpack_require__(353);
	var base64encoder = __webpack_require__(354);
	var after = __webpack_require__(355);
	var utf8 = __webpack_require__(356);

	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */

	var isAndroid = navigator.userAgent.match(/Android/i);

	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;

	/**
	 * Current protocol version.
	 */

	exports.protocol = 3;

	/**
	 * Packet types.
	 */

	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};

	var packetslist = keys(packets);

	/**
	 * Premade error packet.
	 */

	var err = { type: 'error', data: 'parser error' };

	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */

	var Blob = __webpack_require__(357);

	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */

	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }

	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }

	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;

	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }

	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }

	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];

	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }

	  return callback('' + encoded);

	};

	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}

	/**
	 * Encode packet helpers for binary types
	 */

	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);

	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }

	  return callback(resultBuffer.buffer);
	}

	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}

	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }

	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);

	  return callback(blob);
	}

	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */

	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }

	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};

	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */

	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }

	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);

	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }

	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }

	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};

	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */

	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }

	  var data = base64encoder.decode(msg.substr(1));

	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }

	  return { type: type, data: data };
	};

	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */

	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }

	  var isBinary = hasBinary(packets);

	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }

	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }

	  if (!packets.length) {
	    return callback('0:');
	  }

	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};

	/**
	 * Async array map using after
	 */

	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);

	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };

	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}

	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */

	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }

	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	  var length = ''
	    , n, msg;

	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);

	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      msg = data.substr(i + 1, n);

	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);

	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }

	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }

	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }

	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	};

	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */

	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }

	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);

	    var resultArray = new Uint8Array(totalLength);

	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }

	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }

	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;

	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });

	    return callback(resultArray.buffer);
	  });
	};

	/**
	 * Encode as Blob
	 */

	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }

	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;

	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;

	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};

	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */

	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var bufferTail = data;
	  var buffers = [];

	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';

	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;

	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }

	      msgLength += tailArray[i];
	    }

	    if(numberTooLong) return callback(err, 0, 1);

	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);

	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }

	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }

	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 350 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */

	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;

	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(352);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 352 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 353 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */

	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;

	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }

	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }

	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 354 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";

	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";

	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }

	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }

	    return base64;
	  };

	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;

	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }

	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);

	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);

	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }

	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 355 */
/***/ function(module, exports) {

	module.exports = after

	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count

	    return (count === 0) ? callback() : proxy

	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count

	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}

	function noop() {}


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! http://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from http://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from http://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);

			// console.log(JSON.stringify(codePoints.map(function(x) {
			// 	return 'U+' + x.toString(16).toUpperCase();
			// })));

			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, its not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module), (function() { return this; }())))

/***/ },
/* 357 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */

	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;

	/**
	 * Check if Blob constructor is supported
	 */

	var blobSupported = (function() {
	  try {
	    var b = new Blob(['hi']);
	    return b.size == 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if BlobBuilder is supported
	 */

	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;

	function BlobBuilderConstructor(ary, options) {
	  options = options || {};

	  var bb = new BlobBuilder();
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};

	module.exports = (function() {
	  if (blobSupported) {
	    return global.Blob;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 358 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */

	exports.encode = function (obj) {
	  var str = '';

	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }

	  return str;
	};

	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */

	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 359 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(361);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // This hackery is required for IE8,
	  // where the `console.log` function doesn't have 'apply'
	  return 'object' == typeof console
	    && 'function' == typeof console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      localStorage.removeItem('debug');
	    } else {
	      localStorage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = localStorage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(362);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 362 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 's':
	      return n * s;
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */

	var Polling = __webpack_require__(347);
	var inherit = __webpack_require__(359);

	/**
	 * Module exports.
	 */

	module.exports = JSONPPolling;

	/**
	 * Cached regular expressions.
	 */

	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;

	/**
	 * Global JSONP callbacks.
	 */

	var callbacks;

	/**
	 * Callbacks count.
	 */

	var index = 0;

	/**
	 * Noop.
	 */

	function empty () { }

	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */

	function JSONPPolling (opts) {
	  Polling.call(this, opts);

	  this.query = this.query || {};

	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }

	  // callback identifier
	  this.index = callbacks.length;

	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });

	  // append to query string
	  this.query.j = this.index;

	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(JSONPPolling, Polling);

	/*
	 * JSONP only supports binary as base64 encoded strings
	 */

	JSONPPolling.prototype.supportsBinary = false;

	/**
	 * Closes the socket.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }

	  Polling.prototype.doClose.call(this);
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');

	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };

	  var insertAt = document.getElementsByTagName('script')[0];
	  insertAt.parentNode.insertBefore(script, insertAt);
	  this.script = script;

	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};

	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */

	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;

	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;

	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);

	    this.form = form;
	    this.area = area;
	  }

	  this.form.action = this.uri();

	  function complete () {
	    initIframe();
	    fn();
	  }

	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }

	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }

	    iframe.id = self.iframeId;

	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }

	  initIframe();

	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');

	  try {
	    this.form.submit();
	  } catch(e) {}

	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(348);
	var parser = __webpack_require__(349);
	var parseqs = __webpack_require__(358);
	var inherit = __webpack_require__(359);
	var debug = __webpack_require__(360)('engine.io-client:websocket');

	/**
	 * `ws` exposes a WebSocket-compatible interface in
	 * Node, or the `WebSocket` or `MozWebSocket` globals
	 * in the browser.
	 */

	var WebSocket = __webpack_require__(365);

	/**
	 * Module exports.
	 */

	module.exports = WS;

	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */

	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(WS, Transport);

	/**
	 * Transport name.
	 *
	 * @api public
	 */

	WS.prototype.name = 'websocket';

	/*
	 * WebSockets support binary
	 */

	WS.prototype.supportsBinary = true;

	/**
	 * Opens socket.
	 *
	 * @api private
	 */

	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }

	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = { agent: this.agent };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  this.ws = new WebSocket(uri, protocols, opts);

	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }

	  this.ws.binaryType = 'arraybuffer';
	  this.addEventListeners();
	};

	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */

	WS.prototype.addEventListeners = function(){
	  var self = this;

	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};

	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */

	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}

	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */

	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  for (var i = 0, l = packets.length; i < l; i++) {
	    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
	      //Sometimes the websocket has already been closed but the browser didn't
	      //have a chance of informing us about it yet, in that case send will
	      //throw an error
	      try {
	        self.ws.send(data);
	      } catch (e){
	        debug('websocket closed before onclose event');
	      }
	    });
	  }

	  function ondrain() {
	    self.writable = true;
	    self.emit('drain');
	  }
	  // fake drain
	  // defer to next tick to allow Socket to clear writeBuffer
	  setTimeout(ondrain, 0);
	};

	/**
	 * Called upon close
	 *
	 * @api private
	 */

	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};

	/**
	 * Closes socket.
	 *
	 * @api private
	 */

	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';

	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = +new Date;
	  }

	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  return schema + '://' + this.hostname + port + this.path + query;
	};

	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */

	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};


/***/ },
/* 365 */
/***/ function(module, exports) {

	
	/**
	 * Module dependencies.
	 */

	var global = (function() { return this; })();

	/**
	 * WebSocket constructor.
	 */

	var WebSocket = global.WebSocket || global.MozWebSocket;

	/**
	 * Module exports.
	 */

	module.exports = WebSocket ? ws : null;

	/**
	 * WebSocket constructor.
	 *
	 * The third `opts` options object gets ignored in web browsers, since it's
	 * non-standard, and throws a TypeError if passed to the constructor.
	 * See: https://github.com/einaros/ws/issues/227
	 *
	 * @param {String} uri
	 * @param {Array} protocols (optional)
	 * @param {Object) opts (optional)
	 * @api public
	 */

	function ws(uri, protocols, opts) {
	  var instance;
	  if (protocols) {
	    instance = new WebSocket(uri, protocols);
	  } else {
	    instance = new WebSocket(uri);
	  }
	  return instance;
	}

	if (WebSocket) ws.prototype = WebSocket.prototype;


/***/ },
/* 366 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 367 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];

	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');

	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }

	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;

	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }

	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }

	    return uri;
	};


/***/ },
/* 368 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */

	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;

	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }

	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }

	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(331);
	var Emitter = __webpack_require__(335);
	var toArray = __webpack_require__(370);
	var on = __webpack_require__(371);
	var bind = __webpack_require__(372);
	var debug = __webpack_require__(330)('socket.io-client:socket');
	var hasBin = __webpack_require__(373);

	/**
	 * Module exports.
	 */

	module.exports = exports = Socket;

	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */

	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1
	};

	/**
	 * Shortcut to `Emitter#emit`.
	 */

	var emit = Emitter.prototype.emit;

	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */

	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  if (this.io.autoConnect) this.open();
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */

	Socket.prototype.subEvents = function() {
	  if (this.subs) return;

	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};

	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */

	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;

	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  return this;
	};

	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};

	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }

	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };

	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }

	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }

	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};

	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */

	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');

	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};

	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */

	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};

	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;

	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;

	    case parser.EVENT:
	      this.onevent(packet);
	      break;

	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;

	    case parser.ACK:
	      this.onack(packet);
	      break;

	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;

	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;

	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};

	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);

	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }

	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};

	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */

	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);

	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};

	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onack = function(packet){
	  debug('calling ack %s with %j', packet.id, packet.data);
	  var fn = this.acks[packet.id];
	  fn.apply(this, packet.data);
	  delete this.acks[packet.id];
	};

	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */

	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};

	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */

	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];

	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};

	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */

	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};

	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */

	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }

	  this.io.destroy(this);
	};

	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }

	  // remove socket from pool
	  this.destroy();

	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};


/***/ },
/* 370 */
/***/ function(module, exports) {

	module.exports = toArray

	function toArray(list, index) {
	    var array = []

	    index = index || 0

	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }

	    return array
	}


/***/ },
/* 371 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 */

	module.exports = on;

	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 372 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */

	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(374);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 374 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 375 */
/***/ function(module, exports) {

	
	/**
	 * HOP ref.
	 */

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Return own keys in `obj`.
	 *
	 * @param {Object} obj
	 * @return {Array}
	 * @api public
	 */

	exports.keys = Object.keys || function(obj){
	  var keys = [];
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      keys.push(key);
	    }
	  }
	  return keys;
	};

	/**
	 * Return own values in `obj`.
	 *
	 * @param {Object} obj
	 * @return {Array}
	 * @api public
	 */

	exports.values = function(obj){
	  var vals = [];
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      vals.push(obj[key]);
	    }
	  }
	  return vals;
	};

	/**
	 * Merge `b` into `a`.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api public
	 */

	exports.merge = function(a, b){
	  for (var key in b) {
	    if (has.call(b, key)) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};

	/**
	 * Return length of `obj`.
	 *
	 * @param {Object} obj
	 * @return {Number}
	 * @api public
	 */

	exports.length = function(obj){
	  return exports.keys(obj).length;
	};

	/**
	 * Check if `obj` is empty.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api public
	 */

	exports.isEmpty = function(obj){
	  return 0 == exports.length(obj);
	};

/***/ },
/* 376 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */

	module.exports = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};



/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var util = __webpack_require__(12);
	var stream = __webpack_require__(207);
	var _ = __webpack_require__(113);
	var debug = __webpack_require__(378)('serial');



	function SocketSerialPort(options) {
	  this.client = options.client;
	  this.receiveTopic = options.receiveTopic;
	  this.transmitTopic = options.transmitTopic || this.receiveTopic;
	  this.metaData = options.metaData || {};

	  this.buffer = null;

	  var self = this;

	  this.client.on(this.receiveTopic, function(data){
	    try{
	      debug('received', data);
	      if(data.buffer){
	        self.emit('data', data.buffer);
	      }

	    }catch(exp){
	      debug('error on message', exp);
	      //self.emit('error', 'error receiving message: ' + exp);
	    }
	  });

	}

	util.inherits(SocketSerialPort, stream.Stream);


	SocketSerialPort.prototype.open = function (callback) {
	  this.emit('open');
	  if (callback) {
	    callback();
	  }

	};



	SocketSerialPort.prototype.write = function (data, callback) {

	  debug('sending data:', data);

	  var sendObj = _.clone(this.metaData);
	  sendObj.buffer = data;

	  this.client.emit(this.transmitTopic, sendObj);
	};



	SocketSerialPort.prototype.close = function (callback) {
	  debug('closing');
	  if(callback){
	    callback();
	  }
	};

	SocketSerialPort.prototype.flush = function (callback) {
	  debug('flush');
	  if(callback){
	    callback();
	  }
	};

	SocketSerialPort.prototype.drain = function (callback) {
	  debug('drain');
	  if(callback){
	    callback();
	  }
	};


	function bindPhysical(options){
	  var client = options.client;
	  var serialPort = options.serialPort;
	  var receiveTopic = options.receiveTopic;
	  var transmitTopic = options.transmitTopic || receiveTopic;
	  var metaData = options.metaData || {};

	  function serialWrite(data){
	    try{
	      if(typeof data === 'string'){
	        data = new Buffer(data, 'base64');
	      }
	      serialPort.write(data);
	    }catch(exp){
	      debug('error reading message', exp);
	    }
	  }


	  serialPort.on('data', function(data){
	    debug('sending data:', data);
	    if (!Buffer.isBuffer(data)) {
	      data = new Buffer(data);
	    }

	    var sendObj = _.clone(metaData);
	    sendObj.buffer = data;

	    client.emit(transmitTopic, sendObj);
	  });


	  client.on(receiveTopic, function(data){
	    try{
	      if(data.buffer){
	        debug('received', data);
	        serialWrite(data.buffer);      }
	    }catch(exp){
	      debug('error on receive', exp);
	      //self.emit('error', 'error receiving message: ' + exp);
	    }
	  });


	}


	module.exports = {
	  SerialPort: SocketSerialPort,
	  bindPhysical: bindPhysical
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(379);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(380);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 380 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var vector = __webpack_require__(382).vector,
	  rotate = __webpack_require__(382).rotate;

	// Wrap our chains into a single object we can control
	//
	// @param {Object} opts Options: {chains, offset, orientation}
	//  - opts.chains {Array} An array of chains that makeup this robot
	//  - opts.robotType {String} One of the predefined robot types.
	//  - opts.offset {Array} A three element array describing an offset
	//    for the robot's origin point. This can be used to shift the
	//    robot's position relative to its origin point (picture the
	//    robot shifting it's weight along the x/z plane or stretching
	//    to be taller without moving the end effectors)
	//  - opts.orientation {Array} A three element array of Numbers
	//    giving the rotation of the robot's chassis around its
	//    origin point (make it dance! )
	function Robot(opts) {

	  if (!(this instanceof Robot)) {
	    return new Robot(opts);
	  }

	  this.chains = opts.chains;

	  this.offset = opts.offset || [0, 0, 0];

	  if (!opts.orientation) {
	    opts.orientation = {};
	  }

	  this.orientation = {
	    pitch: opts.orientation.pitch || 0,
	    yaw: opts.orientation.yaw || 0,
	    roll: opts.orientation.roll || 0
	  };

	}

	// Call the @@normalize function on each of the chains
	Robot.prototype["@@normalize"] = function(keyFrameSet) {
	  keyFrameSet.forEach(function( keyFrames, index ) {
	    keyFrames = this.chains[index]["@@normalize"](keyFrames);
	  }, this);

	  return keyFrameSet;
	};

	// Find the solution for each chain. Make sure that all requied chains
	// have a valid solution before rendering the robot movement
	Robot.prototype["@@render"] = function(opts) {

	  var passed = true;

	  opts = opts || {};

	  this.chains.forEach( function(chain, index) {
	    if (opts.length < index - 1) {
	      opts[index] = chain.position;
	    }
	    if (!(chain.solve({position: opts[index], orientation: this.orientation, offset: this.offset }))) {
	      passed = false;
	    }

	  }, this);

	  if (passed) {
	    this.chains.forEach( function(chain) {
	      chain.devices["@@render"](chain.angles);
	    });
	  }

	};

	// Wrap our servos object so that we have all the info and
	// methods we need to define and solve our the kinematic system
	//
	// @param {Object} opts Options: {actuators, systemType, origin, bones }
	//  - opts.actuators {Servos}: The Servos() object that contains the chain's actuators
	//  - opts.chainType {String}: One of the pre-defined chain types. Don't see your
	//    system type? Open an issue, or better yet a Pull Request!
	//  - opts.origin {Array}: A three-tuple representing the x, y and z offset of the
	//    chain's origin point from the robot's origin point.
	//  - opts.segments {Object}: An object with the segment names and lengths for our system
	//    The names vary with the systemType
	//
	// returns this chain
	function Chain(opts) {

	  if (!(this instanceof Chain)) {
	    return new Chain(opts);
	  }

	  if (opts.constructor) {
	    this.devices = new opts.constructor(opts.actuators);
	  } else {
	    this.devices = opts.actuators;
	  }

	  this.chainType = opts.chainType;

	  this.segments = opts.segments;

	  this.origin = opts.origin || [0, 0, 0];
	  this.position = opts.startAt || [0, 0, 0];

	  this.require = opts.require || true;

	}

	// // Move all the servos so our end effector is at the
	// // target position.
	// //
	// // returns the Servos() object this was called upon
	// Chain.prototype.render = function( opts ) {
	//   this.solve();
	//   this.forEach(function(device, index) {
	//     // This will call the device's render method
	//     device["@@render"](this.angles[index]);
	//   });
	// };

	// Find the angles needed to position the end effector
	// at a desired point
	//
	// @param {Object} opts Options: {chain, position, orientation, type}
	//  - opts.chain {Servos*}: Typically a Johnny-Five Servos() instance
	//    that contains the servos used in the chain. Prior to using this
	//    method the Servos must be run through tharp.makeChain().
	//  - opts.origin {Array}: Three tuple of kinematic chain origin relative
	//    to the robots origin point
	//  - opts.orientation {Object}: {[pitch][, roll][, yaw]}
	//    pitch, roll and yaw are given in radians
	//  - opts.type {String}: The type of chain (see the readme for
	//    a list of types)
	//  - opts.immediate {Boolean}: Will move the servos immediately this
	//    is usually a bad idea since other legs (chains) of your robot
	//    may not have a valid solution and will not move.
	//
	// returns a three tuple [x, y, z]
	Chain.prototype.solve = function( opts ) {

	  opts = opts || {};

	  if (opts) {
	    this.position = opts.position || this.position;
	    this.orientation = opts.orientation || this.orientation;
	    this.offset = opts.offset || this.offset;
	  }

	  // Find the end effector position relative to the chain origin
	  var offsetPosition = this.eePosition({
	    position: this.position,
	    origin: this.origin,
	    offset: this.offset,
	    orientation: this.orientation
	  });

	  this.angles = ikSolvers[this.chainType](this, offsetPosition);

	  if (opts.immediate) {
	    this.devices["@@render"](this.angles);
	  }

	  // If all the joints could be solved, return true and update last
	  if (this.angles.indexOf(false) === -1) {
	    this.devices.last = {
	      target: this.position
	    };
	    return true;
	  } else {
	    return false;
	  }

	};

	// Find an end effector's position relative to the kinematic chain origin
	//
	// @param {Object} opts Options: {position[, origin][, orientation] }
	//  - opts.position {Array}: Three tuple of end effector position
	//    relative to the robots origin point
	//  - opts.origin {Array}: Three tuple of kinematic chain origin relative
	//    to the robots origin point
	//  - opts.orientation {Object}: {[pitch][, roll][, yaw]}
	//    pitch, roll and yaw are given in radians
	//
	// returns a three tuple [x, y, z]
	Chain.prototype.eePosition = function(opts) {

	  var pos = opts.position || [0, 0, 0];
	  var oPos = opts.origin || [0, 0, 0];
	  var orientation = opts.orientation || {};
	  var roll = orientation.roll || 0;
	  var pitch = orientation.pitch || 0;
	  var yaw = orientation.yaw || 0;
	  var offset = opts.offset || [0, 0, 0];

	  var xOffset = offset[0] || 0;
	  var yOffset = offset[1] || 0;
	  var zOffset = offset[2] || 0;

	  pos = [pos[0] - xOffset, pos[1] - yOffset, pos[2] - zOffset];

	  // End effector position
	  var posVector = new vector(pos);

	  // Chain origin position
	  var oPosVector = new vector(oPos);

	  var rotationMatrix = new rotate.RotZ(roll);
	  posVector = rotationMatrix.dot(posVector);
	  oPosVector = rotationMatrix.dot(oPosVector);

	  rotationMatrix = new rotate.RotX(pitch);
	  posVector = rotationMatrix.dot(posVector);
	  oPosVector = rotationMatrix.dot(oPosVector);

	  rotationMatrix = new rotate.RotY(yaw);
	  posVector = rotationMatrix.dot(posVector);
	  oPosVector = rotationMatrix.dot(oPosVector);

	  // We need to subtract the chain origin from the desired position
	  // but there is no vector.subtract() so let's invert the origin
	  // and then add the vectors together
	  oPosVector = oPosVector.scale(-1);
	  posVector = posVector.add(oPosVector);

	  return posVector.v;

	};

	// Call the @@normalize function on the chain
	Chain.prototype["@@normalize"] = function(keyFrames) {

	  if (keyFrames[0] === null ) {
	    keyFrames[0] = {
	      position: this.position
	    };
	  }

	  keyFrames.forEach(function(keyFrame) {
	    if (typeof keyFrame.position !== "undefined") {
	      keyFrame.value = keyFrame.position;
	    }
	  });

	  keyFrames = this.devices["@@normalize"]([keyFrames])[0];
	  return keyFrames;
	};

	// Convert radians to degrees
	var radToDeg = function(x) {
	  return x / Math.PI * 180;
	};

	// Convert degrees to radians
	var degToRad = function(x) {
	  return x / 180 * Math.PI;
	};

	// Given three sides this will solve a triangle using law of cosines
	//
	// @param {Number} a: An adjacent side's length
	// @param {Number} b: THe other adjacent side's length
	// @param {Number} c: The opposite side's length
	//
	// Returns the angle in radians
	var solveAngle = function(a, b, c) {
	  return Math.acos((a * a + b * b - c * c) / (2 * a * b));
	};

	// Given an angle in radian and a range in degrees will find the correct
	// quadrant for the servo to hit that angle.
	//
	// @param {Number} a: An adjacent side's length
	// @param {Number} b: THe other adjacent side's length
	// @param {Number} c: The opposite side's length
	//
	// Returns the angle in degrees unless no solution can be found. In which
	// case false is returned.
	var findValidAngle = function(angle, range) {
	  var degrees = radToDeg(angle);

	  if (degrees > range[1] || degrees < range[0]) {

	    // Try adding 180
	    if (degrees + 180 >= range[0] && degrees + 180 <= range[1]) {
	      degrees = degrees + 180;
	      return degrees;
	    }

	    // Try subtracting 180
	    if (degrees - 180 >= range[0] && degrees - 180 <= range[1]) {
	      degrees = degrees - 180;
	      return degrees;
	    }

	    // No solution was found
	    return false;
	  }

	  // The angle passed in was valid so just return that in degrees
	  return degrees;

	};

	var ikSolvers = {
	  "CoxaY-FemurZ-TibiaZ": function(chain, offsetPosition) {

	    // Put the coordinates into seperate variables for readability
	    var xd = offsetPosition[0];
	    var yd = offsetPosition[1];
	    var zd = offsetPosition[2];

	    // We use the squares of these a lot so let's store the result
	    var xd_sq = xd * xd;
	    var yd_sq = yd * yd;
	    var zd_sq = zd * zd;

	    // This is the 3D hypoteneuse from the origin point to the end effector
	    var hypot = Math.sqrt(xd_sq + yd_sq + zd_sq);

	    // This is the 2D hypoteneuse on the x/z plane.
	    var hypot2d = Math.sqrt(xd_sq + zd_sq);

	    // Calculate the coxa angle in radians.
	    // This is a simple 2D right triangle solve (yay)
	    var coxaAngle = Math.atan(offsetPosition[2]/offsetPosition[0]);

	    // This is a slightly tougher triangle solve
	    var tibiaAngle = solveAngle(chain.segments.femur, chain.segments.tibia, hypot);

	    // Our last triangle solve
	    var femurAngle = solveAngle(chain.segments.femur, hypot, chain.segments.tibia);

	    // But wait! The femur angle returned represents the angle between the
	    // femur and the 2D hypoteneuse but we actually want the angle between
	    // the femur servo's axis of rotation and the femur so we need to
	    // subtract the angle described by the end effector, the femur origin
	    // and the femur's axis of rotation.
	    // It really is easier than I make it sound.
	    femurAngle += Math.sin(yd/hypot2d);

	    // If the chain is on the left side we need to modify our solutions
	    if (offsetPosition[0] < 0) {
	      femurAngle = Math.PI - femurAngle;
	      tibiaAngle = Math.PI - tibiaAngle;
	    }

	    // Just two things left: The angles are in radians (we need degrees
	    // for our servo) and the angles may or may not be within our servo's
	    // range. Fix that with findValidAngle().
	    var coxaDegrees = findValidAngle(coxaAngle, chain.devices[0].range);
	    var femurDegrees = findValidAngle(femurAngle, chain.devices[1].range);
	    var tibiaDegrees = findValidAngle(tibiaAngle, chain.devices[2].range);

	    // Our solution Array
	    var angles = [coxaDegrees, femurDegrees, tibiaDegrees];

	    return angles;
	  }
	};

	module.exports = {
	  Chain: Chain,
	  Robot: Robot,
	  ikSolvers: ikSolvers,
	  radToDeg: radToDeg,
	  degToRad: degToRad,
	  solveAngle: solveAngle,
	  findValidAngle: findValidAngle
	};


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(383);

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	exports.vector = __webpack_require__(384);
	exports.matrix = __webpack_require__(385);
	exports.rotate = __webpack_require__(386);
	exports.homog = __webpack_require__(387);

/***/ },
/* 384 */
/***/ function(module, exports) {

	// -----------------------------------------------------------
	// Vectors
	// -----------------------------------------------------------
	var Vector = function Vector (x, y, z) {
	  if (typeof y === 'undefined' && typeof z === 'undefined') {
	    this.x = typeof x.x !== 'undefined' ? x.x : x[0];
	    this.y = typeof x.y !== 'undefined' ? x.y : x[1];
	    this.z = typeof x.z !== 'undefined' ? x.z : x[2];
	  } else {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	  }

	  this.v = typeof this.z !== 'undefined' ? [this.x, this.y, this.z] : [this.x, this.y];

	};

	Vector.prototype = {
	  isVector: true,

	  add: function (b) {
	    return new Vector(this.x + b.x, this.y + b.y, this.z + b.z);
	  },

	  dot: function (b) {
	    return this.x * b.x + this.y * b.y + this.z * b.z;
	  },

	  cross: function (b) {
	    var i = this.y * b.z - this.z * b.y;
	    var j = this.z * b.x - this.x * b.z;
	    var k = this.x * b.y - this.y * b.x;
	    return new Vector(i, j, k);
	  },

	  moveTo: function(pt) {
	    this.x = typeof pt.x !== 'undefined' ? pt.x : pt[0];
	    this.y = typeof pt.y !== 'undefined' ? pt.y : pt[1];
	    this.z = typeof pt.z !== 'undefined' ? pt.z : pt[2];
	  },

	  distanceFrom: function (b) {
	    var sumOfSquares = 0;
	    for (var i = 0; i < this.v.length; ++i) {
	      sumOfSquares += (this.v[i] - b.v[i]) * (this.v[i] - b.v[i]);
	    }

	    return Math.sqrt(sumOfSquares);

	  },

	  length: function () {
	    var sumOfSquares = 0;
	    for (var i = 0; i < this.v.length; ++i) {
	      sumOfSquares += this.v[i] * this.v[i];
	    }
	    return Math.sqrt(sumOfSquares);
	  },

	  scale: function (b) {
	    return new Vector(this.x * b, this.y * b, this.z * b);
	  }

	};

	exports = module.exports = Vector;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	var v = __webpack_require__(384);

	// -----------------------------------------------------------
	// Matrices
	// -----------------------------------------------------------
	var Matrix = function Matrix (rows, cols, isIdentity) {
	  // initialize the matrix
	  this.rows = rows;
	  this.cols = cols ? cols : rows; // make it a square matrix if only one argument

	  this.m = new Array(rows);
	  for (var r = 0; r < rows; ++r) {
	    this.m[r] = new Array(cols);
	    for (var c = 0; c < cols; ++c) {
	      this.m[r][c] = 0;
	    }
	  }

	  //square matrices can be declared as identities:
	  if(this.rows === this.cols && isIdentity){
	    for(var i = 0; i<this.rows; i++)
	      this.m[i][i] = 1;
	  }

	  this.isVector = false;

	  this.size = {rows: this.rows, cols: this.cols};

	};

	Matrix.prototype = {
	  set : function (i, j, val) {
	    this.m[i][j] = parseFloat(val.toFixed(12));
	  },

	  setRow: function (i, vals) {
	    var me = this;
	    vals.forEach(function (v, j) {
	      me.set(i, j, v);
	    });
	  },

	  get : function (i, j) {
	    return this.m[i][j];
	  },

	  scale: function (a) {
	    var C = new Matrix(this.rows, this.cols);
	    for (var r = 0; r < this.rows; ++r) {
	      for (var c = 0; c < this.cols; ++c) {
	        var val = this.get(r,c) * a;
	        C.set(r,c, val);
	      }
	    }
	    return C;
	  },

	  add: function (B) {
	    if (B.cols !== this.cols || B.rows !== this.rows)
	      return new Error('A and B must be the same size');

	    var C = new Matrix(this.rows, this.cols);
	    for (var r = 0; r < this.rows; ++r) {
	      for (var c = 0; c < this.cols; ++c) {
	        var val = this.get(r,c) + B.get(r,c);
	        C.set(r,c, val);
	      }
	    }
	    return C;
	  },

	  dot: function (B) {
	    if (B.isVector ? B.v.length !== this.cols : B.rows !== this.cols) {
	      return new Error('number of cols of A must equal number of rows of B');
	    }

	    var C;
	    if (B.isVector) {
	      var arr = Array(B.v.length);
	      for (var i = 0; i < B.v.length; ++i) {
	        arr[i] = 0;
	        for (var j = 0; j < this.rows; ++j) {
	          arr[i] += parseFloat((this.get(i,j) * B.v[j]).toFixed(12));
	        }
	      }
	      C = new v(arr);
	    } else {
	      C = new Matrix(this.rows, B.cols);
	      for (var r = 0; r < C.rows; ++r) {
	        for (var c = 0; c < C.cols; ++c) {
	          var val = 0;
	          for (var m = 0; m < B.rows; ++m) {
	             val += parseFloat((this.get(r,m) * B.get(m,c)).toFixed(12));
	          }
	          // console.log(val);
	          C.set(r, c, val);
	        }
	      }

	    }
	    return C;
	  },

	  transpose: function() {
	    var T = new Matrix(this.rows, this.cols);

	    for (var r = 0; r < this.rows; ++r) {
	      for (var c = 0; c < this.cols; ++c) {
	        T.m[r][c] = this.m[c][r];
	      }
	    }
	    return T;
	  },

	  cofactorDet: function () {
	    if (this.rows !== this.cols) {
	      throw new Error('this is not a square matrix');
	    }

	    var det = 0;
	    var f = 1;
	    for (var i = 0; i < this.rows; i++) {
	      det += this.m[0][i] * this.minor(i, 0).det() * f;
	      f = -f;
	    }

	    return det;
	  },

	  minor: function (k, l) {
	    var M = this.copy();

	    M.removeRow(l);
	    M.removeCol(k);

	    return M;
	  },

	  copy: function () {
	    var M = new Matrix(this.rows, this.cols);
	    for(var i = 0; i < this.rows; i++) {
	      for(var j = 0; j < this.cols; j++) {
	        M.set(i, j, this.get(i, j));
	      }
	    }

	    return M;
	  },

	  removeRow: function (r) {
	    this.m.splice(r, 1);
	    this.rows -= 1;
	  },

	  removeCol: function (c) {
	    for (var i = 0; i < this.rows; i++) {
	      this.m[i].splice(c, 1);
	    }
	    this.cols -= 1;
	  },

	  det: function () {
	    var A, detA, detL, iter, L, l, row;

	    if (this.rows !== this.cols) {
	      throw new Error('this is not a square matrix');
	    }

	    if (this.rows === 2 && this.cols === 2) {
	      return this.m[0][0] * this.m[1][1] - this.m[0][1] * this.m[1][0];
	    }

	    //try a Doolittle extraction for nxn, will bail out to cofactor calculation as necessary
	    // zeroth iteration:
	    A = this;
	    L = new Matrix(this.rows, this.cols, true);
	    l = new Matrix(this.rows, this.cols);

	    for (iter = 1; iter < this.rows; iter++) {
	      // construct this iteration's lower triangular matrix:
	      l = new Matrix(this.rows, this.cols, true);
	      for (row = iter; row < this.rows; row++) {
	        if(A.m[iter - 1][iter - 1] === 0)
	          //bail out to the brute force calculation
	          return this.cofactorDet()
	        l.m[row][iter - 1] = -1 * A.m[row][iter - 1] / A.m[iter - 1][iter - 1];
	        L.m[row][iter - 1] = -1 * l.m[row][iter - 1];
	      }

	      // update A:
	      A = l.dot(A);
	    }

	    detA = 1;
	    detL = 1;
	    for (iter = 0; iter < this.rows; iter++) {
	      detA = detA * A.m[iter][iter];
	      detL = detL * L.m[iter][iter];
	    }

	    return detA * detL;
	  },

	  trace: function () {
	    if (this.rows !== this.cols)
	      return new Error('this is not a square matrix');

	    var trace = 0;
	    for (var r = 0; r < this.rows; ++r) {
	      trace += this.m[r][r];
	    }

	    return trace;
	  },

	  getPoint: function () {
	    if (this.rows === 4 && this.cols === 4)
	      return new v(this.get(0, 3), this.get(1, 3), this.get(2,3));
	    else
	      return new Error('this is not a homogeneous matrix');
	  },

	  getRot: function () {
	    if (this.rows === 4 && this.cols === 4) {
	      var C = new Matrix(3, 3);
	      for (var r = 0; r < 3; ++r) {
	        for (var c = 0; c < 3; ++c) {
	          var val = this.get(r,c);
	          C.set(r,c, val);
	        }
	      }
	      return C;
	    }
	  },

	  calcRotAng: function () {
	    return Math.acos((this.getRot().trace() - 1)/2);
	  },

	  calcRotVec: function () {
	    var rotMat = this.getRot();
	    var rotAng = this.calcRotAng();
	    var negRT = rotMat.scale(-1).transpose();
	    var skewR = rotMat.add(negRT).scale(1/(2 * Math.sin(rotAng)));

	    return new v(-skewR.get(1,2), skewR.get(0,2), -skewR.get(0,1));
	  }
	};


	exports = module.exports = Matrix;


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var m = __webpack_require__(385);

	// -----------------------------------------------------------
	// rotation matrix around the X axis
	// -----------------------------------------------------------
	exports.RotX = function RotX(theta, isDeg) {
	  if (isDeg) theta *= (2 * Math.PI / 360);

	  var R = new m(3);

	  R.set(0, 0, 1);
	  R.set(0, 1, 0);
	  R.set(0, 2, 0);

	  R.set(1, 0, 0); 
	  R.set(1, 1, Math.cos(theta));
	  R.set(1, 2, -Math.sin(theta));

	  R.set(2, 0, 0);
	  R.set(2, 1, Math.sin(theta));
	  R.set(2, 2, Math.cos(theta));

	  return R;
	};

	// -----------------------------------------------------------
	// rotation matrix around the Y axis
	// -----------------------------------------------------------
	exports.RotY = function RotY(theta, isDeg) {
	  if (isDeg) theta *= (2 * Math.PI / 360);

	  var R = new m(3);

	  R.set(0, 0, Math.cos(theta));
	  R.set(0, 1, 0);
	  R.set(0, 2, Math.sin(theta));

	  R.set(1, 0, 0);
	  R.set(1, 1, 1);
	  R.set(1, 2, 0);

	  R.set(2, 0, -Math.sin(theta));
	  R.set(2, 1, 0);
	  R.set(2, 2, Math.cos(theta));

	  return R;
	};

	// -----------------------------------------------------------
	// rotation matrix around the Z axis
	// -----------------------------------------------------------
	exports.RotZ = function RotZ(theta, isDeg) {
	  if (isDeg) theta *= (2 * Math.PI / 360);

	  var R = new m(3);

	  R.set(0, 0, Math.cos(theta));
	  R.set(0, 1, -Math.sin(theta));
	  R.set(0, 2, 0);

	  R.set(1, 0, Math.sin(theta));
	  R.set(1, 1, Math.cos(theta));
	  R.set(1, 2, 0);

	  R.set(2, 0, 0);
	  R.set(2, 1, 0);
	  R.set(2, 2, 1);

	  return R;
	};

	module.exports = exports;


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var v = __webpack_require__(384),
	    m = __webpack_require__(385),
	    Rotate = __webpack_require__(386);

	var Homog = function Homog (rot, trans) {
	  if (rot === 0) {
	    rot = new Rotate.RotX(0);
	  }

	  if (trans === 0) {
	    trans = new v([0, 0, 0]);
	  }

	  if (rot.cols !== rot.rows || trans.v.length !== rot.cols) {
	    return new Error('Rotation matrix must be square and transform must be of same order as matrix');
	  }

	  var H = new m(4);

	  // fill in the rotation part
	  for (var r = 0; r < rot.rows; ++r) {
	    for (var c = 0; c < rot.cols; ++c) {
	      H.set(r, c, rot.get(r, c));
	    }
	  }

	  // fill in the translation part
	  for (var t = 0; t < trans.v.length; ++t) {
	    H.set(t, 3, trans.v[t]);
	  }


	  // add the buffer zone
	  if (rot.cols === 2) { // for 2D systems
	    H.set(2, 0, 0);
	    H.set(2, 1, 0);
	    H.set(2, 2, 1);
	    H.set(2, 3, 0);
	  }

	  H.set(3, 0, 0);
	  H.set(3, 1, 0);
	  H.set(3, 2, 0);
	  H.set(3, 3, 1);

	  return H;
	};

	exports = module.exports = Homog;

/***/ }
/******/ ]);